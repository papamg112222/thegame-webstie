<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gas Laws Game</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Share+Tech+Mono&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary-bg: #1a1a2e;
            --secondary-bg: #16213e;
            --accent-color: #e94560;
            --text-color: #e0e0e0;
            --border-color: #0f3460;
            --glow-color: #ff00ff; /* Base glow for buttons */
        }

        body {
            margin: 0;
            font-family: 'Share Tech Mono', monospace;
            background-color: var(--primary-bg);
            color: var(--text-color);
            overflow: hidden; /* Hide scrollbars for full-screen canvas */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            position: relative;
        }

        canvas#particleCanvas {
            position: fixed;
            top: 0;
            left: 0;
            z-index: -1;
            background-color: var(--primary-bg); /* Ensure background is dark */
        }

        .gameMode, #mainMenu {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: var(--secondary-bg);
            border: 2px solid var(--border-color);
            border-radius: 15px;
            padding: 40px 30px;
            box-shadow: 0 0 25px rgba(0, 0, 0, 0.7);
            text-align: center;
            max-width: 90vw;
            width: 800px; /* Increased width for better layout */
            box-sizing: border-box;
            position: relative; /* For z-index to work */
            z-index: 1; /* Ensure menu is above canvas */
        }

        #mainMenu h1 {
            font-family: 'Orbitron', sans-serif;
            color: var(--accent-color);
            font-size: 3.5rem;
            margin-bottom: 10px;
            text-shadow: 0 0 15px var(--glow-color);
            letter-spacing: 5px;
            background: linear-gradient(45deg, #ff00ff, #00ffff, #ff00ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: textGlow 1.5s infinite alternate;
        }

        @keyframes textGlow {
            0% { text-shadow: 0 0 10px #ff00ff, 0 0 20px #ff00ff; }
            100% { text-shadow: 0 0 20px #00ffff, 0 0 40px #00ffff; }
        }

        #mainMenu h3 {
            color: var(--text-color);
            font-size: 1.2rem;
            margin-top: 0;
            margin-bottom: 30px;
        }

        #mainMenu button,
        .return-btn,
        .avogadro-increase-btn,
        #getNewOneBtn {
            font-family: 'Orbitron', sans-serif;
            background: linear-gradient(90deg, #ff00ff, #00ffff); /* Rainbow gradient */
            background-size: 200% auto;
            color: white;
            padding: 15px 70px;
            border: none;
            border-radius: 8px;
            font-size: 1.3rem;
            cursor: pointer;
            margin: 10px 0;
            transition: all 0.3s ease-in-out;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            text-transform: uppercase;
        }

        #mainMenu button:hover,
        .return-btn:hover,
        .avogadro-increase-btn:hover,
        #getNewOneBtn:hover {
            background-position: right center; /* Move gradient */
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.7);
        }

        .gameMode {
            display: none; /* Hidden by default */
            height: 90vh; /* Make game modes take more height */
            justify-content: flex-start; /* Align content to start for better top spacing */
            padding-top: 30px;
            overflow-y: auto; /* Enable scrolling for smaller screens */
        }

        .game-mode-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 2.8rem;
            color: var(--accent-color);
            margin-bottom: 25px;
            text-shadow: 0 0 10px var(--glow-color);
        }

        .container {
            width: 80%; /* Adjusted for better spacing */
            height: 350px; /* Fixed height for consistent canvas/balloon size */
            background: #222;
            border-radius: 12px;
            margin-top: 20px;
            margin-bottom: 30px;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden; /* Hide overflow for particles/balloon */
            position: relative;
        }

        .slider-container {
            width: 80%; /* Adjusted for better spacing */
            margin: 15px 0;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .slider-container label {
            font-size: 1.1rem;
            margin-bottom: 5px;
            color: var(--text-color);
            width: 100%;
            text-align: center;
        }

        .slider-container input[type="range"] {
            width: 100%;
            -webkit-appearance: none;
            height: 8px;
            background: var(--border-color);
            outline: none;
            border-radius: 5px;
            transition: opacity .2s;
            cursor: pointer;
            box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.3);
        }

        .slider-container input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--accent-color);
            cursor: grab;
            box-shadow: 0 0 8px var(--accent-color);
            transition: background 0.3s ease, box-shadow 0.3s ease;
        }

        .slider-container input[type="range"]::-webkit-slider-thumb:active {
            cursor: grabbing;
            box-shadow: 0 0 15px var(--glow-color);
        }

        /* Balloon specific styles for Charles and Avogadro */
        .balloon-container {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .balloon {
            background: radial-gradient(circle at 25% 25%, #ffbaba, #ff7a7f 30%, #ff5a5f 60%, #cc0000 100%);
            border-radius: 50% 50% 50% 50% / 60% 60% 40% 40%;
            width: 100px; /* Base width */
            height: 150px; /* Base height */
            position: relative;
            bottom: 0;
            transform-origin: bottom center;
            transition: all 0.2s ease-out;
            box-shadow: inset -5px -5px 10px rgba(0,0,0,0.5), 5px 5px 15px rgba(0,0,0,0.3);
            display: flex; /* For centering molecule text */
            justify-content: center;
            align-items: center;
            font-size: 1.5rem;
            color: rgba(255,255,255,0.8);
            text-shadow: 0 0 5px rgba(0,0,0,0.5);
        }

        .balloon::after {
            content: '';
            position: absolute;
            bottom: -10px; /* Adjust based on desired knot length */
            left: 50%;
            transform: translateX(-50%);
            width: 10px;
            height: 20px; /* Height of the knot */
            background-color: #555; /* Knot color */
            border-radius: 0 0 5px 5px;
            box-shadow: inset 0 3px 5px rgba(0,0,0,0.5);
            z-index: 1; /* Ensure knot is behind balloon content */
        }

        .balloon.pop {
            animation: popEffect 0.2s forwards;
        }

        @keyframes popEffect {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.2); opacity: 0.8; }
            100% { transform: scale(0); opacity: 0; }
        }

        .molecule-teller-bg {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 5rem; /* Larger for effect */
            color: rgba(255, 255, 255, 0.05); /* Very faint white */
            pointer-events: none; /* Allow clicks through */
            z-index: 1; /* Behind balloon */
            font-family: 'Orbitron', sans-serif;
            text-shadow: 0 0 10px rgba(255,255,255,0.02);
        }

        #avogadroTopLeftCounter {
            position: absolute;
            top: 10px;
            left: 10px;
            font-size: 1.2rem;
            color: #fff;
            background-color: rgba(0,0,0,0.3);
            padding: 5px 10px;
            border-radius: 5px;
            z-index: 3; /* Above balloon */
        }

        .rainbow-button {
            /* LED Glow Effect */
            box-shadow: 0 0 10px #ff00ff, /* Magenta */
                        0 0 20px #00ffff, /* Cyan */
                        0 0 30px #ffff00; /* Yellow */
            transition: box-shadow 0.3s ease-in-out;
        }

        .rainbow-button:hover {
            box-shadow: 0 0 15px #ff00ff,
                        0 0 30px #00ffff,
                        0 0 45px #ffff00,
                        0 0 60px #ff00ff; /* Stronger glow on hover */
        }

        @keyframes rainbowBackground {
            0% { background-position: 0% 50%; }
            100% { background-position: 100% 50%; }
        }

        /* Specific styles for Boyle's Law title glowing effect */
        .boyle-title-glow {
            background: none; /* Ensure no rainbow background here */
            -webkit-background-clip: unset;
            background-clip: unset;
            -webkit-text-fill-color: unset;
            color: #FFD700; /* Golden color */
            animation: none; /* No background animation */

            /* Golden LED Glowing Effect for text */
            text-shadow: 0 0 8px rgba(255, 215, 0, 0.8),   /* Pure gold glow */
                         0 0 15px rgba(255, 223, 0, 0.6),  /* Lighter gold glow */
                         0 0 25px rgba(255, 204, 0, 0.4),  /* Soft gold glow */
                         0 0 35px rgba(200, 150, 0, 0.2);  /* Deeper amber glow for spread */
            -webkit-text-stroke: 1px rgba(255,255,255,0.05); /* Very subtle white stroke for definition */
        }

        /* Specific styles for Gay-Lussac's Law title glowing effect */
        .gaylussac-title-glow {
            background: none;
            -webkit-background-clip: unset;
            background-clip: unset;
            -webkit-text-fill-color: unset;
            color: #4a90e2; /* Blue to match Gay-Lussac theme */
            animation: none;
            text-shadow: 0 0 8px rgba(74, 144, 226, 0.8),
                         0 0 15px rgba(100, 160, 240, 0.6),
                         0 0 25px rgba(130, 180, 255, 0.4),
                         0 0 35px rgba(50, 100, 180, 0.2);
            -webkit-text-stroke: 1px rgba(255,255,255,0.05);
        }


        /* Canvas sizing for Boyle mode */
        #boyleCanvas {
            width: 100%; /* Make canvas fill container */
            height: 100%; /* Make canvas fill container */
            background:#222;
            border-radius:12px;
            flex-grow: 1; /* Allow canvas to take available space */
        }

        /* Canvas sizing for Gay-Lussac mode */
        #gayLussacCanvas {
            width: 100%;
            height: 100%;
            background: #222; /* Dark background for particles */
            border-radius: 12px;
            flex-grow: 1;
        }

        /* Text for explanations in game modes */
        .explanation-text {
            font-size: 1.1rem;
            text-align: center;
            margin-bottom: 20px;
            max-width: 600px;
            line-height: 1.5;
            color: #ddd;
        }
        .explanation-text strong {
            color: #fff;
        }
        .gaylussac-explanation {
            color: #4a90e2; /* Blue to match Gay-Lussac theme */
            text-shadow: 0 0 5px rgba(74, 144, 226, 0.5);
        }
        .slider-label-explanation {
            font-size: 0.9rem;
            margin-top: 5px;
            margin-bottom: 10px;
            color: #a0a0a0; /* Lighter grey for descriptions */
        }
        .slider-label-explanation strong {
            color: #eee;
        }

        /* Member Page Styles */
        #memberPage h2 {
            font-family: 'Orbitron', sans-serif;
            font-size: 2.5rem;
            color: #fff;
            margin-bottom: 30px;
            text-shadow: 0 0 10px #fff;
        }
        #memberPage ul {
            list-style: none;
            padding: 0;
            width: 100%;
            max-width: 600px; /* Increased max-width for member list */
            display: flex; /* Arrange cards in a row if space allows */
            flex-wrap: wrap; /* Allow cards to wrap to next line */
            justify-content: center; /* Center cards */
            gap: 20px; /* Space between cards */
        }

        .member-card {
            background-color: rgba(30, 45, 70, 0.5); /* Slightly darker, semi-transparent */
            border: 2px solid #0f3460;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 10px; /* Keep some margin if they stack */
            font-size: 1.2rem;
            color: #e0e0e0;
            box-shadow: 0 0 15px rgba(0,0,0,0.5); /* Stronger shadow */
            transition: transform 0.3s ease, box-shadow 0.3s ease, background-color 0.3s ease;
            width: 250px; /* Fixed width for cards */
            text-align: center;
            position: relative;
            overflow: hidden;
        }

        .member-card:hover {
            transform: translateY(-8px) scale(1.03); /* Lift and slightly enlarge */
            box-shadow: 0 10px 30px rgba(0,0,0,0.7),
                        0 0 20px #00ffff, /* Cyan glow on hover */
                        0 0 40px #ff00ff; /* Magenta glow on hover */
            background-color: rgba(22, 33, 62, 0.8); /* Darker on hover */
        }

        .member-card::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: conic-gradient(from 0deg at 50% 50%, #00ffff, #ff00ff, #ffff00, #00ffff);
            animation: borderRotate 4s linear infinite;
            z-index: -1;
            opacity: 0.3; /* Subtle gradient */
            transition: opacity 0.3s ease;
        }

        .member-card:hover::before {
            opacity: 0.7; /* Brighter gradient on hover */
        }

        @keyframes borderRotate {
            to { transform: rotate(1turn); }
        }

        .member-card p {
            margin: 5px 0;
            line-height: 1.6;
        }

        .member-card .name {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.5rem;
            color: var(--accent-color);
            text-shadow: 0 0 8px var(--accent-color);
            margin-bottom: 10px;
        }
        .member-card .group {
            font-size: 0.9rem;
            color: #aaa;
        }


        /* Media Queries for better mobile responsiveness */
        @media (max-width: 600px) {
            #mainMenu h1 {
                font-size: 2.5rem;
                letter-spacing: 3px;
            }
            #mainMenu h3 {
                font-size: 1rem;
            }
            #mainMenu button {
                font-size: 1.2rem;
                padding: 12px 60px;
                margin: 8px 0;
            }
            .game-mode-title {
                font-size: 2rem;
                margin-bottom: 20px;
            }
            .container {
                width: 95vw;
                height: 300px; /* Adjust height for mobile */
                max-width: 320px;
                padding: 15px;
            }
            .slider-container {
                width: 95vw;
                max-width: 280px;
                margin: 10px 0;
            }
            .avogadro-increase-btn, .rainbow-button {
                font-size: 1rem;
                padding: 10px 20px;
            }
            #memberPage h2 {
                font-size: 2.2rem;
            }
            #memberPage ul {
                flex-direction: column; /* Stack cards vertically on small screens */
                gap: 15px;
                max-width: 300px; /* Constrain width for stacked cards */
            }
            .member-card {
                width: 100%; /* Take full width of ul container */
                margin-bottom: 0; /* No extra margin when using gap */
                font-size: 1.1rem;
            }
            .member-card .name {
                font-size: 1.3rem;
            }
            .explanation-text, .slider-label-explanation {
                font-size: 0.85rem;
                margin-bottom: 15px;
            }
        }

    </style>
</head>
<body>

    <canvas id="particleCanvas"></canvas>

    <div id="mainMenu">
        <h1>GAS LAWS GAME</h1>
        <h3>Choose your mode</h3>
        <button onclick="showMode('boyle')">Boyle's Law</button>
        <button onclick="showMode('charles')">Charles' Law</button>
        <button onclick="showMode('gayLussac')">Gay‑Lussac's Law</button>
        <button onclick="showMode('avogadro')">Avogadro's Law</button>
        <button id="memberBtn" onclick="showMemberPage()">Member</button>
    </div>

    <div id="boyle" class="gameMode">
        <h2 class="game-mode-title boyle-title-glow">Boyle's Law</h2>
        <p class="explanation-text">
            In Boyle's Law, when **temperature** and **number of particles** are constant,
            the **pressure** of a gas is inversely proportional to its **volume**.<br>
            Watch how decreasing the container size (volume) affects the speed and density of the particles.
        </p>
        <div class="slider-container">
            <label>Mass: <span id="boyleMassVal">5</span></label>
            <p class="slider-label-explanation">Adjusts the **number of gas particles** (molecules).</p>
            <input type="range" id="boyleMass" min="1" max="20" step="1" value="5">
        </div>
        <div class="slider-container">
            <label>Temperature (°C): <span id="boyleTempVal">20</span></label>
            <p class="slider-label-explanation">Controls the **average speed** of the particles.</p>
            <input type="range" id="boyleTemp" min="0" max="100" value="20">
        </div>
        <div class="container">
            <canvas id="boyleCanvas"></canvas>
        </div>
        <button class="return-btn" onclick="returnToMenu()">Return to Menu</button>
    </div>

    <div id="charles" class="gameMode">
        <h2 class="game-mode-title">Charles' Law</h2>
        <p class="explanation-text">
            In Charles' Law, when **pressure** and **number of particles** are constant,
            the **volume** of a gas is directly proportional to its **temperature**.<br>
            Watch how the balloon expands or contracts as you change the temperature.
        </p>
        <div class="container" style="position: relative;">
            <div class="balloon-container">
                <div id="charlesMoleculeBg" class="molecule-teller-bg">0</div>
                <div id="charlesBalloon" class="balloon" style="z-index: 2;">
                </div>
            </div>
            <div class="slider-container">
                <label>Temperature (°C): <span id="charlesTempVal">20</span></label>
                <p class="slider-label-explanation">Controls the **temperature** affecting balloon size.</p>
                <input type="range" id="charlesTemp" min="0" max="100" value="20">
            </div>
        </div>
        <button class="return-btn" onclick="returnToMenu()">Return to Menu</button>
    </div>

    <div id="gayLussac" class="gameMode">
        <h2 class="game-mode-title gaylussac-title-glow">Gay‑Lussac's Law</h2>
        <p class="explanation-text gaylussac-explanation">
            In Gay-Lussac's Law, when **volume** and **number of particles** are constant,
            the **pressure** of a gas is directly proportional to its **temperature**.<br>
            The container is **rigid and sealed** (constant volume).
        </p>
        <div class="slider-container">
            <label>Temperature (°C): <span id="gayLussacTempVal">20</span></label>
            <p class="slider-label-explanation">Adjusts the **temperature**, which controls the **speed of particles**.</p>
            <input type="range" id="gayLussacTemp" min="0" max="100" value="20">
        </div>
        <div class="slider-container">
            <label>Pressure (arbitrary units): <span id="gayLussacPressureVal">X</span></label>
            <p class="slider-label-explanation">Shows the **resulting pressure**. Faster particles hit walls more often and harder, increasing pressure.</p>
        </div>
        <div class="container">
            <canvas id="gayLussacCanvas"></canvas>
        </div>
        <button class="return-btn" onclick="returnToMenu()">Return to Menu</button>
    </div>

    <div id="avogadro" class="gameMode">
        <h2 class="game-mode-title">Avogadro's Law</h2>
        <p class="explanation-text">
            In Avogadro's Law, when **temperature** and **pressure** are constant,
            the **volume** of a gas is directly proportional to the **number of particles**.<br>
            Increase the number of molecules and watch the balloon expand until it pops!
        </p>
        <div class="container" style="position: relative;">
            <div id="avogadroTopLeftCounter" class="molecule-counter">Molecules: 0</div>

            <div class="balloon-container">
                <div id="avogadroBalloon" class="balloon" style="z-index: 2;"></div>
                <div id="avogadroMoleculeBg" class="molecule-teller-bg">0</div>
                <button id="getNewOneBtn" class="rainbow-button">GET NEW ONE!!!</button>
            </div>
        </div>
        <button id="increaseMoleculeBtn" class="avogadro-increase-btn">Increase Molecules</button>
        <button class="return-btn" onclick="returnToMenu()">Return to Menu</button>
    </div>

    <div id="memberPage" class="gameMode">
        <h2>Our Amazing Team</h2>
        <ul>
            <li>
                <div class="member-card">
                    <p class="name">Jittanan Pasartkeaw</p>
                    <p class="group">G.10/1</p>
                </div>
            </li>
            <li>
                <div class="member-card">
                    <p class="name">Thanunya Udomchaipon</p>
                    <p class="group">G.10/1</p>
                </div>
            </li>
            <li>
                <div class="member-card">
                    <p class="name">Hasana Pathan</p>
                    <p class="group">G.10/1</p>
                </div>
            </li>
            <li>
                <div class="member-card">
                    <p class="name">Phattaraporn Preeda</p>
                    <p class="group">G.10/1</p>
                </div>
            </li>
            <li>
                <div class="member-card">
                    <p class="name">Narisara Eiamsa-ard</p>
                    <p class="group">G.10/1</p>
                </div>
            </li>
            <li>
                <div class="member-card">
                    <p class="name">Chalita Ruttapoom</p>
                    <p class="group">G.10/1</p>
                </div>
            </li>
            <li>
                <div class="member-card">
                    <p class="name">Yanisa Singh</p>
                    <p class="group">G.10/1</p>
                </div>
            </li>
        </ul>
        <button class="return-btn" onclick="returnToMenu()">Return to Menu</button>
    </div>


    <audio id="popSound" src="https://actions.google.com/sounds/v1/cartoon/pop.ogg" preload="auto"></audio>

    <script>
        // === Animated Particles Background ===
        const canvas = document.getElementById('particleCanvas'), ctx = canvas.getContext('2d');
        let particles = [], width, height;
        function initParticles() {
          width = window.innerWidth; height = window.innerHeight;
          canvas.width = width; canvas.height = height;
          particles = [];
          for (let i = 0; i < 80; i++) {
            particles.push({
              x: Math.random() * width,
              y: Math.random() * height,
              radius: Math.random() * 6 + 2,
              speedY: Math.random() * 1.5 + 0.5,
              speedX: (Math.random() - 0.5) * 0.5,
              // Reverted particle color to pinkish-red for main menu background
              color: 'rgba(255, 90, 95, 0.4)', /* Pinkish-red particles */
              alpha: Math.random() * 0.5 + 0.3,
              type: Math.random() > 0.5 ? 'circle' : 'atom'
            });
          }
        }

        function drawAtom(x, y, r) {
          ctx.strokeStyle = 'rgba(255,90,95,0.6)'; /* Pinkish-red atom lines */
          ctx.lineWidth = 1.2;
          ctx.beginPath(); ctx.arc(x, y, r * 0.6, 0, Math.PI * 2);
          ctx.fillStyle = 'rgba(255,90,95,0.7)'; /* Pinkish-red atom fill */
          ctx.fill(); ctx.closePath();
          ctx.beginPath(); ctx.ellipse(x, y, r * 1.2, r * 0.5, 0, 0, Math.PI * 2); ctx.stroke();
          ctx.beginPath(); ctx.ellipse(x, y, r * 0.5, r * 1.2, Math.PI / 4, 0, Math.PI * 2); ctx.stroke();
        }

        function draw() {
          ctx.clearRect(0, 0, width, height);
          for (const p of particles) {
            p.y += p.speedY; p.x += p.speedX;
            if (p.y - p.radius > height) p.y = -p.radius;
            if (p.x - p.radius > width) p.x = -p.radius;
            else if (p.x + p.radius < 0) p.x = width + p.radius;
            ctx.globalAlpha = p.alpha;
            if (p.type === 'circle') {
              ctx.fillStyle = p.color;
              ctx.beginPath();
              ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
              ctx.fill();
              ctx.closePath();
            } else {
              drawAtom(p.x, p.y, p.radius);
            }
            ctx.globalAlpha = 1;
          }
          requestAnimationFrame(draw);
        }
        window.addEventListener('resize', initParticles);
        initParticles();
        draw();

        // === Main Menu & Mode Handling ===
        const modes = ['boyle','charles','gayLussac','avogadro','memberPage']; // Added memberPage
        function showMode(mode) {
          document.getElementById('mainMenu').style.display = 'none';
          modes.forEach(m => {
            document.getElementById(m).style.display = (m === mode ? 'flex' : 'none');
          });
          // Cancel all animations before starting a new one
          cancelAllAnimations();

          if(mode==='boyle') initBoyle();
          else if(mode==='charles') initCharles();
          else if(mode==='gayLussac') initGayLussac();
          else if(mode==='avogadro') initAvogadro(); // Call init for Avogadro
          // No init function needed for memberPage as it's static HTML
        }
        function returnToMenu() {
          document.getElementById('mainMenu').style.display = 'flex';
          modes.forEach(m => {
            document.getElementById(m).style.display = 'none';
          });
          cancelAllAnimations(); // Cancel all animations when returning to menu
        }

        function cancelAllAnimations() {
            cancelBoyleAnimation();
            cancelCharlesAnimation();
            cancelGayLussacAnimation();
            cancelAvogadroAnimation(); // Ensure this is called to stop Avogadro timers
        }

        // Member button function
        function showMemberPage() {
          showMode('memberPage'); // This will handle hiding other modes and displaying memberPage
        }

        // This function is general enough to be used by Boyle, Gay-Lussac, and Charles
        // Renamed to be specific to Boyle's use case to avoid confusion with Gay-Lussac's elasticity
        function resolveBoyleCollision(ball1, ball2) {
            const dx = ball2.x - ball1.x;
            const dy = ball2.y - ball1.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            const minDistance = ball1.radius + ball2.radius;

            if (distance < minDistance && distance > 0) {
                const overlap = minDistance - distance;
                const nx = dx / distance;
                const ny = dy / distance;
                const separationAmount = overlap / 2 + 0.05;

                ball1.x -= nx * separationAmount;
                ball1.y -= ny * separationAmount;
                ball2.x += nx * separationAmount;
                ball2.y += ny * separationAmount;

                const vrx = ball1.speedX - ball2.speedX;
                const vry = ball1.speedY - ball2.speedY;
                const speedAlongNormal = vrx * nx + vry * ny;

                if (speedAlongNormal > 0) return;

                const elasticity = 0.3; // Changed from 0.95 to 0.3 for "stickier" collisions
                const impulseMagnitude = -(1 + elasticity) * speedAlongNormal;

                ball1.speedX += impulseMagnitude * nx;
                ball1.speedY += impulseMagnitude * ny;
                ball2.speedX -= impulseMagnitude * nx;
                ball2.speedY -= impulseMagnitude * ny;
            }
        }


        // === BOYLE MODE ===
        const boyleMassSlider = document.getElementById('boyleMass');
        const boyleTempSlider = document.getElementById('boyleTemp');
        const boyleMassVal = document.getElementById('boyleMassVal');
        const boyleTempVal = document.getElementById('boyleTempVal');
        const boyleCanvas = document.getElementById('boyleCanvas');
        const bCtx = boyleCanvas.getContext('2d');

        let boyleBalls = [];
        let boyleAnimId;
        const BOYLE_BALL_RADIUS = 6; // Fixed radius for consistency
        const MAX_MASS_VALUE = 20; // Max value of the mass slider
        const MIN_TEMP_VALUE = 0;
        const MAX_TEMP_VALUE = 100;

        function initBoyle() {
          const container = boyleCanvas.parentElement;
          boyleCanvas.width = container.clientWidth;
          boyleCanvas.height = container.clientHeight;

          boyleMassVal.textContent = boyleMassSlider.value;
          boyleTempVal.textContent = boyleTempSlider.value;

          boyleBalls = []; // Clear balls initially
          addRemoveBoyleBalls(parseInt(boyleMassSlider.value)); // Populate with initial count
          updateBoyleBallSpeeds(); // Set initial speeds

          animateBoyle();
        }

        function addRemoveBoyleBalls(newMass) {
          const currentBallCount = boyleBalls.length;

          const containerArea = boyleCanvas.width * boyleCanvas.height;
          const ballArea = Math.PI * BOYLE_BALL_RADIUS * BOYLE_BALL_RADIUS;
          const IDEAL_MAX_BALLS = Math.floor(containerArea / (ballArea * 2.5));

          const targetBallCount = Math.floor((newMass / MAX_MASS_VALUE) * IDEAL_MAX_BALLS);

          if (targetBallCount > currentBallCount) {
            for (let i = 0; i < (targetBallCount - currentBallCount); i++) {
              let newBall = {
                x: Math.random() * (boyleCanvas.width - 2 * BOYLE_BALL_RADIUS) + BOYLE_BALL_RADIUS,
                y: Math.random() * (boyleCanvas.height - 2 * BOYLE_BALL_RADIUS) + BOYLE_BALL_RADIUS,
                radius: BOYLE_BALL_RADIUS,
                speedX: 0,
                speedY: 0,
                color: '#ff5a5f'
              };
              boyleBalls.push(newBall);
            }
          } else if (targetBallCount < currentBallCount) {
            boyleBalls.splice(0, currentBallCount - targetBallCount);
          }
        }

        function updateBoyleBallSpeeds() {
          const temp = parseInt(boyleTempSlider.value);
          const mass = parseInt(boyleMassSlider.value);

          const baseSpeed = 1.5;
          const tempFactor = 0.5 + (temp / MAX_TEMP_VALUE) * 2.5;
          const massFactor = 1.0 - ( (mass - 1) / (MAX_MASS_VALUE - 1) ) * 0.7;

          const combinedSpeedFactor = baseSpeed * tempFactor * massFactor;

          boyleBalls.forEach(ball => {
            let currentSpeedMagnitude = Math.sqrt(ball.speedX * ball.speedX + ball.speedY * ball.speedY);

            if (currentSpeedMagnitude === 0 || isNaN(currentSpeedMagnitude) || currentSpeedMagnitude < 0.01) {
                let angle = Math.random() * Math.PI * 2;
                ball.speedX = Math.cos(angle) * combinedSpeedFactor;
                ball.speedY = Math.sin(angle) * combinedSpeedFactor;
            } else {
                const scaleRatio = combinedSpeedFactor / currentSpeedMagnitude;
                ball.speedX *= scaleRatio;
                ball.speedY *= scaleRatio;
            }
          });
        }

        function animateBoyle() {
          const container = boyleCanvas.parentElement;
          if (boyleCanvas.width !== container.clientWidth || boyleCanvas.height !== container.clientHeight) {
            boyleCanvas.width = container.clientWidth;
            boyleCanvas.height = container.clientHeight;
            // Re-initialize ball positions if canvas size changes drastically
            addRemoveBoyleBalls(parseInt(boyleMassSlider.value));
          }

          bCtx.clearRect(0, 0, boyleCanvas.width, boyleCanvas.height);

          for (let i = 0; i < boyleBalls.length; i++) {
            const ball = boyleBalls[i];

            // Update position
            ball.x += ball.speedX;
            ball.y += ball.speedY;

            // Wall collisions
            if (ball.x + ball.radius > boyleCanvas.width || ball.x - ball.radius < 0) {
              ball.speedX *= -1;
              // Correct position to prevent sticking
              if (ball.x + ball.radius > boyleCanvas.width) ball.x = boyleCanvas.width - ball.radius;
              else if (ball.x - ball.radius < 0) ball.x = ball.radius;
            }
            if (ball.y + ball.radius > boyleCanvas.height || ball.y - ball.radius < 0) {
              ball.speedY *= -1;
              // Correct position to prevent sticking
              if (ball.y + ball.radius > boyleCanvas.height) ball.y = boyleCanvas.height - ball.radius;
              else if (ball.y - ball.radius < 0) ball.y = ball.radius;
            }

            // Draw ball
            bCtx.beginPath();
            bCtx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
            bCtx.fillStyle = ball.color;
            bCtx.fill();
            bCtx.closePath();
          }

          // Handle ball-to-ball collisions
          for (let i = 0; i < boyleBalls.length; i++) {
            for (let j = i + 1; j < boyleBalls.length; j++) {
              resolveBoyleCollision(boyleBalls[i], boyleBalls[j]);
            }
          }

          boyleAnimId = requestAnimationFrame(animateBoyle);
        }

        function cancelBoyleAnimation() {
          if (boyleAnimId) {
            cancelAnimationFrame(boyleAnimId);
            boyleAnimId = null;
          }
        }

        boyleMassSlider.addEventListener('input', () => {
          boyleMassVal.textContent = boyleMassSlider.value;
          addRemoveBoyleBalls(parseInt(boyleMassSlider.value));
          updateBoyleBallSpeeds();
        });

        boyleTempSlider.addEventListener('input', () => {
          boyleTempVal.textContent = boyleTempSlider.value;
          updateBoyleBallSpeeds();
        });

        // === CHARLES MODE ===
        const charlesTempSlider = document.getElementById('charlesTemp');
        const charlesTempVal = document.getElementById('charlesTempVal');
        const charlesBalloon = document.getElementById('charlesBalloon');
        const charlesMoleculeBg = document.getElementById('charlesMoleculeBg');

        const INITIAL_CHARLES_BALLOON_WIDTH = 100;
        const INITIAL_CHARLES_BALLOON_HEIGHT = 150;
        const MIN_CHARLES_BALLOON_SCALE = 0.5; // Minimum size factor
        const MAX_CHARLES_BALLOON_SCALE = 1.5; // Maximum size factor
        const CHARLES_FIXED_MOLECULE_COUNT = 50; // Fixed number for Charles's Law

        let charlesAnimId; // To store the requestAnimationFrame ID for Charles's Law

        function initCharles() {
          charlesTempVal.textContent = charlesTempSlider.value;
          // Set initial molecule count for Charles's Law background
          charlesMoleculeBg.textContent = CHARLES_FIXED_MOLECULE_COUNT;

          // Ensure balloon is visible and reset any previous pop state
          charlesBalloon.classList.remove('pop');
          charlesBalloon.style.opacity = '1';
          charlesBalloon.style.display = 'block'; // Make sure it's visible

          // Set initial size based on current slider value
          updateCharlesBalloonSize();

          // No continuous animation loop needed for Charles's Law for now,
          // as updates are driven by slider input.
        }

        function updateCharlesBalloonSize() {
          const tempCelsius = parseInt(charlesTempSlider.value);
          // Convert Celsius to Kelvin, as Charles's Law is based on absolute temperature
          const tempKelvin = tempCelsius + 273; // Using 273 for simplicity

          // We need a reference temperature in Kelvin to scale from.
          // Let's use the initial slider value (20°C) as the reference.
          const initialTempCelsius = 20; // This should match the initial 'value' of the slider in HTML
          const initialTempKelvin = initialTempCelsius + 273;

          // Calculate the scale factor based on Charles's Law: V1/T1 = V2/T2 => V2 = V1 * (T2/T1)
          // The 'volume' (represented by area here) is proportional to temperature.
          // We'll scale both width and height by the square root of the volume ratio to maintain aspect ratio,
          // making the area (volume) scale linearly with temperature.
          const tempRatio = tempKelvin / initialTempKelvin;

          // Apply a scaling factor, clamping it within the defined min/max visual limits
          let scaleFactor = tempRatio;
          scaleFactor = Math.max(MIN_CHARLES_BALLOON_SCALE, Math.min(MAX_CHARLES_BALLOON_SCALE, scaleFactor));

          // Update balloon dimensions
          charlesBalloon.style.width = `${INITIAL_CHARLES_BALLOON_WIDTH * scaleFactor}px`;
          charlesBalloon.style.height = `${INITIAL_CHARLES_BALLOON_HEIGHT * scaleFactor}px`;

          // Update the displayed temperature value
          charlesTempVal.textContent = tempCelsius;
        }

        function cancelCharlesAnimation() {
          if (charlesAnimId) {
            cancelAnimationFrame(charlesAnimId);
            charlesAnimId = null;
          }
        }

        charlesTempSlider.addEventListener('input', updateCharlesBalloonSize);


        // === GAY-LUSSAC MODE ===
        const gayLussacTempSlider = document.getElementById('gayLussacTemp');
        const gayLussacTempVal = document.getElementById('gayLussacTempVal');
        const gayLussacPressureVal = document.getElementById('gayLussacPressureVal');
        const gayLussacCanvas = document.getElementById('gayLussacCanvas');
        const gCtx = gayLussacCanvas.getContext('2d');

        let gayLussacBalls = [];
        let gayLussacAnimId;
        let wallCollisionCount = 0; // To track collisions for pressure calculation
        let lastPressureCalcTime = 0; // Timestamp for last pressure calculation
        const PRESSURE_CALC_INTERVAL = 500; // Calculate pressure every 500ms
        const GAYLUSSAC_BALL_RADIUS = 6;
        const GAYLUSSAC_FIXED_PARTICLE_COUNT = 30; // Fixed number of particles for Gay-Lussac
        const GAYLUSSAC_ELASTICITY = 0.9; // Slightly more elastic for more active movement

        function initGayLussac() {
          const container = gayLussacCanvas.parentElement;
          gayLussacCanvas.width = container.clientWidth;
          gayLussacCanvas.height = container.clientHeight;

          gayLussacTempVal.textContent = gayLussacTempSlider.value;
          gayLussacPressureVal.textContent = '0'; // Initialize pressure display

          gayLussacBalls = []; // Clear any existing balls
          for (let i = 0; i < GAYLUSSAC_FIXED_PARTICLE_COUNT; i++) {
            gayLussacBalls.push({
              x: Math.random() * (gayLussacCanvas.width - 2 * GAYLUSSAC_BALL_RADIUS) + GAYLUSSAC_BALL_RADIUS,
              y: Math.random() * (gayLussacCanvas.height - 2 * GAYLUSSAC_BALL_RADIUS) + GAYLUSSAC_BALL_RADIUS,
              radius: GAYLUSSAC_BALL_RADIUS,
              speedX: 0, // Will be set by updateGayLussacBallSpeeds
              speedY: 0, // Will be set by updateGayLussacBallSpeeds
              color: '#4a90e2' // Blue color for Gay-Lussac particles
            });
          }

          updateGayLussacBallSpeeds(); // Set initial speeds based on slider
          wallCollisionCount = 0; // Reset collision count
          lastPressureCalcTime = performance.now(); // Reset time for pressure calc

          animateGayLussac();
        }

        function updateGayLussacBallSpeeds() {
          const tempCelsius = parseInt(gayLussacTempSlider.value);
          const tempKelvin = tempCelsius + 273; // Convert to Kelvin

          // Speed is proportional to the square root of temperature in Kelvin (kinetic theory)
          const baseSpeed = 0.08; // Adjusted base speed for reasonable particle motion
          const speedFactor = baseSpeed * Math.sqrt(tempKelvin);

          gayLussacBalls.forEach(ball => {
            let currentSpeedMagnitude = Math.sqrt(ball.speedX * ball.speedX + ball.speedY * ball.speedY);

            if (currentSpeedMagnitude === 0 || isNaN(currentSpeedMagnitude) || currentSpeedMagnitude < 0.01) {
              // Initialize speed if it's zero or invalid
              let angle = Math.random() * Math.PI * 2;
              ball.speedX = Math.cos(angle) * speedFactor;
              ball.speedY = Math.sin(angle) * speedFactor;
            } else {
              // Scale existing speed to new temperature
              const scaleRatio = speedFactor / currentSpeedMagnitude;
              ball.speedX *= scaleRatio;
              ball.speedY *= scaleRatio;
            }
          });
        }

        function animateGayLussac(currentTime) {
          const container = gayLussacCanvas.parentElement;
          // Adjust canvas size if container changes
          if (gayLussacCanvas.width !== container.clientWidth || gayLussacCanvas.height !== container.clientHeight) {
            gayLussacCanvas.width = container.clientWidth;
            gayLussacCanvas.height = container.clientHeight;
            // Re-initialize ball positions if canvas size changes drastically
            initGayLussac(); // Re-run init to re-position particles within new bounds
            return; // Exit and let the new init call request the next frame
          }

          gCtx.clearRect(0, 0, gayLussacCanvas.width, gayLussacCanvas.height);

          for (let i = 0; i < gayLussacBalls.length; i++) {
            const ball = gayLussacBalls[i];

            // Update position
            ball.x += ball.speedX;
            ball.y += ball.speedY;

            // Wall collisions (rigid container)
            if (ball.x + ball.radius > gayLussacCanvas.width) {
              ball.x = gayLussacCanvas.width - ball.radius;
              ball.speedX *= -GAYLUSSAC_ELASTICITY;
              wallCollisionCount++;
            } else if (ball.x - ball.radius < 0) {
              ball.x = GAYLUSSAC_BALL_RADIUS;
              ball.speedX *= -GAYLUSSAC_ELASTICITY;
              wallCollisionCount++;
            }

            if (ball.y + ball.radius > gayLussacCanvas.height) {
              ball.y = gayLussacCanvas.height - ball.radius;
              ball.speedY *= -GAYLUSSAC_ELASTICITY;
              wallCollisionCount++;
            } else if (ball.y - ball.radius < 0) {
              ball.y = GAYLUSSAC_BALL_RADIUS;
              ball.speedY *= -GAYLUSSAC_ELASTICITY;
              wallCollisionCount++;
            }

            // Draw ball
            gCtx.beginPath();
            gCtx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
            gCtx.fillStyle = ball.color;
            gCtx.fill();
            gCtx.closePath();
          }

          // Handle ball-to-ball collisions (using the specific Gay-Lussac collision resolver)
          for (let i = 0; i < gayLussacBalls.length; i++) {
            for (let j = i + 1; j < gayLussacBalls.length; j++) {
              resolveGayLussacCollision(gayLussacBalls[i], gayLussacBalls[j]);
            }
          }

          // Update pressure display periodically
          if (currentTime - lastPressureCalcTime > PRESSURE_CALC_INTERVAL) {
            const pressure = wallCollisionCount; // Simple arbitrary unit for pressure
            gayLussacPressureVal.textContent = pressure;
            wallCollisionCount = 0; // Reset count for next interval
            lastPressureCalcTime = currentTime;
          }

          gayLussacAnimId = requestAnimationFrame(animateGayLussac);
        }

        // A slightly modified collision resolution for Gay-Lussac to use its specific elasticity
        function resolveGayLussacCollision(ball1, ball2) {
            const dx = ball2.x - ball1.x;
            const dy = ball2.y - ball1.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            const minDistance = ball1.radius + ball2.radius;

            if (distance < minDistance && distance > 0) {
                const overlap = minDistance - distance;
                const nx = dx / distance;
                const ny = dy / distance;
                const separationAmount = overlap / 2 + 0.05; // Small buffer to prevent sticking

                ball1.x -= nx * separationAmount;
                ball1.y -= ny * separationAmount;
                ball2.x += nx * separationAmount;
                ball2.y += ny * separationAmount;

                const vrx = ball1.speedX - ball2.speedX;
                const vry = ball1.speedY - ball2.speedY;
                const speedAlongNormal = vrx * nx + vry * ny;

                if (speedAlongNormal > 0) return; // Only resolve if balls are moving towards each other

                const impulseMagnitude = -(1 + GAYLUSSAC_ELASTICITY) * speedAlongNormal;

                ball1.speedX += impulseMagnitude * nx;
                ball1.speedY += impulseMagnitude * ny;
                ball2.speedX -= impulseMagnitude * nx;
                ball2.speedY -= impulseMagnitude * ny;
            }
        }

        function cancelGayLussacAnimation() {
          if (gayLussacAnimId) {
            cancelAnimationFrame(gayLussacAnimId);
            gayLussacAnimId = null;
          }
        }

        gayLussacTempSlider.addEventListener('input', () => {
          gayLussacTempVal.textContent = gayLussacTempSlider.value;
          updateGayLussacBallSpeeds();
        });


        // === AVOGADRO MODE ===
        const avogadroBalloon = document.getElementById('avogadroBalloon');
        const avogadroMoleculeBg = document.getElementById('avogadroMoleculeBg');
        const avogadroTopLeftCounter = document.getElementById('avogadroTopLeftCounter');
        const increaseMoleculeBtn = document.getElementById('increaseMoleculeBtn');
        const getNewOneBtn = document.getElementById('getNewOneBtn');
        const popSound = document.getElementById('popSound');

        const INITIAL_AVOGADRO_MOLECULES = 10;
        const MAX_AVOGADRO_MOLECULES = 200; // Increased max molecules for clearer pop
        const AVOGADRO_POP_THRESHOLD = 150; // When the balloon pops
        const AVOGADRO_VOLUME_SCALE_FACTOR = 0.01; // How much volume increases per molecule
        const AVOGADRO_INITIAL_WIDTH = 100;
        const AVOGADRO_INITIAL_HEIGHT = 150;

        let currentAvogadroMolecules = 0;
        let avogadroIntervalId = null; // To hold the interval for increasing molecules

        function initAvogadro() {
            // Reset balloon state
            avogadroBalloon.classList.remove('pop');
            avogadroBalloon.style.opacity = '1';
            avogadroBalloon.style.display = 'flex'; // Make sure it's visible and centered

            currentAvogadroMolecules = INITIAL_AVOGADRO_MOLECULES; // Start with initial molecules
            updateAvogadroDisplay();
            updateAvogadroBalloonSize();

            // Ensure buttons are active
            increaseMoleculeBtn.disabled = false;
            getNewOneBtn.disabled = false;
        }

        function updateAvogadroDisplay() {
            avogadroMoleculeBg.textContent = currentAvogadroMolecules;
            avogadroTopLeftCounter.textContent = `Molecules: ${currentAvogadroMolecules}`;
        }

        function updateAvogadroBalloonSize() {
            // Volume is directly proportional to number of moles (molecules here)
            // V2 = V1 * (N2/N1)
            // We'll scale width and height by the cube root of the volume ratio
            // to represent proportional expansion in 3D, or simply scale by sqrt for 2D visual area.
            // Let's use linear scaling for visual simplicity based on molecule count.

            // Define a visual maximum scale to prevent it from getting too huge before pop
            const MAX_VISUAL_SCALE = 2.5; // Balloon can grow up to 2.5 times initial size

            const scaleRatio = currentAvogadroMolecules / INITIAL_AVOGADRO_MOLECULES;
            let visualScale = Math.min(scaleRatio, MAX_VISUAL_SCALE); // Cap visual growth

            avogadroBalloon.style.width = `${AVOGADRO_INITIAL_WIDTH * visualScale}px`;
            avogadroBalloon.style.height = `${AVOGADRO_INITIAL_HEIGHT * visualScale}px`;

            // Check for pop condition
            if (currentAvogadroMolecules >= AVOGADRO_POP_THRESHOLD) {
                popBalloon();
            }
        }

        function increaseAvogadroMolecules() {
            if (currentAvogadroMolecules < MAX_AVOGADRO_MOLECULES) {
                currentAvogadroMolecules += 5; // Increase by 5 molecules
                updateAvogadroDisplay();
                updateAvogadroBalloonSize();
            }
        }

        function popBalloon() {
            popSound.currentTime = 0; // Rewind sound to start
            popSound.play();
            avogadroBalloon.classList.add('pop'); // Trigger CSS animation
            // Hide after animation
            setTimeout(() => {
                avogadroBalloon.style.display = 'none';
            }, 200); // Match popEffect animation duration

            // Disable buttons after pop
            increaseMoleculeBtn.disabled = true;
            getNewOneBtn.disabled = true;

            // Clear any active interval if it's still running
            cancelAvogadroAnimation();
        }

        function getNewAvogadroBalloon() {
            cancelAvogadroAnimation(); // Stop any active increase interval
            initAvogadro(); // Reset to initial state
        }

        // Event listeners
        increaseMoleculeBtn.addEventListener('click', () => {
            // Start interval if not already running, or just increase once if clicked rapidly
            if (!avogadroIntervalId) {
                avogadroIntervalId = setInterval(increaseAvogadroMolecules, 100); // Increase every 100ms
            }
        });

        // Stop increasing molecules when mouse button is released
        increaseMoleculeBtn.addEventListener('mouseup', cancelAvogadroAnimation);
        increaseMoleculeBtn.addEventListener('mouseleave', cancelAvogadroAnimation); // In case mouse leaves button

        getNewOneBtn.addEventListener('click', getNewAvogadroBalloon);

        function cancelAvogadroAnimation() {
            if (avogadroIntervalId) {
                clearInterval(avogadroIntervalId);
                avogadroIntervalId = null;
            }
        }

    </script>
</body>
</html>

<script>
(() => {
    const PLAYER_HEIGHT = 1.8;
    const GRAVITY = -30;
    const REWIND_MAX_FRAMES = 180;
    const STAMINA_MAX = 100;
    const STAMINA_DRAIN_RATE = 20;
    const STAMINA_RECHARGE_RATE = 40;
    const KEYCARD_COLORS = [0xffff00, 0x00ff00, 0xff00ff];

    let scene, camera, renderer, controls, clock;
    let velocity = new THREE.Vector3(), direction = new THREE.Vector3();
    let move = { forward: false, backward: false, left: false, right: false, sprint: false };
    let canJump = false, gameStarted = false;
    let health = 100, stamina = STAMINA_MAX, keycards = 0, stage = 1;
    let startTime = Date.now();
    let isRewinding = false, isTimeStopped = false;
    let rewindBuffer = [];

    const ui = {
        menu: document.getElementById('main-menu'),
        startBtn: document.getElementById('start-button'),
        hud: document.getElementById('ui'),
        health: document.getElementById('health'),
        healthBar: document.querySelector('#health-bar .bar'),
        stamina: document.getElementById('stamina'),
        staminaBar: document.querySelector('#stamina-bar .bar'),
        keycards: document.getElementById('keycards'),
        stage: document.getElementById('stage'),
        timer: document.getElementById('timer'),
        msg: document.getElementById('message')
    };

    function showMessage(text, duration = 3000) {
        ui.msg.textContent = text;
        ui.msg.style.display = 'block';
        setTimeout(() => ui.msg.style.display = 'none', duration);
    }

    class Door {
        constructor(pos, locked = true, type = 0) {
            this.locked = locked;
            this.type = type;
            this.mesh = new THREE.Mesh(
                new THREE.BoxGeometry(1, 3, 0.2),
                new THREE.MeshPhongMaterial({
                    color: locked ? 0xaa0000 : 0x00aa00,
                    transparent: true,
                    opacity: 0.9,
                    emissive: locked ? 0x660000 : 0x006600
                })
            );
            this.mesh.position.copy(pos);
            scene.add(this.mesh);
        }

        interact() {
            if (this.locked) {
                if (keycards > 0) {
                    keycards--;
                    ui.keycards.textContent = keycards;
                    this.locked = false;
                    this.mesh.material.color.set(0x00aa00);
                    this.mesh.material.emissive.set(0x006600);
                    showMessage("Door unlocked.");
                } else {
                    showMessage("You need a keycard to open this door.");
                }
            } else {
                showMessage("Door is already unlocked.");
            }
        }
    }

    class Enemy {
        constructor(path) {
            this.path = path;
            this.currentWaypoint = 0;
            this.mesh = new THREE.Mesh(
                new THREE.BoxGeometry(0.7, 1.8, 0.7),
                new THREE.MeshPhongMaterial({
                    color: 0xff4444,
                    emissive: 0x990000
                })
            );
            this.mesh.position.copy(this.path[this.currentWaypoint]);
            scene.add(this.mesh);
            this.speed = 3;
        }

        update(delta, playerPos) {
            if (isTimeStopped || isRewinding) return;

            const target = this.path[this.currentWaypoint];
            const dir = new THREE.Vector3().subVectors(target, this.mesh.position).normalize();
            this.mesh.position.addScaledVector(dir, this.speed * delta);

            if (this.mesh.position.distanceTo(target) < 0.5) {
                this.currentWaypoint = (this.currentWaypoint + 1) % this.path.length;
            }

            if (this.mesh.position.distanceTo(playerPos) < 1.2) {
                health -= 10;
                if (health <= 0) {
                    alert("Game Over! You were caught by the system daemon.");
                    location.reload();
                }
                ui.health.textContent = health;
                ui.healthBar.style.width = `${health}%`;
            }
        }
    }

    class Keycard {
        constructor(pos, type = 0) {
            this.type = type;
            this.mesh = new THREE.Mesh(
                new THREE.BoxGeometry(0.3, 0.05, 0.5),
                new THREE.MeshPhongMaterial({
                    color: KEYCARD_COLORS[type],
                    emissive: KEYCARD_COLORS[type],
                    emissiveIntensity: 0.8
                })
            );
            this.mesh.position.copy(pos);
            scene.add(this.mesh);
            this.collected = false;
        }

        checkPickup(playerPos) {
            if (!this.collected && this.mesh.position.distanceTo(playerPos) < 1) {
                this.collected = true;
                scene.remove(this.mesh);
                keycards++;
                ui.keycards.textContent = keycards;
                showMessage("Keycard collected!");
            }
        }
    }

    function initControls() {
        controls = new THREE.PointerLockControls(camera, document.body);

        document.body.addEventListener('click', () => {
            if (!gameStarted) return;
            controls.lock();
        });

        controls.addEventListener('lock', () => {
            ui.menu.style.display = 'none';
            ui.hud.style.display = 'flex';
        });

        controls.addEventListener('unlock', () => {
            ui.menu.style.display = 'flex';
            ui.hud.style.display = 'none';
        });

        document.addEventListener('keydown', onKeyDown);
        document.addEventListener('keyup', onKeyUp);
    }

    function onKeyDown(event) {
        switch(event.code) {
            case 'KeyW': move.forward = true; break;
            case 'KeyS': move.backward = true; break;
            case 'KeyA': move.left = true; break;
            case 'KeyD': move.right = true; break;
            case 'ShiftLeft': move.sprint = true; break;
            case 'KeyE': interact(); break;
            case 'KeyQ': toggleTimeStop(); break;
            case 'KeyR': startRewind(); break;
            case 'Space':
                if (canJump) {
                    velocity.y = 10;
                    canJump = false;
                }
                break;
        }
    }

    function onKeyUp(event) {
        switch(event.code) {
            case 'KeyW': move.forward = false; break;
            case 'KeyS': move.backward = false; break;
            case 'KeyA': move.left = false; break;
            case 'KeyD': move.right = false; break;
            case 'ShiftLeft': move.sprint = false; break;
            case 'KeyR': stopRewind(); break;
        }
    }

    function interact() {
        let playerPos = controls.getObject().position;
        for (const door of doors) {
            if (door.mesh.position.distanceTo(playerPos) < 2) {
                door.interact();
                return;
            }
        }
        showMessage("Nothing to interact with.");
    }

    function toggleTimeStop() {
        if (stamina > 10) {
            isTimeStopped = !isTimeStopped;
            showMessage(isTimeStopped ? "Time stopped." : "Time resumed.");
        } else {
            showMessage("Not enough stamina to stop time.");
        }
    }

    function startRewind() {
        if (rewindBuffer.length > 0) {
            isRewinding = true;
            showMessage("Rewinding...");
        }
    }

    function stopRewind() {
        if (isRewinding) {
            isRewinding = false;
            showMessage("Rewind stopped.");
        }
    }

    function initScene() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x111111);
        camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        clock = new THREE.Clock();

        const light = new THREE.HemisphereLight(0xffffff, 0x444444, 1.5);
        light.position.set(0, 200, 0);
        scene.add(light);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(0, 100, 100);
        scene.add(dirLight);

        const floorGeometry = new THREE.PlaneGeometry(100, 100);
        const floorMaterial = new THREE.MeshPhongMaterial({color: 0x222222});
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = - Math.PI / 2;
        floor.position.y = 0;
        scene.add(floor);
    }

    let doors = [];
    let enemies = [];
    let keycardObjects = [];

    function setupGameObjects() {
        doors.push(new Door(new THREE.Vector3(5, 1.5, -5), true, 0));
        doors.push(new Door(new THREE.Vector3(10, 1.5, -5), true, 1));
        doors.push(new Door(new THREE.Vector3(15, 1.5, -5), true, 2));

        enemies.push(new Enemy([
            new THREE.Vector3(-5, 0, -5),
            new THREE.Vector3(-5, 0, 5),
        ]));

        enemies.push(new Enemy([
            new THREE.Vector3(7, 0, -10),
            new THREE.Vector3(12, 0, -10),
        ]));

        keycardObjects.push(new Keycard(new THREE.Vector3(-3, 0.3, -3), 0));
        keycardObjects.push(new Keycard(new THREE.Vector3(8, 0.3, -4), 1));
        keycardObjects.push(new Keycard(new THREE.Vector3(14, 0.3, -6), 2));
    }

    function animate() {
        requestAnimationFrame(animate);
        if (!gameStarted) return;

        const delta = clock.getDelta();

        if (!isRewinding) {
            direction.z = Number(move.forward) - Number(move.backward);
            direction.x = Number(move.right) - Number(move.left);
            direction.normalize();

            if (controls.isLocked === true) {
                if (move.sprint && stamina > 0) {
                    velocity.x -= direction.x * 50 * delta;
                    velocity.z -= direction.z * 50 * delta;
                    stamina -= STAMINA_DRAIN_RATE * delta;
                } else {
                    velocity.x -= direction.x * 25 * delta;
                    velocity.z -= direction.z * 25 * delta;
                    stamina += STAMINA_RECHARGE_RATE * delta;
                }
                stamina = Math.min(Math.max(stamina, 0), STAMINA_MAX);

                velocity.y += GRAVITY * delta;

                controls.moveRight(-velocity.x * delta);
                controls.moveForward(-velocity.z * delta);
                controls.getObject().position.y += velocity.y * delta;

                if (controls.getObject().position.y < PLAYER_HEIGHT) {
                    velocity.y = 0;
                    controls.getObject().position.y = PLAYER_HEIGHT;
                    canJump = true;
                }

                ui.stamina.textContent = Math.floor(stamina);
                ui.staminaBar.style.width = `${(stamina / STAMINA_MAX) * 100}%`;

                enemies.forEach(enemy => enemy.update(delta, controls.getObject().position));
                keycardObjects.forEach(kc => kc.checkPickup(controls.getObject().position));

                rewindBuffer.push({
                    pos: controls.getObject().position.clone(),
                    rot: camera.rotation.clone(),
                    velocity: velocity.clone(),
                    health: health,
                    stamina: stamina,
                    keycards: keycards
                });
                if (rewindBuffer.length > REWIND_MAX_FRAMES) rewindBuffer.shift();

                const elapsed = (Date.now() - startTime) / 1000;
                const minutes = Math.floor(elapsed / 60).toString().padStart(2, '0');
                const seconds = Math.floor(elapsed % 60).toString().padStart(2, '0');
                ui.timer.textContent = `${minutes}:${seconds}`;
            }

            if (isTimeStopped) {
                stamina -= STAMINA_DRAIN_RATE * delta;
                if (stamina <= 0) {
                    stamina = 0;
                    isTimeStopped = false;
                    showMessage("Time stop ended due to exhaustion.");
                }
                ui.stamina.textContent = Math.floor(stamina);
                ui.staminaBar.style.width = `${(stamina / STAMINA_MAX) * 100}%`;
            }
        } else {
            if (rewindBuffer.length > 0) {
                const state = rewindBuffer.pop();
                controls.getObject().position.copy(state.pos);
                camera.rotation.copy(state.rot);
                velocity.copy(state.velocity);
                health = state.health;
                stamina = state.stamina;
                keycards = state.keycards;

                ui.health.textContent = health;
                ui.healthBar.style.width = `${health}%`;
                ui.stamina.textContent = Math.floor(stamina);
                ui.staminaBar.style.width = `${(stamina / STAMINA_MAX) * 100}%`;
                ui.keycards.textContent = keycards;
            } else {
                stopRewind();
            }
        }

        renderer.render(scene, camera);
    }

    ui.startBtn.addEventListener('click', () => {
        ui.menu.style.display = 'none';
        ui.hud.style.display = 'flex';
        gameStarted = true;
        controls.lock();
    });

    function init() {
        initScene();
        initControls();
        setupGameObjects();
        camera.position.set(0, PLAYER_HEIGHT, 10);
        animate();
    }

    init();
})();
</script>

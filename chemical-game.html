<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Horror Maze â€” Fixed</title>

<!-- load global THREE (non-module) and PointerLockControls that depend on global THREE -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/PointerLockControls.js"></script>

<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght400;700&display=swap" rel="stylesheet">
<style>
  body{margin:0;overflow:hidden;background:#050508;font-family:'Orbitron',sans-serif;color:#e0e0e0;user-select:none;}
  #info{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);background:rgba(0,0,0,0.95);border:2px solid #ff4444;padding:2rem;border-radius:.75rem;text-align:center;z-index:1000;box-shadow:0 0 25px rgba(255,68,68,0.7);cursor:pointer}
  .action-button{padding:.75rem 2rem;background:#ff4444;color:#fff;font-weight:700;border:none;border-radius:.4rem;cursor:pointer}
  .action-button:hover{background:#cc3333}
  #crosshair{position:absolute;top:50%;left:50%;width:10px;height:10px;margin:-5px 0 0 -5px;border:1px solid rgba(255,255,255,0.8);border-radius:50%;z-index:999;opacity:0;pointer-events:none}
  #status-bar{position:fixed;left:0;right:0;bottom:0;padding:10px 20px;background:rgba(0,0,0,0.6);display:flex;justify-content:space-between;color:#00ffff;z-index:50;font-size:14px}
  #message-box{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);background:#111;border:2px solid #ff0044;padding:2rem;border-radius:.5rem;text-align:center;z-index:2000;box-shadow:0 0 30px #ff0044;display:none}
  .win-style{border-color:#00ff00 !important;box-shadow:0 0 30px #00ff00 !important}
  #minimapCanvas{position:fixed;top:20px;right:20px;width:200px;height:200px;background:rgba(0,0,0,0.7);border:2px solid #00ff00;z-index:60;display:none}
</style>
</head>
<body>

<!-- Start UI -->
<div id="info">
  <h1 style="color:#ff4444;font-size:28px;margin-bottom:8px">CRYSTAL HUNT MAZE</h1>
  <p style="max-width:360px;margin:auto;color:#ddd">Click ENTER to start. Collect 250 crystal orbs and find the exit while avoiding ghosts. Use W/A/S/D and mouse. Press M to toggle minimap.</p>
  <div style="margin-top:16px">
    <button id="startBtn" class="action-button">ENTER</button>
  </div>
</div>

<div id="crosshair"></div>

<canvas id="minimapCanvas" width="200" height="200"></canvas>

<div id="status-bar">
  <span id="player-status">Status: Walking...</span>
  <span id="ghost-proximity">Threat: Distant</span>
  <span id="orb-count">Crystals: 0/250</span>
</div>

<div id="message-box"><p id="message-text" style="font-weight:700;margin-bottom:10px"></p><button class="action-button" onclick="location.reload()">RESTART</button></div>

<script>
/* ============================
   Fixed, working game script
   - Uses global THREE (no ESM import)
   - Adds reliable lighting
   - ENTER button starts by locking pointer controls
   - Minimap uses an actual canvas
   ============================ */

const CELL_SIZE = 20, WALL_HEIGHT = 10, PLAYER_HEIGHT = 6;
const MAX_COL = 71, MAX_ROW = 71;
const START_COL = 1, START_ROW = MAX_ROW - 2;
const EXIT_COL = MAX_COL - 2, EXIT_ROW = 1;
const TOTAL_ORBS = 250;

let scene, camera, renderer, controls, raycaster, clock;
let offsetX, offsetZ;
let moveForward=false,moveBackward=false,moveLeft=false,moveRight=false;
let gameActive=false, winPosition=null;
let wallObjects = [], orbs = [], collectedOrbs = 0;
let ghosts = [], ghostGridPosArray = [];
let playerGridPos = {r:0,c:0};

const WALK_SPEED = 32, GHOST_SPEED = 40; // adjusted for playable speeds
let effectiveSpeed = WALK_SPEED;

// Maze generation - same algorithm as before
function generateTrueMaze(rows,cols){
  const grid = Array(rows).fill(0).map(()=>Array(cols).fill(1));
  const stack=[];
  stack.push([START_ROW,START_COL]); grid[START_ROW][START_COL]=0;
  while(stack.length>0){
    const [r,c] = stack[stack.length-1];
    const neighbors = [[r-2,c,r-1,c],[r+2,c,r+1,c],[r,c-2,r,c-1],[r,c+2,r,c+1]]
      .filter(([nr,nc])=> nr>0 && nr<rows-1 && nc>0 && nc<cols-1 && grid[nr][nc]===1);
    if(neighbors.length>0){
      const [nr,nc,wr,wc] = neighbors[Math.floor(Math.random()*neighbors.length)];
      grid[nr][nc]=0; grid[wr][wc]=0; stack.push([nr,nc]);
    } else stack.pop();
  }
  grid[EXIT_ROW][EXIT_COL] = 2;
  for(let r=1;r<rows-1;r++) for(let c=1;c<cols-1;c++) if(grid[r][c]===1 && Math.random()<0.20) grid[r][c]=0;
  return grid;
}
const mazeGrid = generateTrueMaze(MAX_ROW, MAX_COL);

function toGridPosition(worldX, worldZ){
  return { r: Math.floor((worldZ - offsetZ) / CELL_SIZE), c: Math.floor((worldX - offsetX) / CELL_SIZE) };
}
function toWorldPosition(r,c,yOffset=PLAYER_HEIGHT){
  const x = (c + 0.5) * CELL_SIZE + offsetX;
  const z = (r + 0.5) * CELL_SIZE + offsetZ;
  return new THREE.Vector3(x,yOffset,z);
}

function init(){
  // scene/camera/renderer
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x050508);
  scene.fog = new THREE.Fog(0x050508, CELL_SIZE*5, CELL_SIZE*30);
  camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 2000);
  raycaster = new THREE.Raycaster();
  clock = new THREE.Clock();

  offsetX = -(mazeGrid[0].length * CELL_SIZE) / 2;
  offsetZ = -(mazeGrid.length * CELL_SIZE) / 2;
  const startVec = toWorldPosition(START_ROW, START_COL, PLAYER_HEIGHT);
  camera.position.copy(startVec);

  renderer = new THREE.WebGLRenderer({ antialias:true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setPixelRatio(window.devicePixelRatio);
  document.body.appendChild(renderer.domElement);

  // ======= FIX: Add clear lighting =======
  // Ambient for basic scene visibility
  const ambient = new THREE.AmbientLight(0xffffff, 0.6);
  scene.add(ambient);
  // Directional for shadows/shape
  const dir = new THREE.DirectionalLight(0xffffff, 0.8);
  dir.position.set(30, 80, 10);
  scene.add(dir);
  // Small hemisphere for color balance
  const hemi = new THREE.HemisphereLight(0x404050, 0x101020, 0.15);
  scene.add(hemi);
  // Flashlight attached to camera
  const flashlight = new THREE.PointLight(0xffffff, 1.8, 60);
  flashlight.position.set(0,0,0);
  camera.add(flashlight);
  scene.add(camera);

  // controls (pointer lock)
  controls = new THREE.PointerLockControls(camera, document.body);
  controls.addEventListener('lock', ()=> { document.getElementById('info').style.display='none'; document.getElementById('crosshair').style.opacity=1; gameActive = true; });
  controls.addEventListener('unlock', ()=> { if(!document.getElementById('message-box').style.display || document.getElementById('message-box').style.display === 'none') document.getElementById('info').style.display='block'; document.getElementById('crosshair').style.opacity=0; gameActive = false; });

  buildMaze();
  spawnOrbs(TOTAL_ORBS);
  addGhosts(5);

  // input
  window.addEventListener('keydown', onKeyDown);
  window.addEventListener('keyup', onKeyUp);
  window.addEventListener('resize', onWindowResize);

  // minimap toggle (M)
  window.addEventListener('keydown', (e)=>{ if(e.code === 'KeyM'){ const cm = document.getElementById('minimapCanvas'); cm.style.display = (cm.style.display === 'none' || cm.style.display === '') ? 'block' : 'none'; }});
}

function buildMaze(){
  const wallMat = new THREE.MeshPhongMaterial({ color:0x333333, shininess:6 });
  const floorMat = new THREE.MeshPhongMaterial({ color:0x1f1f2a });
  const floorGeo = new THREE.PlaneGeometry(MAX_COL*CELL_SIZE, MAX_ROW*CELL_SIZE);
  const floor = new THREE.Mesh(floorGeo, floorMat);
  floor.rotation.x = -Math.PI/2;
  scene.add(floor);

  const wallGeo = new THREE.BoxGeometry(CELL_SIZE, WALL_HEIGHT, CELL_SIZE);
  for(let r=0;r<mazeGrid.length;r++){
    for(let c=0;c<mazeGrid[r].length;c++){
      const cell = mazeGrid[r][c];
      const pos = toWorldPosition(r,c,WALL_HEIGHT/2);
      if(cell === 1){
        const wall = new THREE.Mesh(wallGeo, wallMat);
        wall.position.copy(pos);
        scene.add(wall);
        wallObjects.push(wall);
      } else if(cell === 2){
        // store exit position (use lower y for ground marker)
        winPosition = toWorldPosition(r,c,0.5);
      }
    }
  }
}

function spawnOrbs(num){
  const orbGeo = new THREE.SphereGeometry(0.6, 16, 16);
  // Crystal-like emissive material to look bright
  const orbMat = new THREE.MeshPhongMaterial({ color:0x55eeff, emissive:0x004455, emissiveIntensity:0.9, transparent:true, opacity:0.95, shininess:80 });
  // distribute randomly in walkable cells
  while(orbs.length < num){
    const r = Math.floor(Math.random() * MAX_ROW);
    const c = Math.floor(Math.random() * MAX_COL);
    if(mazeGrid[r] && mazeGrid[r][c] === 0){
      const orb = new THREE.Mesh(orbGeo, orbMat);
      orb.position.copy(toWorldPosition(r,c,PLAYER_HEIGHT + 1.5));
      scene.add(orb);
      orbs.push(orb);
    }
  }
}

function addGhosts(count){
  // humanoid-ish capsule geometry (if CapsuleGeometry not available in this version, fallback to cylinder+sphere)
  const ghostMat = new THREE.MeshPhongMaterial({ color:0xaa00ff, transparent:true, opacity:0.7 });
  // create simple humanoid: sphere head + cylinder body
  for(let i=0;i<count;i++){
    let r,c;
    do{ r = Math.floor(Math.random()*MAX_ROW); c = Math.floor(Math.random()*MAX_COL);} while(!(mazeGrid[r] && mazeGrid[r][c] === 0));
    const group = new THREE.Group();
    const bodyGeo = new THREE.CylinderGeometry(0.6,0.9,2.6,8);
    const headGeo = new THREE.SphereGeometry(0.6,12,12);
    const body = new THREE.Mesh(bodyGeo, ghostMat);
    body.position.y = PLAYER_HEIGHT + 1.3;
    const head = new THREE.Mesh(headGeo, ghostMat);
    head.position.y = PLAYER_HEIGHT + 2.5;
    group.add(body); group.add(head);
    const pos = toWorldPosition(r,c,PLAYER_HEIGHT);
    group.position.copy(pos);
    scene.add(group);
    ghosts.push(group);
    ghostGridPosArray.push({r,c});
  }
}

function onKeyDown(e){
  if(e.code==='KeyW' || e.code==='ArrowUp') moveForward=true;
  if(e.code==='KeyS' || e.code==='ArrowDown') moveBackward=true;
  if(e.code==='KeyA' || e.code==='ArrowLeft') moveLeft=true;
  if(e.code==='KeyD' || e.code==='ArrowRight') moveRight=true;
}
function onKeyUp(e){
  if(e.code==='KeyW' || e.code==='ArrowUp') moveForward=false;
  if(e.code==='KeyS' || e.code==='ArrowDown') moveBackward=false;
  if(e.code==='KeyA' || e.code==='ArrowLeft') moveLeft=false;
  if(e.code==='KeyD' || e.code==='ArrowRight') moveRight=false;
}

function onWindowResize(){ camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); }

function updatePlayerGridPosition(){ playerGridPos = toGridPosition(camera.position.x, camera.position.z); }

function findPath(startR,startC,endR,endC){
  if(startR===endR && startC===endC) return [];
  const rows = mazeGrid.length, cols = mazeGrid[0].length;
  const queue = [`${startR},${startC}`], visited = new Set(), parent = {};
  visited.add(`${startR},${startC}`);
  let goalKey = null;
  while(queue.length>0){
    const cur = queue.shift(); const [r,c] = cur.split(',').map(Number);
    if(r===endR && c===endC){ goalKey = cur; break; }
    const dirs = [[-1,0],[1,0],[0,-1],[0,1]];
    for(const [dr,dc] of dirs){
      const nr=r+dr, nc=c+dc;
      if(nr>=0 && nr<rows && nc>=0 && nc<cols){
        const key = `${nr},${nc}`;
        if(mazeGrid[nr][nc] !== 1 && !visited.has(key)){ visited.add(key); parent[key]=cur; queue.push(key); }
      }
    }
  }
  if(!goalKey) return [];
  const path = []; let temp = goalKey;
  while(parent[temp]){ path.unshift(temp.split(',').map(Number)); temp = parent[temp]; }
  return path;
}

function moveGhosts(delta){
  for(let i=0;i<ghosts.length;i++){
    const g = ghosts[i];
    const gg = ghostGridPosArray[i];
    // compute path occasionally to reduce cost (simple: every frame but path lengths are small)
    const path = findPath(gg.r, gg.c, playerGridPos.r, playerGridPos.c);
    if(path.length > 0){
      const target = toWorldPosition(path[0][0], path[0][1], PLAYER_HEIGHT);
      // move toward target
      const dir = new THREE.Vector3().subVectors(target, g.position);
      const dist = dir.length();
      if(dist > 0.1){
        dir.normalize();
        const speed = (GHOST_SPEED * 0.7) * delta * (0.8 + Math.random()*0.4); // little variation
        g.position.addScaledVector(dir, Math.min(speed, dist));
      } else {
        // snap and update ghost grid cell
        g.position.copy(target);
        gg.r = path[0][0]; gg.c = path[0][1];
      }
    } else {
      // wander a tiny bit if no path
      g.position.y = PLAYER_HEIGHT + 0.5 + Math.sin(clock.getElapsedTime()*2 + i)*0.4;
    }
  }
}

function checkCollisions(){
  // ghost catch
  for(const g of ghosts){
    if(g.position.distanceTo(camera.position) < 1.6){ showAlert("YOU GOT CAUGHT BY A GHOST!", false); return; }
  }
  // collect orbs
  for(let i = orbs.length - 1; i >= 0; i--){
    if(camera.position.distanceTo(orbs[i].position) < 1.2){
      scene.remove(orbs[i]); orbs.splice(i,1); collectedOrbs++;
      document.getElementById('orb-count').textContent = `Crystals: ${collectedOrbs}/${TOTAL_ORBS}`;
    }
  }
  // win check (only if collected enough)
  if(collectedOrbs >= TOTAL_ORBS && winPosition){
    if(camera.position.distanceTo(winPosition) < 2.0){ showAlert("YOU ESCAPED! ALL CRYSTALS COLLECTED!", true); }
  }
}

function showAlert(msg, isWin){
  gameActive = false; controls.unlock();
  const box = document.getElementById('message-box'); document.getElementById('message-text').textContent = msg;
  if(isWin) box.classList.add('win-style'); else box.classList.remove('win-style');
  box.style.display = 'block';
  document.getElementById('crosshair').style.opacity = 0;
}

function updateHUD(){
  if(ghosts.length === 0) return;
  const nearest = Math.min(...ghosts.map(g => g.position.distanceTo(camera.position)));
  const threatTxt = nearest > 60 ? "Distant" : nearest > 20 ? "Nearby" : "Very Close";
  document.getElementById('ghost-proximity').textContent = 'Threat: ' + threatTxt;
}

function updateMinimap(){
  const canvas = document.getElementById('minimapCanvas');
  if(!canvas || canvas.style.display === 'none') return;
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  ctx.clearRect(0,0,W,H);
  const cellW = W / MAX_COL, cellH = H / MAX_ROW;
  // draw cells
  for(let r=0;r<MAX_ROW;r++){
    for(let c=0;c<MAX_COL;c++){
      if(mazeGrid[r][c] === 1) ctx.fillStyle = '#444';
      else if(mazeGrid[r][c] === 2) ctx.fillStyle = '#007700';
      else ctx.fillStyle = '#000';
      ctx.fillRect(c*cellW, r*cellH, cellW, cellH);
    }
  }
  // draw orbs (cyan)
  ctx.fillStyle = '#00ffff';
  for(const orb of orbs){
    const pos = toGridPosition(orb.position.x, orb.position.z);
    if(pos.r>=0 && pos.c>=0 && pos.r<MAX_ROW && pos.c<MAX_COL) ctx.fillRect(pos.c*cellW, pos.r*cellH, Math.max(1,cellW/2), Math.max(1,cellH/2));
  }
  // draw player (red)
  updatePlayerGridPosition();
  ctx.fillStyle = '#ff0000';
  ctx.fillRect(playerGridPos.c*cellW, playerGridPos.r*cellH, Math.max(1,cellW), Math.max(1,cellH));
  // draw ghosts as purple dots
  ctx.fillStyle = '#aa00ff';
  for(const g of ghosts){
    const pos = toGridPosition(g.position.x, g.position.z);
    if(pos.r>=0 && pos.c>=0 && pos.r<MAX_ROW && pos.c<MAX_COL) ctx.fillRect(pos.c*cellW, pos.r*cellH, Math.max(1,cellW/1.5), Math.max(1,cellH/1.5));
  }
}

function animate(){
  requestAnimationFrame(animate);
  const delta = clock.getDelta();
  if(gameActive){
    // player movement
    const vel = new THREE.Vector3();
    if(moveForward) vel.z -= 1;
    if(moveBackward) vel.z += 1;
    if(moveLeft) vel.x -= 1;
    if(moveRight) vel.x += 1;
    if(vel.length() > 0){ vel.normalize(); vel.multiplyScalar(effectiveSpeed * delta); controls.moveRight(vel.x); controls.moveForward(vel.z); }
    updatePlayerGridPosition();
    moveGhosts(delta);
    checkCollisions();
    updateHUD();
    updateMinimap();
  }
  renderer.render(scene, camera);
}

// ------- STARTUP -----
init();
animate();

// ===== Hook up ENTER button =====
document.getElementById('startBtn').addEventListener('click', ()=>{
  // pointer lock requires user gesture on the page; call controls.lock()
  controls.lock();
  // info hide will happen on 'lock' event
});

// small helper to ensure the info box is clickable even when user clicks text
document.getElementById('info').addEventListener('click', (e)=>{
  // if they clicked the box area we also lock (redundant)
  if(!controls.isLocked) controls.lock();
});

// ensure minimap hidden initially
document.getElementById('minimapCanvas').style.display = 'none';

/* Debug note: If pointer-lock doesn't work, try clicking the ENTER button and then click inside the black area to give pointer focus. */
</script>
</body>
</html>

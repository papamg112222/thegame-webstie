<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>3D Horror Maze: Crystal Hunt</title>
<script src="https://cdn.tailwindcss.com"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/PointerLockControls.js"></script>
<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght400;700&display=swap" rel="stylesheet">
<style>
body { margin:0; overflow:hidden; background:#050508; font-family:'Orbitron', sans-serif; color:#E0E0E0; user-select:none; }
#info { position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); background:rgba(0,0,0,0.9); border:2px solid #ff4444; padding:2rem; border-radius:.75rem; text-align:center; z-index:1000; box-shadow:0 0 25px rgba(255,68,68,0.7); cursor:pointer; }
#crosshair { position:absolute; top:50%; left:50%; width:10px; height:10px; margin:-5px 0 0 -5px; border:1px solid rgba(255,255,255,0.8); border-radius:50%; z-index:999; pointer-events:none; opacity:0; }
#status-bar { position:absolute; bottom:0; left:0; width:100%; padding:10px 20px; background:rgba(0,0,0,0.7); color:#00ffff; font-size:14px; display:flex; justify-content:space-between; align-items:center; z-index:10; }
.sprinting { color:#ff0000; font-weight:bold; text-shadow:0 0 8px #ff0000; }
#message-box { position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); background:#111; border:2px solid #ff0044; padding:2rem; border-radius:.5rem; text-align:center; z-index:2000; box-shadow:0 0 30px #ff0044; display:none; }
.win-style { border-color:#00ff00 !important; box-shadow:0 0 30px #00ff00 !important; }
.action-button { padding:.75rem 2rem; background:#ff4444; color:#fff; font-weight:bold; border:none; border-radius:.375rem; cursor:pointer; transition:background .2s, transform .1s; }
.action-button:hover { background:#cc3333; transform:scale(1.05); }
#minimap { position:absolute; top:20px; right:20px; width:200px; height:200px; background:rgba(0,0,0,0.7); border:2px solid #00ff00; z-index:50; display:none; }
</style>
</head>
<body>
<div id="info">
<h1 class="text-3xl font-bold mb-4 text-[#ff4444]">CRYSTAL HUNT MAZE</h1>
<p class="text-sm mb-4">Click to enter the darkness. Collect 250 crystal orbs and find the exit while avoiding ghosts.</p>
<p class="text-xl font-bold mb-2">Controls</p>
<p class="mb-4 text-left mx-auto max-w-xs">
W/A/S/D: Move<br>
Mouse: Look<br>
M: Toggle minimap
</p>
<button class="action-button">ENTER</button>
</div>

<div id="status-bar">
<span id="player-status">Status: Walking...</span>
<span id="ghost-proximity">Threat: Distant</span>
<span id="orb-count">Crystals: 0/250</span>
</div>

<div id="crosshair"></div>

<div id="message-box">
<p id="message-text" class="text-xl font-bold mb-4"></p>
<button class="action-button" onclick="closeAlert()">RESTART</button>
</div>

<div id="minimap"></div>

<script type="module">
import * as THREE from 'https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.module.js';

let camera, scene, renderer, controls, raycaster;
let clock = new THREE.Clock();
const infoElement = document.getElementById('info');
const crosshair = document.getElementById('crosshair');
const playerStatus = document.getElementById('player-status');
const ghostProximity = document.getElementById('ghost-proximity');
const orbCountDisplay = document.getElementById('orb-count');
const minimap = document.getElementById('minimap');

const CELL_SIZE=20, WALL_HEIGHT=10, PLAYER_HEIGHT=6;
let offsetX, offsetZ;
const WALK_SPEED=32, GHOST_SPEED=80;
let effectiveSpeed=WALK_SPEED;
const SPRINT_DELAY_DURATION=3.0;
let sprintDelayTimer=0;

let moveForward=false, moveBackward=false, moveLeft=false, moveRight=false;
let gameActive=false, winPosition=null;

let ghosts=[], ghostPathArray=[], ghostGridPosArray=[];
let wallObjects=[], orbs=[], collectedOrbs=0;

const MAX_COL=71, MAX_ROW=71;
const START_COL=1, START_ROW=MAX_ROW-2;
const EXIT_COL=MAX_COL-2, EXIT_ROW=1;
const TOTAL_ORBS=250;

const mazeGrid = generateTrueMaze(MAX_ROW, MAX_COL);

function generateTrueMaze(rows,cols){
    const grid = Array(rows).fill(0).map(()=>Array(cols).fill(1));
    const stack=[];
    stack.push([START_ROW, START_COL]); grid[START_ROW][START_COL]=0;
    while(stack.length>0){
        const [r,c]=stack[stack.length-1];
        const neighbors=[[r-2,c,r-1,c],[r+2,c,r+1,c],[r,c-2,r,c-1],[r,c+2,r,c+1]].filter(([nr,nc])=>nr>0&&nr<rows-1&&nc>0&&nc<cols-1&&grid[nr][nc]===1);
        if(neighbors.length>0){
            const [nr,nc,wr,wc]=neighbors[Math.floor(Math.random()*neighbors.length)];
            grid[nr][nc]=0; grid[wr][wc]=0; stack.push([nr,nc]);
        }else stack.pop();
    }
    grid[EXIT_ROW][EXIT_COL]=2;
    for(let r=1;r<rows-1;r++) for(let c=1;c<cols-1;c++) if(grid[r][c]===1&&Math.random()<0.20) grid[r][c]=0;
    return grid;
}

function toGridPosition(worldX, worldZ){
    return {r:Math.floor((worldZ-offsetZ)/CELL_SIZE),c:Math.floor((worldX-offsetX)/CELL_SIZE)};
}
function toWorldPosition(r,c,yOffset=PLAYER_HEIGHT){
    const x=(c+0.5)*CELL_SIZE+offsetX;
    const z=(r+0.5)*CELL_SIZE+offsetZ;
    return new THREE.Vector3(x,yOffset,z);
}
let playerGridPos={r:0,c:0};
function updatePlayerGridPosition(){playerGridPos=toGridPosition(camera.position.x,camera.position.z);}
function showAlert(msg,isWin){
    gameActive=false; controls.unlock();
    const messageBox=document.getElementById('message-box');
    const messageText=document.getElementById('message-text');
    messageText.textContent=msg;
    if(isWin){messageBox.classList.add('win-style'); messageBox.querySelector('.action-button').style.background='#00ff00';}
    else{messageBox.classList.remove('win-style'); messageBox.querySelector('.action-button').style.background='#ff4444';}
    messageBox.style.display='block'; crosshair.style.opacity=0;
}
window.closeAlert=function(){document.getElementById('message-box').style.display='none'; window.location.reload();};

function findPath(startR,startC,endR,endC){
    if(startR===endR&&startC===endC) return [];
    const rows=mazeGrid.length, cols=mazeGrid[0].length;
    const queue=[`${startR},${startC}`], visited=new Set(), parent={};
    visited.add(`${startR},${startC}`); let goalKey=null;
    while(queue.length>0){
        const currentKey=queue.shift(),[r,c]=currentKey.split(',').map(Number);
        if(r===endR&&c===endC){goalKey=currentKey; break;}
        const directions=[[-1,0],[1,0],[0,-1],[0,1]];
        for(const [dr,dc] of directions){
            const nr=r+dr,nc=c+dc;
            if(nr>=0&&nr<rows&&nc>=0&&nc<cols){
                const neighborKey=`${nr},${nc}`;
                if(mazeGrid[nr][nc]!==1&&!visited.has(neighborKey)){
                    visited.add(neighborKey); parent[neighborKey]=currentKey; queue.push(neighborKey);
                }
            }
        }
    }
    if(!goalKey) return [];
    const fullPath=[]; let tempKey=goalKey;
    while(parent[tempKey]){fullPath.unshift(tempKey.split(',').map(Number)); tempKey=parent[tempKey];}
    return fullPath;
}

function init(){
    scene=new THREE.Scene(); scene.background=new THREE.Color(0x050508); scene.fog=new THREE.Fog(0x050508,CELL_SIZE*5,CELL_SIZE*30);
    camera=new THREE.PerspectiveCamera(75,window.innerWidth/window.innerHeight,0.1,1000); raycaster=new THREE.Raycaster();
    offsetX=-(mazeGrid[0].length*CELL_SIZE)/2; offsetZ=-(mazeGrid.length*CELL_SIZE)/2;
    const startPos=toWorldPosition(START_ROW,START_COL,PLAYER_HEIGHT); camera.position.copy(startPos);
    renderer=new THREE.WebGLRenderer({antialias:true}); renderer.setSize(window.innerWidth,window.innerHeight); renderer.setPixelRatio(window.devicePixelRatio); document.body.appendChild(renderer.domElement);
    const ambientLight=new THREE.AmbientLight(0x404040,0.8); scene.add(ambientLight);
    const pointLight=new THREE.PointLight(0xffffff,1,50); camera.add(pointLight); scene.add(camera);
    controls=new THREE.PointerLockControls(camera,document.body);
    controls.addEventListener('lock',()=>{infoElement.style.display='none'; crosshair.style.opacity=1; gameActive=true;});
    controls.addEventListener('unlock',()=>{if(!document.getElementById('message-box').style.display||document.getElementById('message-box').style.display==='none'){infoElement.style.display='block';} gameActive=false; crosshair.style.opacity=0;});
    document.getElementById('info').addEventListener('click',()=>{controls.lock();});
    buildMaze(); spawnOrbs(TOTAL_ORBS); addGhosts(5);
    document.addEventListener('keydown',onKeyDown,false); document.addEventListener('keyup',onKeyUp,false); window.addEventListener('resize',onWindowResize,false);
    document.addEventListener('keydown',(e)=>{if(e.code==='KeyM'){minimap.style.display=minimap.style.display==='none'?'block':'none';}});
}

function buildMaze(){
    const wallMat=new THREE.MeshPhongMaterial({color:0x333333,shininess:10});
    const floorMat=new THREE.MeshPhongMaterial({color:0x1f1f2a});
    const wallGeo=new THREE.BoxGeometry(CELL_SIZE,WALL_HEIGHT,CELL_SIZE);
    const floorGeo=new THREE.PlaneGeometry(MAX_COL*CELL_SIZE,MAX_ROW*CELL_SIZE);
    const floor=new THREE.Mesh(floorGeo,floorMat); floor.rotation.x=-Math.PI/2; scene.add(floor);
    for(let i=0;i<mazeGrid.length;i++){
        for(let j=0;j<mazeGrid[i].length;j++){
            if(mazeGrid[i][j]===1){
                const wall=new THREE.Mesh(wallGeo,wallMat); wall.position.copy(toWorldPosition(i,j,WALL_HEIGHT/2)); scene.add(wall); wallObjects.push(wall);
            }else if(mazeGrid[i][j]===2){winPosition=toWorldPosition(i,j,PLAYER_HEIGHT);}
        }
    }
}

function spawnOrbs(num){
    const orbGeo=new THREE.SphereGeometry(0.6,16,16); const orbMat=new THREE.MeshPhongMaterial({color:0x00ffff,transparent:true,opacity:0.8,shininess:80});
    while(orbs.length<num){
        const r=Math.floor(Math.random()*MAX_ROW); const c=Math.floor(Math.random()*MAX_COL);
        if(mazeGrid[r][c]===0){
            const orb=new THREE.Mesh(orbGeo,orbMat); orb.position.copy(toWorldPosition(r,c,PLAYER_HEIGHT+1.5));
            scene.add(orb); orbs.push(orb);
        }
    }
}

function addGhosts(count){
    const ghostMat=new THREE.MeshPhongMaterial({color:0xff0000,transparent:true,opacity:0.7});
    const ghostGeo=new THREE.CapsuleGeometry(0.8,3,4,8);
    for(let i=0;i<count;i++){
        const ghost=new THREE.Mesh(ghostGeo,ghostMat); let r,c;
        do{r=Math.floor(Math.random()*MAX_ROW); c=Math.floor(Math.random()*MAX_COL);}while(mazeGrid[r][c]!==0);
        ghost.position.copy(toWorldPosition(r,c,PLAYER_HEIGHT)); scene.add(ghost); ghosts.push(ghost); ghostGridPosArray.push({r,c});
    }
}

function onKeyDown(event){
    switch(event.code){
        case 'ArrowUp': case 'KeyW': moveForward=true; break;
        case 'ArrowLeft': case 'KeyA': moveLeft=true; break;
        case 'ArrowDown': case 'KeyS': moveBackward=true; break;
        case 'ArrowRight': case 'KeyD': moveRight=true; break;
    }
}
function onKeyUp(event){
    switch(event.code){
        case 'ArrowUp': case 'KeyW': moveForward=false; break;
        case 'ArrowLeft': case 'KeyA': moveLeft=false; break;
        case 'ArrowDown': case 'KeyS': moveBackward=false; break;
        case 'ArrowRight': case 'KeyD': moveRight=false; break;
    }
}
function onWindowResize(){camera.aspect=window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth,window.innerHeight);}

function animate(){
    requestAnimationFrame(animate); const delta=clock.getDelta();
    if(gameActive){movePlayer(delta); moveGhosts(delta); checkCollisions();}
    renderer.render(scene,camera); updateHUD(); updateMinimap();
}

function movePlayer(delta){
    let velocity=new THREE.Vector3();
    if(moveForward) velocity.z-=1;
    if(moveBackward) velocity.z+=1;
    if(moveLeft) velocity.x-=1;
    if(moveRight) velocity.x+=1;
    if(velocity.length()>0){velocity.normalize(); velocity.multiplyScalar(effectiveSpeed*delta); controls.moveRight(velocity.x); controls.moveForward(velocity.z);}
    updatePlayerGridPosition();
}

function moveGhosts(delta){
    for(let i=0;i<ghosts.length;i++){
        const ghost=ghosts[i]; const ghostGrid=ghostGridPosArray[i];
        const path=findPath(ghostGrid.r,ghostGrid.c,playerGridPos.r,playerGridPos.c);
        if(path.length>0){
            const next=toWorldPosition(path[0][0],path[0][1],PLAYER_HEIGHT); ghost.position.lerp(next,delta*0.6);
            ghostGrid.r=path[0][0]; ghostGrid.c=path[0][1];
        }
    }
}

function checkCollisions(){
    for(let i=0;i<ghosts.length;i++){
        const dist=ghosts[i].position.distanceTo(camera.position);
        if(dist<1.5){showAlert("YOU GOT CAUGHT BY A GHOST!",false);}
    }
    for(let i=orbs.length-1;i>=0;i--){
        if(camera.position.distanceTo(orbs[i].position)<1.2){scene.remove(orbs[i]); orbs.splice(i,1); collectedOrbs++; orbCountDisplay.textContent=`Crystals: ${collectedOrbs}/${TOTAL_ORBS}`;}
    }
    if(collectedOrbs>=TOTAL_ORBS){
        if(camera.position.distanceTo(winPosition)<1.5){showAlert("YOU ESCAPED! ALL CRYSTALS COLLECTED!",true);}
    }
}

function updateHUD(){
    const nearestGhost=Math.min(...ghosts.map(g=>g.position.distanceTo(camera.position)));
    ghostProximity.textContent="Threat: "+(nearestGhost>15?"Distant":nearestGhost>6?"Nearby":"Very Close");
}

function updateMinimap(){
    if(minimap.style.display==='none') return;
    const ctx=minimap.getContext('2d')||minimap.getContext('2d')||minimap.appendChild(document.createElement('canvas')).getContext('2d');
    ctx.clearRect(0,0,minimap.width,minimap.height);
    const cellW=minimap.width/MAX_COL, cellH=minimap.height/MAX_ROW;
    for(let r=0;r<MAX_ROW;r++){for(let c=0;c<MAX_COL;c++){
        if(mazeGrid[r][c]===1) ctx.fillStyle="#444"; else if(mazeGrid[r][c]===2) ctx.fillStyle="#00ff00"; else ctx.fillStyle="#000"; ctx.fillRect(c*cellW,r*cellH,cellW,cellH);
    }}
    ctx.fillStyle="#00ffff"; for(let orb of orbs){const pos=toGridPosition(orb.position.x,orb.position.z); ctx.fillRect(pos.c*cellW,pos.r*cellH,cellW,cellH);}
    ctx.fillStyle="#ff0000"; ctx.fillRect(playerGridPos.c*cellW,playerGridPos.r*cellH,cellW,cellH);
}

init(); animate();
</script>
</body>
</html>

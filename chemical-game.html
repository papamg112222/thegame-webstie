<script type="module">
    // --- 3D Setup Variables ---
    let camera, scene, renderer, controls, raycaster;
    let clock = new THREE.Clock();
    const infoElement = document.getElementById('info');
    const crosshair = document.getElementById('crosshair');
    const playerStatus = document.getElementById('player-status');
    const ghostProximity = document.getElementById('ghost-proximity');
    const minimap = document.createElement('canvas'); // Create canvas for minimap
    minimap.id = 'minimap';
    document.body.appendChild(minimap); // Append it to the body

    const CELL_SIZE = 20;
    const WALL_HEIGHT = 10;
    const PLAYER_HEIGHT = 6;
    
    // World Offset (Calculated in init, but declared globally for access)
    let offsetX, offsetZ;
    
    // Speed Definitions
    const WALK_SPEED = 32;
    const GHOST_SPEED = 80; // Fast speed for the Ghost AI
    const SPRINT_SPEED = GHOST_SPEED; // Player matches Ghost speed when seen
    let effectiveSpeed = WALK_SPEED;
    
    // Sprint Delay Variables
    const SPRINT_DELAY_DURATION = 3.0; // 3 seconds delay
    let sprintDelayTimer = 0;

    let moveForward = false;
    let moveBackward = false;
    let moveLeft = false;
    let moveRight = false;
    let gameActive = false;
    let winPosition = null;
    let wallObjects = [];

    // --- NEW OBJECT ARRAYS ---
    let ghosts = []; // Array to hold all ghost meshes
    let ghostPaths = []; // Array to hold path for each ghost
    let crystals = []; // Array to hold all collectible crystal meshes
    let crystalsCollected = 0;
    const TOTAL_CRYSTALS = 250;
    
    let playerGridPos = { r: 0, c: 0 }; // Updated in animate loop

    // Maze Grid Definitions
    const MAX_COL = 71;
    const MAX_ROW = 71;
    const START_COL = 1;
    const START_ROW = MAX_ROW - 2;
    const EXIT_COL = MAX_COL - 2;
    const EXIT_ROW = 1;

    // Ghost starting positions (must be open cells)
    const GHOST_START_POSITIONS = [
        { r: MAX_ROW - 2, c: MAX_COL - 2 }, // Near the far corner
        { r: 1, c: 1 }, // Near the exit
        { r: Math.floor(MAX_ROW / 2), c: Math.floor(MAX_COL / 2) + 10 }, // Center-right
        { r: Math.floor(MAX_ROW / 2) + 10, c: Math.floor(MAX_COL / 2) }, // Center-bottom
        { r: 10, c: 10 }, // Top-left corner
        { r: 20, c: MAX_COL - 10 } // Another distant point
    ];
    // Filter to ensure they are open cells (0 or 2)
    GHOST_START_POSITIONS.forEach(pos => {
        if (mazeGrid[pos.r][pos.c] === 1) {
            // Find a nearby open cell if the chosen one is a wall
            for (let dr = -1; dr <= 1; dr++) {
                for (let dc = -1; dc <= 1; dc++) {
                    const nr = pos.r + dr;
                    const nc = pos.c + dc;
                    if (nr >= 0 && nr < MAX_ROW && nc >= 0 && nc < MAX_COL && mazeGrid[nr][nc] !== 1) {
                        pos.r = nr;
                        pos.c = nc;
                        return; // Found a valid start cell
                    }
                }
            }
        }
    });


    // Generate the complex, non-linear maze structure
    const mazeGrid = generateTrueMaze(MAX_ROW, MAX_COL);
    
    // --- Maze Generation (Recursive Backtracker + Aggressive Looping) ---
    /**
     * Generates a complex, non-linear maze structure using a carving algorithm.
     */
    function generateTrueMaze(rows, cols) {
        const grid = Array(rows).fill(0).map(() => Array(cols).fill(1));
        const stack = [];

        // 2. Start carving from the START cell
        stack.push([START_ROW, START_COL]);
        grid[START_ROW][START_COL] = 0; 

        while (stack.length > 0) {
            const [r, c] = stack[stack.length - 1];
            
            const neighbors = [
                [r - 2, c, r - 1, c], [r + 2, c, r + 1, c],
                [r, c - 2, r, c - 1], [r, c + 2, r, c + 1]
            ].filter(([nr, nc]) => 
                nr > 0 && nr < rows - 1 && nc > 0 && nc < cols - 1 && grid[nr][nc] === 1 
            );

            if (neighbors.length > 0) {
                const [nr, nc, wr, wc] = neighbors[Math.floor(Math.random() * neighbors.length)];
                grid[nr][nc] = 0;
                grid[wr][wc] = 0;
                stack.push([nr, nc]);
            } else {
                stack.pop(); 
            }
        }

        // 3. Set the Exit point
        grid[EXIT_ROW][EXIT_COL] = 2; 

        // 4. Introduce LOOPS for complexity
        const LOOP_PERCENTAGE = 0.20; 
        for (let r = 1; r < rows - 1; r++) {
            for (let c = 1; c < cols - 1; c++) {
                if (grid[r][c] === 1 && Math.random() < LOOP_PERCENTAGE) {
                    grid[r][c] = 0; 
                }
            }
        }
        return grid;
    }

    // --- Utility Functions for Grid/World Conversion ---

    /**
     * Converts world coordinates to maze grid coordinates.
     */
    function toGridPosition(worldX, worldZ) {
        const r = Math.floor((worldZ - offsetZ) / CELL_SIZE);
        const c = Math.floor((worldX - offsetX) / CELL_SIZE);
        return { r, c };
    }

    /**
     * Converts grid coordinates to world coordinates (center of the cell).
     */
    function toWorldPosition(r, c) {
        const x = (c + 0.5) * CELL_SIZE + offsetX;
        const z = (r + 0.5) * CELL_SIZE + offsetZ;
        return new THREE.Vector3(x, PLAYER_HEIGHT, z);
    }

    /**
     * Updates the player's current grid position.
     */
    function updatePlayerGridPosition() {
        playerGridPos = toGridPosition(camera.position.x, camera.position.z);
    }
    
    /**
     * Custom alert to avoid window.alert in the iframe.
     */
    function showAlert(message, isWin) {
        gameActive = false;
        controls.unlock();
        const messageBox = document.getElementById('message-box');
        const messageText = document.getElementById('message-text');
        messageText.textContent = message;

        if (isWin) {
            messageBox.classList.add('win-style');
            messageBox.querySelector('.action-button').style.background = '#00ff00';
        } else {
            messageBox.classList.remove('win-style');
            messageBox.querySelector('.action-button').style.background = '#ff4444';
        }

        messageBox.style.display = 'block';
        crosshair.style.opacity = 0;
    }

    window.closeAlert = function() {
        document.getElementById('message-box').style.display = 'none';
        window.location.reload();
    }

    // --- Pathfinding (Breadth-First Search) ---

    /**
     * Uses Breadth-First Search (BFS) to find the shortest path from start to end.
     * Returns an array of grid coordinates (excluding start, including end).
     */
    function findPath(startR, startC, endR, endC) {
        if (startR === endR && startC === endC) return [];
        
        const rows = mazeGrid.length;
        const cols = mazeGrid[0].length;
        const queue = [`${startR},${startC}`];
        const visited = new Set();
        const parent = {}; // Stores { 'r,c': 'parentR,parentC' }
        
        visited.add(`${startR},${startC}`);
        let goalKey = null;

        while (queue.length > 0) {
            const currentKey = queue.shift();
            const [r, c] = currentKey.split(',').map(Number);

            if (r === endR && c === endC) {
                goalKey = currentKey;
                break;
            }

            // Neighbors (N, S, E, W)
            const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];

            for (const [dr, dc] of directions) {
                const nr = r + dr;
                const nc = c + dc;
                
                if (nr >= 0 && nr < rows && nc >= 0 && nc < cols) {
                    const neighborKey = `${nr},${nc}`;
                    
                    // If not a solid wall (1) and not visited
                    if (mazeGrid[nr][nc] !== 1 && !visited.has(neighborKey)) {
                        visited.add(neighborKey);
                        parent[neighborKey] = currentKey; // The current cell is the parent of the neighbor
                        queue.push(neighborKey);
                    }
                }
            }
        }

        // Path reconstruction
        if (!goalKey) return [];

        const fullPath = [];
        let tempKey = goalKey;
        
        // Loop backward from goal until reaching the start cell
        while (parent[tempKey]) {
            fullPath.unshift(tempKey.split(',').map(Number));
            tempKey = parent[tempKey];
        }
        
        // fullPath now contains: [[nextR, nextC], ..., [endR, endC]]
        return fullPath; 
    }

    // --- Initialization ---

    function init() {
        // 1. Scene setup
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x050508);
        scene.fog = new THREE.Fog(0x050508, CELL_SIZE * 5, CELL_SIZE * 30); 

        // 2. Camera setup
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        raycaster = new THREE.Raycaster();
        
        // Calculate and assign world offset for use in grid conversions
        offsetX = -(mazeGrid[0].length * CELL_SIZE) / 2;
        offsetZ = -(mazeGrid.length * CELL_SIZE) / 2;

        // Start position
        const startX = (START_COL + 0.5) * CELL_SIZE + offsetX;
        const startZ = (START_ROW + 0.5) * CELL_SIZE + offsetZ;
        camera.position.set(startX, PLAYER_HEIGHT, startZ);

        // 3. Renderer setup
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        // 4. Lighting
        const ambientLight = new THREE.AmbientLight(0x404040, 0.8);
        scene.add(ambientLight);

        // Flashlight effect
        const pointLight = new THREE.PointLight(0xffffff, 1, 50);
        camera.add(pointLight); 
        scene.add(camera);

        // 5. Controls
        controls = new THREE.PointerLockControls(camera, document.body);

        controls.addEventListener('lock', () => {
            infoElement.style.display = 'none';
            crosshair.style.opacity = 1;
            gameActive = true;
        });
        controls.addEventListener('unlock', () => {
            if (!document.getElementById('message-box').style.display || document.getElementById('message-box').style.display === 'none') {
                infoElement.style.display = 'block';
            }
            gameActive = false;
            crosshair.style.opacity = 0;
        });

        document.getElementById('info').addEventListener('click', () => {
            controls.lock();
        });

        // 6. Build the Maze, Ghosts, and Crystals
        buildMaze(offsetX, offsetZ);
        addGhosts(); // Updated to add multiple ghosts
        addCrystals();
        
        // 7. Mini-map Styling
        minimap.width = 150;
        minimap.height = 150;
        minimap.style.cssText = `
            position: absolute;
            top: 20px;
            right: 20px;
            border: 2px solid #00ffff;
            background: rgba(0, 0, 0, 0.8);
            display: none; /* Starts hidden */
            z-index: 100;
        `;

        // 8. Event listeners
        document.addEventListener('keydown', onKeyDown, false);
        document.addEventListener('keyup', onKeyUp, false);
        window.addEventListener('resize', onWindowResize, false);
    }

    /**
     * Builds the 3D geometry for the maze.
     */
    function buildMaze(offsetX, offsetZ) {
        const wallMaterial = new THREE.MeshPhongMaterial({ color: 0x333333, shininess: 10 });
        const floorMaterial = new THREE.MeshPhongMaterial({ color: 0x1f1f2a });
        const wallGeometry = new THREE.BoxGeometry(CELL_SIZE, WALL_HEIGHT, CELL_SIZE);
        
        // Floor
        const floorGeometry = new THREE.PlaneGeometry(MAX_COL * CELL_SIZE, MAX_ROW * CELL_SIZE);
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        scene.add(floor);

        for (let i = 0; i < mazeGrid.length; i++) {
            for (let j = 0; j < mazeGrid[i].length; j++) {
                const cellType = mazeGrid[i][j];
                const x = j * CELL_SIZE + offsetX + CELL_SIZE / 2;
                const z = i * CELL_SIZE + offsetZ + CELL_SIZE / 2;

                if (cellType === 1) { // Wall
                    const wall = new THREE.Mesh(wallGeometry, wallMaterial);
                    wall.position.set(x, WALL_HEIGHT / 2, z);
                    wall.userData.isWall = true;
                    scene.add(wall);
                    wallObjects.push(wall);
                } else if (cellType === 2) { // Exit
                    const exitMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.8 });
                    const exitGeometry = new THREE.BoxGeometry(CELL_SIZE * 0.8, WALL_HEIGHT / 4, CELL_SIZE * 0.8);
                    const exitCube = new THREE.Mesh(exitGeometry, exitMaterial);
                    exitCube.position.set(x, 0.1, z);
                    exitCube.userData.isExit = true;
                    
                    const exitLight = new THREE.PointLight(0x00ff00, 2, 25);
                    exitLight.position.set(x, 5, z);
                    scene.add(exitLight);
                    exitCube.userData.light = exitLight;

                    scene.add(exitCube);
                    winPosition = exitCube;
                }
            }
        }
    }
    
    /**
     * Adds ALL ghost entities to the scene.
     */
    function addGhosts() {
        const ghostMaterial = new THREE.MeshBasicMaterial({ 
            color: 0xaa00ff, // Magenta/Purple/Menacing
            transparent: true,
            opacity: 0.5,
            blending: THREE.AdditiveBlending 
        });
        const ghostGeometry = new THREE.SphereGeometry(2, 16, 16);
        
        ghosts = [];
        ghostPaths = [];
        
        GHOST_START_POSITIONS.forEach((startPos, index) => {
            const ghostMesh = new THREE.Mesh(ghostGeometry, ghostMaterial);
            ghostMesh.userData.isGhost = true;
            
            const ghostWorldPos = toWorldPosition(startPos.r, startPos.c);
            ghostMesh.position.copy(ghostWorldPos);
            
            // Add a point light to make it glow
            const ghostLight = new THREE.PointLight(0xaa00aa, 4, 50);
            ghostMesh.add(ghostLight);
            
            scene.add(ghostMesh);
            ghosts.push(ghostMesh);
            ghostPaths.push([]); // Initialize empty path for this ghost
        });
    }

    /**
     * Adds the collectible crystal objects to the scene.
     */
    function addCrystals() {
        const crystalMaterial = new THREE.MeshPhongMaterial({
            color: 0x00ffff, // Cyan/Aqua for the crystal
            emissive: 0x00ffff,
            emissiveIntensity: 0.5,
            specular: 0xffffff,
            shininess: 100,
            transparent: true,
            opacity: 0.9
        });
        // Use a Dodecahedron for a 'crystal' look
        const crystalGeometry = new THREE.DodecahedronGeometry(1); 
        
        let count = 0;
        for (let i = 1; i < MAX_ROW - 1; i += 2) { // Only check open corridors
            for (let j = 1; j < MAX_COL - 1; j += 2) {
                if (mazeGrid[i][j] !== 1 && Math.random() < 0.2) { // Randomly place in open cells
                    if (count >= TOTAL_CRYSTALS) return;
                    
                    const crystal = new THREE.Mesh(crystalGeometry, crystalMaterial);
                    const worldPos = toWorldPosition(i, j);
                    crystal.position.set(worldPos.x + (Math.random() - 0.5) * 5, 
                                        PLAYER_HEIGHT / 2, // Half the player height so it's on the ground
                                        worldPos.z + (Math.random() - 0.5) * 5);
                    crystal.userData.isCrystal = true;
                    crystal.userData.gridPos = { r: i, c: j };
                    
                    scene.add(crystal);
                    crystals.push(crystal);
                    count++;
                }
            }
        }
    }

    /**
     * Checks if the ghost is in direct line of sight (pure check).
     */
    function isGhostVisible(ghostMesh) {
        if (!ghostMesh) return false;

        const playerPosition = camera.position.clone();
        const ghostPosition = ghostMesh.position.clone();

        // Check if distance is too far to bother with raycasting
        const dist = playerPosition.distanceTo(ghostPosition);
        if (dist > CELL_SIZE * 10) {
             return false;
        }

        // Direction vector from player to ghost
        const direction = new THREE.Vector3().subVectors(ghostPosition, playerPosition).normalize();

        // Setup Raycaster
        raycaster.set(playerPosition, direction);

        // Check for intersections with walls
        const intersects = raycaster.intersectObjects(wallObjects);

        // If intersections exist, check the distance
        if (intersects.length > 0) {
            const distanceToWall = intersects[0].distance;
            
            // If distance to ghost is less than distance to the closest wall, the ghost is visible.
            return dist < distanceToWall - 0.5;
        }
        
        return true; // No wall between
    }

    /**
     * Handles the Ghost's movement and AI.
     */
    function moveGhosts(delta) {
        const currentTime = clock.getElapsedTime();

        ghosts.forEach((ghostMesh, index) => {
            const ghostWorldPos = ghostMesh.position;
            const ghostIsSeeingPlayer = isGhostVisible(ghostMesh);
            let ghostPath = ghostPaths[index]; // Current path for this specific ghost

            // --- Smart AI Update Logic: Only update path if player is visible ---
            if (ghostIsSeeingPlayer) {
                // If the ghost sees the player, recalculate the direct shortest path immediately.
                const ghostGridPos = toGridPosition(ghostWorldPos.x, ghostWorldPos.z);
                
                // Find path from ghost's current cell to the player's current cell
                ghostPath = findPath(
                    ghostGridPos.r, ghostGridPos.c, 
                    playerGridPos.r, playerGridPos.c
                );
                
                ghostPaths[index] = ghostPath; // Update the stored path
                // Note: Not resetting lastPathUpdateTime as all ghosts should always track if visible.
            }
            // The ghost continues to follow the last path if it loses sight.

            // --- Movement Execution ---
            if (ghostPath.length > 0) {
                // The first cell in the path is the next target cell
                const [nextR, nextC] = ghostPath[0];
                const targetWorldPos = toWorldPosition(nextR, nextC);
                
                // Use vector interpolation for smooth movement
                const moveDistance = GHOST_SPEED * delta;
                
                // Check if we will overshoot the target
                if (ghostWorldPos.distanceTo(targetWorldPos) < moveDistance) {
                    // Snap to target and remove this cell from the path
                    ghostWorldPos.x = targetWorldPos.x;
                    ghostWorldPos.z = targetWorldPos.z;
                    ghostPath.shift(); 
                } else {
                    // Move towards the target position
                    const direction = new THREE.Vector3().subVectors(targetWorldPos, ghostWorldPos).normalize();
                    ghostWorldPos.addScaledVector(direction, moveDistance);
                }
                
                // Make the ghost face the direction of movement
                if (ghostPath.length > 0) {
                    const lookAtTarget = toWorldPosition(ghostPath[0][0], ghostPath[0][1]);
                    ghostMesh.lookAt(lookAtTarget.x, ghostWorldPos.y, lookAtTarget.z);
                }
            }
            
            // Simple bobbing and rotation (always on)
            ghostMesh.rotation.y += 1.0 * delta;
            ghostMesh.position.y = PLAYER_HEIGHT + 0.5 + Math.sin(currentTime * 3 + index) * 0.5;

            // --- Check for Game Over (Catch) ---
            checkCatchCondition(ghostWorldPos);
        });
    }

    /**
     * Checks if the Ghost has caught the player (Game Over condition).
     */
    function checkCatchCondition(ghostPosition) {
        const catchDistance = 3; // Catch if distance is less than 3 units
        const dist = camera.position.distanceTo(ghostPosition);

        if (dist < catchDistance) {
            showAlert("CAUGHT! The Ghost found you in the dark maze.", false);
        }
    }

    /**
     * Checks if the player is collecting a crystal.
     */
    function checkCrystalCollection() {
        const playerPos = camera.position;
        const collectionRadius = 2; // Radius to collect a crystal

        for (let i = crystals.length - 1; i >= 0; i--) {
            const crystal = crystals[i];
            if (playerPos.distanceTo(crystal.position) < collectionRadius) {
                scene.remove(crystal);
                crystals.splice(i, 1);
                crystalsCollected++;
                
                // Update status bar immediately
                updateStatusBar(); 

                // Check for collection complete
                if (crystalsCollected >= TOTAL_CRYSTALS) {
                    minimap.style.display = 'block'; // Show the map!
                }

                // Only allow collecting one crystal per frame to prevent skipping
                return;
            }
        }
    }

    /**
     * Updates the status bar with current game info.
     */
    function updateStatusBar() {
        // Player Status is handled inside the animate loop based on visibility/sprint timer
        
        // Threat Proximity (Using the closest ghost)
        let closestDist = Infinity;
        ghosts.forEach(ghost => {
            const dist = camera.position.distanceTo(ghost.position);
            closestDist = Math.min(closestDist, dist);
        });

        if (closestDist > CELL_SIZE * 10) {
             ghostProximity.textContent = `Threat: Distant | Crystals: ${crystalsCollected}/${TOTAL_CRYSTALS}`;
        } else if (closestDist > CELL_SIZE * 4) {
             ghostProximity.textContent = `Threat: Nearby | Crystals: ${crystalsCollected}/${TOTAL_CRYSTALS}`;
        } else {
             ghostProximity.textContent = `THREAT: IMMINENT! | Crystals: ${crystalsCollected}/${TOTAL_CRYSTALS}`;
        }
    }

    /**
     * Draws the minimap if unlocked.
     */
    function updateMinimap() {
        if (minimap.style.display === 'none') return;

        const ctx = minimap.getContext('2d');
        const mapSize = minimap.width;
        const cellMapSize = mapSize / MAX_COL;

        ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
        ctx.fillRect(0, 0, mapSize, mapSize);

        // Draw Walls (The white background of the canvas is the open space)
        ctx.fillStyle = '#111111'; // Dark color for walls
        for (let r = 0; r < MAX_ROW; r++) {
            for (let c = 0; c < MAX_COL; c++) {
                if (mazeGrid[r][c] === 1) {
                    ctx.fillRect(c * cellMapSize, r * cellMapSize, cellMapSize, cellMapSize);
                }
            }
        }

        // Draw Exit (Green dot)
        ctx.fillStyle = '#00ff00';
        ctx.fillRect(EXIT_COL * cellMapSize, EXIT_ROW * cellMapSize, cellMapSize, cellMapSize);
        
        // Draw Player (Red dot in the center of its grid cell)
        ctx.fillStyle = '#ff0000';
        ctx.beginPath();
        const playerMapX = playerGridPos.c * cellMapSize + cellMapSize / 2;
        const playerMapY = playerGridPos.r * cellMapSize + cellMapSize / 2;
        ctx.arc(playerMapX, playerMapY, cellMapSize * 0.4, 0, 2 * Math.PI);
        ctx.fill();
    }


    // --- Input Handlers (Unchanged) ---

    function onKeyDown(event) {
        switch (event.code) {
            case 'ArrowUp': case 'KeyW': moveForward = true; break;
            case 'ArrowLeft': case 'KeyA': moveLeft = true; break;
            case 'ArrowDown': case 'KeyS': moveBackward = true; break;
            case 'ArrowRight': case 'KeyD': moveRight = true; break;
        }
    }

    function onKeyUp(event) {
        switch (event.code) {
            case 'ArrowUp': case 'KeyW': moveForward = false; break;
            case 'ArrowLeft': case 'KeyA': moveLeft = false; break;
            case 'ArrowDown': case 'KeyS': moveBackward = false; break;
            case 'ArrowRight': case 'KeyD': moveRight = false; break;
        }
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    // --- Game Loop and Logic ---

    function animate() {
        requestAnimationFrame(animate);

        const delta = clock.getDelta();

        if (controls.isLocked === true && gameActive) {
            
            // 1. Update Player position
            updatePlayerGridPosition(); 
            
            // Check Ghost vision (now checking ALL ghosts)
            let ghostInSight = false;
            ghosts.forEach(ghost => {
                if(isGhostVisible(ghost)) {
                    ghostInSight = true;
                }
            });
            
            // 2. Ghost AI Movement (All six ghosts move)
            moveGhosts(delta); 

            // 3. Crystal Collection Check
            checkCrystalCollection();

            // --- Sprint Logic (With 3-second delay) ---
            
            if (ghostInSight) {
                // Ghost is in sight: Sprint immediately, reset delay timer
                effectiveSpeed = SPRINT_SPEED;
                sprintDelayTimer = SPRINT_DELAY_DURATION; 
                playerStatus.textContent = "Status: SPRINTING! (GO! GO! GO!)";
                playerStatus.classList.add('sprinting');
            } else if (sprintDelayTimer > 0) {
                // Ghost is out of sight, but delay is active: Keep sprinting
                sprintDelayTimer -= delta;
                // Clamp timer to prevent negative display numbers
                sprintDelayTimer = Math.max(0, sprintDelayTimer);
                effectiveSpeed = SPRINT_SPEED;
                playerStatus.textContent = `Status: SPRINTING! (Delay: ${sprintDelayTimer.toFixed(1)}s)`;
                playerStatus.classList.add('sprinting');
            } else {
                // Delay expired or never triggered: Walk
                effectiveSpeed = WALK_SPEED;
                playerStatus.textContent = "Status: Walking...";
                playerStatus.classList.remove('sprinting');
            }
            
            // --- Status Bar Update ---
            updateStatusBar();

            // 4. Movement Calculation
            const velocity = new THREE.Vector3();
            if (moveForward) velocity.z -= effectiveSpeed * delta;
            if (moveBackward) velocity.z += effectiveSpeed * delta;
            if (moveLeft) velocity.x -= effectiveSpeed * delta;
            if (moveRight) velocity.x += effectiveSpeed * delta;

            const oldPosition = camera.position.clone();
            
            // Apply movement
            controls.moveRight(velocity.x); 
            controls.moveForward(-velocity.z);

            // --- Collision Detection ---
            const currentGridX = Math.floor((camera.position.x - offsetX) / CELL_SIZE);
            const currentGridZ = Math.floor((camera.position.z - offsetZ) / CELL_SIZE);

            if (isColliding(currentGridX, currentGridZ, oldPosition)) {
                camera.position.copy(oldPosition);
            }

            // --- Win Condition ---
            checkWinCondition();
            
            // Animate exit light pulse & crystals
            if (winPosition && winPosition.userData.light) {
                winPosition.userData.light.intensity = 2 + Math.sin(clock.getElapsedTime() * 5) * 1;
            }
            crystals.forEach(crystal => {
                crystal.rotation.y += 2 * delta;
                crystal.position.y = PLAYER_HEIGHT / 2 + 0.5 + Math.sin(clock.getElapsedTime() * 4) * 0.2;
            });

            // 5. Update Minimap
            updateMinimap();
        }

        renderer.render(scene, camera);
    }

    /**
     * Checks the player's position against the maze grid for walls.
     */
    function isColliding(gridX, gridZ, oldPosition) {
        // Check bounds 
        if (gridZ < 0 || gridZ >= mazeGrid.length || gridX < 0 || gridX >= mazeGrid[0].length) {
            return true;
        }

        if (mazeGrid[gridZ][gridX] === 1) {
            
            // Attempt to revert movement along one axis to unstick the player
            
            // Test X-revert:
            const tempX = oldPosition.x;
            const tempZ = camera.position.z;
            
            let testGridX = Math.floor((tempX - offsetX) / CELL_SIZE);
            let testGridZ = Math.floor((tempZ - offsetZ) / CELL_SIZE);
            
            if (mazeGrid[testGridZ] && mazeGrid[testGridZ][testGridX] === 1) {
                camera.position.z = oldPosition.z;
            }
            
            // Test Z-revert:
            const tempX_2 = camera.position.x;
            const tempZ_2 = oldPosition.z;

            let testGridX_2 = Math.floor((tempX_2 - offsetX) / CELL_SIZE);
            let testGridZ_2 = Math.floor((tempZ_2 - offsetZ) / CELL_SIZE);
            
            if (mazeGrid[testGridZ_2] && mazeGrid[testGridZ_2][testGridX_2] === 1) {
                camera.position.x = oldPosition.x;
            }

            // Final check after partial reverts
            const finalGridX = Math.floor((camera.position.x - offsetX) / CELL_SIZE);
            const finalGridZ = Math.floor((camera.position.z - offsetZ) / CELL_SIZE);
            
            if (mazeGrid[finalGridZ] && mazeGrid[finalGridZ][finalGridX] === 1) {
                return true; 
            }
        }
        return false;
    }

    function checkWinCondition() {
        if (!winPosition) return;
        
        const distanceToExit = camera.position.distanceTo(winPosition.position);
        
        if (distanceToExit < CELL_SIZE / 2) {
            showAlert("SUCCESS! You escaped the deep maze and the Ghost's sight!", true);
        }
    }

    // --- Start the App ---
    window.onload = function () {
        init();
        animate();
    };

</script>
/* ... existing styles ... */
        
        #status-bar {
            /* ... existing status-bar styles ... */
        }
        .sprinting {
            /* ... existing sprinting styles ... */
        }
        
        /* --- NEW MINIMAP STYLE --- */
        #minimap {
            position: absolute;
            top: 20px;
            right: 20px;
            border: 2px solid #00ffff; /* Aqua border */
            background: rgba(0, 0, 0, 0.8);
            display: none; /* Initially hidden */
            z-index: 100;
        }
        /* -------------------------- */
    </style>

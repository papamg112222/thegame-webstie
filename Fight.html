<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Pixel Commando 3D: Ultimate</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #1a1a24;
            font-family: 'Press Start 2P', cursive;
            touch-action: none;
            user-select: none;
        }

        #game-container {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
        }

        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            display: flex; flex-direction: column; justify-content: space-between;
            z-index: 10;
        }

        /* HUD */
        .hud-top {
            display: flex; justify-content: space-between; align-items: flex-start;
            padding: 20px; width: 100%; box-sizing: border-box;
        }

        .bar-wrap {
            width: 40%; display: flex; flex-direction: column; gap: 5px;
        }

        .score-board {
            display: flex; flex-direction: column; align-items: center;
            width: 20%; margin-top: -5px;
        }
        
        .round-score {
            font-size: 30px; color: #fff; text-shadow: 2px 2px 0 #000;
            background: rgba(0,0,0,0.5); padding: 5px 10px; border: 2px solid #fff;
        }
        .round-label { font-size: 10px; color: #aaa; margin-bottom: 5px; }

        .hp-border {
            border: 3px solid #fff; background: #000; height: 20px;
            position: relative; box-shadow: 4px 4px 0 rgba(0,0,0,0.5); transform: skewX(-10deg);
        }

        .hp-fill {
            height: 100%; background: linear-gradient(to right, #ffaa00, #ffff00);
            width: 100%; transition: width 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        }
        .p2-fill { background: linear-gradient(to right, #aa0000, #ff4444); }

        .stam-border {
            border: 2px solid #888; background: #000; height: 8px;
            position: relative; width: 80%; transform: skewX(-10deg);
        }
        .stam-fill {
            height: 100%; background: linear-gradient(to right, #00ffff, #0088ff);
            width: 100%; transition: width 0.1s linear;
        }

        .name { color: #fff; margin-bottom: 2px; text-shadow: 2px 2px #000; font-size: 10px; letter-spacing: 2px; }

        /* BIG TEXT OVERLAYS */
        .center-msg {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            font-size: 80px; color: #ff0; text-shadow: 5px 5px 0 #f00, -2px -2px 0 #fff;
            white-space: nowrap; opacity: 0; pointer-events: none; z-index: 50;
        }
        
        .anim-pop { animation: popIn 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards; }
        .anim-shake { animation: shake 0.5s infinite; }
        
        @keyframes popIn { 0% { opacity:0; transform: translate(-50%, -50%) scale(0); } 80% { transform: translate(-50%, -50%) scale(1.2); opacity: 1; } 100% { transform: translate(-50%, -50%) scale(1); opacity: 1; } }
        @keyframes shake { 0% { transform: translate(-50%, -50%) rotate(0deg); } 25% { transform: translate(-52%, -48%) rotate(-5deg); } 75% { transform: translate(-48%, -52%) rotate(5deg); } 100% { transform: translate(-50%, -50%) rotate(0deg); } }

        /* CONTROLS */
        #controls { pointer-events: auto; padding: 20px; display: flex; justify-content: space-between; align-items: flex-end; margin-bottom: 10px; }
        .d-pad { display: flex; gap: 15px; align-items: flex-end; }
        .action-pad { position: relative; width: 240px; height: 240px; }
        
        .btn {
            background: rgba(255, 255, 255, 0.1); border: 2px solid rgba(255,255,255,0.6);
            color: white; display: flex; justify-content: center; align-items: center;
            font-size: 20px; box-shadow: 0 4px 0 #000; transition: all 0.05s;
            cursor: pointer; backdrop-filter: blur(4px);
        }
        .btn:active, .btn.pressed { transform: translateY(4px); box-shadow: 0 0 0 #000; background: rgba(255, 255, 255, 0.3); }

        .btn-move { width: 75px; height: 75px; border-radius: 12px; }
        .move-col { display: flex; flex-direction: column; align-items: center; gap: 15px; }
        .btn-jump { width: 85px; height: 85px; border-radius: 12px; background: rgba(0, 255, 0, 0.15); border-color: #0f0; }
        .btn-block { width: 70px; height: 70px; border-radius: 12px; background: rgba(50, 50, 255, 0.15); border-color: #55f; font-size: 12px; }

        .btn-atk { position: absolute; bottom: 0; right: 0; width: 110px; height: 110px; border-radius: 50%; background: rgba(255, 0, 0, 0.2); border-color: #f00; font-size: 16px; z-index: 20; }
        .btn-skill { position: absolute; width: 65px; height: 65px; border-radius: 50%; font-size: 8px; border-width: 2px; text-align: center; line-height: 1.2; padding: 2px; }
        .btn-s1 { bottom: 25px; right: 125px; border-color: #0ff; color: #0ff; background: rgba(0, 255, 255, 0.15); }
        .btn-s2 { bottom: 100px; right: 100px; border-color: #ff0; color: #ff0; background: rgba(255, 255, 0, 0.15); }
        .btn-s3 { bottom: 130px; right: 20px; border-color: #f0f; color: #f0f; background: rgba(255, 0, 255, 0.15); }
        .cd-overlay { position: absolute; top:0; left:0; width:100%; height:100%; background: rgba(0,0,0,0.8); border-radius: 50%; display: none; justify-content: center; align-items: center; font-size: 14px; }

        .combo-box { position: absolute; top: 120px; width: 150px; display: flex; flex-direction: column; opacity: 0; transition: opacity 0.2s; }
        .c-left { left: 20px; align-items: flex-start; } .c-right { right: 20px; align-items: flex-end; }
        .combo-count { font-size: 30px; color: #fff; text-shadow: 3px 3px 0 #f00; }
        .combo-bar { width: 100%; height: 6px; background: #333; border: 1px solid #fff; }
        .combo-fill { height: 100%; background: #ffcc00; width: 100%; }

        /* MENUS */
        .screen-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: #111; display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 100; color: #fff; }
        .hidden { display: none !important; }
        h1 { color: #ff3333; text-shadow: 4px 4px 0 #500, -2px -2px 0 #fff; font-size: 40px; text-align: center; margin-bottom: 20px; line-height: 1.5; }
        .menu-btn { padding: 20px 40px; font-family: inherit; font-size: 20px; background: linear-gradient(to bottom, #4444ff, #0000aa); color: #fff; border: 4px solid #fff; box-shadow: 0 8px 0 #000055; cursor: pointer; text-transform: uppercase; margin: 10px; width: 280px; text-align: center; }
        .menu-btn:active { transform: translateY(8px); box-shadow: 0 0 0 #000; }
        .btn-secondary { background: linear-gradient(to bottom, #444, #222); box-shadow: 0 8px 0 #111; font-size: 16px; padding: 15px; }

    </style>
</head>
<body>

<div id="game-container"></div>

<div id="ui-layer">
    <div class="hud-top">
        <div class="bar-wrap">
            <div class="name">P1: ELITE</div>
            <div class="hp-border"><div class="hp-fill" id="p1-hp"></div></div>
            <div class="stam-border"><div class="stam-fill" id="p1-stam"></div></div>
        </div>
        
        <div class="score-board">
            <div class="round-label">ROUNDS</div>
            <div class="round-score"><span id="score-p1">0</span> - <span id="score-p2">0</span></div>
        </div>

        <div class="bar-wrap" style="align-items: flex-end;">
            <div class="name">P2: ROGUE</div>
            <div class="hp-border" style="width: 100%"><div class="hp-fill p2-fill" id="p2-hp"></div></div>
            <div class="stam-border" style="width: 80%"><div class="stam-fill" id="p2-stam"></div></div>
        </div>
    </div>
    
    <div id="msg-overlay" class="center-msg"></div>

    <div id="c1-box" class="combo-box c-left"><div style="font-size:10px;color:#fc0">COMBO</div><div id="c1-num" class="combo-count">0</div><div class="combo-bar"><div id="c1-bar" class="combo-fill"></div></div></div>
    <div id="c2-box" class="combo-box c-right"><div style="font-size:10px;color:#fc0">COMBO</div><div id="c2-num" class="combo-count">0</div><div class="combo-bar"><div id="c2-bar" class="combo-fill"></div></div></div>

    <div id="controls">
        <div class="d-pad">
            <div class="btn btn-move" id="btn-left">◀</div>
            <div class="move-col">
                <div class="btn btn-jump" id="btn-jump">JUMP</div>
                <div class="btn btn-block" id="btn-block">BLOCK</div>
            </div>
            <div class="btn btn-move" id="btn-right">▶</div>
        </div>
        <div class="action-pad">
            <div class="btn btn-atk" id="btn-atk">ATK</div>
            <div class="btn btn-skill btn-s1" id="btn-s1">BLAST<div class="cd-overlay" id="cd-s1"></div></div>
            <div class="btn btn-skill btn-s2" id="btn-s2">DASH<div class="cd-overlay" id="cd-s2"></div></div>
            <div class="btn btn-skill btn-s3" id="btn-s3">ULT<div class="cd-overlay" id="cd-s3"></div></div>
        </div>
    </div>
</div>

<div id="start-screen" class="screen-overlay">
    <h1>PIXEL COMMANDO<br>ULTIMATE</h1>
    <p style="font-size: 12px; color: #888;">TACTICAL ENGINE V5.0 // ROUND SYSTEM</p>
    <button class="menu-btn" id="start-btn">START GAME</button>
    <button class="menu-btn btn-secondary" id="local-menu-btn">PLAY LOCAL</button>
</div>

<div id="local-screen" class="screen-overlay hidden">
    <h1>LOCAL PLAY</h1>
    <button class="menu-btn" id="host-btn">HOST GAME</button>
    <button class="menu-btn" id="join-btn">JOIN GAME</button>
    <button class="menu-btn btn-secondary" id="back-btn">BACK</button>
</div>

<!-- Audio & Game Script -->
<script>
    const AudioSys = {
        ctx: null,
        init: () => { window.AudioContext = window.AudioContext || window.webkitAudioContext; AudioSys.ctx = new AudioContext(); },
        playTone: (freq, type, dur, vol=0.1) => {
            if(!AudioSys.ctx) return;
            const osc = AudioSys.ctx.createOscillator(); const gain = AudioSys.ctx.createGain();
            osc.type = type; osc.frequency.setValueAtTime(freq, AudioSys.ctx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(freq/2, AudioSys.ctx.currentTime + dur);
            gain.gain.setValueAtTime(vol, AudioSys.ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, AudioSys.ctx.currentTime + dur);
            osc.connect(gain); gain.connect(AudioSys.ctx.destination);
            osc.start(); osc.stop(AudioSys.ctx.currentTime + dur);
        },
        noise: (dur) => {
            if(!AudioSys.ctx) return;
            const size = AudioSys.ctx.sampleRate * dur; const buf = AudioSys.ctx.createBuffer(1, size, AudioSys.ctx.sampleRate);
            const data = buf.getChannelData(0); for(let i=0;i<size;i++) data[i] = Math.random()*2-1;
            const src = AudioSys.ctx.createBufferSource(); src.buffer = buf;
            const gain = AudioSys.ctx.createGain(); gain.gain.setValueAtTime(0.2, AudioSys.ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, AudioSys.ctx.currentTime + dur);
            src.connect(gain); gain.connect(AudioSys.ctx.destination); src.start();
        },
        playBlock: () => { if(AudioSys.ctx) { AudioSys.playTone(800, 'square', 0.1, 0.05); } },
        playAnnouncer: (freqs) => { 
            if(!AudioSys.ctx) return;
            freqs.forEach((f, i) => setTimeout(() => AudioSys.playTone(f, 'square', 0.1, 0.2), i*100));
        }
    };

    // --- THREE.JS ---
    const container = document.getElementById('game-container');
    const renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.shadowMap.enabled = true;
    container.appendChild(renderer.domElement);

    const sceneGame = new THREE.Scene(); sceneGame.background = new THREE.Color(0x1a1a24); sceneGame.fog = new THREE.Fog(0x1a1a24, 15, 40);
    const sceneScreen = new THREE.Scene();
    const aspect = window.innerWidth / window.innerHeight;
    const camGame = new THREE.PerspectiveCamera(40, aspect, 0.1, 100); camGame.position.set(0, 7, 24); 
    const camScreen = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
    const renderTarget = new THREE.WebGLRenderTarget(480, Math.floor(480/aspect), { minFilter: THREE.NearestFilter, magFilter: THREE.NearestFilter });
    sceneScreen.add(new THREE.Mesh(new THREE.PlaneGeometry(2, 2), new THREE.MeshBasicMaterial({ map: renderTarget.texture })));

    const ambLight = new THREE.AmbientLight(0x404050, 0.6); sceneGame.add(ambLight);
    const dirLight = new THREE.DirectionalLight(0xffeebb, 0.9); dirLight.position.set(10, 20, 10); dirLight.castShadow = true;
    dirLight.shadow.mapSize.width = 1024; dirLight.shadow.mapSize.height = 1024;
    dirLight.shadow.camera.left = -20; dirLight.shadow.camera.right = 20; sceneGame.add(dirLight);

    function createGridTexture() {
        const c = document.createElement('canvas'); c.width = 64; c.height = 64;
        const x = c.getContext('2d'); x.fillStyle = '#111116'; x.fillRect(0,0,64,64);
        x.strokeStyle = '#222230'; x.lineWidth = 2; x.strokeRect(0,0,64,64);
        x.fillStyle = '#1a1a24'; x.fillRect(2,2,60,60);
        const t = new THREE.CanvasTexture(c); t.magFilter = THREE.NearestFilter; t.minFilter = THREE.NearestFilter;
        t.wrapS = THREE.RepeatWrapping; t.wrapT = THREE.RepeatWrapping; t.repeat.set(50, 20); return t;
    }
    const ground = new THREE.Mesh(new THREE.PlaneGeometry(200, 40), new THREE.MeshStandardMaterial({ map: createGridTexture(), roughness: 0.8 }));
    ground.rotation.x = -Math.PI/2; ground.receiveShadow = true; sceneGame.add(ground);

    const boxGeo = new THREE.BoxGeometry(1,1,1);
    for(let i=0; i<30; i++) {
        const h = 2+Math.random()*6; const m = new THREE.Mesh(boxGeo, new THREE.MeshLambertMaterial({color: 0x0a1a10}));
        m.position.set((Math.random()-0.5)*80, h/2, -5 - Math.random()*15); m.scale.set(1, h, 1);
        m.castShadow = true; m.receiveShadow = true; sceneGame.add(m);
    }

    const GRAVITY = 0.035; const GROUND = 0; const MAP_LIMIT = 14.0;
    let particles = [];
    class Particle {
        constructor(x, y, z, color, size, life, vel, grav=0, glow=false) {
            this.mesh = new THREE.Mesh(boxGeo, new THREE.MeshBasicMaterial({ color: color, transparent: true }));
            this.mesh.position.set(x, y, z); this.mesh.scale.set(size, size, size);
            this.vel = vel; this.life = life; this.maxLife = life; this.grav = grav;
            if(glow) { const l = new THREE.PointLight(color, 1, 3); this.mesh.add(l); }
            sceneGame.add(this.mesh);
        }
        update() {
            this.vel.y -= this.grav; this.mesh.position.add(this.vel);
            this.life--; this.mesh.rotation.x += 0.2;
            this.mesh.material.opacity = this.life / this.maxLife;
            if(this.life <= 0) { sceneGame.remove(this.mesh); return false; }
            return true;
        }
    }
    function spawnDust(x, z, count) {
        for(let i=0; i<count; i++) particles.push(new Particle(x, 0.1, z+(Math.random()-0.5), 0xaaaaaa, 0.2, 20, new THREE.Vector3((Math.random()-0.5)*0.1, Math.random()*0.1, (Math.random()-0.5)*0.1)));
    }
    function spawnExplosion(x, y, z, color, count) {
        for(let i=0; i<count; i++) {
            const v = new THREE.Vector3((Math.random()-0.5)*0.5, (Math.random()-0.5)*0.5, (Math.random()-0.5)*0.5);
            particles.push(new Particle(x, y, z, color, 0.5, 30, v, 0, true));
        }
    }

    // --- CHARACTER ---
    class Character {
        constructor(x, color, isPlayer, id) {
            this.startX = x;
            this.x = x; this.y = 0; this.z = 0;
            this.vx = 0; this.vy = 0;
            this.speed = 0.22; this.friction = 0.8;
            this.facingRight = isPlayer;
            this.hp = 100; this.maxStamina = 100; this.stamina = 100; this.tired = false;
            this.state = 'idle'; this.animTimer = 0; this.runTime = 0;
            this.combo = 0; this.lastAttackTime = 0;
            this.cooldowns = { s1:0, s2:0, s3:0 };
            this.hitCount = 0; this.comboTimer = 0;
            this.playerId = id; this.blocking = false;
            
            // Model Construction
            this.root = new THREE.Group();
            const matSkin = new THREE.MeshLambertMaterial({ color: 0xeebb99 });
            const matUniform = new THREE.MeshLambertMaterial({ color: isPlayer ? 0x2a4a3a : 0x4a2a2a });
            const matGear = new THREE.MeshLambertMaterial({ color: 0x111111 });
            const matVest = new THREE.MeshLambertMaterial({ color: 0x050505 });
            const matAccent = new THREE.MeshLambertMaterial({ color: color });
            
            this.hips = new THREE.Group(); this.hips.position.y = 2.0; this.root.add(this.hips);
            const createLimb = (w, h, d, mat, ox, oy, oz) => {
                const m = new THREE.Mesh(boxGeo, mat); m.scale.set(w, h, d); m.position.set(ox, oy, oz);
                m.castShadow = true; m.receiveShadow = true; return m;
            }

            this.legL = new THREE.Group(); this.legL.position.set(-0.35, 0, 0); this.legR = new THREE.Group(); this.legR.position.set(0.35, 0, 0);
            this.hips.add(this.legL, this.legR);
            this.legL.add(createLimb(0.5, 0.9, 0.5, matUniform, 0, -0.45, 0)); this.legR.add(createLimb(0.5, 0.9, 0.5, matUniform, 0, -0.45, 0));
            this.kneeL = new THREE.Group(); this.kneeL.position.set(0, -0.9, 0); this.kneeR = new THREE.Group(); this.kneeR.position.set(0, -0.9, 0);
            this.legL.add(this.kneeL); this.legR.add(this.kneeR);
            this.kneeL.add(createLimb(0.45, 0.9, 0.45, matUniform, 0, -0.45, 0)); this.kneeR.add(createLimb(0.45, 0.9, 0.45, matUniform, 0, -0.45, 0));
            this.kneeL.add(createLimb(0.5, 0.4, 0.7, matGear, 0, -0.95, 0.1)); this.kneeR.add(createLimb(0.5, 0.4, 0.7, matGear, 0, -0.95, 0.1));

            this.spine = new THREE.Group(); this.hips.add(this.spine);
            this.spine.add(createLimb(1.1, 0.3, 0.7, matGear, 0, 0.15, 0));
            this.spine.add(createLimb(1.1, 1.2, 0.7, matUniform, 0, 0.9, 0));
            this.spine.add(createLimb(1.15, 0.8, 0.8, matVest, 0, 1.0, 0));
            this.spine.add(createLimb(0.8, 0.8, 0.4, matGear, 0, 1.0, -0.5));

            this.neck = new THREE.Group(); this.neck.position.set(0, 1.6, 0); this.spine.add(this.neck);
            this.neck.add(createLimb(0.6, 0.7, 0.7, matSkin, 0, 0.35, 0));
            this.neck.add(createLimb(0.65, 0.2, 0.75, matAccent, 0, 0.6, 0));
            this.neck.add(createLimb(0.5, 0.1, 0.1, matGear, 0, 0.4, 0.36));

            this.shoulderL = new THREE.Group(); this.shoulderL.position.set(-0.8, 1.3, 0); this.shoulderR = new THREE.Group(); this.shoulderR.position.set(0.8, 1.3, 0);
            this.spine.add(this.shoulderL, this.shoulderR);
            this.shoulderL.add(createLimb(0.4, 0.7, 0.4, matSkin, 0, -0.35, 0)); this.shoulderR.add(createLimb(0.4, 0.7, 0.4, matSkin, 0, -0.35, 0));
            this.elbowL = new THREE.Group(); this.elbowL.position.set(0, -0.7, 0); this.elbowR = new THREE.Group(); this.elbowR.position.set(0, -0.7, 0);
            this.shoulderL.add(this.elbowL); this.shoulderR.add(this.elbowR);
            this.elbowL.add(createLimb(0.35, 0.7, 0.35, matSkin, 0, -0.35, 0)); this.elbowR.add(createLimb(0.35, 0.7, 0.35, matSkin, 0, -0.35, 0));
            this.elbowL.add(createLimb(0.4, 0.3, 0.4, matGear, 0, -0.8, 0)); this.elbowR.add(createLimb(0.4, 0.3, 0.4, matGear, 0, -0.8, 0));
            
            const shieldGeo = new THREE.CylinderGeometry(1.5, 1.5, 0.2, 6);
            const shieldMat = new THREE.MeshBasicMaterial({ color: 0x4444ff, transparent: true, opacity: 0.4, wireframe: false });
            this.shield = new THREE.Mesh(shieldGeo, shieldMat);
            this.shield.rotation.x = Math.PI/2; this.shield.rotation.y = Math.PI/2;
            this.shield.position.set(0, 1.5, 1.5); this.shield.visible = false;
            this.shield.add(new THREE.Mesh(shieldGeo, new THREE.MeshBasicMaterial({ color: 0x8888ff, wireframe: true })));
            this.root.add(this.shield);

            this.meshes = []; this.root.traverse(c => { if(c.isMesh) this.meshes.push(c); });
            sceneGame.add(this.root);
        }

        reset(isRoundStart = false) {
            this.x = this.startX; this.y = 0; this.vx = 0; this.vy = 0;
            this.hp = 100; this.stamina = 100; this.tired = false;
            this.state = 'idle'; this.blocking = false; this.shield.visible = false;
            this.root.rotation.set(0,0,0);
            this.meshes.forEach(m => m.material.emissive = new THREE.Color(0x000000));
            this.resetAnim();
        }

        update(opponent) {
            if (this.state === 'dead') {
                // Falling Animation
                if(this.root.rotation.x > -Math.PI/2) this.root.rotation.x -= 0.1;
                if(this.y > 0) this.y -= 0.1;
                this.root.position.set(this.x, this.y, this.z);
                return;
            }

            this.vx *= this.friction;
            if(Math.abs(this.vx) < 0.001) this.vx = 0;
            this.x += this.vx; this.x = Math.max(-MAP_LIMIT, Math.min(MAP_LIMIT, this.x)); 
            this.vy -= GRAVITY; this.y += this.vy;
            if(this.y <= GROUND) { if(this.y < GROUND && this.vy < -0.2) spawnDust(this.x, this.z, 5); this.y = GROUND; this.vy = 0; }
            this.root.position.set(this.x, this.y, this.z);

            // Stamina & Blocking Logic
            if(this.stamina <= 0) { this.tired = true; this.state = 'tired'; this.shield.visible = false; }
            if(this.tired) {
                this.stamina += 0.4; if(this.stamina > 30) { this.tired = false; this.state = 'idle'; }
            } else if (this.state !== 'dash' && this.state !== 'block' && this.state !== 'attack' && this.state !== 'jump') {
                this.stamina = Math.min(this.maxStamina, this.stamina + 0.5);
            }
            if(this.blocking && !this.tired) this.stamina -= 0.5;

            // State Management for Blocking
            if(this.blocking && !this.tired && this.state !== 'hurt' && this.state !== 'attack' && this.state !== 'dash' && this.y <= 0.1) {
                this.state = 'block'; this.shield.visible = true;
            } else {
                this.shield.visible = false;
                if(this.state === 'block') this.state = 'idle';
            }

            // Facing
            if(this.state !== 'dash' && this.state !== 'hurt' && this.state !== 'attack' && this.state !== 'block' && this.state !== 'tired') {
                if(Math.abs(this.vx) > 0.05) this.facingRight = this.vx > 0;
                else this.facingRight = opponent.x > this.x;
            }
            const targetRot = this.facingRight ? Math.PI/2 : -Math.PI/2;
            this.root.rotation.y += (targetRot - this.root.rotation.y) * 0.25;

            // Timers
            if(this.hitCount > 0) { this.comboTimer--; if(this.comboTimer <= 0) this.hitCount = 0; }
            if(this.cooldowns.s1 > 0) this.cooldowns.s1--;
            if(this.cooldowns.s2 > 0) this.cooldowns.s2--;
            if(this.cooldowns.s3 > 0) this.cooldowns.s3--;

            if(this.animTimer > 0) {
                this.animTimer--;
                if(this.animTimer === 0 && this.state !== 'idle' && !this.tired) {
                    this.state = 'idle'; this.resetAnim(); this.meshes.forEach(m => m.material.emissive = new THREE.Color(0x000000));
                }
            } else {
                if(this.state !== 'block' && !this.tired) {
                    if(this.y > 0.1) this.state = 'jump';
                    else if(Math.abs(this.vx) > 0.05) this.state = 'run';
                    else {
                        this.state = 'idle';
                        if(Date.now() - this.lastAttackTime > 1200) this.combo = 0;
                    }
                }
                if(this.tired) this.state = 'tired';
            }
            this.animate();
        }

        hurt(damage, kX, kY) {
            if(this.state === 'dead') return;
            if(this.state === 'block' && this.facingRight !== (kX > 0)) { 
                AudioSys.playBlock(); this.stamina -= 10; this.vx = kX * 0.2; 
                this.shield.material.opacity = 1; setTimeout(() => this.shield.material.opacity = 0.4, 100);
                return;
            }
            this.hp -= damage; this.vx = kX; this.vy = kY;
            this.state = 'hurt'; this.animTimer = 20; this.hitCount = 0; 
            AudioSys.playTone(150, 'sawtooth', 0.1); 
            this.meshes.forEach(m => m.material.emissive = new THREE.Color(0xff0000));
            
            if(this.hp <= 0) {
                this.hp = 0;
                this.state = 'dead';
                handleKO(this.playerId); // Trigger global KO logic
            }
        }

        resetAnim() {
            this.spine.rotation.set(0,0,0);
            this.shoulderL.rotation.set(0,0,0); this.shoulderR.rotation.set(0,0,0);
            this.elbowL.rotation.set(0,0,0); this.elbowR.rotation.set(0,0,0);
            this.legL.rotation.set(0,0,0); this.legR.rotation.set(0,0,0);
            this.kneeL.rotation.set(0,0,0); this.kneeR.rotation.set(0,0,0);
            this.hips.position.y = 2.0; this.neck.rotation.set(0,0,0);
        }

        animate() {
            const t = Date.now() * 0.01;
            if(this.state === 'idle') {
                this.spine.rotation.x = Math.sin(t*0.5) * 0.05;
                this.shoulderL.rotation.z = 0.2; this.shoulderR.rotation.z = -0.2;
                this.shoulderL.rotation.x = Math.sin(t*0.5 + 1) * 0.05; this.shoulderR.rotation.x = Math.sin(t*0.5) * 0.05;
                this.legL.rotation.x = -0.2; this.legR.rotation.x = 0.2;
                this.elbowL.rotation.x = -0.5; this.elbowR.rotation.x = -0.5;
            }
            else if(this.state === 'tired') {
                const breath = Math.sin(t*10) * 0.1;
                this.hips.position.y = 1.7 + breath;
                this.spine.rotation.x = 0.8 + breath; this.neck.rotation.x = -0.6;
                this.shoulderL.rotation.x = 0; this.shoulderL.rotation.z = 0.5; 
                this.shoulderR.rotation.x = 0; this.shoulderR.rotation.z = -0.5;
                this.elbowL.rotation.x = -0.2; this.elbowR.rotation.x = -0.2;
            }
            else if(this.state === 'block') {
                this.spine.rotation.x = 0.3;
                this.shoulderL.rotation.x = -1.0; this.shoulderL.rotation.z = 1.0; 
                this.shoulderR.rotation.x = -1.0; this.shoulderR.rotation.z = -1.0;
                this.legL.rotation.x = -0.5; this.legR.rotation.x = 0.5;
            }
            else if (this.state === 'run') {
                this.runTime += 0.3;
                if(this.runTime % Math.PI < 0.2) spawnDust(this.x, this.z, 1);
                const rt = this.runTime;
                this.hips.position.y = 2.0 + Math.abs(Math.sin(rt)) * 0.1;
                this.spine.rotation.y = Math.cos(rt) * 0.1;
                this.legL.rotation.x = Math.sin(rt) * 1.0; this.kneeL.rotation.x = Math.max(0, -Math.sin(rt) * 1.5);
                this.legR.rotation.x = Math.sin(rt + Math.PI) * 1.0; this.kneeR.rotation.x = Math.max(0, -Math.sin(rt + Math.PI) * 1.5);
                this.shoulderL.rotation.x = Math.sin(rt + Math.PI) * 0.8; this.elbowL.rotation.x = -1.0;
                this.shoulderR.rotation.x = Math.sin(rt) * 0.8; this.elbowR.rotation.x = -1.0;
            }
            else if (this.state === 'jump') {
                this.legL.rotation.x = 0.5; this.kneeL.rotation.x = 1.0;
                this.legR.rotation.x = -0.2; this.kneeR.rotation.x = 0.5;
                this.shoulderL.rotation.z = 0.5; this.shoulderR.rotation.z = -0.5;
            }
            else if (this.state === 'hurt') {
                this.spine.rotation.x = -0.5; this.hips.position.y = 1.8;
                this.shoulderL.rotation.x = -2.0; this.shoulderR.rotation.x = -2.0;
                this.neck.rotation.x = -0.5;
            }
            else if (this.state === 'attack') {
                const p = 1 - (this.animTimer / (this.combo===3?30:(this.combo===2?20:15)));
                if (this.combo === 1) { 
                    if(p < 0.5) { this.spine.rotation.y = 0.5; this.shoulderL.rotation.x = -1.5; this.elbowL.rotation.x = -0.1; this.shoulderL.position.z = p*2; } 
                    else this.shoulderL.position.z = (1-p)*2;
                    this.shoulderR.rotation.x = -0.5; this.elbowR.rotation.x = -2.0;
                }
                else if (this.combo === 2) { 
                    this.spine.rotation.y = -1.0 + (p*1.5);
                    if(p < 0.5) { this.shoulderR.rotation.x = -1.4; this.shoulderR.rotation.y = 1.0 - (p*3); }
                }
                else if (this.combo === 3) { 
                    if(p < 0.3) this.hips.position.y = 1.5;
                    else { this.hips.position.y = 2.0 + (p-0.3)*2; this.shoulderR.rotation.x = -3.0; this.spine.rotation.x = -0.5; }
                }
            }
            else if (this.state === 'dash') {
                this.spine.rotation.x = 0.5;
                this.shoulderL.rotation.x = 1.0; this.shoulderR.rotation.x = 1.0;
                this.legL.rotation.x = -0.5; this.legR.rotation.x = -0.5;
                spawnDust(this.x, this.z, 2);
            }
        }

        // INPUT ACTIONS
        moveInput(dir) { if(this.state !== 'attack' && this.state !== 'dash' && this.state !== 'hurt' && this.state !== 'block' && !this.tired) this.vx += dir * 0.05; }
        blockInput(active) { if(!this.tired) this.blocking = active; else this.blocking = false; }
        
        jump() {
            if(this.y <= GROUND + 0.1 && this.state !== 'attack' && this.state !== 'dash' && this.state !== 'hurt' && this.state !== 'block' && !this.tired) {
                if(this.consumeStamina(15)) { this.vy = 0.75; spawnDust(this.x, this.z, 8); AudioSys.playTone(300, 'square', 0.1); }
            }
        }

        checkHit(opponent, damage, kX, kY) {
            const dist = Math.abs(this.x - opponent.x);
            if(dist < 3.5 && Math.abs(this.y - opponent.y) < 4.0) {
                spawnExplosion(opponent.x, opponent.y+3.0, 0, 0xffaa00, 5);
                opponent.hurt(damage, kX, kY);
                shake = damage > 10 ? 10 : 3;
                this.hitCount++; this.comboTimer = 100;
                return true;
            }
            return false;
        }

        performAttack(opponent) {
            if(this.state !== 'idle' && this.state !== 'run') return;
            if(!this.consumeStamina(8)) return;
            const now = Date.now();
            if (now - this.lastAttackTime < 800) { this.combo++; if(this.combo > 3) this.combo = 1; } else this.combo = 1;
            this.lastAttackTime = now; this.state = 'attack';
            let dmg = 5, kX = 0, kY = 0, delay = 100;
            const dir = this.facingRight ? 1 : -1;
            if(this.combo === 1) { this.animTimer = 15; dmg = 4; kX = dir * 0.3; delay=100; this.vx = dir * 0.2; AudioSys.playTone(400, 'triangle', 0.05); } 
            else if (this.combo === 2) { this.animTimer = 20; dmg = 8; kX = dir * 0.5; delay=150; AudioSys.playTone(300, 'square', 0.1); } 
            else if (this.combo === 3) { this.animTimer = 30; dmg = 15; kX = dir * 0.2; kY = 0.6; delay=250; AudioSys.playTone(150, 'sawtooth', 0.2); this.vx = dir * 0.3; }
            setTimeout(() => { if(this.state==='attack') this.checkHit(opponent, dmg, kX, kY); }, delay);
        }

        skill1(opponent) {
            if(this.cooldowns.s1 > 0 || this.state !== 'idle' || this.tired || !this.consumeStamina(20)) return;
            this.cooldowns.s1 = 60; this.state = 'attack'; this.animTimer = 20; this.combo = 1;
            const dir = this.facingRight ? 1 : -1;
            shots.push(new Projectile(this.x + dir, 2.2, dir, this)); AudioSys.playTone(600, 'square', 0.2);
        }

        skill2(opponent) {
            if(this.cooldowns.s2 > 0 || this.state === 'hurt' || this.state === 'block' || this.tired || !this.consumeStamina(25)) return;
            this.cooldowns.s2 = 100; this.state = 'dash'; this.animTimer = 20; this.vy = 0; this.vx = (this.facingRight ? 1 : -1) * 0.9;
            let dInt = setInterval(() => { 
                if(this.state !== 'dash') { clearInterval(dInt); return; }
                if(this.checkHit(opponent, 10, this.vx*0.5, 0.2)) clearInterval(dInt); 
            }, 30);
            setTimeout(()=>clearInterval(dInt), 200); AudioSys.noise(0.2);
        }

        skill3(opponent) {
            if(this.cooldowns.s3 > 0 || this.state === 'hurt' || this.state === 'block' || this.tired || !this.consumeStamina(40)) return;
            this.cooldowns.s3 = 200; this.state = 'attack'; this.animTimer = 60; this.vy = 1.0;
            setTimeout(() => {
                if(this.state !== 'attack') return;
                this.vy = -1.5; 
                let slam = setInterval(() => {
                    if(this.y <= GROUND) {
                        clearInterval(slam);
                        shake = 25; AudioSys.noise(0.5);
                        for(let i=0; i<30; i++) {
                            const v = new THREE.Vector3((Math.random()-0.5)*1.5, Math.random(), (Math.random()-0.5)*1.5);
                            particles.push(new Particle(this.x, 0.5, this.z, 0xffaa00, 0.5, 40, v, 0.05));
                        }
                        const beam = new THREE.Mesh(new THREE.CylinderGeometry(3,3,30,16), new THREE.MeshBasicMaterial({color: 0xffffaa, transparent:true, opacity:0.8}));
                        beam.position.set(this.x, 15, 0); sceneGame.add(beam);
                        let bInt = setInterval(() => {
                            beam.scale.x*=0.9; beam.scale.z*=0.9; beam.material.opacity-=0.05;
                            if(beam.material.opacity<=0) { clearInterval(bInt); sceneGame.remove(beam); }
                        }, 30);
                        if(Math.abs(this.x - opponent.x) < 8) opponent.hurt(30, 0, 0.9);
                    }
                }, 16);
            }, 300);
        }

        consumeStamina(amount) {
            if(this.tired) return false;
            if(this.stamina >= amount) { this.stamina -= amount; return true; } 
            else { this.stamina = 0; return false; }
        }
    }

    class Projectile {
        constructor(x, y, dir, owner) {
            this.x = x; this.y = y; this.dir = dir; this.owner = owner; this.active = true;
            this.mesh = new THREE.Mesh(new THREE.BoxGeometry(1.2, 1.2, 1.2), new THREE.MeshBasicMaterial({color:0x00ffff}));
            this.mesh.position.set(x,y,0); sceneGame.add(this.mesh);
            this.light = new THREE.PointLight(0x00ffff, 1, 8); this.mesh.add(this.light);
        }
        update(opponent) {
            if(!this.active) return false;
            const oldX = this.x; this.x += this.dir * 0.6; this.mesh.position.x = this.x;
            this.mesh.rotation.x += 0.3; this.mesh.rotation.y += 0.3;
            if(Math.abs(this.x) > MAP_LIMIT + 5) { this.destroy(); return false; }
            const minX = Math.min(oldX, this.x); const maxX = Math.max(oldX, this.x);
            if(opponent.x >= minX - 1.5 && opponent.x <= maxX + 1.5 && Math.abs(this.y - opponent.y) < 5.0) {
                spawnExplosion(this.x, this.y, 0, 0x00ffff, 30); opponent.hurt(12, this.dir * 0.4, 0.3);
                AudioSys.playTone(100, 'square', 0.1); this.destroy(); return false;
            }
            return true;
        }
        destroy() { this.active = false; sceneGame.remove(this.mesh); }
    }

    // --- GAME LOGIC ---
    let p1, p2, shots = [], shake = 0;
    let inputs = { left: false, right: false, block: false };
    let gameState = 'MENU'; // MENU, COUNTDOWN, FIGHT, KO
    let scores = { p1: 0, p2: 0 };
    let slowMoFactor = 1;

    function init() {
        if(p1) { sceneGame.remove(p1.root); sceneGame.remove(p2.root); }
        p1 = new Character(-5, 0xff3333, true, 'p1');
        p2 = new Character(5, 0x3333ff, false, 'p2');
        scores = { p1: 0, p2: 0 }; updateScoreUI();
        startRound();
        loop();
    }

    function startRound() {
        p1.reset(); p2.reset(); shots.forEach(s => s.destroy()); shots = [];
        p1.x = -5; p2.x = 5;
        gameState = 'COUNTDOWN';
        const msg = document.getElementById('msg-overlay');
        msg.className = 'center-msg anim-pop';
        
        let count = 3;
        msg.innerText = count;
        AudioSys.playAnnouncer([400]);

        let interval = setInterval(() => {
            count--;
            if(count > 0) {
                msg.classList.remove('anim-pop'); void msg.offsetWidth; msg.classList.add('anim-pop');
                msg.innerText = count; AudioSys.playAnnouncer([400]);
            } else {
                clearInterval(interval);
                msg.classList.remove('anim-pop'); void msg.offsetWidth; msg.classList.add('anim-pop');
                msg.innerText = "FIGHT!"; AudioSys.playAnnouncer([600, 800]);
                setTimeout(() => { msg.innerText = ""; gameState = 'FIGHT'; }, 1000);
            }
        }, 1000);
    }

    function handleKO(loserId) {
        if(gameState === 'KO') return;
        gameState = 'KO'; slowMoFactor = 0.2;
        
        const winnerId = loserId === 'p1' ? 'p2' : 'p1';
        scores[winnerId]++; updateScoreUI();

        const msg = document.getElementById('msg-overlay');
        msg.className = 'center-msg anim-shake';
        
        // Final Win Check
        if(scores[winnerId] >= 3) {
            msg.innerText = "NAILED IT!"; msg.style.color = "#0ff";
            AudioSys.playAnnouncer([400, 500, 600, 800]);
            setTimeout(() => { location.reload(); }, 5000); // Reset Game
        } else {
            msg.innerText = "K.O."; msg.style.color = "#ff0";
            AudioSys.playAnnouncer([200, 100]);
            setTimeout(() => { 
                slowMoFactor = 1; msg.innerText = ""; 
                startRound(); 
            }, 3000);
        }
    }

    function updateScoreUI() {
        document.getElementById('score-p1').innerText = scores.p1;
        document.getElementById('score-p2').innerText = scores.p2;
    }

    function updateComboUI(id, count, timer) {
        const box = document.getElementById(id==='p1'?'c1-box':'c2-box');
        const num = document.getElementById(id==='p1'?'c1-num':'c2-num');
        const bar = document.getElementById(id==='p1'?'c1-bar':'c2-bar');
        if(count > 0) { box.style.opacity = 1; box.style.transform = `scale(1.2)`; num.innerText = count; bar.style.width = (timer) + '%'; } 
        else { box.style.opacity = 0; box.style.transform = `scale(1.0)`; }
    }

    function updateStamUI(id, val, max, tired) {
        const el = document.getElementById(id==='p1'?'p1-stam':'p2-stam');
        el.style.width = (val/max)*100 + '%'; el.style.background = tired ? '#ff0000' : 'linear-gradient(to right, #00ffff, #0088ff)';
    }

    function loop() {
        requestAnimationFrame(loop);
        
        // Slow Mo Logic
        let steps = slowMoFactor < 1 ? 1 : 1; 
        if(slowMoFactor < 1 && Math.random() > slowMoFactor) return; // Skip frames for poor man's slowmo

        // Inputs (Polling)
        if(gameState === 'FIGHT') {
            if(inputs.left) p1.moveInput(-1);
            if(inputs.right) p1.moveInput(1);
            p1.blockInput(inputs.block);

            // Body Collision
            if(Math.abs(p1.x - p2.x) < 1.0 && Math.abs(p1.y - p2.y) < 2.0) {
                const push = 0.05;
                if(p1.x < p2.x) { p1.x -= push; p2.x += push; } else { p1.x += push; p2.x -= push; }
            }
        }

        // AI
        if(gameState === 'FIGHT' && p2.hp > 0) {
             const dist = Math.abs(p2.x - p1.x); const dir = p1.x > p2.x ? 1 : -1;
             if(p1.state === 'attack' && dist < 3 && Math.random() < 0.1) p2.blockInput(true);
             else {
                 p2.blockInput(false);
                 if(dist > 2.5) { p2.moveInput(dir); if(dist > 8 && Math.random()<0.02) p2.skill1(p1); if(dist>4 && dist<8 && Math.random()<0.05) p2.skill2(p1); }
                 else if(dist<=2.5) { if(p2.cooldowns.s3===0 && Math.random()<0.1) p2.skill3(p1); else if(Math.random()<0.15) p2.performAttack(p1); }
             }
        }

        p1.update(p2); p2.update(p1);
        shots = shots.filter(s => s.update(s.owner===p1?p2:p1));
        particles = particles.filter(p => p.update());

        // Camera
        if(shake > 0) { camGame.position.x = (Math.random()-0.5)*shake*0.1; camGame.position.y = 7 + (Math.random()-0.5)*shake*0.1; shake *= 0.9; } 
        else { const mid = (p1.x + p2.x)/2; camGame.position.x += (mid - camGame.position.x) * 0.1; camGame.position.x = Math.max(-5, Math.min(5, camGame.position.x)); }
        camGame.lookAt(camGame.position.x, 2, 0);

        // UI Updates
        document.getElementById('p1-hp').style.width = Math.max(0, p1.hp) + '%';
        document.getElementById('p2-hp').style.width = Math.max(0, p2.hp) + '%';
        updateStamUI('p1', p1.stamina, p1.maxStamina, p1.tired);
        updateStamUI('p2', p2.stamina, p2.maxStamina, p2.tired);
        const setCD = (id,v) => { document.getElementById(id).style.display = v>0?'flex':'none'; document.getElementById(id).innerText = Math.ceil(v/60); };
        setCD('cd-s1', p1.cooldowns.s1); setCD('cd-s2', p1.cooldowns.s2); setCD('cd-s3', p1.cooldowns.s3);

        renderer.setRenderTarget(renderTarget); renderer.render(sceneGame, camGame);
        renderer.setRenderTarget(null); renderer.render(sceneScreen, camScreen);
    }

    // Input Handling (State Polling)
    window.addEventListener('keydown', e => {
        if(e.key === 'ArrowLeft') inputs.left = true;
        if(e.key === 'ArrowRight') inputs.right = true;
        if(e.key === 'ArrowDown') inputs.block = true;
        if(gameState !== 'FIGHT') return;
        if(e.key === 'ArrowUp') p1.jump();
        if(e.key === 'z') p1.performAttack(p2);
        if(e.key === 'x') p1.skill1(p2);
        if(e.key === 'c') p1.skill2(p2);
        if(e.key === 'v') p1.skill3(p2);
    });
    window.addEventListener('keyup', e => {
        if(e.key === 'ArrowLeft') inputs.left = false;
        if(e.key === 'ArrowRight') inputs.right = false;
        if(e.key === 'ArrowDown') inputs.block = false;
    });

    const bindMove = (id, key) => {
        const el = document.getElementById(id);
        const s = (e) => { e.preventDefault(); inputs[key] = true; el.classList.add('pressed'); };
        const n = (e) => { e.preventDefault(); inputs[key] = false; el.classList.remove('pressed'); };
        el.addEventListener('mousedown', s); el.addEventListener('touchstart', s);
        el.addEventListener('mouseup', n); el.addEventListener('touchend', n); el.addEventListener('mouseleave', n);
    };
    bindMove('btn-left', 'left'); bindMove('btn-right', 'right'); bindMove('btn-block', 'block');

    const bindAction = (id, fn) => {
        const el = document.getElementById(id);
        const s = (e) => { e.preventDefault(); if(gameState==='FIGHT') fn(); el.classList.add('pressed'); };
        const n = (e) => { e.preventDefault(); el.classList.remove('pressed'); };
        el.addEventListener('mousedown', s); el.addEventListener('touchstart', s);
        el.addEventListener('mouseup', n); el.addEventListener('touchend', n);
    };
    bindAction('btn-jump', ()=>p1.jump());
    bindAction('btn-atk', ()=>p1.performAttack(p2));
    bindAction('btn-s1', ()=>p1.skill1(p2)); bindAction('btn-s2', ()=>p1.skill2(p2)); bindAction('btn-s3', ()=>p1.skill3(p2));

    const get = (id) => document.getElementById(id);
    get('start-btn').onclick = () => { AudioSys.init(); get('start-screen').classList.add('hidden'); init(); };
    get('local-menu-btn').onclick = () => { get('start-screen').classList.add('hidden'); get('local-screen').classList.remove('hidden'); };
    get('host-btn').onclick = () => { get('local-screen').classList.add('hidden'); get('host-screen').classList.remove('hidden'); get('host-code').innerText = Math.floor(100000 + Math.random() * 900000); };
    get('host-cancel').onclick = () => { get('host-screen').classList.add('hidden'); get('local-screen').classList.remove('hidden'); };
    get('join-btn').onclick = () => { get('local-screen').classList.add('hidden'); get('join-screen').classList.remove('hidden'); };
    get('join-cancel').onclick = () => { get('join-screen').classList.add('hidden'); get('local-screen').classList.remove('hidden'); };
    get('back-btn').onclick = () => { get('local-screen').classList.add('hidden'); get('start-screen').classList.remove('hidden'); };
    get('connect-btn').onclick = () => { const btn = get('connect-btn'); const txt = btn.innerText; btn.innerText = "CONNECTING..."; setTimeout(() => { btn.innerText = "FAILED"; setTimeout(()=>btn.innerText=txt, 1000); }, 2000); };

    window.addEventListener('resize', () => {
        const a = window.innerWidth/window.innerHeight;
        camGame.aspect = a; camGame.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
</script>
</body>
</html>


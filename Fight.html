<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Pixel Commando 3D: Ultimate</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #1a1a24;
            font-family: 'Press Start 2P', cursive;
            touch-action: none;
            user-select: none;
        }

        #game-container {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
        }

        #ui-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            z-index: 10;
        }

        /* HUD */
        .hud-top {
            display: flex;
            justify-content: space-between;
            padding: 20px;
            width: 100%;
            box-sizing: border-box;
        }

        .bar-wrap {
            width: 45%;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .hp-border {
            border: 3px solid #fff;
            background: #000;
            height: 20px;
            position: relative;
            box-shadow: 4px 4px 0 rgba(0,0,0,0.5);
            transform: skewX(-10deg);
        }

        .hp-fill {
            height: 100%;
            background: linear-gradient(to right, #ffaa00, #ffff00);
            width: 100%;
            transition: width 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        }
        .p2-fill { background: linear-gradient(to right, #aa0000, #ff4444); }

        /* STAMINA BAR */
        .stam-border {
            border: 2px solid #888;
            background: #000;
            height: 10px;
            position: relative;
            width: 80%;
            transform: skewX(-10deg);
        }
        .stam-fill {
            height: 100%;
            background: linear-gradient(to right, #00ffff, #0088ff);
            width: 100%;
            transition: width 0.1s linear;
        }

        .name {
            color: #fff;
            margin-bottom: 2px;
            text-shadow: 2px 2px #000;
            font-size: 10px;
            letter-spacing: 2px;
        }

        /* Combo Counters */
        .combo-box {
            position: absolute;
            top: 100px;
            width: 150px;
            display: flex;
            flex-direction: column;
            opacity: 0;
            transition: opacity 0.2s, transform 0.1s;
        }
        
        .c-left { left: 20px; align-items: flex-start; text-align: left; }
        .c-right { right: 20px; align-items: flex-end; text-align: right; }

        .combo-count {
            font-size: 24px;
            color: #fff;
            text-shadow: 3px 3px 0 #f00;
            margin-bottom: 5px;
        }
        .combo-label { font-size: 10px; color: #ffcc00; margin-bottom: 5px; }

        .combo-timer-bg { width: 100%; height: 6px; background: #333; border: 1px solid #fff; }
        .combo-timer-fill { height: 100%; background: #ffcc00; width: 100%; }

        /* Controls */
        #controls {
            pointer-events: auto;
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: flex-end;
            margin-bottom: 10px;
        }

        .d-pad { display: flex; gap: 15px; align-items: flex-end; }
        .action-pad { position: relative; width: 240px; height: 240px; }

        .btn {
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255,255,255,0.6);
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 20px;
            box-shadow: 0 4px 0 #000;
            transition: all 0.05s;
            cursor: pointer;
            backdrop-filter: blur(4px);
        }

        .btn:active, .btn.pressed { transform: translateY(4px); box-shadow: 0 0 0 #000; background: rgba(255, 255, 255, 0.3); }

        .btn-move { width: 75px; height: 75px; border-radius: 12px; }
        
        .move-col { display: flex; flex-direction: column; align-items: center; gap: 15px; }

        .btn-jump { 
            width: 85px; height: 85px; border-radius: 12px; 
            background: rgba(0, 255, 0, 0.15); border-color: #0f0; 
        }
        
        .btn-block {
            width: 70px; height: 70px; border-radius: 12px;
            background: rgba(50, 50, 255, 0.15); border-color: #55f;
            font-size: 12px;
        }

        .btn-atk {
            position: absolute; bottom: 0; right: 0;
            width: 110px; height: 110px; border-radius: 50%;
            background: rgba(255, 0, 0, 0.2); border-color: #f00; font-size: 16px; z-index: 20;
        }

        .btn-skill {
            position: absolute; width: 65px; height: 65px;
            border-radius: 50%; font-size: 8px; border-width: 2px;
            text-align: center; line-height: 1.2; padding: 2px;
        }

        .btn-s1 { bottom: 25px; right: 125px; border-color: #0ff; color: #0ff; background: rgba(0, 255, 255, 0.15); }
        .btn-s2 { bottom: 100px; right: 100px; border-color: #ff0; color: #ff0; background: rgba(255, 255, 0, 0.15); }
        .btn-s3 { bottom: 130px; right: 20px; border-color: #f0f; color: #f0f; background: rgba(255, 0, 255, 0.15); }

        .cd-overlay {
            position: absolute; top:0; left:0; width:100%; height:100%;
            background: rgba(0,0,0,0.8); border-radius: 50%;
            display: none; justify-content: center; align-items: center; font-size: 14px;
        }

        /* MENUS */
        .screen-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #111; display: flex; flex-direction: column;
            justify-content: center; align-items: center; z-index: 100; color: #fff;
        }
        
        .hidden { display: none !important; }

        h1 { 
            color: #ff3333; text-shadow: 4px 4px 0 #500, -2px -2px 0 #fff;
            font-size: 40px; text-align: center; margin-bottom: 20px;
            line-height: 1.5; letter-spacing: -2px;
        }

        .menu-btn {
            padding: 20px 40px; font-family: inherit; font-size: 20px;
            background: linear-gradient(to bottom, #4444ff, #0000aa);
            color: #fff; border: 4px solid #fff; box-shadow: 0 8px 0 #000055;
            cursor: pointer; text-transform: uppercase; margin: 10px;
            width: 280px; text-align: center;
        }
        .menu-btn:active { transform: translateY(8px); box-shadow: 0 0 0 #000; }
        
        .btn-secondary {
            background: linear-gradient(to bottom, #444, #222);
            box-shadow: 0 8px 0 #111; font-size: 16px; padding: 15px;
        }

        .code-display {
            font-size: 40px; letter-spacing: 10px; color: #0f0;
            background: #000; padding: 20px; border: 2px solid #0f0;
            margin-bottom: 20px; text-shadow: 0 0 10px #0f0;
        }
        
        input.code-input {
            font-family: inherit; font-size: 30px; letter-spacing: 5px;
            background: #000; color: #fff; border: 2px solid #fff;
            padding: 15px; width: 200px; text-align: center;
            margin-bottom: 20px; outline: none;
        }

    </style>
</head>
<body>

<div id="game-container"></div>

<div id="ui-layer">
    <div class="hud-top">
        <div class="bar-wrap">
            <div class="name">P1: ELITE</div>
            <div class="hp-border"><div class="hp-fill" id="p1-hp"></div></div>
            <div class="stam-border"><div class="stam-fill" id="p1-stam"></div></div>
        </div>
        <div class="bar-wrap" style="align-items: flex-end;">
            <div class="name">P2: ROGUE</div>
            <div class="hp-border" style="width: 100%"><div class="hp-fill p2-fill" id="p2-hp"></div></div>
            <div class="stam-border" style="width: 80%"><div class="stam-fill" id="p2-stam"></div></div>
        </div>
    </div>
    
    <div id="c1-box" class="combo-box c-left"><div class="combo-label">COMBO</div><div id="c1-num" class="combo-count">0</div><div class="combo-timer-bg"><div id="c1-bar" class="combo-timer-fill"></div></div></div>
    <div id="c2-box" class="combo-box c-right"><div class="combo-label">COMBO</div><div id="c2-num" class="combo-count">0</div><div class="combo-timer-bg"><div id="c2-bar" class="combo-timer-fill"></div></div></div>

    <div id="controls">
        <div class="d-pad">
            <div class="btn btn-move" id="btn-left">◀</div>
            <div class="move-col">
                <div class="btn btn-jump" id="btn-jump">JUMP</div>
                <div class="btn btn-block" id="btn-block">BLOCK</div>
            </div>
            <div class="btn btn-move" id="btn-right">▶</div>
        </div>
        <div class="action-pad">
            <div class="btn btn-atk" id="btn-atk">ATK</div>
            <div class="btn btn-skill btn-s1" id="btn-s1">BLAST<div class="cd-overlay" id="cd-s1"></div></div>
            <div class="btn btn-skill btn-s2" id="btn-s2">DASH<div class="cd-overlay" id="cd-s2"></div></div>
            <div class="btn btn-skill btn-s3" id="btn-s3">ULT<div class="cd-overlay" id="cd-s3"></div></div>
        </div>
    </div>
</div>

<div id="start-screen" class="screen-overlay">
    <h1>PIXEL COMMANDO<br>ULTIMATE</h1>
    <p style="font-size: 12px; color: #888; margin-top:0;">TACTICAL ENGINE V4.3 // BLAST FIX</p>
    <button class="menu-btn" id="start-btn">START GAME</button>
    <button class="menu-btn btn-secondary" id="local-menu-btn">PLAY LOCAL</button>
</div>

<div id="local-screen" class="screen-overlay hidden">
    <h1>LOCAL PLAY</h1>
    <button class="menu-btn" id="host-btn">HOST GAME</button>
    <button class="menu-btn" id="join-btn">JOIN GAME</button>
    <button class="menu-btn btn-secondary" id="back-btn">BACK</button>
</div>

<div id="host-screen" class="screen-overlay hidden">
    <p style="color: #888;">SHARE THIS CODE:</p>
    <div class="code-display" id="host-code">------</div>
    <p class="blink">WAITING FOR PLAYER...</p>
    <button class="menu-btn btn-secondary" id="host-cancel">CANCEL</button>
</div>

<div id="join-screen" class="screen-overlay hidden">
    <p style="color: #888;">ENTER HOST CODE:</p>
    <input type="text" class="code-input" maxlength="6" placeholder="000000">
    <button class="menu-btn" id="connect-btn">CONNECT</button>
    <button class="menu-btn btn-secondary" id="join-cancel">CANCEL</button>
</div>

<style> .blink { animation: blink 1s infinite; } @keyframes blink { 50% { opacity: 0.5; } } </style>

<script>
    const AudioSys = {
        ctx: null,
        init: () => { window.AudioContext = window.AudioContext || window.webkitAudioContext; AudioSys.ctx = new AudioContext(); },
        playTone: (freq, type, dur, vol=0.1) => {
            if(!AudioSys.ctx) return;
            const osc = AudioSys.ctx.createOscillator(); const gain = AudioSys.ctx.createGain();
            osc.type = type; osc.frequency.setValueAtTime(freq, AudioSys.ctx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(freq/2, AudioSys.ctx.currentTime + dur);
            gain.gain.setValueAtTime(vol, AudioSys.ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, AudioSys.ctx.currentTime + dur);
            osc.connect(gain); gain.connect(AudioSys.ctx.destination);
            osc.start(); osc.stop(AudioSys.ctx.currentTime + dur);
        },
        noise: (dur) => {
            if(!AudioSys.ctx) return;
            const size = AudioSys.ctx.sampleRate * dur; const buf = AudioSys.ctx.createBuffer(1, size, AudioSys.ctx.sampleRate);
            const data = buf.getChannelData(0); for(let i=0;i<size;i++) data[i] = Math.random()*2-1;
            const src = AudioSys.ctx.createBufferSource(); src.buffer = buf;
            const gain = AudioSys.ctx.createGain(); gain.gain.setValueAtTime(0.2, AudioSys.ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, AudioSys.ctx.currentTime + dur);
            src.connect(gain); gain.connect(AudioSys.ctx.destination); src.start();
        },
        playHurt: () => {
            if(!AudioSys.ctx) return;
            const osc = AudioSys.ctx.createOscillator(); const gain = AudioSys.ctx.createGain(); const filter = AudioSys.ctx.createBiquadFilter();
            osc.type = 'sawtooth'; osc.frequency.setValueAtTime(150, AudioSys.ctx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(80, AudioSys.ctx.currentTime + 0.2);
            filter.type = 'lowpass'; filter.frequency.setValueAtTime(800, AudioSys.ctx.currentTime);
            filter.frequency.linearRampToValueAtTime(200, AudioSys.ctx.currentTime + 0.2);
            gain.gain.setValueAtTime(0.3, AudioSys.ctx.currentTime); gain.gain.exponentialRampToValueAtTime(0.01, AudioSys.ctx.currentTime + 0.2);
            osc.connect(filter); filter.connect(gain); gain.connect(AudioSys.ctx.destination); osc.start(); osc.stop(AudioSys.ctx.currentTime + 0.2);
        },
        playBlock: () => {
             if(!AudioSys.ctx) return;
             AudioSys.playTone(800, 'square', 0.1, 0.05);
             AudioSys.playTone(600, 'sine', 0.2, 0.1);
        }
    };

    const container = document.getElementById('game-container');
    const renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.shadowMap.enabled = true;
    container.appendChild(renderer.domElement);

    const sceneGame = new THREE.Scene(); sceneGame.background = new THREE.Color(0x1a1a24); sceneGame.fog = new THREE.Fog(0x1a1a24, 15, 40);
    const sceneScreen = new THREE.Scene();
    const aspect = window.innerWidth / window.innerHeight;
    const camGame = new THREE.PerspectiveCamera(40, aspect, 0.1, 100); camGame.position.set(0, 7, 24); 
    const camScreen = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
    const renderTarget = new THREE.WebGLRenderTarget(480, Math.floor(480/aspect), { minFilter: THREE.NearestFilter, magFilter: THREE.NearestFilter });
    sceneScreen.add(new THREE.Mesh(new THREE.PlaneGeometry(2, 2), new THREE.MeshBasicMaterial({ map: renderTarget.texture })));

    const ambLight = new THREE.AmbientLight(0x404050, 0.6); sceneGame.add(ambLight);
    const dirLight = new THREE.DirectionalLight(0xffeebb, 0.9); dirLight.position.set(10, 20, 10); dirLight.castShadow = true;
    dirLight.shadow.mapSize.width = 1024; dirLight.shadow.mapSize.height = 1024;
    dirLight.shadow.camera.left = -20; dirLight.shadow.camera.right = 20; sceneGame.add(dirLight);

    function createGridTexture() {
        const c = document.createElement('canvas'); c.width = 64; c.height = 64;
        const x = c.getContext('2d'); x.fillStyle = '#111116'; x.fillRect(0,0,64,64);
        x.strokeStyle = '#222230'; x.lineWidth = 2; x.strokeRect(0,0,64,64);
        x.fillStyle = '#1a1a24'; x.fillRect(2,2,60,60);
        const t = new THREE.CanvasTexture(c); t.magFilter = THREE.NearestFilter; t.minFilter = THREE.NearestFilter;
        t.wrapS = THREE.RepeatWrapping; t.wrapT = THREE.RepeatWrapping; t.repeat.set(50, 20); return t;
    }
    const ground = new THREE.Mesh(new THREE.PlaneGeometry(200, 40), new THREE.MeshStandardMaterial({ map: createGridTexture(), roughness: 0.8 }));
    ground.rotation.x = -Math.PI/2; ground.receiveShadow = true; sceneGame.add(ground);

    const boxGeo = new THREE.BoxGeometry(1,1,1);
    for(let i=0; i<30; i++) {
        const h = 2+Math.random()*6; const m = new THREE.Mesh(boxGeo, new THREE.MeshLambertMaterial({color: 0x0a1a10}));
        m.position.set((Math.random()-0.5)*80, h/2, -5 - Math.random()*15); m.scale.set(1, h, 1);
        m.castShadow = true; m.receiveShadow = true; sceneGame.add(m);
    }

    const GRAVITY = 0.035; const GROUND = 0; const MAP_LIMIT = 14.0;
    let particles = [];
    class Particle {
        constructor(x, y, z, color, size, life, vel, grav=0, glow=false) {
            this.mesh = new THREE.Mesh(boxGeo, new THREE.MeshBasicMaterial({ color: color, transparent: true }));
            this.mesh.position.set(x, y, z); this.mesh.scale.set(size, size, size);
            this.vel = vel; this.life = life; this.maxLife = life; this.grav = grav;
            if(glow) { const l = new THREE.PointLight(color, 1, 3); this.mesh.add(l); }
            sceneGame.add(this.mesh);
        }
        update() {
            this.vel.y -= this.grav; this.mesh.position.add(this.vel);
            this.life--; this.mesh.rotation.x += 0.2;
            this.mesh.material.opacity = this.life / this.maxLife;
            if(this.life <= 0) { sceneGame.remove(this.mesh); return false; }
            return true;
        }
    }
    function spawnDust(x, z, count) {
        for(let i=0; i<count; i++) particles.push(new Particle(x, 0.1, z+(Math.random()-0.5), 0xaaaaaa, 0.2, 20, new THREE.Vector3((Math.random()-0.5)*0.1, Math.random()*0.1, (Math.random()-0.5)*0.1)));
    }
    function spawnExplosion(x, y, z, color, count) {
        for(let i=0; i<count; i++) {
            const v = new THREE.Vector3((Math.random()-0.5)*0.5, (Math.random()-0.5)*0.5, (Math.random()-0.5)*0.5);
            particles.push(new Particle(x, y, z, color, 0.5, 30, v, 0, true));
        }
    }

    class Character {
        constructor(x, color, isPlayer, id) {
            this.x = x; this.y = 0; this.z = 0;
            this.vx = 0; this.vy = 0;
            this.speed = 0.22; this.friction = 0.8;
            this.facingRight = isPlayer;
            this.hp = 100;
            this.maxStamina = 100; this.stamina = 100; this.tired = false;
            this.state = 'idle';
            this.animTimer = 0; this.runTime = 0;
            this.combo = 0; this.lastAttackTime = 0;
            this.cooldowns = { s1:0, s2:0, s3:0 };
            this.hitCount = 0; this.comboTimer = 0;
            this.playerId = id; this.blocking = false;

            this.root = new THREE.Group();
            const matSkin = new THREE.MeshLambertMaterial({ color: 0xeebb99 });
            const matUniform = new THREE.MeshLambertMaterial({ color: isPlayer ? 0x2a4a3a : 0x4a2a2a });
            const matGear = new THREE.MeshLambertMaterial({ color: 0x111111 });
            const matVest = new THREE.MeshLambertMaterial({ color: 0x050505 });
            const matAccent = new THREE.MeshLambertMaterial({ color: color });
            
            this.hips = new THREE.Group(); this.hips.position.y = 2.0; this.root.add(this.hips);
            const createLimb = (w, h, d, mat, ox, oy, oz) => {
                const m = new THREE.Mesh(boxGeo, mat); m.scale.set(w, h, d); m.position.set(ox, oy, oz);
                m.castShadow = true; m.receiveShadow = true; return m;
            }

            this.legL = new THREE.Group(); this.legL.position.set(-0.35, 0, 0); this.legR = new THREE.Group(); this.legR.position.set(0.35, 0, 0);
            this.hips.add(this.legL, this.legR);
            this.legL.add(createLimb(0.5, 0.9, 0.5, matUniform, 0, -0.45, 0)); this.legR.add(createLimb(0.5, 0.9, 0.5, matUniform, 0, -0.45, 0));
            this.kneeL = new THREE.Group(); this.kneeL.position.set(0, -0.9, 0); this.kneeR = new THREE.Group(); this.kneeR.position.set(0, -0.9, 0);
            this.legL.add(this.kneeL); this.legR.add(this.kneeR);
            this.kneeL.add(createLimb(0.45, 0.9, 0.45, matUniform, 0, -0.45, 0)); this.kneeR.add(createLimb(0.45, 0.9, 0.45, matUniform, 0, -0.45, 0));
            this.kneeL.add(createLimb(0.5, 0.4, 0.7, matGear, 0, -0.95, 0.1)); this.kneeR.add(createLimb(0.5, 0.4, 0.7, matGear, 0, -0.95, 0.1));

            this.spine = new THREE.Group(); this.hips.add(this.spine);
            this.spine.add(createLimb(1.1, 0.3, 0.7, matGear, 0, 0.15, 0));
            this.spine.add(createLimb(1.1, 1.2, 0.7, matUniform, 0, 0.9, 0));
            this.spine.add(createLimb(1.15, 0.8, 0.8, matVest, 0, 1.0, 0));
            this.spine.add(createLimb(0.8, 0.8, 0.4, matGear, 0, 1.0, -0.5));

            this.neck = new THREE.Group(); this.neck.position.set(0, 1.6, 0); this.spine.add(this.neck);
            this.neck.add(createLimb(0.6, 0.7, 0.7, matSkin, 0, 0.35, 0));
            this.neck.add(createLimb(0.65, 0.2, 0.75, matAccent, 0, 0.6, 0));
            this.neck.add(createLimb(0.5, 0.1, 0.1, matGear, 0, 0.4, 0.36));

            this.shoulderL = new THREE.Group(); this.shoulderL.position.set(-0.8, 1.3, 0); this.shoulderR = new THREE.Group(); this.shoulderR.position.set(0.8, 1.3, 0);
            this.spine.add(this.shoulderL, this.shoulderR);
            this.shoulderL.add(createLimb(0.4, 0.7, 0.4, matSkin, 0, -0.35, 0)); this.shoulderR.add(createLimb(0.4, 0.7, 0.4, matSkin, 0, -0.35, 0));
            this.elbowL = new THREE.Group(); this.elbowL.position.set(0, -0.7, 0); this.elbowR = new THREE.Group(); this.elbowR.position.set(0, -0.7, 0);
            this.shoulderL.add(this.elbowL); this.shoulderR.add(this.elbowR);
            this.elbowL.add(createLimb(0.35, 0.7, 0.35, matSkin, 0, -0.35, 0)); this.elbowR.add(createLimb(0.35, 0.7, 0.35, matSkin, 0, -0.35, 0));
            this.elbowL.add(createLimb(0.4, 0.3, 0.4, matGear, 0, -0.8, 0)); this.elbowR.add(createLimb(0.4, 0.3, 0.4, matGear, 0, -0.8, 0));
            
            const shieldGeo = new THREE.CylinderGeometry(1.5, 1.5, 0.2, 6);
            const shieldMat = new THREE.MeshBasicMaterial({ color: 0x4444ff, transparent: true, opacity: 0.4, wireframe: false });
            this.shield = new THREE.Mesh(shieldGeo, shieldMat);
            this.shield.rotation.x = Math.PI/2; this.shield.rotation.y = Math.PI/2;
            this.shield.position.set(0, 1.5, 1.5); this.shield.visible = false;
            this.shield.add(new THREE.Mesh(shieldGeo, new THREE.MeshBasicMaterial({ color: 0x8888ff, wireframe: true })));
            this.root.add(this.shield);

            this.meshes = []; this.root.traverse(c => { if(c.isMesh) this.meshes.push(c); });
            sceneGame.add(this.root);
        }

        consumeStamina(amount) {
            if(this.tired) return false;
            if(this.stamina >= amount) { this.stamina -= amount; return true; } 
            else { this.stamina = 0; return false; }
        }

        update(opponent) {
            this.vx *= this.friction;
            if(Math.abs(this.vx) < 0.001) this.vx = 0;
            this.x += this.vx;
            this.x = Math.max(-MAP_LIMIT, Math.min(MAP_LIMIT, this.x)); 

            this.vy -= GRAVITY;
            this.y += this.vy;
            if(this.y <= GROUND) {
                if(this.y < GROUND && this.vy < -0.2) spawnDust(this.x, this.z, 5);
                this.y = GROUND; this.vy = 0;
            }
            this.root.position.set(this.x, this.y, this.z);

            if(this.stamina <= 0) { this.tired = true; this.state = 'tired'; this.shield.visible = false; }
            if(this.tired) {
                this.stamina += 0.4; 
                if(this.stamina > 30) { this.tired = false; this.state = 'idle'; }
            } else if (this.state !== 'dash' && this.state !== 'block' && this.state !== 'attack' && this.state !== 'jump') {
                this.stamina = Math.min(this.maxStamina, this.stamina + 0.5);
            }
            if(this.blocking && !this.tired) this.stamina -= 0.5;

            if(this.state !== 'dash' && this.state !== 'hurt' && this.state !== 'attack' && this.state !== 'block' && this.state !== 'tired') {
                if(Math.abs(this.vx) > 0.05) this.facingRight = this.vx > 0;
                else this.facingRight = opponent.x > this.x;
            }
            const targetRot = this.facingRight ? Math.PI/2 : -Math.PI/2;
            this.root.rotation.y += (targetRot - this.root.rotation.y) * 0.25;

            if(this.hitCount > 0) { this.comboTimer--; if(this.comboTimer <= 0) this.hitCount = 0; }
            updateComboUI(this.playerId, this.hitCount, this.comboTimer);

            if(this.cooldowns.s1 > 0) this.cooldowns.s1--;
            if(this.cooldowns.s2 > 0) this.cooldowns.s2--;
            if(this.cooldowns.s3 > 0) this.cooldowns.s3--;
            
            if(this.blocking && !this.tired && this.state !== 'hurt' && this.state !== 'attack' && this.state !== 'dash' && this.y <= 0.1) {
                this.state = 'block'; this.shield.visible = true;
            } else {
                this.shield.visible = false;
                if(this.state === 'block') this.state = 'idle';
            }

            if(this.animTimer > 0) {
                this.animTimer--;
                if(this.animTimer === 0 && this.state !== 'idle' && !this.tired) {
                    this.state = 'idle'; this.resetAnim(); this.meshes.forEach(m => m.material.emissive = new THREE.Color(0x000000));
                }
            } else {
                if(this.state !== 'block' && !this.tired) {
                    if(this.y > 0.1) this.state = 'jump';
                    else if(Math.abs(this.vx) > 0.05) this.state = 'run';
                    else {
                        this.state = 'idle';
                        if(Date.now() - this.lastAttackTime > 1200) this.combo = 0;
                    }
                }
                if(this.tired) this.state = 'tired';
            }
            this.animate();
        }

        hurt(damage, kX, kY) {
            if(this.state === 'block' && this.facingRight !== (kX > 0)) { 
                AudioSys.playBlock(); this.stamina -= 10; this.vx = kX * 0.2; 
                this.shield.material.opacity = 1; setTimeout(() => this.shield.material.opacity = 0.4, 100);
                return;
            }
            this.hp -= damage; this.vx = kX; this.vy = kY;
            this.state = 'hurt'; this.animTimer = 20; this.hitCount = 0; 
            AudioSys.playHurt(); this.meshes.forEach(m => m.material.emissive = new THREE.Color(0xff0000));
        }

        resetAnim() {
            this.spine.rotation.set(0,0,0);
            this.shoulderL.rotation.set(0,0,0); this.shoulderR.rotation.set(0,0,0);
            this.elbowL.rotation.set(0,0,0); this.elbowR.rotation.set(0,0,0);
            this.legL.rotation.set(0,0,0); this.legR.rotation.set(0,0,0);
            this.kneeL.rotation.set(0,0,0); this.kneeR.rotation.set(0,0,0);
            this.hips.position.y = 2.0; this.neck.rotation.set(0,0,0);
        }

        animate() {
            const t = Date.now() * 0.01;
            if(this.state === 'idle') {
                this.spine.rotation.x = Math.sin(t*0.5) * 0.05;
                this.shoulderL.rotation.z = 0.2; this.shoulderR.rotation.z = -0.2;
                this.shoulderL.rotation.x = Math.sin(t*0.5 + 1) * 0.05; this.shoulderR.rotation.x = Math.sin(t*0.5) * 0.05;
                this.legL.rotation.x = -0.2; this.legR.rotation.x = 0.2;
                this.elbowL.rotation.x = -0.5; this.elbowR.rotation.x = -0.5;
                this.neck.rotation.x = 0;
            }
            else if(this.state === 'tired') {
                const breath = Math.sin(t*10) * 0.1;
                this.hips.position.y = 1.7 + breath;
                this.spine.rotation.x = 0.8 + breath; this.neck.rotation.x = -0.6;
                this.shoulderL.rotation.x = 0; this.shoulderL.rotation.z = 0.5; 
                this.shoulderR.rotation.x = 0; this.shoulderR.rotation.z = -0.5;
                this.elbowL.rotation.x = -0.2; this.elbowR.rotation.x = -0.2;
            }
            else if(this.state === 'block') {
                this.spine.rotation.x = 0.3;
                this.shoulderL.rotation.x = -1.0; this.shoulderL.rotation.z = 1.0; 
                this.shoulderR.rotation.x = -1.0; this.shoulderR.rotation.z = -1.0;
                this.legL.rotation.x = -0.5; this.legR.rotation.x = 0.5;
            }
            else if (this.state === 'run') {
                this.runTime += 0.3;
                if(this.runTime % Math.PI < 0.2) spawnDust(this.x, this.z, 1);
                const rt = this.runTime;
                this.hips.position.y = 2.0 + Math.abs(Math.sin(rt)) * 0.1;
                this.spine.rotation.y = Math.cos(rt) * 0.1;
                this.legL.rotation.x = Math.sin(rt) * 1.0; this.kneeL.rotation.x = Math.max(0, -Math.sin(rt) * 1.5);
                this.legR.rotation.x = Math.sin(rt + Math.PI) * 1.0; this.kneeR.rotation.x = Math.max(0, -Math.sin(rt + Math.PI) * 1.5);
                this.shoulderL.rotation.x = Math.sin(rt + Math.PI) * 0.8; this.elbowL.rotation.x = -1.0;
                this.shoulderR.rotation.x = Math.sin(rt) * 0.8; this.elbowR.rotation.x = -1.0;
            }
            else if (this.state === 'jump') {
                this.legL.rotation.x = 0.5; this.kneeL.rotation.x = 1.0;
                this.legR.rotation.x = -0.2; this.kneeR.rotation.x = 0.5;
                this.shoulderL.rotation.z = 0.5; this.shoulderR.rotation.z = -0.5;
            }
            else if (this.state === 'hurt') {
                this.spine.rotation.x = -0.5; this.hips.position.y = 1.8;
                this.shoulderL.rotation.x = -2.0; this.shoulderR.rotation.x = -2.0;
                this.neck.rotation.x = -0.5;
            }
            else if (this.state === 'attack') {
                const p = 1 - (this.animTimer / (this.combo===3?30:(this.combo===2?20:15)));
                if (this.combo === 1) { 
                    if(p < 0.5) { this.spine.rotation.y = 0.5; this.shoulderL.rotation.x = -1.5; this.elbowL.rotation.x = -0.1; this.shoulderL.position.z = p*2; } 
                    else this.shoulderL.position.z = (1-p)*2;
                    this.shoulderR.rotation.x = -0.5; this.elbowR.rotation.x = -2.0;
                }
                else if (this.combo === 2) { 
                    this.spine.rotation.y = -1.0 + (p*1.5);
                    if(p < 0.5) { this.shoulderR.rotation.x = -1.4; this.shoulderR.rotation.y = 1.0 - (p*3); }
                }
                else if (this.combo === 3) { 
                    if(p < 0.3) this.hips.position.y = 1.5;
                    else { this.hips.position.y = 2.0 + (p-0.3)*2; this.shoulderR.rotation.x = -3.0; this.spine.rotation.x = -0.5; }
                }
            }
            else if (this.state === 'dash') {
                this.spine.rotation.x = 0.5;
                this.shoulderL.rotation.x = 1.0; this.shoulderR.rotation.x = 1.0;
                this.legL.rotation.x = -0.5; this.legR.rotation.x = -0.5;
                spawnDust(this.x, this.z, 2);
            }
        }

        move(dir) {
            if(this.state === 'attack' || this.state === 'dash' || this.state === 'hurt' || this.state === 'block' || this.tired) return;
            this.vx += dir * 0.05;
        }

        jump() {
            if(this.y <= GROUND + 0.1 && this.state !== 'attack' && this.state !== 'dash' && this.state !== 'hurt' && this.state !== 'block' && !this.tired) {
                if(this.consumeStamina(15)) {
                    this.vy = 0.75; spawnDust(this.x, this.z, 8); AudioSys.playTone(300, 'square', 0.1);
                }
            }
        }

        block(active) {
            if(this.tired) { this.blocking = false; return; }
            this.blocking = active;
        }

        checkHit(opponent, damage, kX, kY) {
            const dist = Math.abs(this.x - opponent.x);
            if(dist < 3.5 && Math.abs(this.y - opponent.y) < 4.0) {
                spawnExplosion(opponent.x, opponent.y+3.0, 0, 0xffaa00, 5);
                opponent.hurt(damage, kX, kY);
                shake = damage > 10 ? 10 : 3;
                this.hitCount++; this.comboTimer = 100;
                return true;
            }
            return false;
        }

        performAttack(opponent) {
            if(this.state !== 'idle' && this.state !== 'run') return;
            if(!this.consumeStamina(8)) return;

            const now = Date.now();
            if (now - this.lastAttackTime < 800) { this.combo++; if(this.combo > 3) this.combo = 1; } 
            else this.combo = 1;
            this.lastAttackTime = now;
            this.state = 'attack';
            
            let dmg = 5, kX = 0, kY = 0, delay = 100;
            const dir = this.facingRight ? 1 : -1;
            if(this.combo === 1) { 
                this.animTimer = 15; dmg = 4; kX = dir * 0.3; delay=100; 
                this.vx = dir * 0.2; 
                AudioSys.playTone(400, 'triangle', 0.05); 
            } 
            else if (this.combo === 2) { this.animTimer = 20; dmg = 8; kX = dir * 0.5; delay=150; AudioSys.playTone(300, 'square', 0.1); } 
            else if (this.combo === 3) { this.animTimer = 30; dmg = 15; kX = dir * 0.2; kY = 0.6; delay=250; AudioSys.playTone(150, 'sawtooth', 0.2); this.vx = dir * 0.3; }
            
            setTimeout(() => { if(this.state==='attack') this.checkHit(opponent, dmg, kX, kY); }, delay);
        }

        skill1(opponent) { // Blast
            if(this.cooldowns.s1 > 0 || this.state !== 'idle' || this.tired) return;
            if(!this.consumeStamina(20)) return;
            this.cooldowns.s1 = 60; this.state = 'attack'; this.animTimer = 20; this.combo = 1;
            const dir = this.facingRight ? 1 : -1;
            // Spawn at chest level (2.2), fix hitbox issue
            shots.push(new Projectile(this.x + dir, 2.2, dir, this));
            AudioSys.playTone(600, 'square', 0.2);
        }

        skill2(opponent) { // Dash
            if(this.cooldowns.s2 > 0 || this.state === 'hurt' || this.state === 'block' || this.tired) return;
            if(!this.consumeStamina(25)) return;
            this.cooldowns.s2 = 100; this.state = 'dash'; this.animTimer = 20;
            this.vy = 0; this.vx = (this.facingRight ? 1 : -1) * 0.9;
            let dInt = setInterval(() => { 
                if(this.state !== 'dash') { clearInterval(dInt); return; }
                if(this.checkHit(opponent, 10, this.vx*0.5, 0.2)) clearInterval(dInt); 
            }, 30);
            setTimeout(()=>clearInterval(dInt), 200);
            AudioSys.noise(0.2);
        }

        skill3(opponent) { // Ult
            if(this.cooldowns.s3 > 0 || this.state === 'hurt' || this.state === 'block' || this.tired) return;
            if(!this.consumeStamina(40)) return;
            this.cooldowns.s3 = 200; this.state = 'attack'; this.animTimer = 60; this.vy = 1.0;
            setTimeout(() => {
                if(this.state !== 'attack') return;
                this.vy = -1.5; 
                let slam = setInterval(() => {
                    if(this.y <= GROUND) {
                        clearInterval(slam);
                        shake = 25; AudioSys.noise(0.5);
                        for(let i=0; i<30; i++) {
                            const v = new THREE.Vector3((Math.random()-0.5)*1.5, Math.random(), (Math.random()-0.5)*1.5);
                            particles.push(new Particle(this.x, 0.5, this.z, 0xffaa00, 0.5, 40, v, 0.05));
                        }
                        const beam = new THREE.Mesh(new THREE.CylinderGeometry(3,3,30,16), new THREE.MeshBasicMaterial({color: 0xffffaa, transparent:true, opacity:0.8}));
                        beam.position.set(this.x, 15, 0); sceneGame.add(beam);
                        let bInt = setInterval(() => {
                            beam.scale.x*=0.9; beam.scale.z*=0.9; beam.material.opacity-=0.05;
                            if(beam.material.opacity<=0) { clearInterval(bInt); sceneGame.remove(beam); }
                        }, 30);
                        if(Math.abs(this.x - opponent.x) < 8) opponent.hurt(30, 0, 0.9);
                    }
                }, 16);
            }, 300);
        }
    }

    class Projectile {
        constructor(x, y, dir, owner) {
            this.x = x; this.y = y; this.dir = dir; this.owner = owner; this.active = true;
            this.mesh = new THREE.Mesh(new THREE.BoxGeometry(1.2, 1.2, 1.2), new THREE.MeshBasicMaterial({color:0x00ffff}));
            this.mesh.position.set(x,y,0); sceneGame.add(this.mesh);
            this.light = new THREE.PointLight(0x00ffff, 1, 8); this.mesh.add(this.light);
        }
        update(opponent) {
            if(!this.active) return false;
            const oldX = this.x;
            this.x += this.dir * 0.6; 
            this.mesh.position.x = this.x;
            this.mesh.rotation.x += 0.3; this.mesh.rotation.y += 0.3;
            if(Math.abs(this.x) > MAP_LIMIT + 5) { this.destroy(); return false; }
            
            // Fixed Hitbox Logic
            const minX = Math.min(oldX, this.x); const maxX = Math.max(oldX, this.x);
            // Increased vertical tolerance to < 5.0 to catch even when jumping
            if(opponent.x >= minX - 1.5 && opponent.x <= maxX + 1.5 && Math.abs(this.y - opponent.y) < 5.0) {
                // Blue Explosion Effect
                spawnExplosion(this.x, this.y, 0, 0x00ffff, 30); 
                opponent.hurt(12, this.dir * 0.4, 0.3);
                AudioSys.playTone(100, 'square', 0.1); 
                this.destroy(); return false;
            }
            return true;
        }
        destroy() { this.active = false; sceneGame.remove(this.mesh); }
    }

    let p1, p2, shots = [], shake = 0;

    function init() {
        if(p1) { sceneGame.remove(p1.root); sceneGame.remove(p2.root); }
        p1 = new Character(-5, 0xff3333, true, 'p1');
        p2 = new Character(5, 0x3333ff, false, 'p2');
        loop();
    }

    function updateComboUI(id, count, timer) {
        const box = document.getElementById(id==='p1'?'c1-box':'c2-box');
        const num = document.getElementById(id==='p1'?'c1-num':'c2-num');
        const bar = document.getElementById(id==='p1'?'c1-bar':'c2-bar');
        
        if(count > 0) {
            box.style.opacity = 1; box.style.transform = `scale(1.2)`;
            num.innerText = count; bar.style.width = (timer) + '%';
        } else {
            box.style.opacity = 0; box.style.transform = `scale(1.0)`;
        }
    }

    function updateStamUI(id, val, max, tired) {
        const el = document.getElementById(id==='p1'?'p1-stam':'p2-stam');
        el.style.width = (val/max)*100 + '%';
        el.style.background = tired ? '#ff0000' : 'linear-gradient(to right, #00ffff, #0088ff)';
    }

    function loop() {
        requestAnimationFrame(loop);

        if(Math.abs(p1.x - p2.x) < 1.0 && Math.abs(p1.y - p2.y) < 2.0) {
            const push = 0.05;
            if(p1.x < p2.x) { p1.x -= push; p2.x += push; }
            else { p1.x += push; p2.x -= push; }
        }

        if(p2.hp > 0 && p2.state !== 'hurt' && !p2.tired) {
            const dist = Math.abs(p2.x - p1.x);
            const dirToP1 = p1.x > p2.x ? 1 : -1;
            
            if(p1.state === 'attack' && dist < 3 && Math.random() < 0.1) {
                p2.block(true);
            } else {
                p2.block(false);
                if(dist > 2.5) {
                    p2.move(dirToP1);
                    if(dist > 8 && Math.random() < 0.02) p2.skill1(p1);
                    if(dist > 4 && dist < 8 && Math.random() < 0.05) p2.skill2(p1);
                } 
                else if (dist <= 2.5) {
                    if(p2.cooldowns.s3 === 0 && Math.random() < 0.1) p2.skill3(p1);
                    else if(Math.random() < 0.15) p2.performAttack(p1);
                }
            }
        } else if (p2.tired) {
            p2.block(false);
        }

        p1.update(p2); p2.update(p1);
        
        if(keys['ArrowLeft'] || touch.l) p1.move(-1);
        if(keys['ArrowRight'] || touch.r) p1.move(1);

        shots = shots.filter(s => s.update(s.owner===p1?p2:p1));
        particles = particles.filter(p => p.update());

        if(shake > 0) {
            camGame.position.x = (Math.random()-0.5)*shake*0.1;
            camGame.position.y = 7 + (Math.random()-0.5)*shake*0.1;
            shake *= 0.9;
        } else {
            const mid = (p1.x + p2.x)/2;
            camGame.position.x += (mid - camGame.position.x) * 0.1;
            camGame.position.x = Math.max(-5, Math.min(5, camGame.position.x));
        }
        camGame.lookAt(camGame.position.x, 2, 0);

        document.getElementById('p1-hp').style.width = Math.max(0, p1.hp) + '%';
        document.getElementById('p2-hp').style.width = Math.max(0, p2.hp) + '%';
        updateStamUI('p1', p1.stamina, p1.maxStamina, p1.tired);
        updateStamUI('p2', p2.stamina, p2.maxStamina, p2.tired);

        const setCD = (id,v) => { document.getElementById(id).style.display = v>0?'flex':'none'; document.getElementById(id).innerText = Math.ceil(v/60); };
        setCD('cd-s1', p1.cooldowns.s1); setCD('cd-s2', p1.cooldowns.s2); setCD('cd-s3', p1.cooldowns.s3);

        renderer.setRenderTarget(renderTarget); renderer.render(sceneGame, camGame);
        renderer.setRenderTarget(null); renderer.render(sceneScreen, camScreen);

        if(p2.hp <= 0) { p2.hp = 100; p2.x = 8; p2.y=10; p2.stamina=100; }
        if(p1.hp <= 0) { p1.hp = 100; p1.x = -8; p1.y=10; p1.stamina=100; }
    }

    const keys = {}; const touch = {l:false, r:false};
    window.addEventListener('keydown', e => {
        keys[e.key] = true;
        if(e.key === 'ArrowUp') p1.jump();
        if(e.key === 'ArrowDown') p1.block(true); 
        if(e.key === 'z') p1.performAttack(p2);
        if(e.key === 'x') p1.skill1(p2);
        if(e.key === 'c') p1.skill2(p2);
        if(e.key === 'v') p1.skill3(p2);
    });
    window.addEventListener('keyup', e => {
        keys[e.key] = false;
        if(e.key === 'ArrowDown') p1.block(false);
    });

    const bind = (id, k, startFn, endFn) => {
        const el = document.getElementById(id);
        const s = (e) => { e.preventDefault(); if(k) touch[k]=true; if(startFn) startFn(); el.classList.add('pressed'); };
        const n = (e) => { e.preventDefault(); if(k) touch[k]=false; if(endFn) endFn(); el.classList.remove('pressed'); };
        el.addEventListener('mousedown', s); el.addEventListener('touchstart', s);
        el.addEventListener('mouseup', n); el.addEventListener('touchend', n);
        el.addEventListener('mouseleave', n); el.addEventListener('touchcancel', n);
    };
    bind('btn-left', 'l'); bind('btn-right', 'r');
    bind('btn-jump', null, ()=>p1.jump()); 
    bind('btn-block', null, ()=>p1.block(true), ()=>p1.block(false));
    bind('btn-atk', null, ()=>p1.performAttack(p2));
    bind('btn-s1', null, ()=>p1.skill1(p2)); bind('btn-s2', null, ()=>p1.skill2(p2)); bind('btn-s3', null, ()=>p1.skill3(p2));

    const get = (id) => document.getElementById(id);
    get('start-btn').onclick = () => { AudioSys.init(); get('start-screen').classList.add('hidden'); init(); };
    get('local-menu-btn').onclick = () => { get('start-screen').classList.add('hidden'); get('local-screen').classList.remove('hidden'); };
    get('host-btn').onclick = () => { get('local-screen').classList.add('hidden'); get('host-screen').classList.remove('hidden'); get('host-code').innerText = Math.floor(100000 + Math.random() * 900000); };
    get('host-cancel').onclick = () => { get('host-screen').classList.add('hidden'); get('local-screen').classList.remove('hidden'); };
    get('join-btn').onclick = () => { get('local-screen').classList.add('hidden'); get('join-screen').classList.remove('hidden'); };
    get('join-cancel').onclick = () => { get('join-screen').classList.add('hidden'); get('local-screen').classList.remove('hidden'); };
    get('back-btn').onclick = () => { get('local-screen').classList.add('hidden'); get('start-screen').classList.remove('hidden'); };
    get('connect-btn').onclick = () => { const btn = get('connect-btn'); const txt = btn.innerText; btn.innerText = "CONNECTING..."; setTimeout(() => { btn.innerText = "FAILED"; setTimeout(()=>btn.innerText=txt, 1000); }, 2000); };

    window.addEventListener('resize', () => {
        const a = window.innerWidth/window.innerHeight;
        camGame.aspect = a; camGame.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
</script>
</body>
</html>


<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Tactical Warfare: Peer-to-Peer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/js/all.min.js"></script>
    <!-- PeerJS for Serverless Multiplayer -->
    <script src="https://unpkg.com/peerjs@1.5.4/dist/peerjs.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #1a1a1a; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; user-select: none; }
        canvas { display: block; }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        .pointer-events-auto { pointer-events: auto; }
        
        /* Custom UI Styling */
        .glass-panel {
            background: rgba(20, 20, 25, 0.95);
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.5);
        }
        
        .health-bar-container {
            width: 100%; height: 6px; background: #333; border-radius: 3px; overflow: hidden; margin-top: 4px;
        }
        .health-bar-fill { height: 100%; transition: width 0.2s; }
        
        /* Disable context menu for right click move */
        canvas { -webkit-touch-callout: none; -webkit-user-select: none; -khtml-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; outline: none; }

        .hidden { display: none !important; }
        
        /* Animations */
        @keyframes pulse-red {
            0% { box-shadow: 0 0 0 0 rgba(255, 50, 50, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(255, 50, 50, 0); }
            100% { box-shadow: 0 0 0 0 rgba(255, 50, 50, 0); }
        }
        .danger-zone { animation: pulse-red 2s infinite; }
        
        .loader {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3498db;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 2s linear infinite;
            display: inline-block;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body>

<!-- Setup & Menu UI -->
<div id="menu-screen" class="absolute inset-0 flex items-center justify-center z-50 bg-gray-900 bg-opacity-95 text-white">
    <div class="glass-panel p-8 rounded-xl max-w-md w-full text-center">
        <h1 class="text-4xl font-bold mb-2 tracking-tighter text-blue-400">TACTICAL<span class="text-white">WARFARE</span></h1>
        <p class="text-gray-400 mb-6 text-sm">Direct P2P Multiplayer (No Server)</p>

        <!-- Status -->
        <div id="connection-status" class="mb-4 text-sm text-yellow-400">Initializing Network...</div>

        <!-- Lobby Controls -->
        <div id="lobby-controls" class="space-y-4">
            <div class="flex gap-2">
                <input type="text" id="player-name" placeholder="Enter Codename" class="flex-1 bg-gray-800 border border-gray-700 text-white px-4 py-2 rounded focus:outline-none focus:border-blue-500" value="Soldier">
            </div>
            
            <div class="grid grid-cols-2 gap-4">
                <button id="btn-create" class="bg-blue-600 hover:bg-blue-500 py-3 rounded font-bold transition">CREATE OP</button>
                <button id="btn-join-menu" class="bg-gray-700 hover:bg-gray-600 py-3 rounded font-bold transition">JOIN OP</button>
            </div>

            <div id="join-input-area" class="hidden mt-4 p-4 bg-gray-800 rounded border border-gray-700">
                <p class="text-xs text-left text-gray-400 mb-1">Paste Friend's ID:</p>
                <input type="text" id="game-id-input" placeholder="e.g. 5f4d3a..." class="w-full bg-gray-900 border border-gray-600 px-3 py-2 rounded mb-2 text-white font-mono">
                <button id="btn-join-action" class="w-full bg-green-600 hover:bg-green-500 py-2 rounded font-bold">CONNECT</button>
            </div>
        </div>

        <!-- Waiting Room -->
        <div id="waiting-room" class="hidden mt-6 text-left">
            <div id="host-info-panel" class="bg-gray-800 p-4 rounded mb-4 border border-gray-700">
                <p class="text-xs text-gray-500 uppercase">Your Game ID (Send to friend)</p>
                <div class="flex items-center gap-2 mt-1">
                    <code id="display-game-id" class="flex-1 bg-black p-2 rounded text-green-400 font-mono text-lg select-all overflow-hidden whitespace-nowrap">Generating...</code>
                    <button id="btn-copy" class="p-2 bg-gray-700 rounded hover:bg-gray-600 text-white"><i class="fas fa-copy"></i></button>
                </div>
            </div>

            <h3 class="text-lg font-bold mb-2">Select Loadout</h3>
            <div class="grid grid-cols-3 gap-2 mb-6">
                <button class="loadout-btn bg-gray-700 p-2 rounded border border-transparent hover:border-blue-400 transition text-sm" data-gun="glock">
                    <div class="font-bold">Glock</div>
                    <div class="text-xs text-gray-400">Agile</div>
                </button>
                <button class="loadout-btn bg-gray-700 p-2 rounded border border-transparent hover:border-blue-400 transition text-sm border-blue-500 bg-gray-600" data-gun="ar">
                    <div class="font-bold">Rifle</div>
                    <div class="text-xs text-gray-400">Balanced</div>
                </button>
                <button class="loadout-btn bg-gray-700 p-2 rounded border border-transparent hover:border-blue-400 transition text-sm" data-gun="sniper">
                    <div class="font-bold">Sniper</div>
                    <div class="text-xs text-gray-400">Heavy</div>
                </button>
            </div>

            <div class="bg-black bg-opacity-30 p-3 rounded mb-4">
                <div id="p1-status" class="flex items-center gap-2 mb-1"><div class="w-2 h-2 rounded-full bg-green-500"></div> <span id="p1-name">You</span> <span class="text-xs text-gray-500">(Host)</span></div>
                <div id="p2-status" class="flex items-center gap-2"><div class="w-2 h-2 rounded-full bg-red-500 animate-pulse"></div> <span id="p2-name">Waiting for connection...</span></div>
            </div>

            <button id="btn-start" class="w-full bg-green-600 hover:bg-green-500 py-4 rounded-lg font-bold text-xl disabled:opacity-50 disabled:cursor-not-allowed disabled:bg-gray-600" disabled>WAITING FOR PLAYER...</button>
        </div>
    </div>
</div>

<!-- In-Game HUD -->
<div id="hud" class="hidden pointer-events-none absolute inset-0 p-4">
    <!-- Top Bar -->
    <div class="flex justify-between items-start">
        <!-- Team Blue (Host) -->
        <div class="glass-panel p-3 rounded-lg w-64 pointer-events-auto">
            <div class="flex justify-between text-sm mb-1">
                <span class="text-blue-400 font-bold">BLUE BASE</span>
                <span id="host-tower-hp-text">1000/1000</span>
            </div>
            <div class="health-bar-container"><div id="host-tower-bar" class="health-bar-fill bg-blue-500" style="width: 100%"></div></div>
        </div>

        <!-- Timer/Status -->
        <div class="glass-panel px-6 py-2 rounded-full font-mono text-xl font-bold text-white">
            <span id="game-status-text">ENGAGE</span>
        </div>

        <!-- Team Red (Guest) -->
        <div class="glass-panel p-3 rounded-lg w-64 pointer-events-auto">
            <div class="flex justify-between text-sm mb-1">
                <span class="text-red-400 font-bold">RED BASE</span>
                <span id="guest-tower-hp-text">1000/1000</span>
            </div>
            <div class="health-bar-container"><div id="guest-tower-bar" class="health-bar-fill bg-red-500" style="width: 100%"></div></div>
        </div>
    </div>

    <!-- Bottom Player Stats -->
    <div class="absolute bottom-6 left-6 pointer-events-auto">
        <div class="glass-panel p-4 rounded-lg w-72">
            <div class="flex items-center gap-4 mb-2">
                <div class="w-12 h-12 bg-gray-800 rounded-full flex items-center justify-center border-2 border-gray-600">
                    <i class="fas fa-crosshairs text-xl text-gray-400"></i>
                </div>
                <div>
                    <h2 id="hud-player-name" class="font-bold text-lg leading-none">Soldier</h2>
                    <span id="hud-weapon-name" class="text-xs text-gray-400 uppercase tracking-wider">Assault Rifle</span>
                </div>
            </div>
            <div class="space-y-2">
                <div>
                    <div class="flex justify-between text-xs text-gray-400 uppercase"><span>Integrity</span> <span id="hud-hp-text">500</span></div>
                    <div class="health-bar-container"><div id="hud-hp-bar" class="health-bar-fill bg-green-500" style="width: 100%"></div></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Controls Hint -->
    <div class="absolute bottom-6 right-6 text-right text-white opacity-50 text-sm">
        <p><span class="font-bold text-yellow-400">R-CLICK</span> MOVE</p>
        <p><span class="font-bold text-yellow-400">L-CLICK</span> SHOOT</p>
    </div>
</div>

<!-- Victory/Defeat Screen -->
<div id="end-screen" class="hidden absolute inset-0 flex items-center justify-center z-50 bg-black bg-opacity-80">
    <div class="glass-panel p-10 rounded-2xl text-center transform scale-110">
        <h1 id="end-title" class="text-6xl font-black mb-4 uppercase text-white drop-shadow-lg">VICTORY</h1>
        <p id="end-reason" class="text-xl text-gray-300 mb-8">Enemy Command Post Neutralized</p>
        <button onclick="location.reload()" class="bg-white text-black px-8 py-3 rounded-full font-bold hover:bg-gray-200 transition">RETURN TO BASE</button>
    </div>
</div>

<canvas id="gameCanvas"></canvas>

<!-- Scripts -->
<script>
    // --- Constants & Config ---
    const CANVAS = document.getElementById('gameCanvas');
    const CTX = CANVAS.getContext('2d');
    
    const MAP_WIDTH = 2000;
    const MAP_HEIGHT = 1500;
    const TOWER_HP = 1000;
    const PLAYER_HP = 500;
    const TOWER_RANGE = 400;
    const TOWER_DMG = 250;
    const TOWER_COOLDOWN = 2000; 

    const GUNS = {
        glock: { name: 'Glock 19', damage: 35, fireRate: 400, range: 600, speed: 20, color: '#facc15', spread: 0.1 },
        ar: { name: 'M4 Carbine', damage: 25, fireRate: 100, range: 800, speed: 25, color: '#60a5fa', spread: 0.15 },
        sniper: { name: 'AWP', damage: 200, fireRate: 1500, range: 1200, speed: 40, color: '#f87171', spread: 0.02 }
    };

    // --- State Variables ---
    let myPeerId = null;
    let peer = null;
    let conn = null; // DataConnection
    let isHost = false;
    let gameStarted = false;

    // Game Objects
    let localPlayer = {
        x: 0, y: 0, 
        destX: 0, destY: 0,
        hp: PLAYER_HP,
        angle: 0,
        gun: 'ar',
        team: 'blue', 
        lastShot: 0,
        moving: false,
        name: 'Player 1'
    };

    let remotePlayer = {
        x: -1000, y: -1000, // offscreen initially
        hp: PLAYER_HP,
        angle: 0,
        gun: 'ar',
        team: 'red',
        moving: false,
        name: 'Player 2',
        targetX: -1000, targetY: -1000
    };

    let projectiles = [];
    let particles = [];
    let obstacles = [];
    let towers = {
        blue: { x: 200, y: MAP_HEIGHT/2, hp: TOWER_HP, lastFire: 0, color: '#3b82f6' },
        red: { x: MAP_WIDTH - 200, y: MAP_HEIGHT/2, hp: TOWER_HP, lastFire: 0, color: '#ef4444' }
    };
    let camera = { x: 0, y: 0 };
    let mouse = { x: 0, y: 0, worldX: 0, worldY: 0 };

    // --- UI Elements ---
    const connectionStatus = document.getElementById('connection-status');
    const lobbyControls = document.getElementById('lobby-controls');
    const waitingRoom = document.getElementById('waiting-room');
    const displayGameId = document.getElementById('display-game-id');
    const btnStart = document.getElementById('btn-start');
    const p1Name = document.getElementById('p1-name');
    const p2Name = document.getElementById('p2-name');
    const p2Status = document.getElementById('p2-status').querySelector('div');

    // --- Initialization ---
    // Start PeerJS immediately to be ready
    function initPeer() {
        connectionStatus.innerText = "Connecting to P2P Network...";
        peer = new Peer(null, {
            debug: 2
        });

        peer.on('open', (id) => {
            myPeerId = id;
            connectionStatus.innerText = "Network Ready. Select mode.";
            connectionStatus.classList.replace('text-yellow-400', 'text-green-400');
            console.log('My ID:', id);
        });

        peer.on('connection', (c) => {
            // Incoming connection (I am Host)
            if(conn && conn.open) {
                c.close(); // Already have a player
                return;
            }
            conn = c;
            setupConnection();
        });

        peer.on('error', (err) => {
            console.error(err);
            connectionStatus.innerText = "Network Error: " + err.type;
            connectionStatus.classList.replace('text-yellow-400', 'text-red-500');
        });
    }

    initPeer();

    // --- Lobby Logic ---
    document.getElementById('btn-create').addEventListener('click', () => {
        if(!myPeerId) return alert("Network not ready yet.");
        isHost = true;
        enterLobby();
        displayGameId.innerText = myPeerId;
        p1Name.innerText = document.getElementById('player-name').value || "Host";
        localPlayer.name = p1Name.innerText;
        localPlayer.team = 'blue';
        remotePlayer.team = 'red';
    });

    document.getElementById('btn-join-menu').addEventListener('click', () => {
        document.getElementById('join-input-area').classList.toggle('hidden');
    });

    document.getElementById('btn-join-action').addEventListener('click', () => {
        const targetId = document.getElementById('game-id-input').value.trim();
        if(!targetId) return;
        if(!myPeerId) return alert("Network not ready yet.");
        
        isHost = false;
        connectionStatus.innerText = "Connecting to Host...";
        
        // Connect to Host
        conn = peer.connect(targetId);
        setupConnection();
        
        enterLobby();
        document.getElementById('host-info-panel').classList.add('hidden'); // Guests don't show ID
        p1Name.innerText = document.getElementById('player-name').value || "Guest";
        localPlayer.name = p1Name.innerText;
        localPlayer.team = 'red';
        remotePlayer.team = 'blue';
    });

    document.getElementById('btn-copy').addEventListener('click', () => {
        navigator.clipboard.writeText(myPeerId);
        const btn = document.getElementById('btn-copy');
        btn.innerHTML = '<i class="fas fa-check"></i>';
        setTimeout(() => btn.innerHTML = '<i class="fas fa-copy"></i>', 2000);
    });

    // Loadout Selection
    const loadoutBtns = document.querySelectorAll('.loadout-btn');
    loadoutBtns.forEach(btn => {
        btn.addEventListener('click', () => {
            loadoutBtns.forEach(b => {
                b.classList.remove('border-blue-500', 'bg-gray-600');
                b.classList.add('border-transparent');
            });
            btn.classList.add('border-blue-500', 'bg-gray-600');
            btn.classList.remove('border-transparent');
            localPlayer.gun = btn.dataset.gun;
            // Send update if connected
            if(conn && conn.open) {
                sendData({ type: 'lobby_update', name: localPlayer.name, gun: localPlayer.gun });
            }
        });
    });

    document.getElementById('btn-start').addEventListener('click', () => {
        if(!isHost) return;
        // Send Start Signal
        sendData({ type: 'start_game', seed: Date.now() });
        startGame(Date.now());
    });

    function enterLobby() {
        lobbyControls.classList.add('hidden');
        waitingRoom.classList.remove('hidden');
    }

    function setupConnection() {
        conn.on('open', () => {
            console.log("Connected to: " + conn.peer);
            connectionStatus.innerText = "Connected!";
            
            // Send initial handshake
            sendData({ type: 'lobby_update', name: localPlayer.name, gun: localPlayer.gun });
        });

        conn.on('data', (data) => {
            handleData(data);
        });

        conn.on('close', () => {
            alert("Connection lost!");
            location.reload();
        });
    }

    function sendData(data) {
        if(conn && conn.open) {
            conn.send(data);
        }
    }

    function handleData(data) {
        if(data.type === 'lobby_update') {
            remotePlayer.name = data.name;
            remotePlayer.gun = data.gun;
            p2Name.innerText = data.name;
            p2Status.classList.replace('bg-red-500', 'bg-green-500');
            p2Status.classList.remove('animate-pulse');
            
            if(isHost) {
                btnStart.innerText = "DEPLOY TEAM";
                btnStart.disabled = false;
                btnStart.classList.remove('disabled:bg-gray-600');
            } else {
                btnStart.innerText = "WAITING FOR HOST...";
            }
        }
        else if(data.type === 'start_game') {
            startGame(data.seed);
        }
        else if(data.type === 'game_update') {
            // Update Remote Player State
            remotePlayer.targetX = data.p.x;
            remotePlayer.targetY = data.p.y;
            remotePlayer.hp = data.p.hp;
            remotePlayer.angle = data.p.a;
            remotePlayer.moving = data.p.m;

            // Sync Towers (Host is authority, but for simplicity both sync hp)
            // Ideally Host calculates tower dmg and sends it.
            // P2P Trust model: receive remote tower HP
            if(!isHost) {
                 towers.blue.hp = data.t.blue;
                 towers.red.hp = data.t.red;
            } else {
                // Host receives guest's view of towers? No, Host is authority.
                // But Guest might shoot tower.
                // Let's rely on Event Based damage for shots
            }
        }
        else if(data.type === 'shot') {
            // Remote player shot
            // We locally spawn a bullet from them
            // angle, gun
            spawnBullet(remotePlayer, data.angle, data.gun);
        }
        else if(data.type === 'hit_tower') {
            // Remote player says they hit a tower
            const t = towers[data.team]; // team is color of tower
            if(t) t.hp -= data.dmg;
        }
        else if(data.type === 'hit_player') {
            // Remote player says they hit ME
            localPlayer.hp -= data.dmg;
        }
    }

    // --- Game Logic ---

    function generateObstacles(seed) {
        // Simple seeded procedural (using seed to make random seem same)
        // Just fixed map for reliability in this demo
        obstacles = [];
        // Center Block
        obstacles.push({x: MAP_WIDTH/2 - 50, y: MAP_HEIGHT/2 - 150, w: 100, h: 300, type: 'wall'});
        // Flank Covers
        obstacles.push({x: MAP_WIDTH/2 - 400, y: MAP_HEIGHT/2 - 400, w: 200, h: 50, type: 'crate'});
        obstacles.push({x: MAP_WIDTH/2 + 200, y: MAP_HEIGHT/2 + 350, w: 200, h: 50, type: 'crate'});
        
        // Fixed randoms
        const staticRocks = [
            {x: 400, y: 400, w: 60, h: 60}, {x: 1600, y: 1100, w: 80, h: 80},
            {x: 800, y: 200, w: 50, h: 50}, {x: 1200, y: 1300, w: 50, h: 50},
            {x: 200, y: 1000, w: 70, h: 70}, {x: 1800, y: 500, w: 70, h: 70}
        ];
        staticRocks.forEach(r => obstacles.push({...r, type: 'rock'}));
    }

    function startGame(seed) {
        gameStarted = true;
        document.getElementById('menu-screen').style.display = 'none';
        document.getElementById('hud').classList.remove('hidden');
        
        generateObstacles(seed);

        // Positions
        if(isHost) {
            localPlayer.x = 200; localPlayer.y = MAP_HEIGHT/2;
            remotePlayer.x = MAP_WIDTH - 200; remotePlayer.y = MAP_HEIGHT/2;
        } else {
            localPlayer.x = MAP_WIDTH - 200; localPlayer.y = MAP_HEIGHT/2;
            remotePlayer.x = 200; remotePlayer.y = MAP_HEIGHT/2;
        }
        localPlayer.destX = localPlayer.x;
        localPlayer.destY = localPlayer.y;

        // UI Setup
        document.getElementById('hud-player-name').innerText = localPlayer.name;
        document.getElementById('hud-weapon-name').innerText = GUNS[localPlayer.gun].name;

        // Start Loops
        requestAnimationFrame(gameLoop);
        setInterval(networkLoop, 50); // 20 updates per second
    }

    function networkLoop() {
        if(!gameStarted) return;
        
        // Send my State
        const payload = {
            type: 'game_update',
            p: {
                x: Math.round(localPlayer.x),
                y: Math.round(localPlayer.y),
                a: parseFloat(localPlayer.angle.toFixed(2)),
                hp: localPlayer.hp,
                m: localPlayer.moving
            }
        };

        if(isHost) {
            payload.t = { blue: towers.blue.hp, red: towers.red.hp };
        }

        sendData(payload);
    }

    function resizeCanvas() {
        CANVAS.width = window.innerWidth;
        CANVAS.height = window.innerHeight;
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    // Input
    window.addEventListener('mousemove', (e) => {
        const rect = CANVAS.getBoundingClientRect();
        mouse.x = e.clientX - rect.left;
        mouse.y = e.clientY - rect.top;
        mouse.worldX = mouse.x + camera.x;
        mouse.worldY = mouse.y + camera.y;
    });

    window.addEventListener('contextmenu', (e) => {
        e.preventDefault();
        localPlayer.destX = mouse.worldX;
        localPlayer.destY = mouse.worldY;
        localPlayer.moving = true;
        createGroundMarker(mouse.worldX, mouse.worldY);
    });

    window.addEventListener('mousedown', (e) => {
        if(e.button === 0 && gameStarted && localPlayer.hp > 0) {
            tryShoot();
        }
    });

    function tryShoot() {
        const now = Date.now();
        const gun = GUNS[localPlayer.gun];
        if(now - localPlayer.lastShot > gun.fireRate) {
            localPlayer.lastShot = now;
            
            // Fire Locally
            spawnBullet(localPlayer, localPlayer.angle, localPlayer.gun);
            
            // Recoil
            camera.x += (Math.random() - 0.5) * 10;
            camera.y += (Math.random() - 0.5) * 10;

            // Notify Network
            sendData({ type: 'shot', angle: localPlayer.angle, gun: localPlayer.gun });
        }
    }

    function spawnBullet(shooter, angle, gunType) {
        const gun = GUNS[gunType];
        
        // Flash
        particles.push({
            x: shooter.x + Math.cos(angle) * 30,
            y: shooter.y + Math.sin(angle) * 30,
            vx: 0, vy: 0, life: 5, color: '#ffffaa', size: 10
        });

        const speed = gun.speed;
        const finalAngle = angle + (Math.random() - 0.5) * gun.spread;
        
        projectiles.push({
            x: shooter.x, y: shooter.y,
            vx: Math.cos(finalAngle) * speed,
            vy: Math.sin(finalAngle) * speed,
            ownerTeam: shooter.team, 
            damage: gun.damage,
            range: gun.range,
            distTraveled: 0,
            color: gun.color
        });
    }

    function gameLoop() {
        if(!gameStarted) return;
        update();
        render();
        requestAnimationFrame(gameLoop);
    }

    function update() {
        // Move Local
        const dx = localPlayer.destX - localPlayer.x;
        const dy = localPlayer.destY - localPlayer.y;
        const dist = Math.sqrt(dx*dx + dy*dy);
        const speed = 4;

        if(dist > speed) {
            localPlayer.x += (dx/dist) * speed;
            localPlayer.y += (dy/dist) * speed;
            localPlayer.moving = true;
        } else {
            localPlayer.moving = false;
        }

        localPlayer.angle = Math.atan2(mouse.worldY - localPlayer.y, mouse.worldX - localPlayer.x);

        // Move Remote (Interpolation)
        remotePlayer.x += (remotePlayer.targetX - remotePlayer.x) * 0.1;
        remotePlayer.y += (remotePlayer.targetY - remotePlayer.y) * 0.1;

        // Projectiles
        for(let i = projectiles.length - 1; i >= 0; i--) {
            let p = projectiles[i];
            p.x += p.vx; p.y += p.vy;
            p.distTraveled += Math.sqrt(p.vx*p.vx + p.vy*p.vy);

            if(p.distTraveled > p.range || p.x < 0 || p.x > MAP_WIDTH || p.y < 0 || p.y > MAP_HEIGHT) {
                projectiles.splice(i, 1); continue;
            }

            // Wall check
            let hitWall = false;
            for(let obs of obstacles) {
                if(p.x > obs.x && p.x < obs.x + obs.w && p.y > obs.y && p.y < obs.y + obs.h) {
                    hitWall = true; break;
                }
            }
            if(hitWall) {
                createExplosion(p.x, p.y, 5, '#888');
                projectiles.splice(i, 1); continue;
            }

            // Hit Checks (Only check what WE hit, send result)
            if(p.ownerTeam === localPlayer.team) {
                // Check if hit remote player
                const dEnemy = Math.hypot(p.x - remotePlayer.x, p.y - remotePlayer.y);
                if(dEnemy < 25) {
                    createExplosion(p.x, p.y, 10, '#f00');
                    projectiles.splice(i, 1);
                    // Send Damage Event
                    sendData({ type: 'hit_player', dmg: p.damage });
                    continue;
                }

                // Check if hit Enemy Tower
                const enemyTowerColor = localPlayer.team === 'blue' ? 'red' : 'blue';
                const enemyTower = towers[enemyTowerColor];
                const dTower = Math.hypot(p.x - enemyTower.x, p.y - enemyTower.y);
                if(dTower < 50 && enemyTower.hp > 0) {
                    enemyTower.hp -= p.damage;
                    createExplosion(p.x, p.y, 8, '#ffa500');
                    projectiles.splice(i, 1);
                    sendData({ type: 'hit_tower', team: enemyTowerColor, dmg: p.damage });
                    continue;
                }
            }
        }

        // Tower Logic (Host handles AI shooting)
        if(isHost) {
            checkTowerAI(towers.blue, remotePlayer); // Blue tower shoots Red player
            checkTowerAI(towers.red, localPlayer); // Red tower shoots Blue player
        } else {
            // Guest logic for their tower? No, host is authority.
            // Wait, simpler: Each client checks tower vs THEM.
            // If I am near enemy tower, it shoots ME.
            // This prevents laggy shots.
            const enemyTowerColor = localPlayer.team === 'blue' ? 'red' : 'blue';
            checkTowerAI(towers[enemyTowerColor], localPlayer);
        }

        // Camera
        camera.x = localPlayer.x - CANVAS.width / 2;
        camera.y = localPlayer.y - CANVAS.height / 2;
        camera.x = Math.max(0, Math.min(camera.x, MAP_WIDTH - CANVAS.width));
        camera.y = Math.max(0, Math.min(camera.y, MAP_HEIGHT - CANVAS.height));

        // Win Check
        if(towers.blue.hp <= 0) endGame('red');
        if(towers.red.hp <= 0) endGame('blue');
    }

    function checkTowerAI(tower, target) {
        if(tower.hp <= 0 || target.hp <= 0) return;
        const dist = Math.hypot(target.x - tower.x, target.y - tower.y);
        if(dist < TOWER_RANGE) {
            const now = Date.now();
            if(now - (tower.lastFire || 0) > TOWER_COOLDOWN) {
                tower.lastFire = now;
                // Fire cannon
                const angle = Math.atan2(target.y - tower.y, target.x - tower.x);
                projectiles.push({
                    x: tower.x, y: tower.y,
                    vx: Math.cos(angle) * 15, vy: Math.sin(angle) * 15,
                    ownerTeam: 'tower', damage: TOWER_DMG, range: 1000,
                    color: '#000', isCannon: true
                });
                // We don't sync this projectile, purely visual/local damage logic
                // If it hits me, I take damage.
            }
        }
    }

    function render() {
        CTX.fillStyle = '#1a1a1a';
        CTX.fillRect(0, 0, CANVAS.width, CANVAS.height);

        CTX.save();
        CTX.translate(-camera.x, -camera.y);

        // Grid
        CTX.strokeStyle = 'rgba(255,255,255,0.03)';
        CTX.lineWidth = 2;
        CTX.beginPath();
        for(let x=0; x<=MAP_WIDTH; x+=100) { CTX.moveTo(x,0); CTX.lineTo(x, MAP_HEIGHT); }
        for(let y=0; y<=MAP_HEIGHT; y+=100) { CTX.moveTo(0,y); CTX.lineTo(MAP_WIDTH, y); }
        CTX.stroke();
        CTX.strokeRect(0,0, MAP_WIDTH, MAP_HEIGHT);

        // Shadows
        CTX.shadowColor = 'rgba(0,0,0,0.5)';
        CTX.shadowBlur = 15;
        CTX.shadowOffsetY = 10;

        obstacles.forEach(obs => {
            CTX.fillStyle = obs.type === 'crate' ? '#78350f' : '#4b5563';
            CTX.fillRect(obs.x, obs.y, obs.w, obs.h);
            CTX.fillStyle = 'rgba(255,255,255,0.05)';
            CTX.fillRect(obs.x, obs.y, obs.w, obs.h*0.8);
        });
        CTX.shadowBlur = 0;

        // Particles
        renderParticles();

        // Towers
        drawTower(towers.blue, 'blue');
        drawTower(towers.red, 'red');

        // Players
        drawPlayer(localPlayer);
        drawPlayer(remotePlayer);

        // Projectiles
        projectiles.forEach(p => {
            CTX.beginPath();
            if(p.isCannon) {
                CTX.fillStyle = '#000';
                CTX.arc(p.x, p.y, 8, 0, Math.PI*2);
            } else {
                CTX.fillStyle = p.color;
                CTX.arc(p.x, p.y, 3, 0, Math.PI*2);
            }
            CTX.fill();
            
            // Checking simple collision with local player for cannon here
            if(p.isCannon) {
                const distToMe = Math.hypot(p.x - localPlayer.x, p.y - localPlayer.y);
                if(distToMe < 20) {
                     localPlayer.hp -= p.damage;
                     createExplosion(p.x, p.y, 10, '#f00');
                     p.distTraveled = 9999; // kill bullet
                }
            }
        });

        // Danger Zones
        if(towers.red.hp > 0 && localPlayer.team === 'blue') drawRangeRing(towers.red);
        if(towers.blue.hp > 0 && localPlayer.team === 'red') drawRangeRing(towers.blue);

        CTX.restore();
        updateHUD();
    }

    function drawTower(tower, color) {
        if(tower.hp <= 0) {
            CTX.fillStyle = '#333';
            CTX.beginPath(); CTX.arc(tower.x, tower.y, 40, 0, Math.PI*2); CTX.fill();
            return;
        }
        CTX.shadowColor = 'rgba(0,0,0,0.6)'; CTX.shadowBlur = 20;
        CTX.fillStyle = '#333'; CTX.beginPath(); CTX.arc(tower.x, tower.y, 50, 0, Math.PI*2); CTX.fill();
        CTX.shadowBlur = 0;
        CTX.fillStyle = tower.color; CTX.beginPath(); CTX.arc(tower.x, tower.y, 30, 0, Math.PI*2); CTX.fill();
        // Bar
        CTX.fillStyle = 'red'; CTX.fillRect(tower.x - 40, tower.y - 70, 80, 8);
        CTX.fillStyle = '#0f0'; CTX.fillRect(tower.x - 40, tower.y - 70, 80 * (tower.hp/TOWER_HP), 8);
    }

    function drawPlayer(p) {
        if(p.hp <= 0) return;
        CTX.save();
        CTX.translate(p.x, p.y);
        CTX.rotate(p.angle);
        
        if(p.moving) {
            CTX.fillStyle = '#111';
            const offset = Math.sin(Date.now() / 100) * 10;
            CTX.fillRect(-10, 5 + offset, 10, 10);
            CTX.fillRect(-10, -15 - offset, 10, 10);
        }

        CTX.shadowColor = 'rgba(0,0,0,0.5)'; CTX.shadowBlur = 10;
        CTX.fillStyle = p.team === 'blue' ? '#1e3a8a' : '#991b1b';
        CTX.beginPath(); CTX.ellipse(0, 0, 20, 15, 0, 0, Math.PI*2); CTX.fill();
        CTX.shadowBlur = 0;
        CTX.fillStyle = p.team === 'blue' ? '#3b82f6' : '#ef4444';
        CTX.beginPath(); CTX.arc(0, 0, 12, 0, Math.PI*2); CTX.fill();
        CTX.fillStyle = '#111'; CTX.fillRect(10, -3, 30, 6);
        CTX.restore();

        CTX.fillStyle = '#fff'; CTX.font = '10px Arial'; CTX.textAlign = 'center';
        CTX.fillText(p.name || '', p.x, p.y - 40);
        CTX.fillStyle = '#333'; CTX.fillRect(p.x - 20, p.y - 30, 40, 5);
        CTX.fillStyle = p.team === localPlayer.team ? '#0f0' : '#f00';
        CTX.fillRect(p.x - 20, p.y - 30, 40 * (p.hp/PLAYER_HP), 5);
    }

    function drawRangeRing(tower) {
        CTX.beginPath(); CTX.arc(tower.x, tower.y, TOWER_RANGE, 0, Math.PI*2);
        CTX.lineWidth = 2; CTX.strokeStyle = 'rgba(255, 0, 0, 0.2)';
        CTX.setLineDash([10, 10]); CTX.stroke(); CTX.setLineDash([]);
    }

    function createGroundMarker(x, y) {
        particles.push({x, y, vx: 0, vy: 0, life: 20, color: '#0f0', size: 5, type: 'marker'});
    }

    function createExplosion(x, y, count, color) {
        for(let i=0; i<count; i++) {
            particles.push({
                x, y, vx: (Math.random()-0.5)*5, vy: (Math.random()-0.5)*5,
                life: 30 + Math.random()*20, color: color, size: Math.random()*4 + 2
            });
        }
    }

    function renderParticles() {
        for(let i=particles.length-1; i>=0; i--) {
            let p = particles[i];
            if(p.type === 'marker') {
                CTX.strokeStyle = `rgba(0, 255, 0, ${p.life/20})`;
                CTX.beginPath(); CTX.arc(p.x, p.y, (20-p.life), 0, Math.PI*2); CTX.stroke();
            } else {
                p.x += p.vx; p.y += p.vy; p.life--;
                CTX.globalAlpha = p.life / 50; CTX.fillStyle = p.color;
                CTX.beginPath(); CTX.arc(p.x, p.y, p.size, 0, Math.PI*2); CTX.fill();
                CTX.globalAlpha = 1;
            }
            if(p.life <= 0) particles.splice(i, 1);
        }
    }

    function updateHUD() {
        document.getElementById('hud-hp-text').innerText = Math.max(0, Math.ceil(localPlayer.hp));
        document.getElementById('hud-hp-bar').style.width = `${Math.max(0, (localPlayer.hp / PLAYER_HP) * 100)}%`;
        document.getElementById('host-tower-bar').style.width = `${(towers.blue.hp/TOWER_HP)*100}%`;
        document.getElementById('host-tower-hp-text').innerText = `${Math.max(0, towers.blue.hp)}/1000`;
        document.getElementById('guest-tower-bar').style.width = `${(towers.red.hp/TOWER_HP)*100}%`;
        document.getElementById('guest-tower-hp-text').innerText = `${Math.max(0, towers.red.hp)}/1000`;
    }

    function endGame(winningTeam) {
        const screen = document.getElementById('end-screen');
        screen.classList.remove('hidden');
        const title = document.getElementById('end-title');
        
        if(localPlayer.team === winningTeam) {
            title.innerText = "VICTORY";
            title.className = "text-6xl font-black mb-4 uppercase text-green-500 drop-shadow-lg";
        } else {
            title.innerText = "DEFEAT";
            title.className = "text-6xl font-black mb-4 uppercase text-red-500 drop-shadow-lg";
        }
        gameStarted = false;
    }

</script>
</body>
</html>

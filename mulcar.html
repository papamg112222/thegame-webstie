<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Tokyo Drift</title>
<!-- Imported Pixel Font -->
<link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
<!-- MQTT.js Client Library for Serverless Multiplayer -->
<script src="https://unpkg.com/mqtt/dist/mqtt.min.js"></script>
<style>
body {
margin: 0;
padding: 0;
overflow: hidden;
background-color: #14141e; /* COLOR_BG_VOID */
font-family: 'Press Start 2P', cursive; /* Updated Font */
touch-action: none; /* Prevent mobile scrolling */
-webkit-touch-callout: none;
-webkit-user-select: none;
user-select: none;
}
canvas {
display: block;
/* Force pixelated rendering for crisp edges */
image-rendering: pixelated;
image-rendering: crisp-edges;
}
/* ONLINE STATUS UI */
#online-ui {
position: absolute;
top: 20px;
right: 20px;
background-color: #505050; /* Bubble square gray color */
padding: 12px 16px;
border-radius: 12px;
border: 3px solid #2d2d32;
display: flex;
align-items: center;
gap: 12px;
box-shadow: 0 4px 0 rgba(0,0,0,0.5);
pointer-events: none; /* Let clicks pass through */
z-index: 100;
}
.status-dot {
width: 12px;
height: 12px;
background-color: #32ff64; /* Green circle */
border-radius: 50%;
box-shadow: 0 0 8px #32ff64;
animation: pulse 2s infinite;
}
.status-text {
color: #ffffff;
font-size: 12px;
text-transform: uppercase;
text-shadow: 2px 2px #000;
}
/* ADMIN PANEL STYLES */
#admin-panel {
position: absolute;
top: 80px; /* Below Online UI */
right: 20px;
background-color: #505050;
padding: 16px;
border-radius: 12px;
border: 3px solid #2d2d32;
display: none; /* Hidden by default */
flex-direction: column;
gap: 10px;
box-shadow: 0 4px 0 rgba(0,0,0,0.5);
z-index: 200;
min-width: 200px;
}
.admin-title {
color: #ff3232;
font-size: 12px;
text-align: center;
margin-bottom: 5px;
text-shadow: 1px 1px #000;
}
.admin-row {
display: flex;
justify-content: space-between;
align-items: center;
font-size: 10px;
color: #fff;
}
.admin-row input {
width: 70px;
background-color: #2d2d32;
border: 2px solid #000;
color: #32ff64; /* Hacker Green */
font-family: 'Press Start 2P', cursive;
font-size: 10px;
padding: 4px;
outline: none;
}
@keyframes pulse {
0% { opacity: 1; transform: scale(1); }
50% { opacity: 0.7; transform: scale(0.9); }
100% { opacity: 1; transform: scale(1); }
}
#ui-layer {
position: absolute;
top: 0;
left: 0;
width: 100%;
height: 100%;
pointer-events: none;
}
</style>
</head>
<body>
<!-- Online UI Bubble -->
<div id="online-ui">
<div class="status-dot"></div>
<div class="status-text" id="online-text">online: 1</div>
</div>
<!-- Admin Panel (Hidden by default, toggle with 1090) -->
<div id="admin-panel">
<div class="admin-title">ADMIN CONTROL</div>
<div class="admin-row">
<label>SCORE</label>
<input type="number" id="adm-score" value="0">
</div>
<div class="admin-row">
<label>SPEED</label>
<input type="number" id="adm-speed" value="9">
</div>
<div class="admin-row">
<label>ARMOR</label>
<input type="number" id="adm-armor" value="100">
</div>
<div class="admin-row">
<label>HANDLING</label>
<input type="number" id="adm-handling" value="4">
</div>
</div>
<canvas id="gameCanvas"></canvas>
<script>
/**
* TOKYO DRIFT CHASE - ONLINE MULTIPLAYER EDITION
*/
// --- Constants & Configuration ---
const FPS = 60;
const BLOCK_SIZE = 380;
const BUILDING_GAP = 20;
// Colors
const COLORS = {
BG_VOID: '#14141e',
ASPHALT: '#2d2d32',
PAINT_YELLOW: '#d2b414',
PAINT_WHITE: '#dcdcdc',
SIDEWALK: '#828287',
WOOD_DARK: '#50281e',
WOOD_RED: '#8c1e14',
CONCRETE: '#9696a0',
CONCRETE_DARK: '#64646e',
ROOF_TILE_JP: '#3c3c46',
LANTERN_RED: '#dc3232',
NEON_PINK: '#ff3296',
NEON_BLUE: '#3296ff',
NEON_CYAN: '#32ffff',
NEON_GREEN: '#32ff64',
VENDING_BLUE: '#3264c8',
SCHOOL_BEIGE: '#e6dcbe',
CLOCK_FACE: '#ffffff',
WIN_LIT_WARM: '#fff0b4',
WIN_LIT_COOL: '#c8dcff',
WIN_DARK: '#282832',
SAKURA_PINK: '#ffb4c8',
SAKURA_DARK: '#c8788c',
ZOO_BASE: '#328c32',
WATER: '#3296fa',
AC: '#b4b4be',
PLAYER: '#dc2828',
COP_BODY: '#0a0a0f',
COP_DOOR: '#e6e6f0',
HP_GREEN: '#32c832',
HP_YELLOW: '#dcc832',
HP_RED: '#c83232',
TEXT_WHITE: '#ffffff',
GRASS: '#2d7d2d',
GRASS_LIGHT: '#3da03d'
};
const CAR_TYPES = {
'sedan': { w: 48, h: 24, speed: 1.0, colors: ['#3c5a96', '#969696', '#dcdcdc', '#503250', '#8c2828'] },
'coupe': { w: 44, h: 22, speed: 1.3, colors: ['#c83232', '#3264c8', '#e6e632', '#141414'] },
'hatchback': { w: 40, h: 22, speed: 0.9, colors: ['#32965a', '#c87832', '#9696c8'] },
'taxi': { w: 48, h: 24, speed: 1.1, colors: ['#e6af2d'] }, // Japanese Taxi
'truck': { w: 56, h: 26, speed: 0.7, colors: ['#ffffff', '#32465a'] }
};
// --- PLAYER ROSTER ---
const PLAYER_ROSTER = [
{
id: 'standard',
name: 'STREET LEGEND',
type: 'sedan',
color: '#dc2828',
desc: "Balanced. [Z]: Instant Repair (+50HP)",
stats: { speed: 9.0, turn: 4.0, accel: 0.20, hp: 100 },
hasSpoiler: true,
unlockScore: 0,
powerData: { name: "Repair", color: "#32c832", cooldown: 45 * 60 },
pedData: { style: 'street', shirt: '#dc2828', hair: '#000', hairStyle: 'short', ability: 'sprint', abilityColor: '#fff' }
},
{
id: 'drifter',
name: 'DRIFT KING',
type: 'coupe',
color: '#d2b414',
desc: "Loose handling. [Z]: Oil Slick",
stats: { speed: 10.5, turn: 4.5, accel: 0.25, hp: 80 },
hasSpoiler: true,
unlockScore: 100,
powerData: { name: "Oil Slick", color: "#141414", cooldown: 15 * 60 },
pedData: { style: 'hoodie', shirt: '#d2b414', hair: '#555', hairStyle: 'cap', ability: 'stealth', abilityColor: '#555' }
},
{
id: 'tank',
name: 'THE BEAST',
type: 'truck',
color: '#14141e',
desc: "Heavy Armor. [Z]: Juggernaut (Invincible Ram)",
stats: { speed: 7.5, turn: 3.0, accel: 0.15, hp: 200 },
hasSpoiler: false,
unlockScore: 200,
powerData: { name: "Juggernaut", color: "#c83232", cooldown: 40 * 60 },
pedData: { style: 'military', shirt: '#3e3e3e', hair: '#000', hairStyle: 'bald', ability: 'shield', abilityColor: '#c83232' }
},
{
id: 'mecha',
name: 'MECHA-V',
type: 'coupe',
color: '#32ffff', // Neon Cyan
desc: "High Tech. [Z]: EMP Blast (Stun Cops)",
stats: { speed: 11.0, turn: 5.5, accel: 0.30, hp: 60 },
hasSpoiler: true,
unlockScore: 350,
powerData: { name: "EMP Blast", color: "#3296ff", cooldown: 30 * 60 },
pedData: { style: 'cyborg', shirt: '#32ffff', hair: '#fff', hairStyle: 'short', ability: 'shock', abilityColor: '#32ffff' }
},
{
id: 'angel',
name: 'SERAPHIM',
type: 'coupe',
color: '#ffffff',
desc: "Divine. [Z]: Smite (Destroy Nearby Cops)",
stats: { speed: 10.0, turn: 5.0, accel: 0.22, hp: 150 },
hasSpoiler: false,
unlockScore: 500,
powerData: { name: "Smite", color: "#ffd700", cooldown: 60 * 60 },
pedData: { style: 'holy', shirt: '#fff', hair: '#ffd700', hairStyle: 'long', ability: 'heal_aura', abilityColor: '#ffd700' }
},
// --- NEW CARS (First Batch) ---
{
id: 'cybertruck',
name: 'CYBER-X',
type: 'truck',
color: '#c0c0c0',
desc: "Future Metal. [Z]: Pulse Ram (Push everything)",
stats: { speed: 8.5, turn: 3.5, accel: 0.28, hp: 250 },
hasSpoiler: false,
unlockScore: 650,
powerData: { name: "Pulse Ram", color: "#00ffcc", cooldown: 20 * 60 },
pedData: { style: 'tech', shirt: '#c0c0c0', hair: '#888', hairStyle: 'short', ability: 'push', abilityColor: '#00ffcc' }
},
{
id: 'nightshade',
name: 'NIGHT SHADE',
type: 'coupe',
color: '#240046', // Deep purple
desc: "Stealth. [Z]: Phase Shift (Walk through walls)",
stats: { speed: 11.5, turn: 5.0, accel: 0.25, hp: 70 },
hasSpoiler: true,
unlockScore: 800,
powerData: { name: "Phase Shift", color: "#9d4edd", cooldown: 45 * 60 },
pedData: { style: 'ninja', shirt: '#1a0030', hair: '#000', hairStyle: 'short_messy', ability: 'phase', abilityColor: '#9d4edd' }
},
{
id: 'hotrod',
name: 'HELL RAISER',
type: 'sedan',
color: '#ff4d00',
desc: "Classic Muscle. [Z]: Flamethrower",
stats: { speed: 9.5, turn: 3.8, accel: 0.35, hp: 120 },
hasSpoiler: false,
unlockScore: 1000,
powerData: { name: "Flamethrower", color: "#ff4d00", cooldown: 10 * 60 },
pedData: { style: 'biker', shirt: '#222', hair: '#500', hairStyle: 'mohawk', ability: 'fire_trail', abilityColor: '#ff4d00' }
},
{
id: 'interceptor',
name: 'ENFORCER',
type: 'sedan',
color: '#000000', // Cop style
desc: "Undercover. [Z]: Siren Wail (Confuse Cops)",
stats: { speed: 10.8, turn: 4.2, accel: 0.26, hp: 140 },
hasSpoiler: true,
unlockScore: 1200,
powerData: { name: "Siren Wail", color: "#0032ff", cooldown: 30 * 60 },
pedData: { style: 'cop', shirt: '#111', hair: '#333', hairStyle: 'short', ability: 'taser', abilityColor: '#0032ff' }
},
{
id: 'gold',
name: 'MIDAS',
type: 'coupe',
color: '#ffd700',
desc: "Luxury. [Z]: Midas Touch (Turn cars to Score)",
stats: { speed: 10.0, turn: 4.0, accel: 0.22, hp: 100 },
hasSpoiler: false,
unlockScore: 1500,
powerData: { name: "Midas Touch", color: "#ffd700", cooldown: 50 * 60 },
pedData: { style: 'suit', shirt: '#ffd700', hair: '#fff', hairStyle: 'short', ability: 'money_shield', abilityColor: '#ffd700' }
},
{
id: 'f1',
name: 'FORMULA ZERO',
type: 'coupe',
color: '#ff0000',
desc: "Track Speed. [Z]: Warp Speed (Teleport Forward)",
stats: { speed: 13.0, turn: 6.0, accel: 0.40, hp: 40 },
hasSpoiler: true,
unlockScore: 2000,
powerData: { name: "Warp Speed", color: "#00ffff", cooldown: 15 * 60 },
pedData: { style: 'racer', shirt: '#ff0000', hair: '#000', hairStyle: 'cap', ability: 'blink', abilityColor: '#00ffff' }
},
{
id: 'ufo',
name: 'THE VISITOR',
type: 'hatchback', // Round shape override
color: '#39ff14',
desc: "Alien Tech. [Z]: Abduct (Suck Civs for HP)",
stats: { speed: 11.0, turn: 8.0, accel: 0.30, hp: 90 },
hasSpoiler: false,
unlockScore: 2500,
powerData: { name: "Abduct", color: "#39ff14", cooldown: 25 * 60 },
pedData: { style: 'alien', shirt: '#39ff14', hair: '#000', hairStyle: 'bald', ability: 'levitate', abilityColor: '#39ff14' }
},
{
id: 'monster',
name: 'CRUSHER',
type: 'truck',
color: '#4caf50',
desc: "Big Wheels. [Z]: Smash (Jump & Crush)",
stats: { speed: 8.0, turn: 2.5, accel: 0.20, hp: 300 },
hasSpoiler: false,
unlockScore: 3000,
powerData: { name: "Smash", color: "#4caf50", cooldown: 20 * 60 },
pedData: { style: 'redneck', shirt: '#4caf50', hair: '#8d5524', hairStyle: 'long', ability: 'stomp', abilityColor: '#4caf50' }
},
{
id: 'time',
name: 'DELOREAN',
type: 'coupe',
color: '#b0b0b0',
desc: "Time Travel. [Z]: Bullet Time (Slow Motion)",
stats: { speed: 10.0, turn: 4.0, accel: 0.22, hp: 100 },
hasSpoiler: true,
unlockScore: 4000,
powerData: { name: "Bullet Time", color: "#ffffff", cooldown: 60 * 60 },
pedData: { style: 'flash', shirt: '#b80000', hair: '#e6c86e', hairStyle: 'short_messy', ability: 'flash_run', abilityColor: '#ffd700' }
},
{
id: 'demon',
name: 'DOOM BRINGER',
type: 'sedan',
color: '#1a0505',
desc: "Evil. [Z]: Hellfire (Map-wide Damage)",
stats: { speed: 11.0, turn: 4.5, accel: 0.30, hp: 666 },
hasSpoiler: true,
unlockScore: 6666,
powerData: { name: "Hellfire", color: "#ff0000", cooldown: 60 * 60 },
pedData: { style: 'cultist', shirt: '#000', hair: '#f0f', hairStyle: 'long', ability: 'drain', abilityColor: '#f00' }
},
// --- 10 NEW CARS (UNIQUE SKILLS) ---
{
id: 'neon',
name: 'NEON RIDER',
type: 'coupe', // Actually bike-like
color: '#000000',
desc: "Digital Cycle. [Z]: Light Wall (Deadly Trail)",
stats: { speed: 12.0, turn: 6.5, accel: 0.35, hp: 50 },
hasSpoiler: false,
unlockScore: 7000,
powerData: { name: "Light Wall", color: "#00ffff", cooldown: 40 * 60 },
pedData: { style: 'cyborg', shirt: '#000', hair: '#0ff', hairStyle: 'short', ability: 'sprint', abilityColor: '#0ff' }
},
{
id: 'icecream',
name: 'MR. FREEZE',
type: 'truck',
color: '#ffffff',
desc: "Sweet. [Z]: Sticky Goo (Slows Cops to Crawl)",
stats: { speed: 8.5, turn: 3.5, accel: 0.20, hp: 150 },
hasSpoiler: false,
unlockScore: 7500,
powerData: { name: "Sticky Goo", color: "#ff69b4", cooldown: 30 * 60 },
pedData: { style: 'clown', shirt: '#fff', hair: '#f0f', hairStyle: 'afro', ability: 'shield', abilityColor: '#f0f' }
},
{
id: 'dozer',
name: 'CONSTRUCTO',
type: 'truck',
color: '#ffcc00',
desc: "Heavy Duty. [Z]: Demolition (Break Buildings)",
stats: { speed: 7.0, turn: 2.5, accel: 0.15, hp: 350 },
hasSpoiler: false,
unlockScore: 8000,
powerData: { name: "Demolition", color: "#ffcc00", cooldown: 45 * 60 },
pedData: { style: 'worker', shirt: '#ffcc00', hair: '#555', hairStyle: 'cap', ability: 'stomp', abilityColor: '#ffcc00' }
},
{
id: 'rocket',
name: 'STARSHIP',
type: 'coupe',
color: '#cccccc',
desc: "Space Age. [Z]: Takeoff (Fly above hazards)",
stats: { speed: 12.5, turn: 4.0, accel: 0.32, hp: 60 },
hasSpoiler: true,
unlockScore: 8500,
powerData: { name: "Takeoff", color: "#ff4400", cooldown: 25 * 60 },
pedData: { style: 'astro', shirt: '#ccc', hair: '#000', hairStyle: 'bald', ability: 'levitate', abilityColor: '#ff4400' }
},
{
id: 'ambulance',
name: 'LIFESAVER',
type: 'truck',
color: '#ffffff',
desc: "Emergency. [Z]: Panic Siren (Fear Cops)",
stats: { speed: 9.5, turn: 3.8, accel: 0.25, hp: 180 },
hasSpoiler: false,
unlockScore: 9000,
powerData: { name: "Panic Siren", color: "#ff0000", cooldown: 35 * 60 },
pedData: { style: 'medic', shirt: '#fff', hair: '#555', hairStyle: 'short', ability: 'heal_aura', abilityColor: '#f00' }
},
{
id: 'wasteland',
name: 'WASTELANDER',
type: 'sedan',
color: '#8b4513',
desc: "Rusty. [Z]: Landmines (Explosive Trap)",
stats: { speed: 9.0, turn: 4.0, accel: 0.28, hp: 130 },
hasSpoiler: false,
unlockScore: 9500,
powerData: { name: "Landmines", color: "#ff8800", cooldown: 20 * 60 },
pedData: { style: 'raider', shirt: '#533', hair: '#000', hairStyle: 'mohawk', ability: 'fire_trail', abilityColor: '#f80' }
},
{
id: 'hover',
name: 'AG-RACER',
type: 'coupe',
color: '#8800ff',
desc: "Anti-Grav. [Z]: Bunny Hop (Jump Obstacles)",
stats: { speed: 11.5, turn: 7.0, accel: 0.30, hp: 70 },
hasSpoiler: false,
unlockScore: 10000,
powerData: { name: "Bunny Hop", color: "#aa00ff", cooldown: 5 * 60 },
pedData: { style: 'pilot', shirt: '#80f', hair: '#fff', hairStyle: 'short', ability: 'blink', abilityColor: '#a0f' }
},
{
id: 'pirate',
name: 'BLACK PEARL',
type: 'sedan',
color: '#3e2723',
desc: "Cursed. [Z]: Broadside (Cannon Fire L/R)",
stats: { speed: 9.0, turn: 3.0, accel: 0.20, hp: 200 },
hasSpoiler: false,
unlockScore: 11000,
powerData: { name: "Broadside", color: "#000000", cooldown: 15 * 60 },
pedData: { style: 'pirate', shirt: '#000', hair: '#000', hairStyle: 'long', ability: 'sprint', abilityColor: '#000' }
},
{
id: 'nano',
name: 'NANO-TECH',
type: 'hatchback',
color: '#00ff00',
desc: "Micro. [Z]: Shrink Ray (Weaken Cops)",
stats: { speed: 10.0, turn: 5.0, accel: 0.25, hp: 80 },
hasSpoiler: false,
unlockScore: 12000,
powerData: { name: "Shrink Ray", color: "#0f0", cooldown: 40 * 60 },
pedData: { style: 'scientist', shirt: '#fff', hair: '#aaa', hairStyle: 'bald', ability: 'shock', abilityColor: '#0f0' }
},
{
id: 'chronos',
name: 'CHRONOS',
type: 'sedan',
color: '#cd7f32', // Bronze
desc: "Steampunk. [Z]: Rewind (Teleport 3s Back)",
stats: { speed: 9.5, turn: 3.5, accel: 0.22, hp: 120 },
hasSpoiler: false,
unlockScore: 13000,
powerData: { name: "Rewind", color: "#cd7f32", cooldown: 30 * 60 },
pedData: { style: 'steampunk', shirt: '#a65', hair: '#543', hairStyle: 'short_messy', ability: 'flash_run', abilityColor: '#da0' }
}
];
// Physics
const ACCELERATION = 0.20;
const FRICTION = 0.96;
const TURN_SPEED = 4.0;
const DRIFT_SLIDE = 0.99;
const MAX_SPEED_PLAYER = 9.0;
const MAX_SPEED_COP = 10.2;
const MAX_SPEED_CIVILIAN_BASE = 6.0;
// --- Utility Classes ---
class Vector2 {
constructor(x, y) {
this.x = x;
this.y = y;
}
add(v) { return new Vector2(this.x + v.x, this.y + v.y); }
sub(v) { return new Vector2(this.x - v.x, this.y - v.y); }
mult(n) { return new Vector2(this.x * n, this.y * n); }
mag() { return Math.sqrt(this.x * this.x + this.y * this.y); }
normalize() {
let m = this.mag();
if (m === 0) return new Vector2(0, 0);
return new Vector2(this.x / m, this.y / m);
}
dot(v) { return this.x * v.x + this.y * v.y; }
rotate(angleDegrees) {
let rad = angleDegrees * Math.PI / 180;
let cos = Math.cos(rad);
let sin = Math.sin(rad);
return new Vector2(this.x * cos - this.y * sin, this.x * sin + this.y * cos);
}
distanceTo(v) {
return Math.sqrt((this.x - v.x)**2 + (this.y - v.y)**2);
}
lerp(v, t) {
return new Vector2(this.x + (v.x - this.x) * t, this.y + (v.y - this.y) * t,);
}
}
class Rect {
constructor(x, y, w, h) {
this.x = x;
this.y = y;
this.w = w;
this.h = h;
}
get left() { return this.x; }
get right() { return this.x + this.w; }
get top() { return this.y; }
get bottom() { return this.y + this.h; }
get centerx() { return this.x + this.w / 2; }
get centery() { return this.y + this.h / 2; }
set centerx(v) { this.x = v - this.w / 2; }
set centery(v) { this.y = v - this.h / 2; }
collidePoint(px, py) {
return px >= this.x && px <= this.x + this.w && py >= this.y && py <= this.y + this.h;
}
collideRect(other) {
return this.x < other.x + other.w && this.x + this.w > other.x &&
this.y < other.y + other.h && this.y + this.h > other.y;
}
inflate(dw, dh) {
return new Rect(this.x - dw/2, this.y - dh/2, this.w + dw, this.h + dh);
}
}
// --- Seeded Random for Map Consistency ---
class SeededRNG {
constructor(seed) {
this.seed = seed;
}
// Simple LCG
next() {
this.seed = (this.seed * 9301 + 49297) % 233280;
return this.seed / 233280;
}
randInt(min, max) {
return Math.floor(this.next() * (max - min + 1)) + min;
}
randFloat(min, max) {
return this.next() * (max - min) + min;
}
choice(arr) {
return arr[Math.floor(this.next() * arr.length)];
}
}
// --- Helper Functions (Standard) ---
function randInt(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; }
function randFloat(min, max) { return Math.random() * (max - min) + min; }
function randChoice(arr) { return arr[Math.floor(Math.random() * arr.length)]; }
function degToRad(deg) { return deg * Math.PI / 180; }
// --- Drawing Helpers ---
function drawRect(ctx, color, x, y, w, h, radius = 0) {
ctx.fillStyle = color;
if (radius > 0) {
ctx.beginPath();
if (ctx.roundRect) {
ctx.roundRect(x, y, w, h, radius);
} else {
ctx.rect(x, y, w, h);
}
ctx.fill();
} else {
ctx.fillRect(x, y, w, h);
}
}
function drawCircle(ctx, color, x, y, r) {
ctx.fillStyle = color;
ctx.beginPath();
ctx.arc(x, y, r, 0, Math.PI * 2);
ctx.fill();
}
// --- Asset Generation (Caching complex drawings) ---
function createRoadTexture(size) {
const cvs = document.createElement('canvas');
cvs.width = size;
cvs.height = size;
const ctx = cvs.getContext('2d');
ctx.fillStyle = COLORS.ASPHALT;
ctx.fillRect(0, 0, size, size);
// Noise
for (let i = 0; i < 800; i++) {
const x = randInt(0, size);
const y = randInt(0, size);
const c = randInt(35, 55);
ctx.fillStyle = `rgb(${c},${c},${c+5})`;
ctx.fillRect(x, y, 2, 2);
}
// Cracks
ctx.strokeStyle = '#222';
ctx.lineWidth = 1;
for(let i=0; i<3; i++) {
let x = randInt(0, size);
let y = randInt(0, size);
ctx.beginPath();
ctx.moveTo(x, y);
for(let j=0; j<5; j++) {
x += randInt(-10, 10);
y += randInt(-10, 10);
ctx.lineTo(x, y);
}
ctx.stroke();
}
// Manhole
const mx = size/2 + randInt(-50, 50);
const my = size/2 + randInt(-50, 50);
ctx.fillStyle = '#46464b';
ctx.beginPath(); ctx.arc(mx, my, 14, 0, Math.PI*2); ctx.fill();
ctx.strokeStyle = '#28282d';
ctx.lineWidth = 2;
ctx.stroke();
ctx.strokeStyle = '#28282d';
for(let i=0; i<360; i+=45) {
let rad = degToRad(i);
ctx.beginPath();
ctx.moveTo(mx, my);
ctx.lineTo(mx + Math.cos(rad)*10, my + Math.sin(rad)*10);
ctx.stroke();
}
return cvs;
}
function createGrassTexture(size) {
const cvs = document.createElement('canvas');
cvs.width = size;
cvs.height = size;
const ctx = cvs.getContext('2d');
ctx.fillStyle = COLORS.GRASS;
ctx.fillRect(0, 0, size, size);
// Noise
for (let i = 0; i < 1500; i++) {
const x = randInt(0, size);
const y = randInt(0, size);
ctx.fillStyle = COLORS.GRASS_LIGHT;
ctx.fillRect(x, y, 3, 3);
}
return cvs;
}
const roadPatternCanvas = createRoadTexture(BLOCK_SIZE);
const grassPatternCanvas = createGrassTexture(BLOCK_SIZE);
// --- Game Objects ---
class Camera {
constructor() {
this.offset = new Vector2(0, 0);
this.viewRect = new Rect(0, 0, 0, 0); // Updates in update()
}
update(target, gameW, gameH) {
// Target is typically the player car or ped
// We want target to be in center.
// Camera offset shifts the WORLD, so if player moves right (+x), offset moves left (-x)
const targetX = -target.pos.x + gameW / 2;
const targetY = -target.pos.y + gameH / 2;
this.offset.x += (targetX - this.offset.x) * 0.1;
this.offset.y += (targetY - this.offset.y) * 0.1;
// View rect determines what chunks to load. Inflate slightly for smooth loading.
this.viewRect = new Rect(-this.offset.x - 600, -this.offset.y - 600, gameW + 1200, gameH + 1200);
}
apply(rect) {
// Transforms a world rect to screen rect
if (!rect) return new Rect(0,0,0,0); // Safety check
return new Rect(rect.x + this.offset.x, rect.y + this.offset.y, rect.w, rect.h);
}
}
class CarHealth {
constructor(maxHp = 100) {
this.maxHp = maxHp;
this.parts = {
'front_torso': maxHp,
'back_torso': maxHp,
'fl_wheel': maxHp,
'fr_wheel': maxHp,
'rl_wheel': maxHp,
'rr_wheel': maxHp
};
}
getColor(hp) {
if (hp > this.maxHp * 0.5) return COLORS.HP_GREEN;
if (hp > 0) return COLORS.HP_YELLOW;
return COLORS.HP_RED;
}
checkFullyDestroyed() {
for (let key in this.parts) {
if (this.parts[key] > 0) return false;
}
return true;
}
takeDamage(amount) {
let aliveKeys = Object.keys(this.parts).filter(k => this.parts[k] > 0);
if (aliveKeys.length === 0) return;
let target = randChoice(aliveKeys);
this.parts[target] -= amount;
// Splash damage
if (Math.random() > 0.5) {
if (this.parts['front_torso'] > 0) this.parts['front_torso'] -= amount / 2;
} else {
if (this.parts['back_torso'] > 0) this.parts['back_torso'] -= amount / 2;
}
}
drawUI(ctx, x, y) {
const s = 2.5; // Scale
const wBody = 16 * s;
const hFront = 14 * s;
const hBack = 14 * s;
const wWheel = 4 * s;
const hWheel = 8 * s;
const cx = x + wBody / 2;
// Helpers
const drawPart = (color, px, py, pw, ph, rad=0) => {
ctx.fillStyle = color;
ctx.strokeStyle = '#000';
ctx.lineWidth = 2;
ctx.beginPath();
if (rad > 0) {
if (ctx.roundRect) ctx.roundRect(px, py, pw, ph, rad);
else ctx.rect(px, py, pw, ph);
} else {
ctx.rect(px, py, pw, ph);
}
ctx.fill();
ctx.stroke();
};
// Wheels
drawPart(this.getColor(this.parts['fl_wheel']), cx - wBody/2 - wWheel + 2, y + 4*s, wWheel, hWheel);
drawPart(this.getColor(this.parts['fr_wheel']), cx + wBody/2 - 2, y + 4*s, wWheel, hWheel);
drawPart(this.getColor(this.parts['rl_wheel']), cx - wBody/2 - wWheel + 2, y + hFront + 2*s, wWheel, hWheel);
drawPart(this.getColor(this.parts['rr_wheel']), cx + wBody/2 - 2, y + hFront + 2*s, wWheel, hWheel);
// Body
// Front (Hood)
ctx.fillStyle = this.getColor(this.parts['front_torso']);
ctx.strokeStyle = '#000';
ctx.beginPath();
if (ctx.roundRect) ctx.roundRect(cx - wBody/2, y, wBody, hFront, [4*s, 4*s, 0, 0]);
else ctx.rect(cx - wBody/2, y, wBody, hFront);
ctx.fill(); ctx.stroke();
// Back (Cabin)
ctx.fillStyle = this.getColor(this.parts['back_torso']);
ctx.beginPath();
if (ctx.roundRect) ctx.roundRect(cx - wBody/2, y + hFront, wBody, hBack, [0, 0, 2*s, 2*s]);
else ctx.rect(cx - wBody/2, y + hFront, wBody, hBack);
ctx.fill(); ctx.stroke();
// Windshield line
ctx.beginPath();
ctx.moveTo(cx - wBody/2, y + hFront);
ctx.lineTo(cx + wBody/2, y + hFront);
ctx.stroke();
}
}
class Car {
constructor(x, y, typeOrColor, isCop=false, isCivilian=false) {
this.pos = new Vector2(x, y);
this.vel = new Vector2(0, 0);
this.angle = 0; // Degrees
this.rotDirection = 0;
this.accInput = 0;
this.isCop = isCop;
this.isCivilian = isCivilian;
this.id = null; // Specific ID for special cars
// Defaults
this.width = 48;
this.height = 24;
this.speedTrait = 1.0;
this.color = '#fff';
this.type = 'sedan';
this.hasSpoiler = false;
// Custom Player Stats (populated later for player)
this.customMaxSpeed = null;
this.customTurnSpeed = null;
this.customAccel = null;
// Tracking for Ghostly Rider achievement
this.lastRotDirection = 0;
this.turnComplete = false;
this.isCollidingWithBuilding = false;
this.isCollidingWithCop = false;
// Status Effects
this.stunTimer = 0; // For EMP
this.spinTimer = 0; // For Oil Slick
this.scale = 1.0; // For shrinkage
this.dead = false;
this.isPhasing = false; // For Night Shade
if (isCivilian) {
this.type = typeOrColor || 'sedan'; // Pass type string for civilians
const stats = CAR_TYPES[this.type];
this.width = stats.w;
this.height = stats.h;
this.color = randChoice(stats.colors);
// "Weirdly Perfection" - random variation on top of base speed
this.speedTrait = stats.speed * randFloat(0.85, 1.15);
} else if (isCop) {
this.color = COLORS.COP_BODY;
this.speedTrait = 1.2;
} else {
// Player
this.color = typeOrColor; // Hex for player
// Default HP check, overridden in initGame
this.health = new CarHealth(100);
}
// Generate sprite
this.sprite = this.createCarSprite();
if (isCop || isCivilian) {
this.health = null;
}
this.stuckTimer = 0;
this.reversing = false; // For AI
// Civilian specific
this.targetHeading = null;
this.blockedTimer = 0;
this.cooldownTimer = 0;
this.laneSwitchDir = 0; // -1 left, 1 right, 0 none
this.patience = randInt(60, 150);
this.brakingVisual = false;
// New Car Specifics
this.fearActive = false; // For Ambulance fear effect
}
createCarSprite() {
const cvs = document.createElement('canvas');
// Increase canvas size for Angel Wings or other large features
let padding = 0;
if (this.id === 'angel' || this.id === 'demon' || this.id === 'ufo' || this.id === 'monster' || this.id === 'pirate' || this.id === 'dozer') padding = 20;
cvs.width = this.width + padding*2;
cvs.height = this.height + padding*2;
const ctx = cvs.getContext('2d');
// Disable smoothing for sharp pixels on sprite generation
ctx.imageSmoothingEnabled = false;
// Center drawing if padded
ctx.translate(padding, padding);
const w = this.width, h = this.height;
// Shadow/Underbody
ctx.fillStyle = 'rgba(0,0,0,0.4)';
ctx.beginPath();
if (this.id === 'ufo') {
ctx.ellipse(w/2, h/2 + 4, w/2, h/2, 0, 0, Math.PI*2);
} else {
if (ctx.roundRect) ctx.roundRect(4, 6, w-2, h-6, 4);
else ctx.rect(4, 6, w-2, h-6);
}
ctx.fill();
// Special Rendering for UFO
if (this.id === 'ufo') {
ctx.fillStyle = '#222';
ctx.beginPath(); ctx.ellipse(w/2, h/2, w/2, h/2, 0, 0, Math.PI*2); ctx.fill();
ctx.fillStyle = this.color;
ctx.beginPath(); ctx.ellipse(w/2, h/2, w/2-2, h/2-2, 0, 0, Math.PI*2); ctx.fill();
// Dome
ctx.fillStyle = '#80deea';
ctx.beginPath(); ctx.arc(w/2, h/2, w/4, 0, Math.PI*2); ctx.fill();
// Lights
for(let i=0; i<8; i++) {
let ang = (i/8) * Math.PI*2;
let lx = w/2 + Math.cos(ang) * (w/2 - 4);
let ly = h/2 + Math.sin(ang) * (h/2 - 4);
ctx.fillStyle = i%2===0 ? '#ff0000' : '#ffff00';
ctx.fillRect(lx-1, ly-1, 3, 3);
}
return cvs;
}
// Special Rendering for F1 & Neon Rider (Bike like)
if (this.id === 'f1' || this.id === 'neon') {
// Wheels exposed
ctx.fillStyle = '#111';
ctx.fillRect(0, 0, 10, 8); // FL
ctx.fillRect(w-10, 0, 10, 8); // FR
ctx.fillRect(0, h-8, 10, 8); // RL
ctx.fillRect(w-10, h-8, 10, 8); // RR
// Body
ctx.fillStyle = this.color;
ctx.beginPath();
ctx.moveTo(w/2, -5);
ctx.lineTo(w/2 + 6, h/2);
ctx.lineTo(w/2 + 10, h);
ctx.lineTo(w/2 - 10, h);
ctx.lineTo(w/2 - 6, h/2);
ctx.closePath();
ctx.fill();
// Details
if (this.id === 'neon') {
ctx.strokeStyle = '#0ff'; ctx.lineWidth = 2; ctx.stroke();
ctx.fillStyle = '#0ff'; ctx.fillRect(w/2-2, 0, 4, h);
} else {
// Spoiler F1
ctx.fillStyle = '#000';
ctx.fillRect(w/2 - 12, h-4, 24, 4);
}
return cvs;
}
// Special Rendering for Hover
if (this.id === 'hover') {
ctx.fillStyle = '#444';
ctx.beginPath(); ctx.ellipse(w/2, h/2, w/2, h/3, 0, 0, Math.PI*2); ctx.fill();
ctx.fillStyle = this.color;
ctx.beginPath(); ctx.moveTo(w, h/2); ctx.lineTo(w/2, 0); ctx.lineTo(0, h/2); ctx.lineTo(w/2, h); ctx.fill();
ctx.fillStyle = '#00ffff'; // Engine glow
ctx.beginPath(); ctx.arc(w/2, h-5, 5, 0, Math.PI*2); ctx.fill();
return cvs;
}
// Standard Car Rendering
// Wheels with more detail
const tireColor = '#191919';
const rimColor = this.isCop ? '#505050' : '#dcdcdc';
let axleF = w - 12, axleR = 10;
if (this.id === 'monster' || this.id === 'dozer') { axleF = w-14; axleR = 14; }
const tires = [[axleF, 1], [axleF, h-5], [axleR, 1], [axleR, h-5]];
tires.forEach(([tx, ty]) => {
if (this.id !== 'icecream' && this.id !== 'ambulance') { // Boxy cars hide wheels partially
ctx.fillStyle = tireColor;
let tw = 10, th = 4;
if (this.id === 'monster' || this.id === 'dozer') { tw = 14; th = 8; ty -= 2; }
ctx.fillRect(tx, ty, tw, th);
// Rim detail
ctx.fillStyle = rimColor;
ctx.fillRect(tx+3, ty+1, 4, 2);
}
});
const bodyY = 3, bodyH = h - 6;
// Body Base
if (this.isCop) {
ctx.fillStyle = '#0a0a0f'; // Dark Body
ctx.beginPath();
if (ctx.roundRect) ctx.roundRect(2, bodyY, w-4, bodyH, 1);
else ctx.rect(2, bodyY, w-4, bodyH);
ctx.fill();
ctx.fillStyle = COLORS.COP_DOOR; // White Door
ctx.fillRect(14, bodyY, 18, bodyH);
// "POLICE" text hint
ctx.fillStyle = '#000';
ctx.fillRect(16, bodyY+2, 14, 2);
ctx.fillStyle = '#9696a0'; // Pillar
ctx.fillRect(23, bodyY, 1, bodyH);
} else {
ctx.fillStyle = this.color;
ctx.beginPath();
if (ctx.roundRect) ctx.roundRect(2, bodyY, w-4, bodyH, 4);
else ctx.rect(2, bodyY, w-4, bodyH);
ctx.fill();
// Texture details based on type
if (this.type === 'taxi') {
ctx.fillStyle = '#000'; // Stripe
ctx.fillRect(0, bodyY+bodyH/2-1, w, 2);
}
if (this.id === 'hotrod' || this.id === 'wasteland') {
ctx.fillStyle = this.id==='wasteland' ? '#5a3a22' : '#ffaa00';
ctx.beginPath();
ctx.moveTo(w, bodyY + bodyH/2);
ctx.lineTo(w-20, bodyY);
ctx.lineTo(w-10, bodyY + bodyH/2);
ctx.lineTo(w-20, bodyY + bodyH);
ctx.fill();
}
if (this.id === 'cybertruck') {
ctx.fillStyle = '#e0e0e0'; // Top shine
ctx.beginPath();
ctx.moveTo(10, bodyY);
ctx.lineTo(w-10, bodyY);
ctx.lineTo(w/2, bodyY + bodyH/2);
ctx.fill();
}
// Hood Vents
ctx.fillStyle = 'rgba(0,0,0,0.3)';
ctx.fillRect(w - 12, bodyY + 4, 4, 2);
ctx.fillRect(w - 12, bodyY + bodyH - 6, 4, 2);
// Side Skirt Shadow
ctx.fillStyle = 'rgba(0,0,0,0.2)';
ctx.fillRect(10, bodyY + bodyH - 2, 28, 1);
}
// Bumpers (Detailed)
ctx.fillStyle = '#222';
ctx.fillRect(w-3, bodyY, 2, bodyH); // Front Bumper
ctx.fillRect(w-4, bodyY+1, 1, bodyH-2); // Front detail
ctx.fillRect(1, bodyY, 2, bodyH); // Rear Bumper
// Cabin/Glass
let cabinRect = this.isCop ? {x:10, y:bodyY+2, w:24, h:bodyH-4} : {x:12, y:bodyY+3, w:20, h:bodyH-6};
// Type adjustments
if (this.type === 'truck') cabinRect = {x: 8, y: bodyY+2, w: 16, h: bodyH-4};
if (this.type === 'coupe') cabinRect = {x: 10, y: bodyY+3, w: 18, h: bodyH-6};
if (this.id === 'cybertruck') cabinRect = {x: 14, y: bodyY+4, w: 20, h: bodyH-8};
if (this.id === 'icecream' || this.id === 'ambulance') cabinRect = {x: 14, y: bodyY+2, w: 20, h: bodyH-4};
ctx.fillStyle = '#2d3c46'; // Dark Glass
ctx.beginPath();
if (ctx.roundRect) ctx.roundRect(cabinRect.x, cabinRect.y, cabinRect.w, cabinRect.h, 2);
else ctx.rect(cabinRect.x, cabinRect.y, cabinRect.w, cabinRect.h);
ctx.fill();
// Glass Reflection
ctx.fillStyle = '#506e82';
ctx.beginPath();
ctx.moveTo(cabinRect.x + 4, cabinRect.y);
ctx.lineTo(cabinRect.x + 8, cabinRect.y);
ctx.lineTo(cabinRect.x + 4, cabinRect.y + cabinRect.h);
ctx.lineTo(cabinRect.x, cabinRect.y + cabinRect.h);
ctx.fill();
// Roof
let roofColor = this.isCop ? '#0a0a0f' : this.color;
let roofRect = {x:cabinRect.x+2, y:cabinRect.y+1, w:cabinRect.w-4, h:cabinRect.h-2};
if (this.type === 'truck' && this.id !== 'icecream' && this.id !== 'ambulance' && this.id !== 'dozer') {
// Truck Bed
ctx.fillStyle = '#333';
ctx.fillRect(24, bodyY+2, w-30, bodyH-4);
ctx.fillStyle = '#222'; // Bed lines
for(let i=26; i<w-6; i+=4) ctx.fillRect(i, bodyY+2, 1, bodyH-4);
}
ctx.fillStyle = roofColor;
ctx.fillRect(roofRect.x, roofRect.y, roofRect.w, roofRect.h);
// Taxi sign
if (this.type === 'taxi') {
ctx.fillStyle = '#fff';
ctx.fillRect(roofRect.x + roofRect.w/2 - 2, roofRect.y + 1, 4, roofRect.h - 2);
}
// Sunroof (Player only or Coupe)
if ((!this.isCop && !this.isCivilian || this.type === 'coupe') && this.id !== 'cybertruck' && this.id !== 'icecream' && this.id !== 'ambulance') {
ctx.fillStyle = '#111';
ctx.fillRect(roofRect.x + 4, roofRect.y + 2, roofRect.w - 8, roofRect.h - 4);
ctx.fillStyle = '#222'; // Sunroof shine
ctx.fillRect(roofRect.x + 4, roofRect.y + 2, 2, roofRect.h - 4);
}
// Special Roofs
if (this.id === 'icecream') {
ctx.fillStyle = '#ff99cc'; // Pink cone top
ctx.beginPath(); ctx.moveTo(roofRect.x, roofRect.y); ctx.lineTo(roofRect.x+10, roofRect.y-5); ctx.lineTo(roofRect.x+20, roofRect.y); ctx.fill();
}
if (this.id === 'ambulance') {
ctx.fillStyle = '#ff0000';
ctx.fillRect(roofRect.x + 5, roofRect.y + 2, 10, 2);
ctx.fillRect(roofRect.x + 9, roofRect.y - 2, 2, 10);
// Lights
ctx.fillStyle = '#f00'; ctx.fillRect(roofRect.x+roofRect.w-2, roofRect.y, 2, 2);
ctx.fillStyle = '#00f'; ctx.fillRect(roofRect.x+roofRect.w-2, roofRect.y+roofRect.h-2, 2, 2);
}
if (this.id === 'dozer') {
ctx.fillStyle = '#333'; // Blade connection
ctx.fillRect(w-5, bodyY+2, 5, bodyH-4);
ctx.fillStyle = '#ffcc00'; // Blade
ctx.beginPath(); ctx.moveTo(w, bodyY-2); ctx.lineTo(w+5, bodyY); ctx.lineTo(w+5, bodyY+bodyH); ctx.lineTo(w, bodyY+bodyH+2); ctx.fill();
}
if (this.id === 'rocket') {
ctx.fillStyle = '#ff4400'; // Thruster
ctx.beginPath(); ctx.arc(0, h/2, 6, 0, Math.PI*2); ctx.fill();
}
if (this.id === 'pirate') {
ctx.fillStyle = '#eee'; // Sail hint
ctx.fillRect(15, bodyY+5, 10, bodyH-10);
ctx.fillStyle = '#533'; // Mast
ctx.beginPath(); ctx.arc(20, h/2, 3, 0, Math.PI*2); ctx.fill();
// Cannons
ctx.fillStyle = '#000';
ctx.fillRect(15, 0, 4, 3);
ctx.fillRect(25, 0, 4, 3);
ctx.fillRect(15, h-3, 4, 3);
ctx.fillRect(25, h-3, 4, 3);
}
if (this.id === 'chronos') {
ctx.fillStyle = '#da0'; // Brass gears hint
ctx.beginPath(); ctx.arc(w-10, h/2, 5, 0, Math.PI*2); ctx.fill();
}
if (this.id === 'nano') {
ctx.fillStyle = '#0f0'; // Dish
ctx.beginPath(); ctx.arc(15, h/2, 6, 0, Math.PI*2); ctx.fill();
ctx.fillStyle = '#000'; ctx.beginPath(); ctx.arc(15, h/2, 3, 0, Math.PI*2); ctx.fill();
}
// Lights
// Headlights (Detailed)
ctx.fillStyle = '#e6e6e6'; // Casing
ctx.fillRect(w-5, bodyY+1, 4, 4);
ctx.fillRect(w-5, bodyY+bodyH-5, 4, 4);
ctx.fillStyle = '#fff'; // Bulb
ctx.fillRect(w-3, bodyY+2, 2, 2);
ctx.fillRect(w-3, bodyY+bodyH-4, 2, 2);
// Taillights (Detailed)
ctx.fillStyle = '#800000'; // Dark Red Housing
ctx.fillRect(1, bodyY+1, 3, 5);
ctx.fillRect(1, bodyY+bodyH-6, 3, 5);
// Brake Lights (Will be drawn dynamically if braking, else dim)
// Draw static part
ctx.fillStyle = '#500000'; // Off state
ctx.fillRect(1, bodyY+2, 2, 3);
ctx.fillRect(1, bodyY+bodyH-5, 2, 3);
// Accessories
if (this.isCop || this.id === 'interceptor') {
// Lightbar
let barX = roofRect.x + roofRect.w/2 - 2;
ctx.fillStyle = '#141414';
ctx.fillRect(barX, roofRect.y-1, 4, roofRect.h+2);
ctx.fillStyle = '#dc0000'; // Red
ctx.fillRect(barX, roofRect.y-2, 4, 4);
ctx.fillStyle = '#fff'; // Center white
ctx.fillRect(barX+1, roofRect.y, 2, roofRect.h);
ctx.fillStyle = '#0032ff'; // Blue
ctx.fillRect(barX, roofRect.y + roofRect.h - 2, 4, 4);
// Push bar
ctx.fillStyle = '#333';
ctx.fillRect(w-1, bodyY+4, 1, bodyH-8);
ctx.fillStyle = '#111';
ctx.fillRect(w-2, bodyY+4, 1, 2);
ctx.fillRect(w-2, bodyY+bodyH-6, 1, 2);
} else if (!this.isCivilian) {
// Spoiler logic
if (this.hasSpoiler) {
// Spoiler (Player only)
ctx.fillStyle = '#141414';
ctx.fillRect(5, bodyY+1, 2, 3);
ctx.fillRect(5, bodyY+bodyH-4, 2, 3);
ctx.fillStyle = '#1e1e1e'; // Wing
ctx.fillRect(3, bodyY, 3, bodyH);
ctx.fillStyle = '#333'; // Carbon highlight
ctx.fillRect(3, bodyY+2, 1, bodyH-4);
}
// ANGEL WINGS logic
if (this.id === 'angel') {
ctx.fillStyle = '#fff';
ctx.strokeStyle = '#e0e0e0';
// Left Wing
ctx.beginPath(); ctx.moveTo(10, bodyY); ctx.lineTo(0, bodyY - 8); ctx.lineTo(12, bodyY - 12); ctx.lineTo(20, bodyY); ctx.fill();
// Right Wing
ctx.beginPath(); ctx.moveTo(10, bodyY + bodyH); ctx.lineTo(0, bodyY + bodyH + 8); ctx.lineTo(12, bodyY + bodyH + 12); ctx.lineTo(20, bodyY + bodyH); ctx.fill();
// Halo hint
ctx.strokeStyle = '#ffd700'; ctx.beginPath(); ctx.arc(w - 10, bodyY + bodyH/2, 6, 0, Math.PI * 2); ctx.stroke();
}
// DEMON HORNS logic
if (this.id === 'demon') {
ctx.fillStyle = '#500';
ctx.beginPath(); ctx.moveTo(w-5, bodyY); ctx.lineTo(w+5, bodyY-10); ctx.lineTo(w-15, bodyY+5); ctx.fill();
ctx.beginPath(); ctx.moveTo(w-5, bodyY+bodyH); ctx.lineTo(w+5, bodyY+bodyH+10); ctx.lineTo(w-15, bodyY+bodyH-5); ctx.fill();
}
}
return cvs;
}
getRect() {
let w = this.width * this.scale;
let h = this.height * this.scale;
return new Rect(this.pos.x - w/2, this.pos.y - h/2, w, h);
}
getHitbox() {
// Hitbox is slightly smaller than sprite
let w = (this.width-10) * this.scale;
let h = (this.height-10) * this.scale;
return new Rect(this.pos.x - w/2, this.pos.y - h/2, w, h);
}
// New Smart Raycast System
checkSensors(allCars, player, buildings) {
let results = {
front: false,
left: false,
right: false,
frontDist: 999,
rightClear: true,
leftClear: true
};
const rayDist = 200;
const sideRayDist = 60;
const rad = degToRad(this.angle);
const forward = new Vector2(Math.cos(rad), -Math.sin(rad));
const right = new Vector2(Math.cos(rad + Math.PI/2), -Math.sin(rad + Math.PI/2));
const left = new Vector2(Math.cos(rad - Math.PI/2), -Math.sin(rad - Math.PI/2));
// Helper for point-box collision (simplified)
const checkRay = (start, dir, length, widthCheck=30) => {
let hit = false;
let minDist = length;
let end = start.add(dir.mult(length));
// Check cars
// Handle null player for menu
let objects = [...allCars];
if (player) objects.push(player);
for (let obj of objects) {
if (obj === this) continue;
// Simple distance check first
let d = this.pos.distanceTo(obj.pos);
if (d > length + 50) continue;
// Project obj pos onto ray
let toObj = obj.pos.sub(start);
let dot = toObj.dot(dir);
let latDist = Math.abs(toObj.dot(new Vector2(-dir.y, dir.x))); // Perpendicular distance
if (dot > 0 && dot < length && latDist < widthCheck) {
hit = true;
if (dot < minDist) minDist = dot;
}
}
return { hit, dist: minDist };
};
// Front Ray (Traffic)
let fRay = checkRay(this.pos, forward, rayDist, 25);
if (fRay.hit) {
results.front = true;
results.frontDist = fRay.dist;
}
// Side Rays (Blind spots for lane change)
let rRay = checkRay(this.pos, right, sideRayDist, 40);
if (rRay.hit) results.rightClear = false;
let lRay = checkRay(this.pos, left, sideRayDist, 40);
if (lRay.hit) results.leftClear = false;
return results;
}
physics(buildings, drift, fireWheelActive) {
// USE CUSTOM STATS IF AVAILABLE (PLAYER), ELSE DEFAULTS
let turnSpeed = this.customTurnSpeed || TURN_SPEED;
let maxSpeed = this.customMaxSpeed || (this.isCop ? MAX_SPEED_COP : (this.isCivilian ? MAX_SPEED_CIVILIAN_BASE : MAX_SPEED_PLAYER));
let acceleration = this.customAccel || ACCELERATION;
// --- Fire Wheel Skill Check ---
if (!this.isCop && !this.isCivilian && fireWheelActive) {
maxSpeed = 1.5; // 5x faster in both modes
acceleration = 2;
}
if (this.isCivilian) maxSpeed = this.speedTrait;
let acc = this.accInput;
// Damage Effects
if (this.health) {
let rr = this.health.parts['rr_wheel'] <= 0;
let rl = this.health.parts['rl_wheel'] <= 0;
if (rr && rl) { acc = 0; maxSpeed = 0; }
else if (rr || rl) { maxSpeed = 0.6; acc = 0.6; }
if (this.health.parts['back_torso'] <= 0) maxSpeed = 0.75;
if (this.rotDirection === -1 && this.health.parts['fl_wheel'] <= 0) turnSpeed = 0.2;
if (this.rotDirection === 1 && this.health.parts['fr_wheel'] <= 0) turnSpeed = 0.2;
}
// Ghostly Rider Achievement Tracking (Player only) - DEPRECATED LOGIC
if (!this.isCop && !this.isCivilian) {
if (this.rotDirection !== 0 && this.lastRotDirection === 0 && this.vel.mag() > 0.5) {
// Starting a turn
this.turnComplete = true; // Set to true at start, cleared if hit building
}
this.lastRotDirection = this.rotDirection;
}
// Turning
if (this.rotDirection !== 0 && this.vel.mag() > 0.5) {
let rad = degToRad(this.angle);
let headingVec = new Vector2(Math.cos(rad), -Math.sin(rad));
let dot = this.vel.dot(headingVec);
let flip = dot > 0 ? 1 : -1;
this.angle -= this.rotDirection * turnSpeed * flip;
}
// Velocity
let rad = degToRad(this.angle);
let forward = new Vector2(Math.cos(rad), -Math.sin(rad));
this.vel = this.vel.add(forward.mult(acc));
let speed = this.vel.mag();
// Friction / Drift
if (drift && speed > 3) {
this.vel = this.vel.mult(DRIFT_SLIDE);
} else {
if (speed > 0.1) {
let dot = this.vel.dot(forward);
let direction = dot > 0 ? 1 : -1;
let targetVel = forward.mult(speed * direction);
this.vel = this.vel.lerp(targetVel, 0.12);
this.vel = this.vel.mult(FRICTION);
} else {
if (Math.abs(acc) < 0.01) this.vel = new Vector2(0, 0);
}
}
if (this.vel.mag() > maxSpeed) {
this.vel = this.vel.normalize().mult(maxSpeed);
}
this.pos = this.pos.add(this.vel);
// Building Collisions
// Skip collisions if Phase Shift is active OR flying
if (this.isPhasing || this.isFlying) return;
let hitbox = this.getHitbox();
this.isCollidingWithBuilding = false; // Reset collision state
// Check bounds loop
for (let i = buildings.length - 1; i >= 0; i--) {
let b = buildings[i];
if (hitbox.collideRect(b.rect)) {
if (!this.isCop && !this.isCivilian) {
// Demolition Logic
if (this.id === 'dozer' && this.powerActive) {
buildings.splice(i, 1); // Destroy building
this.score += 50; // Bonus
continue;
}
this.turnComplete = false; // Failed Ghostly Rider check
this.isCollidingWithBuilding = true;
}
let dx = hitbox.centerx - b.rect.centerx;
let dy = hitbox.centery - b.rect.centery;
let wCombined = (hitbox.w + b.rect.w) / 2;
let hCombined = (hitbox.h + b.rect.h) / 2;
let ox = wCombined - Math.abs(dx);
let oy = hCombined - Math.abs(dy);
if (ox < oy) {
if (dx > 0) this.pos.x += ox; else this.pos.x -= ox;
this.vel.x = 0.5;
} else {
if (dy > 0) this.pos.y += oy; else this.pos.y -= oy;
this.vel.y = 0.5;
}
hitbox = this.getHitbox();
if (this.isCivilian) {
this.reversing = !this.reversing;
this.stuckTimer = 0;
}
}
}
}
updateCop(target, buildings, isGhostlyRiderActive) {
if (!this.isCop) return;
// Stunned Logic
if (this.stunTimer > 0) {
this.stunTimer--;
this.vel = this.vel.mult(0.9); // Slow down significantly
return; // No AI when stunned
}
// Oil Slick Spin Logic
if (this.spinTimer > 0) {
this.spinTimer--;
this.angle += 15; // Spin uncontrollably
this.vel = this.vel.mult(0.96); // Slide
this.physics(buildings, true, false); // Physics with drift enabled
return;
}
// If player is invisible, ignore them!
if (isGhostlyRiderActive) {
this.accInput = ACCELERATION * 0.1; // Just cruise slowly
this.rotDirection = 0;
this.physics(buildings, false, false);
return;
}
let futurePos = target.pos.add(target.vel.mult(25));
let diff = futurePos.sub(this.pos);
if (this.fearActive) {
diff = diff.mult(-1); // Flee
}
if (this.vel.mag() < 1.0) this.stuckTimer++;
else this.stuckTimer = 0;
if (this.stuckTimer > 50) this.reversing = true;
if (this.stuckTimer > 90) { this.reversing = false; this.stuckTimer = 0; }
if (this.reversing) {
this.accInput = -ACCELERATION * 0.6;
this.rotDirection = 1;
} else {
this.accInput = ACCELERATION * 0.98;
let targetAngle = Math.atan2(-diff.y, diff.x) * 180 / Math.PI;
let currentAngle = this.angle;
let angleDiff = (targetAngle - currentAngle + 180) % 360 - 180;
if (angleDiff < -180) angleDiff += 360;
if (angleDiff > 180) angleDiff -= 360;
if (angleDiff > 8) this.rotDirection = -1;
else if (angleDiff < -8) this.rotDirection = 1;
else this.rotDirection = 0;
}
this.physics(buildings, false, false);
}
updateCivilian(buildings, allCars, player) {
if (!this.isCivilian) return;
// Grid info
const gx = Math.floor(this.pos.x / BLOCK_SIZE);
const gy = Math.floor(this.pos.y / BLOCK_SIZE);
const cx = gx * BLOCK_SIZE + BLOCK_SIZE/2;
const cy = gy * BLOCK_SIZE + BLOCK_SIZE/2;
const isIntersection = (gx % 3 === 0) && (gy % 3 === 0);
// Init heading if null
if (this.targetHeading === null) {
this.targetHeading = Math.round(this.angle / 90) * 90;
}
// --- 1. SENSOR CHECK ---
const sensors = this.checkSensors(allCars, player, buildings);
let braking = false;
let coasting = false; // NEW: Coasting state
let yielding = false;
// --- 2. INTERSECTION & YIELD LOGIC ---
let distToCenter = Math.sqrt((this.pos.x - cx)**2 + (this.pos.y - cy)**2);
let insideBox = isIntersection && distToCenter < 140;
// If approaching intersection, check for cross traffic
if (isIntersection && !insideBox && distToCenter < 280) {
let intendedTurn = (this.targetHeading - this.angle + 360) % 360;
let isRightTurn = (Math.abs(intendedTurn - 90) < 45);
for(let other of allCars) {
if (other === this) continue;
let otherDist = Math.sqrt((other.pos.x - cx)**2 + (other.pos.y - cy)**2);
// General Intersection Yield (stop crashes)
// Only yield if other car is closer or already entering
if (otherDist < distToCenter * 0.8 || otherDist < 120) {
let angleDiff = Math.abs(this.angle - other.angle);
// If perpendicular (cross traffic)
if (angleDiff > 80 && angleDiff < 100 || angleDiff > 260 && angleDiff < 280) {
yielding = true;
}
// Special Right Turn Yield (Oncoming)
if (isRightTurn && Math.abs(angleDiff - 180) < 20) {
// Oncoming traffic within range
if (otherDist < 250) yielding = true;
}
}
}
}
// Inside box = Right of way (Clear it!)
if (insideBox) {
yielding = false;
// Only stop if literally touching bumper to bumper
if (sensors.front && sensors.frontDist > 50) braking = false;
} else {
// Front sensor brake logic modified for coasting
if (sensors.front) {
if (sensors.frontDist < 30) braking = true; // Panic stop only when VERY close
else if (sensors.frontDist < 100) coasting = true; // Just lift off gas
}
if (yielding) braking = true;
}
// --- 3. LANE LOGIC & OVERTAKING ---
if ((braking || coasting) && !yielding && !insideBox) {
this.blockedTimer++;
// If stuck behind someone slow, try to overtake
if (this.blockedTimer > this.patience && this.speedTrait > 1.0) {
// Check if lane change is safe
if (this.laneSwitchDir === 0) {
// Prefer passing on Right (center) if safe
if (sensors.rightClear) this.laneSwitchDir = 1;
else if (sensors.leftClear) this.laneSwitchDir = -1;
}
}
} else {
this.blockedTimer = 0;
this.laneSwitchDir = 0;
}
// --- 4. STUCK/REVERSE ---
if (this.vel.mag() < 0.5 && !braking) this.stuckTimer++;
else this.stuckTimer = 0;
if (this.stuckTimer > 100) this.reversing = true;
if (this.stuckTimer > 150 || (this.reversing && this.vel.mag() > 2)) {
this.reversing = false;
this.stuckTimer = 0;
this.angle += 45; // Hard steer to unstick
}
// --- 5. EXECUTION ---
this.brakingVisual = false;
if (this.reversing) {
this.accInput = -ACCELERATION * 0.5;
this.rotDirection = -1;
// Reverse lights (not red)
} else {
if (braking) {
// Hard Brake
this.accInput = -ACCELERATION * 1.5;
this.brakingVisual = true;
if (this.vel.mag() < 0.1) {
this.vel = new Vector2(0, 0);
this.accInput = 0;
}
} else if (coasting) {
// Gentle Slow Down (No Brake Lights)
this.accInput = 0; // Lift off gas
// Friction will naturally slow the car
} else {
this.accInput = ACCELERATION * 0.4;
}
// --- LHT LANE CALCULATIONS ---
let laneOffset = 80;
if (this.laneSwitchDir === 1) laneOffset = 20; // Move to center (Overtake)
if (this.laneSwitchDir === -1) laneOffset = 140; // Move to shoulder?
let targetX = this.pos.x;
let targetY = this.pos.y;
let h = (this.targetHeading % 360 + 360) % 360;
if (h === 0) targetY = cy - laneOffset;
else if (h === 180) targetY = cy + laneOffset;
else if (h === 90) targetX = cx + laneOffset;
else if (h === 270) targetX = cx - laneOffset;
let lookAhead = 150;
let steeringTarget = new Vector2(targetX, targetY);
if (h === 0 || h === 180) steeringTarget.x = this.pos.x + (h===0?lookAhead:-lookAhead);
else steeringTarget.y = this.pos.y + (h===90?lookAhead:-lookAhead);
let diff = steeringTarget.sub(this.pos);
let desiredAngle = Math.atan2(-diff.y, diff.x) * 180 / Math.PI;
// Pick Heading at Intersection
if (this.cooldownTimer > 0) this.cooldownTimer--;
if (isIntersection && distToCenter < 60 && this.cooldownTimer <= 0) {
// Bias towards going straight (less chaos)
const directions = [0, 90, 180, 270];
// Remove U-turn
let valid = directions.filter(d => Math.abs(d - this.targetHeading) !== 180);
const newHeading = randChoice(valid);
this.targetHeading = newHeading;
this.cooldownTimer = 200;
}
let currentAngle = this.angle;
let targetSteer = (isIntersection && distToCenter < 90) ? this.targetHeading : desiredAngle;
let angleDiff = (targetSteer - currentAngle + 180) % 360 - 180;
if (angleDiff < -180) angleDiff += 360;
if (angleDiff > 180) angleDiff -= 360;
if (angleDiff > 4) this.rotDirection = -1;
else if (angleDiff < -4) this.rotDirection = 1;
else this.rotDirection = 0;
}
// Deadlock Breaker: If stuck yielding for too long, just go
if (yielding) {
this.blockedTimer++;
if (this.blockedTimer > 150) yielding = false; // "I'm going!"
}
this.physics(buildings, false, false);
}
draw(ctx) {
ctx.save();
let padding = (this.id === 'angel' || this.id === 'demon' || this.id === 'ufo' || this.id === 'monster' || this.id === 'pirate' || this.id === 'dozer') ? 20 : 0;
ctx.translate(this.pos.x, this.pos.y);
// Rocket fly effect
if (this.isFlying) {
ctx.translate(0, -20);
ctx.shadowBlur = 20;
ctx.shadowColor = 'rgba(0,0,0,0.5)';
}
ctx.rotate(-degToRad(this.angle));
// Draw car sprite centered properly even with padding
ctx.drawImage(this.sprite, -this.width/2 - padding, -this.height/2 - padding);
// Draw Dynamic Brake Lights
if (this.brakingVisual) {
ctx.fillStyle = '#ff0000';
ctx.shadowBlur = 10;
ctx.shadowColor = '#ff0000';
const bodyY = 3, bodyH = this.height - 6;
ctx.fillRect(1, bodyY+2, 3, 3);
ctx.fillRect(1, bodyY+bodyH-5, 3, 3);
ctx.shadowBlur = 0;
}
// EMP Visual Indicator (on car)
if (this.stunTimer > 0) {
ctx.strokeStyle = '#3296ff';
ctx.lineWidth = 2;
ctx.beginPath();
ctx.arc(0, 0, this.width, 0, Math.PI * 2);
ctx.stroke();
}
// Phase Visual
if (this.isPhasing) {
ctx.strokeStyle = '#9d4edd';
ctx.lineWidth = 2;
ctx.beginPath(); ctx.arc(0,0, this.width+5, 0, Math.PI * 2); ctx.stroke();
}
ctx.restore();
}
}
class Person {
constructor(x, y, walkArea, isPlayer=false, customConfig=null) {
this.pos = new Vector2(x, y);
this.angle = -randFloat(0, Math.PI * 2) * 180 / Math.PI;
this.isPlayer = isPlayer;
if (customConfig && isPlayer) {
this.skinColor = '#ffdbac'; // Default skin for now, could be added to config
this.shirtColor = customConfig.shirt || '#d32f2f';
this.pantColor = '#222';
this.hairColor = customConfig.hair || '#000';
this.hairStyle = customConfig.hairStyle || 'short_messy';
this.shoeColor = '#000';
this.ability = customConfig.ability;
this.abilityColor = customConfig.abilityColor;
} else {
this.skinColor = randChoice(['#ffdbac', '#f1c27d', '#e0ac69', '#8d5524', '#c68642']);
this.shirtColor = randChoice(['#ffffff', '#14141e', '#c83232', '#3264c8', '#32c864', '#ffff32', '#ff96c8', '#a0a0a0', '#503250']);
this.pantColor = randChoice(['#1e1e28', '#2d2d3c', '#283250', '#50463c', '#3c3c46', '#202020']);
this.hairColor = randChoice(['#000000', '#281e14', '#4b3c28', '#e6c86e', '#8c2828', '#c8c8c8', '#e6e6e6']);
this.hairStyle = randChoice(['bald', 'short', 'short_messy', 'long', 'ponytail', 'cap', 'afro', 'mohawk']);
this.shoeColor = randChoice(['#000000', '#ffffff', '#50321e', '#323232']);
}
let angleRad = randFloat(0, Math.PI * 2);
this.vel = new Vector2(Math.cos(angleRad), Math.sin(angleRad)).mult(0.4);
this.angle = -angleRad * 180 / Math.PI;
this.walkArea = walkArea;
this.rect = new Rect(x-7, y-7, 14, 14);
this.isDead = false;
this.isAngry = false;
this.shoutTimer = 0;
this.curseWord = "";
this.frame = randFloat(0, 10);
this.curseList = ["HEY!", "WATCH IT!", "I'M WALKIN!", "IDIOT!", "NOOO!", "WHAT?!", "CRAZY!"];
// Ability Stats
this.abilityActive = false;
this.abilityTimer = 0;
this.abilityCooldown = 0;
this.moveSpeed = 3.5;
if (this.isPlayer) {
this.vel = new Vector2(0,0);
this.walkArea = null; // Player can walk anywhere
}
}
die(bloodGroup) {
if (this.isDead || this.isPlayer) return; // Player character doesn't die same way for now
this.isDead = true;
this.vel = new Vector2(0,0);
for (let i=0; i<2; i++) {
bloodGroup.push(new Blood(this.pos.x + randInt(-5,5), this.pos.y + randInt(-5,5)));
}
}
update(playerCar, bloodGroup) {
if (this.isDead) return;
// Player controlled character logic handled in Game loop
if (this.isPlayer) {
this.rect.centerx = this.pos.x;
this.rect.centery = this.pos.y;
// Animate only if moving
if (this.vel.mag() > 0.1) {
this.frame += 0.2;
// Face movement direction
this.angle = Math.atan2(this.vel.y, this.vel.x) * 180 / Math.PI;
} else {
this.frame = 0;
}
return;
}
let dist = this.pos.distanceTo(playerCar.pos);
if (dist < 30 && playerCar.vel.mag() > 2.0) {
this.die(bloodGroup);
return;
}
if (dist < 70 && !this.isAngry) {
this.isAngry = true;
this.shoutTimer = 120;
this.curseWord = randChoice(this.curseList);
this.vel = new Vector2(0,0);
}
if (this.isAngry) {
this.shoutTimer--;
if (this.shoutTimer <= 0) {
this.isAngry = false;
let angleRad = randFloat(0, Math.PI * 2);
this.vel = new Vector2(Math.cos(angleRad), Math.sin(angleRad)).mult(0.4);
this.angle = -angleRad * 180 / Math.PI;
}
} else {
if (this.walkArea) {
let futurePos = this.pos.add(this.vel.mult(5));
if (!this.walkArea.collidePoint(futurePos.x, futurePos.y)) {
this.vel = this.vel.rotate(180);
this.angle = (this.angle + 180) % 360;
}
}
this.pos = this.pos.add(this.vel);
if (Math.random() < 0.01) {
let rot = randChoice([90, -90, 180]);
this.vel = this.vel.rotate(rot);
this.angle = (this.angle + rot) % 360;
}
}
this.rect.centerx = this.pos.x;
this.rect.centery = this.pos.y;
this.frame += 0.2;
}
draw(ctx) {
ctx.save();
ctx.translate(this.pos.x, this.pos.y);
if (this.isDead) {
ctx.rotate(-degToRad(this.angle));
ctx.fillStyle = '#960000';
ctx.beginPath(); ctx.ellipse(0, 0, 14, 8, 0, 0, Math.PI*2); ctx.fill();
ctx.fillStyle = this.shirtColor;
ctx.fillRect(-6, -4, 12, 8);
ctx.fillStyle = this.skinColor;
ctx.fillRect(4, -3, 6, 6);
} else {
ctx.rotate(-degToRad(this.angle - 90)); // Fix orientation: 0 deg faces right
let speed = this.isAngry ? 0 : 1;
let walkCycle = this.frame * 0.8 * speed;
// Flash Run Animation
if (this.isPlayer && this.abilityActive && this.ability === 'flash_run') {
walkCycle = this.frame * 2.0; // super fast legs
}
let leftLeg = Math.sin(walkCycle) * 4;
let rightLeg = Math.sin(walkCycle + Math.PI) * 4;
let leftArm = Math.sin(walkCycle + Math.PI) * 4;
let rightArm = Math.sin(walkCycle) * 4;
if (this.isAngry) {
leftLeg = 0; rightLeg = 0;
leftArm = 0; rightArm = 0;
}
// Legs
ctx.fillStyle = this.pantColor;
ctx.fillRect(-6, leftLeg - 2, 4, 6); // Left
ctx.fillRect(2, rightLeg - 2, 4, 6); // Right
// Shoes
ctx.fillStyle = this.shoeColor;
ctx.fillRect(-6, leftLeg + 2, 4, 3);
ctx.fillRect(2, rightLeg + 2, 4, 3);
// Arms
ctx.fillStyle = this.shirtColor;
ctx.fillRect(-9, leftArm - 2, 3, 7);
ctx.fillRect(6, rightArm - 2, 3, 7);
// Hands
ctx.fillStyle = this.skinColor;
if (this.isAngry) {
let shake = randInt(-1, 1);
ctx.fillRect(-10 + shake, -8, 5, 5);
ctx.fillRect(5 + shake, -8, 5, 5);
} else {
ctx.fillRect(-9, leftArm + 4, 3, 3);
ctx.fillRect(6, rightArm + 4, 3, 3);
}
// Body
ctx.fillStyle = this.shirtColor;
ctx.fillRect(-6, -4, 12, 10);
// Collar/Neck
ctx.fillStyle = 'rgba(0,0,0,0.15)';
ctx.fillRect(-2, -4, 4, 2);
// Head
ctx.fillStyle = this.skinColor;
ctx.fillRect(-4, -8, 8, 7);
// Hair
if (this.hairStyle === 'cap') {
ctx.fillStyle = this.hairColor;
ctx.fillRect(-5, -9, 10, 7);
ctx.fillStyle = 'rgba(0,0,0,0.2)';
ctx.fillRect(-5, -2, 10, 3); // Visor
} else if (this.hairStyle === 'mohawk') {
ctx.fillStyle = this.skinColor;
ctx.fillRect(-5, -9, 10, 6);
ctx.fillStyle = this.hairColor;
ctx.fillRect(-1, -10, 2, 8);
} else if (this.hairStyle === 'afro') {
ctx.fillStyle = this.hairColor;
ctx.fillRect(-6, -10, 12, 10);
} else if (this.hairStyle !== 'bald') {
ctx.fillStyle = this.hairColor;
if (this.hairStyle === 'short') {
ctx.fillRect(-5, -9, 10, 6);
} else if (this.hairStyle === 'short_messy') {
ctx.fillRect(-5, -9, 10, 7);
ctx.fillRect(-3, -10, 2, 2);
ctx.fillRect(1, -10, 2, 2);
} else if (this.hairStyle === 'long') {
ctx.fillRect(-5, -9, 10, 6);
ctx.fillRect(-6, -6, 12, 4);
} else if (this.hairStyle === 'ponytail') {
ctx.fillRect(-5, -9, 10, 6);
ctx.fillRect(-2, -11, 4, 4);
}
}
}
ctx.restore();
}
}
class Building {
constructor(gx, gy, isPark) {
this.gx = gx;
this.gy = gy;
let x = gx * BLOCK_SIZE + BLOCK_SIZE/2;
let y = gy * BLOCK_SIZE + BLOCK_SIZE/2;
this.pos = new Vector2(x, y);
this.w = BLOCK_SIZE - BUILDING_GAP * 2;
this.h = BLOCK_SIZE - BUILDING_GAP * 2;
this.rect = new Rect(x - this.w/2, y - this.h/2, this.w, this.h);
this.rng = new SeededRNG(Math.abs(gx * 73856093 ^ gy * 19349663));
this.sprite = this.generateSprite(isPark);
this.style = isPark ? 'park' : 'building';
}
generateSprite(isPark) {
const cvs = document.createElement('canvas');
cvs.width = this.w;
cvs.height = this.h;
const ctx = cvs.getContext('2d');
ctx.imageSmoothingEnabled = false;
const w = this.w, h = this.h;
const rng = this.rng;
if (isPark) {
ctx.fillStyle = COLORS.ZOO_BASE;
ctx.fillRect(0, 0, w, h);
ctx.fillStyle = '#2d7d2d';
for(let i=0; i<300; i++) {
ctx.fillRect(rng.randInt(0,w), rng.randInt(0,h), 2, 2);
}
ctx.fillStyle = '#b4aa96';
ctx.fillRect(w/2 - 20, 0, 40, h);
ctx.fillRect(0, h/2 - 20, w, 40);
for (let r=60; r>10; r-=5) {
ctx.fillStyle = `rgb(50, 150, ${250-r})`;
ctx.beginPath(); ctx.arc(w/2+80, h/2-80, r, 0, Math.PI*2); ctx.fill();
}
} else {
ctx.fillStyle = COLORS.SIDEWALK;
ctx.fillRect(0, 0, w, h);
ctx.fillStyle = '#737378';
for(let i=0; i<w; i+=20) {
ctx.fillRect(i, 0, 1, h);
ctx.fillRect(0, i, w, 1);
}
for (let i=0; i<5; i++) {
let px = rng.randInt(5, w-20);
let py = rng.randInt(5, h-20);
if (px > 30 && px < w-30 && py > 30 && py < h-50) continue;
let type = rng.choice(['planter', 'box', 'vent', 'light']);
if (type === 'planter') {
ctx.fillStyle = '#644632'; ctx.fillRect(px, py, 12, 12);
ctx.fillStyle = '#3c8c3c'; ctx.beginPath(); ctx.arc(px+6, py+6, 5, 0, Math.PI*2); ctx.fill();
} else if (type === 'box') {
ctx.fillStyle = '#64646e'; ctx.fillRect(px, py, 10, 16);
ctx.fillStyle = '#50505a'; ctx.fillRect(px+1, py+1, 8, 14);
} else if (type === 'light') {
// Street light base
ctx.fillStyle = '#222'; ctx.beginPath(); ctx.arc(px, py, 4, 0, Math.PI*2); ctx.fill();
} else {
ctx.fillStyle = '#aaa'; ctx.fillRect(px, py, 12, 12);
ctx.fillStyle = '#555';
ctx.fillRect(px+2, py+2, 8, 2);
ctx.fillRect(px+2, py+5, 8, 2);
ctx.fillRect(px+2, py+8, 8, 2);
}
}
let pad = 12;
let wallH = 35;
let iw = w - pad*2, ih = h - pad*2;
let roofRect = {x:pad, y:pad, w:iw, h:ih - wallH};
let wallRect = {x:pad, y:pad+ih-wallH, w:iw, h:wallH};
let styles = ['modern', 'izakaya', 'brick', 'school'];
let style = rng.choice(styles);
this.buildingStyle = style;
if (style === 'school') {
ctx.fillStyle = COLORS.SCHOOL_BEIGE; ctx.fillRect(roofRect.x, roofRect.y, roofRect.w, roofRect.h);
ctx.fillStyle = '#dcd2b4';
for(let i=0; i<roofRect.w; i+=4) ctx.fillRect(roofRect.x+i, roofRect.y, 1, roofRect.h);
ctx.fillStyle = '#c8beace'; ctx.fillRect(wallRect.x, wallRect.y, wallRect.w, wallRect.h);
ctx.fillStyle = '#b4aa96'; ctx.fillRect(roofRect.x+roofRect.w/2-20, roofRect.y+roofRect.h/2-20, 40, 40);
drawCircle(ctx, COLORS.CLOCK_FACE, roofRect.x+roofRect.w/2, roofRect.y+roofRect.h/2, 15);
ctx.strokeStyle = '#000'; ctx.beginPath(); ctx.moveTo(roofRect.x+roofRect.w/2, roofRect.y+roofRect.h/2); ctx.lineTo(roofRect.x+roofRect.w/2, roofRect.y+roofRect.h/2-10); ctx.stroke();
ctx.fillStyle = '#6496c8';
for(let r=0; r<3; r++) {
for(let c=0; c<6; c++) {
if (rng.next()>0.2) {
let wx = roofRect.x + c*(iw/6)+8;
let wy = roofRect.y + r*25+15;
ctx.fillStyle = '#465a6e';
ctx.fillRect(wx-1, wy-1, 22, 17);
ctx.fillStyle = '#6496c8';
ctx.fillRect(wx, wy, 20, 15);
ctx.fillStyle = '#a0c8fa';
ctx.beginPath(); ctx.moveTo(wx+12, wy); ctx.lineTo(wx+16, wy); ctx.lineTo(wx+4, wy+15); ctx.lineTo(wx, wy+15); ctx.fill();
}
}
}
} else if (style === 'izakaya') {
ctx.fillStyle = COLORS.WOOD_DARK; ctx.fillRect(roofRect.x-2, roofRect.y-2, roofRect.w+4, roofRect.h+4);
ctx.fillStyle = COLORS.ROOF_TILE_JP; ctx.fillRect(roofRect.x, roofRect.y, roofRect.w, roofRect.h);
ctx.fillStyle = '#2d2d32';
for(let i=0; i<roofRect.h; i+=6) {
ctx.fillRect(roofRect.x, roofRect.y+i, roofRect.w, 2);
}
ctx.fillStyle = COLORS.WOOD_RED; ctx.fillRect(wallRect.x, wallRect.y, wallRect.w, wallRect.h);
for(let i=0; i<4; i++) {
let lx = wallRect.x + (iw/4)*i + 20;
let ly = wallRect.y+5;
drawCircle(ctx, '#000', lx, ly-2, 2);
drawCircle(ctx, COLORS.LANTERN_RED, lx, ly, 6);
ctx.fillStyle = '#ffaa32';
ctx.fillRect(lx-2, ly-2, 4, 4);
}
} else if (style === 'modern') {
ctx.fillStyle = '#9696a0'; ctx.fillRect(roofRect.x, roofRect.y, roofRect.w, roofRect.h);
for(let i=0; i<200; i++) {
ctx.fillStyle = rng.next() > 0.5 ? '#a0a0aa' : '#8c8c96';
ctx.fillRect(roofRect.x + rng.randInt(0, roofRect.w), roofRect.y + rng.randInt(0, roofRect.h), 2, 2);
}
ctx.strokeStyle = '#555'; ctx.lineWidth = 2;
ctx.strokeRect(roofRect.x+4, roofRect.y+4, roofRect.w-8, roofRect.h-8);
ctx.fillStyle = '#787882'; ctx.fillRect(wallRect.x, wallRect.y, wallRect.w, wallRect.h);
let winW = iw/3 - 5, winH = (ih-wallH)/3 - 5;
for(let r=0; r<3; r++) {
for(let c=0; c<3; c++) {
let wx = roofRect.x + c*(winW+5) + 8, wy = roofRect.y + r*(winH+5) + 8;
ctx.fillStyle = rng.choice([COLORS.WIN_LIT_COOL, COLORS.WIN_LIT_WARM, COLORS.WIN_DARK]);
ctx.fillRect(wx, wy, winW, winH);
if (rng.next() > 0.6) {
ctx.fillStyle = COLORS.AC;
ctx.fillRect(wx+winW-10, wy+winH, 10, 8);
drawCircle(ctx, '#333', wx+winW-5, wy+winH+4, 3);
}
}
}
} else { // Brick
ctx.fillStyle = '#a06450'; ctx.fillRect(roofRect.x, roofRect.y, roofRect.w, roofRect.h);
ctx.fillStyle = '#8c5040';
for(let by = roofRect.y; by < roofRect.bottom; by+=6) {
ctx.fillRect(roofRect.x, by, roofRect.w, 1);
for(let bx = roofRect.x + (by%12===0?0:6); bx < roofRect.right; bx+=12) {
ctx.fillRect(bx, by, 1, 6);
}
}
ctx.fillStyle = COLORS.SIDEWALK; ctx.fillRect(wallRect.x, wallRect.y, wallRect.w, wallRect.h);
let ww = iw/5, wh = (ih-wallH)/4;
for(let r=0; r<4; r++) {
for(let c=0; c<5; c++) {
ctx.fillStyle = rng.choice([COLORS.WIN_LIT_WARM, COLORS.WIN_DARK]);
ctx.fillRect(roofRect.x + c*ww + 8, roofRect.y + r*wh + 8, ww-16, wh-20);
ctx.fillStyle = '#555';
ctx.fillRect(roofRect.x + c*ww + 7, roofRect.y + r*wh + 8 + wh - 20, ww-14, 2);
}
}
}
}
return cvs;
}
draw(ctx) {
ctx.fillStyle = 'rgba(0,0,0,0.25)';
ctx.fillRect(this.rect.x+8, this.rect.y+8, this.w, this.h);
ctx.drawImage(this.sprite, this.rect.x, this.rect.y);
}
}
// NEW: Wall Class for Bomb Pass Mode
class Wall {
constructor(x, y, w, h) {
this.rect = new Rect(x, y, w, h);
this.w = w;
this.h = h;
}
draw(ctx) {
// Draw Concrete Wall look
ctx.fillStyle = '#444';
ctx.fillRect(this.rect.x, this.rect.y, this.rect.w, this.rect.h);
// 3D Top edge highlight
ctx.fillStyle = '#666';
ctx.fillRect(this.rect.x, this.rect.y, this.rect.w, 10);
// Stripes for visibility
ctx.fillStyle = '#333';
for(let i=0; i<this.rect.w; i+=40) {
ctx.fillRect(this.rect.x + i, this.rect.y + 10, 4, this.rect.h - 10);
}
// Border
ctx.strokeStyle = '#111';
ctx.lineWidth = 2;
ctx.strokeRect(this.rect.x, this.rect.y, this.rect.w, this.rect.h);
}
}
class Tree {
constructor(x, y) {
this.pos = new Vector2(x, y);
this.w = 60;
this.h = 60;
this.rect = new Rect(x - this.w/2, y - this.h/2, this.w, this.h);
this.sprite = this.generateSprite();
}
generateSprite() {
const cvs = document.createElement('canvas');
cvs.width = this.w; cvs.height = this.h;
const ctx = cvs.getContext('2d');
// Trunk
ctx.fillStyle = '#50281e';
ctx.fillRect(25, 30, 10, 30);
// Leaves
ctx.fillStyle = '#2d7d2d';
ctx.beginPath(); ctx.arc(30, 20, 20, 0, Math.PI*2); ctx.fill();
ctx.fillStyle = '#3da03d';
ctx.beginPath(); ctx.arc(25, 15, 10, 0, Math.PI*2); ctx.fill();
return cvs;
}
draw(ctx) {
ctx.fillStyle = 'rgba(0,0,0,0.2)';
ctx.beginPath(); ctx.ellipse(this.pos.x, this.pos.y+20, 20, 10, 0, 0, Math.PI*2); ctx.fill();
ctx.drawImage(this.sprite, this.rect.x, this.rect.y);
}
}
class Sakura {
constructor(x, y) {
this.pos = new Vector2(x, y);
this.rect = new Rect(x-20, y-20, 40, 40);
this.sprite = this.generate();
this.petals = [];
for(let i=0; i<5; i++) {
this.petals.push({x: randInt(-15, 15), y: randInt(10, 20), c: randChoice([COLORS.SAKURA_PINK, '#fff'])});
}
}
generate() {
const cvs = document.createElement('canvas');
cvs.width = 40; cvs.height = 40;
const ctx = cvs.getContext('2d');
ctx.fillStyle = '#46281e'; ctx.fillRect(18, 20, 4, 20);
for(let i=0; i<15; i++) {
ctx.fillStyle = COLORS.SAKURA_DARK;
drawCircle(ctx, ctx.fillStyle, randInt(5,35), randInt(10,35), randInt(3,5));
}
for(let i=0; i<20; i++) {
ctx.fillStyle = COLORS.SAKURA_PINK;
drawCircle(ctx, ctx.fillStyle, randInt(5,35), randInt(5,30), randInt(3,5));
}
for(let i=0; i<10; i++) {
ctx.fillStyle = '#ffdcdc';
drawCircle(ctx, ctx.fillStyle, randInt(10,30), randInt(5,25), randInt(1,3));
}
return cvs;
}
draw(ctx) {
this.petals.forEach(p => {
ctx.fillStyle = p.c;
ctx.fillRect(this.pos.x + p.x, this.pos.y + p.y, 3, 3);
});
ctx.drawImage(this.sprite, this.rect.x, this.rect.y);
}
}
class Blood {
constructor(x, y) {
this.pos = new Vector2(x, y);
this.size = randInt(15, 30);
this.color = '#b40000';
this.rect = new Rect(x-this.size/2, y-this.size/2, this.size, this.size);
}
draw(ctx) {
ctx.fillStyle = this.color;
ctx.beginPath();
ctx.arc(this.pos.x, this.pos.y, this.size/2, 0, Math.PI*2);
ctx.fill();
ctx.fillStyle = '#8c0000';
ctx.beginPath();
ctx.arc(this.pos.x + randInt(-5,5), this.pos.y + randInt(-5,5), this.size/3, 0, Math.PI*2);
ctx.fill();
}
}
class Particle {
constructor(x, y, type) {
this.pos = new Vector2(x, y);
this.type = type;
this.life = type === 'smoke' ? 40 : 20;
this.maxLife = this.life;
if (type === 'smoke') {
this.vel = new Vector2(randFloat(-1, 1), randFloat(-1, 1));
this.size = randInt(4, 10);
let c = randInt(50, 100);
this.color = `rgb(${c},${c},${c})`;
} else if (type === 'spark') {
this.vel = new Vector2(randFloat(-4, 4), randFloat(-4, 4));
this.size = 5;
this.color = '#ff6400';
} else if (type === 'repair') {
this.vel = new Vector2(randFloat(-2, 2), randFloat(-2, 2));
this.size = randInt(3, 6);
this.color = '#32ff64';
} else if (type === 'gold') {
this.vel = new Vector2(randFloat(-3, 3), randFloat(-3, 3));
this.size = 4;
this.color = '#ffd700';
} else if (type === 'lightning') {
this.vel = new Vector2(0, 0);
this.life = 15;
this.maxLife = 15;
this.size = 2; // Line width
this.color = '#ffd700';
// Generate random lightning path
this.path = [];
this.path.push({x:0, y:0});
let cx=0, cy=0;
for(let i=0; i<5; i++) {
cx += randInt(-15, 15);
cy += randInt(-15, 15);
this.path.push({x:cx, y:cy});
}
}
}
update() {
if (this.type !== 'lightning') this.pos = this.pos.add(this.vel);
this.life--;
}
draw(ctx) {
if (this.type === 'lightning') {
ctx.save();
ctx.translate(this.pos.x, this.pos.y);
ctx.strokeStyle = this.color;
ctx.lineWidth = this.size;
ctx.globalAlpha = this.life / this.maxLife;
ctx.beginPath();
ctx.moveTo(0,0);
this.path.forEach(p => ctx.lineTo(p.x, p.y));
ctx.stroke();
ctx.restore();
} else {
ctx.fillStyle = this.color;
ctx.fillRect(this.pos.x - this.size/2, this.pos.y - this.size/2, this.size, this.size);
}
}
}
class Skid {
constructor(x, y, angle) {
this.pos = new Vector2(x, y);
this.angle = angle;
this.life = 100;
this.rect = new Rect(x-10, y-10, 20, 20);
}
update() { this.life -= 2; }
draw(ctx) {
ctx.save();
ctx.translate(this.pos.x, this.pos.y);
ctx.rotate(-degToRad(this.angle));
ctx.fillStyle = `rgba(30, 30, 30, ${this.life/100 * 0.6})`;
ctx.fillRect(-5, -2, 10, 4);
ctx.restore();
}
}
// New: Fire Trail for Floor (Fire Wheel) - Revamped for pixel vibe
class FireTrail {
constructor(x, y, angle) {
this.pos = new Vector2(x, y);
this.angle = angle;
this.life = 40;
this.maxLife = 40;
this.pixels = [];
// Generate a cluster of "pixel fire"
for(let i=0; i<12; i++) {
this.pixels.push({
x: randInt(-15, 15),
y: randInt(-5, 5),
size: randInt(3, 6),
color: randChoice(['#ffeb3b', '#ff9800', '#f44336', '#d32f2f']), // Yellow -> Orange -> Red
decay: randFloat(0.5, 1.5)
});
}
}
update() { this.life--; }
draw(ctx) {
ctx.save();
ctx.translate(this.pos.x, this.pos.y);
ctx.rotate(-degToRad(this.angle));
let globalAlpha = this.life / this.maxLife;
this.pixels.forEach(p => {
if (this.life * p.decay < this.maxLife) {
ctx.fillStyle = p.color;
ctx.globalAlpha = globalAlpha;
// Jitter effect
let jx = randInt(-1, 1);
let jy = randInt(-1, 1);
ctx.fillRect(p.x + jx, p.y + jy, p.size, p.size);
}
});
ctx.restore();
ctx.globalAlpha = 1.0;
}
}
// New: Oil Slick for Drifter
class OilSlick {
constructor(x, y) {
this.pos = new Vector2(x, y);
this.life = 10 * 60; // 10 seconds
this.radius = 25;
}
update() { this.life--; }
draw(ctx) {
let alpha = Math.min(1.0, this.life / 60);
ctx.fillStyle = `rgba(20, 20, 20, ${alpha})`;
ctx.beginPath();
ctx.arc(this.pos.x, this.pos.y, this.radius, 0, Math.PI*2);
ctx.fill();
// Shine
ctx.fillStyle = `rgba(100, 100, 100, ${alpha * 0.3})`;
ctx.beginPath();
ctx.ellipse(this.pos.x - 5, this.pos.y - 5, 8, 4, 0.5, 0, Math.PI*2);
ctx.fill();
}
}
// Sticky Goo (Mr Freeze)
class StickyPuddle {
constructor(x, y) {
this.pos = new Vector2(x, y);
this.life = 8 * 60;
this.radius = 30;
}
update() { this.life--; }
draw(ctx) {
let alpha = Math.min(1.0, this.life / 60);
ctx.fillStyle = `rgba(255, 105, 180, ${alpha * 0.8})`; // Pink
ctx.beginPath();
ctx.arc(this.pos.x, this.pos.y, this.radius, 0, Math.PI*2);
ctx.fill();
ctx.fillStyle = `rgba(255, 200, 220, ${alpha * 0.5})`;
ctx.beginPath();
ctx.arc(this.pos.x - 5, this.pos.y - 5, 10, 0, Math.PI*2);
ctx.fill();
}
}
// Mines (Wastelander)
class Mine {
constructor(x, y) {
this.pos = new Vector2(x, y);
this.triggered = false;
this.radius = 12;
}
draw(ctx) {
ctx.fillStyle = '#555';
ctx.beginPath(); ctx.arc(this.pos.x, this.pos.y, this.radius, 0, Math.PI*2); ctx.fill();
ctx.fillStyle = '#f00';
ctx.beginPath(); ctx.arc(this.pos.x, this.pos.y, 4, 0, Math.PI*2); ctx.fill(); // Blinking light
}
}
// Light Wall (Neon)
class LightWall {
constructor(x, y) {
this.pos = new Vector2(x, y);
this.life = 5 * 60;
this.radius = 15;
}
update() { this.life--; }
draw(ctx) {
let alpha = Math.min(1.0, this.life / 60);
ctx.fillStyle = `rgba(0, 255, 255, ${alpha})`;
ctx.shadowBlur = 10; ctx.shadowColor = '#0ff';
ctx.fillRect(this.pos.x-10, this.pos.y-10, 20, 20);
ctx.shadowBlur = 0;
}
}
// New: Shockwave for Angel Ability & EMP
class Shockwave {
constructor(x, y, color, maxR) {
this.pos = new Vector2(x, y);
this.r = 10;
this.maxR = maxR || 400;
this.color = color || '#fff';
this.active = true;
}
update() {
this.r += 15; // Expand fast
if (this.r > this.maxR) this.active = false;
}
draw(ctx) {
let alpha = 1.0 - (this.r / this.maxR);
ctx.strokeStyle = this.color;
ctx.globalAlpha = alpha;
ctx.lineWidth = 10;
ctx.beginPath();
ctx.arc(this.pos.x, this.pos.y, this.r, 0, Math.PI*2);
ctx.stroke();
ctx.globalAlpha = 1.0;
}
}
// --- MULTIPLAYER CLASSES ---
class RemoteCar extends Car {
constructor(id, x, y, carTypeIndex, name) {
// Find car config
let config = PLAYER_ROSTER[carTypeIndex] || PLAYER_ROSTER[0];
super(x, y, config.color, false, false);
this.remoteId = id;
this.playerName = name || "Guest";
this.targetPos = new Vector2(x, y);
this.targetAngle = 0;
// Apply sprite config
this.type = config.type;
this.id = config.id;
this.hasSpoiler = config.hasSpoiler;
this.sprite = this.createCarSprite(); // Re-gen sprite
this.health = null; // No local health tracking for remote
}
interpolate() {
// Simple Lerp
this.pos = this.pos.lerp(this.targetPos, 0.1);
// Angle lerp
let diff = (this.targetAngle - this.angle + 180) % 360 - 180;
if (diff < -180) diff += 360;
if (diff > 180) diff -= 360;
this.angle += diff * 0.1;
}
// Override physics to do nothing, position is set by network
physics() {
this.interpolate();
}
draw(ctx) {
super.draw(ctx);
// Draw Name Tag
ctx.save();
ctx.translate(this.pos.x, this.pos.y);
ctx.fillStyle = "rgba(0,0,0,0.5)";
ctx.fillRect(-30, -40, 60, 16);
ctx.fillStyle = "#fff";
ctx.textAlign = "center";
ctx.font = "10px 'Press Start 2P'";
ctx.fillText(this.playerName, 0, -28);
ctx.restore();
}
}
// Manages Real-Time Multiplayer via MQTT over WebSockets
class MultiplayerManager {
constructor() {
this.client = null;
this.connected = false;
this.remotePlayers = {}; // id -> { car: RemoteCar, lastSeen: timestamp }
this.myId = 'p_' + Math.random().toString(36).substr(2, 9);
this.lastPublish = 0;
this.publishInterval = 50; // ms (20 updates/sec)
// Topic Prefix (unique enough to avoid collisions with other users of the broker)
this.topicBase = 'tokyo_drift_chase_v1/global/';
}
connect() {
console.log("Connecting to MQTT Broker...");
// Public EMQX Broker (WebSocket Secure Port)
this.client = mqtt.connect('wss://broker.emqx.io:8084/mqtt');
this.client.on('connect', () => {
console.log("Connected to Global Server");
this.connected = true;
this.client.subscribe(this.topicBase + '#');
});
this.client.on('message', (topic, message) => {
// parse topic to get ID
// topic: tokyo_drift_chase_v1/global/{id}
const parts = topic.split('/');
const senderId = parts[parts.length - 1];
if (senderId === this.myId) return;
try {
const data = JSON.parse(message.toString());
this.handleUpdate(senderId, data);
} catch (e) {
// ignore garbled
}
});
this.client.on('error', (err) => {
console.error("Connection Error", err);
});
}
handleUpdate(id, data) {
if (!this.remotePlayers[id]) {
// New Player
const newCar = new RemoteCar(id, data.x, data.y, data.t, data.n);
this.remotePlayers[id] = { car: newCar, lastSeen: Date.now(), mode: data.m };
} else {
// Update Existing
const p = this.remotePlayers[id];
p.lastSeen = Date.now();
p.mode = data.m;
p.car.targetPos = new Vector2(data.x, data.y);
p.car.targetAngle = data.a;
// Update name/type if changed (rare)
if (p.car.playerName !== data.n) p.car.playerName = data.n;
}
}
update(player, buildings, gameMode) {
const now = Date.now();
// 1. Publish My State
if (this.connected && now - this.lastPublish > this.publishInterval) {
const payload = {
x: Math.round(player.pos.x),
y: Math.round(player.pos.y),
a: Math.round(player.angle),
t: player.selectedCarIndex,
n: "Racer " + this.myId.substr(0,4).toUpperCase(),
m: gameMode
};
this.client.publish(this.topicBase + this.myId, JSON.stringify(payload));
this.lastPublish = now;
}
// 2. Prune disconnected players (timeout > 5 sec)
for (const id in this.remotePlayers) {
if (now - this.remotePlayers[id].lastSeen > 5000) {
delete this.remotePlayers[id];
} else {
// Interpolate
this.remotePlayers[id].car.physics();
}
}
// 3. Update UI
this.updateUI();
}
updateUI() {
const uiText = document.getElementById('online-text');
const count = 1 + Object.keys(this.remotePlayers).length;
uiText.innerText = "online: " + count;
}
draw(ctx, camera, localGameMode) {
for (const id in this.remotePlayers) {
const p = this.remotePlayers[id];
// Filter players by game mode
if (p.mode !== localGameMode) continue;
// View Culling
let rect = p.car.getRect();
let screenRect = camera.apply(rect);
if (screenRect.right > 0 && screenRect.left < ctx.canvas.width &&
screenRect.bottom > 0 && screenRect.top < ctx.canvas.height) {
p.car.draw(ctx);
}
}
}
}
// --- Main Game Class ---
class Game {
constructor() {
this.canvas = document.getElementById('gameCanvas');
this.ctx = this.canvas.getContext('2d');
this.ctx.imageSmoothingEnabled = false;
this.resize();
window.addEventListener('resize', () => this.resize());
// Inputs
this.keys = {};
this.kPressed = false; // For K key toggle
this.zPressed = false; // For Power Ability
this.leftPressed = false; // Menu navigation
this.rightPressed = false; // Menu navigation
this.fPressed = false; // Enter/Exit Car
this.ePressed = false; // Repair
window.addEventListener('keydown', e => this.keys[e.key.toLowerCase()] = true);
window.addEventListener('keyup', e => this.keys[e.key.toLowerCase()] = false);
this.canvas.addEventListener('mousedown', e => this.onClick(e));
// Touch Input Handling
this.touchData = {
stickID: null,
stickOrigin: new Vector2(0,0),
stickCurr: new Vector2(0,0),
buttons: {} // key -> touchID
};
this.canvas.addEventListener('touchstart', e => this.handleTouch(e), {passive: false});
this.canvas.addEventListener('touchmove', e => this.handleTouch(e), {passive: false});
this.canvas.addEventListener('touchend', e => this.handleTouch(e), {passive: false});
// Game State
this.state = 'MENU'; // MENU, CAR_SELECT, MODE_SELECT, PLAY, GAMEOVER, SETTINGS
this.selectedCarIndex = 0; // Default car selection
this.gameMode = 'POLICE_RUN'; // POLICE_RUN or BOMB_PASS
this.score = 0;
this.highScore = 0;
this.achievements = []; // { name: '...', timer: 180 }
this.deviceMode = 'PC'; // PC or MOBILE
// Buttons
this.restartRect = new Rect(0,0,0,0);
this.playRect = new Rect(0,0,0,0);
this.selectRect = new Rect(0,0,0,0);
this.settingsRect = new Rect(0,0,0,0);
this.resetProgressRect = new Rect(0,0,0,0);
this.backRect = new Rect(0,0,0,0);
this.tvToggleRect = new Rect(0,0,0,0);
this.deviceToggleRect = new Rect(0,0,0,0); // New Device Button
this.modeSelectPoliceRect = new Rect(0,0,0,0); // Mode buttons
this.modeSelectBombRect = new Rect(0,0,0,0);
// Confirm Dialog Buttons
this.confirmYesRect = new Rect(0,0,0,0);
this.confirmNoRect = new Rect(0,0,0,0);
this.showResetConfirm = false;
// --- ACHIEVEMENT & SKILL MECHANISMS ---
this.hasGhostlyRider = false;
this.ghostlyRiderActive = false;
this.ghostlyRiderCooldown = 0;
this.ghostlyRiderDuration = 0;
this.ghostlyRiderCooldownMax = 15 * FPS;
this.ghostlyRiderDurationMax = 15 * FPS;
this.hasFireWheel = false;
this.fireWheelActive = false;
this.fireWheelCooldown = 0;
this.fireWheelDuration = 0;
this.fireWheelCooldownMax = 15 * FPS;
this.fireWheelDurationMax = 15 * FPS;
// Z Power
this.powerCooldown = 0;
this.powerActive = false; // For duration based powers (Ramming)
this.powerTimer = 0;
this.timeScale = 1.0; // Global time scale for Time Slow ability
this.turnCount = 0;
this.driftTime = 0;
this.showProgress = false;
// TV Mode Settings
this.tvMode = true; // Default ON
// Intersection turn tracking
this.isInsideIntersection = false;
this.playerInitialAngle = null;
// On-Foot Mechanics
this.isWalking = false;
this.playerPed = null; // Will be an instance of Person when walking
this.playerPosHistory = []; // For Chronos Rewind
// --- MULTIPLAYER SETUP ---
this.multiplayer = new MultiplayerManager();
// --- ADMIN PANEL SETUP ---
this.adminOpen = false;
this.keyBuffer = "";
this.setupAdminInput();
// Load Data
this.loadData();
// Initialize game world so background renders in Menu
this.initGame();
this.loop = this.loop.bind(this);
requestAnimationFrame(this.loop);
}
// --- Persistence ---
saveData() {
const data = {
highScore: Math.max(this.score, this.highScore),
tvMode: this.tvMode,
deviceMode: this.deviceMode
};
localStorage.setItem('tokyo_drift_chase_v2', JSON.stringify(data));
this.highScore = data.highScore;
}
loadData() {
const saved = localStorage.getItem('tokyo_drift_chase_v2');
if (saved) {
const data = JSON.parse(saved);
this.highScore = data.highScore || 0;
// Unlocks reset to false
this.hasGhostlyRider = false;
this.hasFireWheel = false;
if (data.tvMode !== undefined) this.tvMode = data.tvMode;
if (data.deviceMode !== undefined) this.deviceMode = data.deviceMode;
}
}
resetData() {
localStorage.removeItem('tokyo_drift_chase_v2');
this.highScore = 0;
this.hasGhostlyRider = false;
this.hasFireWheel = false;
this.tvMode = true; // Default back to true
this.deviceMode = 'PC';
}
setupAdminInput() {
// Detect 1090
window.addEventListener('keydown', (e) => {
this.keyBuffer += e.key;
if (this.keyBuffer.length > 10) this.keyBuffer = this.keyBuffer.slice(-10);
if (this.keyBuffer.endsWith('1090')) {
this.adminOpen = !this.adminOpen;
const panel = document.getElementById('admin-panel');
panel.style.display = this.adminOpen ? 'flex' : 'none';
if (this.adminOpen) {
// Populate values when opening
document.getElementById('adm-score').value = this.score;
document.getElementById('adm-speed').value = this.player.customMaxSpeed || 9.0;
document.getElementById('adm-armor').value = this.player.health ? this.player.health.maxHp : 100;
document.getElementById('adm-handling').value = this.player.customTurnSpeed || 4.0;
}
}
});
// Inputs
const scoreInp = document.getElementById('adm-score');
const speedInp = document.getElementById('adm-speed');
const armorInp = document.getElementById('adm-armor');
const handInp = document.getElementById('adm-handling');
// Prevent game controls when typing in inputs
const stopProp = (e) => e.stopPropagation();
scoreInp.addEventListener('keydown', stopProp);
speedInp.addEventListener('keydown', stopProp);
armorInp.addEventListener('keydown', stopProp);
handInp.addEventListener('keydown', stopProp);
// Apply Changes
scoreInp.addEventListener('input', (e) => { this.score = parseInt(e.target.value) || 0; });
speedInp.addEventListener('input', (e) => { this.player.customMaxSpeed = parseFloat(e.target.value) || 9.0; });
handInp.addEventListener('input', (e) => { this.player.customTurnSpeed = parseFloat(e.target.value) || 4.0; });
armorInp.addEventListener('input', (e) => {
let val = parseInt(e.target.value) || 100;
if (this.player.health) {
this.player.health.maxHp = val;
// Refill health to max to apply effect immediately
for(let k in this.player.health.parts) this.player.health.parts[k] = val;
}
});
}
initGame() {
// Init player based on Selection
let carSpec = PLAYER_ROSTER[this.selectedCarIndex];
// Create car
this.player = new Car(0, 0, carSpec.color);
// Apply stats & ID
this.player.type = carSpec.type;
this.player.id = carSpec.id; // Important for sprite gen
this.player.hasSpoiler = carSpec.hasSpoiler;
this.player.sprite = this.player.createCarSprite();
this.player.customMaxSpeed = carSpec.stats.speed;
this.player.customTurnSpeed = carSpec.stats.turn;
this.player.customAccel = carSpec.stats.accel;
this.player.health = new CarHealth(carSpec.stats.hp);
this.player.powerData = carSpec.powerData;
this.player.selectedCarIndex = this.selectedCarIndex; // For networking
this.camera = new Camera();
this.buildings = [];
this.people = [];
this.cops = [];
this.civilians = [];
this.sakura = [];
this.particles = [];
this.skids = [];
this.floorEffects = []; // New layer for floor trails & oil
this.shockwaves = []; // New list for Angel ability
this.blood = [];
this.loadedChunks = new Set();
// Setup menu camera pos
this.menuCamPos = new Vector2(0, 0);
this.spawnTimer = 0;
this.score = 0;
// Reset state
this.ghostlyRiderActive = false;
this.ghostlyRiderCooldown = 0;
this.ghostlyRiderDuration = 0;
this.fireWheelActive = false;
this.fireWheelDuration = 0;
this.fireWheelCooldown = 0;
this.powerCooldown = 0;
this.powerActive = false;
this.powerTimer = 0;
this.timeScale = 1.0;
this.turnCount = 0;
this.driftTime = 0;
this.isInsideIntersection = false;
this.playerInitialAngle = null;
// Reset walking state
this.isWalking = false;
this.playerPed = null;
this.playerPosHistory = [];
// Connect Multiplayer
this.multiplayer.connect();
// MAP GENERATION LOGIC
if (this.gameMode === 'BOMB_PASS') {
// Static Arena Map (Square Box)
// Clear chunk system logic mostly
// Map Size: 4000x4000 centered at 0,0
const mapSize = 4000;
const halfSize = mapSize / 2;
// Generate Walls using Wall class
const wallThick = 200;
// Top Wall
this.buildings.push(new Wall(-halfSize - wallThick, -halfSize - wallThick, mapSize + wallThick*2, wallThick));
// Bottom Wall
this.buildings.push(new Wall(-halfSize - wallThick, halfSize, mapSize + wallThick*2, wallThick));
// Left Wall
this.buildings.push(new Wall(-halfSize - wallThick, -halfSize, wallThick, mapSize));
// Right Wall
this.buildings.push(new Wall(halfSize, -halfSize, wallThick, mapSize));
// Add Random Trees
for(let i=0; i<80; i++) {
let x = randInt(-halfSize + 200, halfSize - 200);
let y = randInt(-halfSize + 200, halfSize - 200);
// Don't spawn on player start
if (Math.abs(x) < 300 && Math.abs(y) < 300) continue;
this.buildings.push(new Tree(x, y));
}
}
}
resize() {
this.canvas.width = window.innerWidth;
this.canvas.height = window.innerHeight;
this.ctx.imageSmoothingEnabled = false;
}
onClick(e) {
const mx = e.clientX;
const my = e.clientY;
if (this.state === 'MENU') {
if (this.playRect.collidePoint(mx, my)) {
this.state = 'CAR_SELECT';
}
if (this.settingsRect.collidePoint(mx, my)) {
this.state = 'SETTINGS';
}
} else if (this.state === 'SETTINGS') {
if (this.showResetConfirm) {
if (this.confirmYesRect.collidePoint(mx, my)) {
this.resetData();
this.showResetConfirm = false;
}
if (this.confirmNoRect.collidePoint(mx, my)) {
this.showResetConfirm = false;
}
return; // Block other clicks
}
if (this.backRect.collidePoint(mx, my)) {
this.state = 'MENU';
this.saveData(); // Save settings when leaving
}
if (this.resetProgressRect.collidePoint(mx, my)) {
this.showResetConfirm = true;
}
if (this.tvToggleRect.collidePoint(mx, my)) {
this.tvMode = !this.tvMode;
}
if (this.deviceToggleRect.collidePoint(mx, my)) {
this.deviceMode = this.deviceMode === 'PC' ? 'MOBILE' : 'PC';
}
} else if (this.state === 'CAR_SELECT') {
// Check for drive button
if (this.selectRect.collidePoint(mx, my)) {
// Check lock
let spec = PLAYER_ROSTER[this.selectedCarIndex];
if (spec.unlockScore && this.highScore < spec.unlockScore) {
// Locked
return;
}
// Proceed to Mode Selection
this.state = 'MODE_SELECT';
}
} else if (this.state === 'MODE_SELECT') {
if (this.modeSelectPoliceRect.collidePoint(mx, my)) {
this.gameMode = 'POLICE_RUN';
this.initGame();
this.state = 'PLAY';
}
if (this.modeSelectBombRect.collidePoint(mx, my)) {
this.gameMode = 'BOMB_PASS';
this.initGame();
this.state = 'PLAY';
}
} else if (this.state === 'GAMEOVER') {
if (this.restartRect.collidePoint(mx, my)) {
this.initGame();
this.state = 'PLAY';
}
}
}
// --- TOUCH CONTROLS ---
handleTouch(e) {
if (this.state !== 'PLAY' || this.deviceMode !== 'MOBILE') return;
e.preventDefault();
const w = this.canvas.width;
const h = this.canvas.height;
const touches = e.changedTouches;
// Button Config
const cx = w - 100;
const cy = h - 100;
const btnDrift = { x: cx, y: cy, r: 55, key: ' ' };
const dist = 100;
const rSat = 32;
const satellites = [
{ x: cx - dist, y: cy, r: rSat, key: 'f' }, // Left (F)
{ x: cx - dist*0.707, y: cy - dist*0.707, r: rSat, key: 'z' }, // Top-Left (Z)
{ x: cx, y: cy - dist, r: rSat, key: 'x' }, // Top (X)
{ x: cx + dist*0.6, y: cy - dist*0.8, r: rSat, key: 'c' } // Top-Right (C)
];
for (let i = 0; i < touches.length; i++) {
let t = touches[i];
let tx = t.clientX;
let ty = t.clientY;
if (e.type === 'touchstart') {
// LEFT SIDE: Virtual Joystick
if (tx < w / 2) {
if (this.touchData.stickID === null) {
this.touchData.stickID = t.identifier;
this.touchData.stickOrigin = new Vector2(tx, ty);
this.touchData.stickCurr = new Vector2(tx, ty);
}
}
// RIGHT SIDE: Buttons
else {
// Check Drift
if (Math.hypot(tx - btnDrift.x, ty - btnDrift.y) < btnDrift.r) {
this.touchData.buttons['drift'] = t.identifier;
this.keys[' '] = true;
}
// Check Satellites
satellites.forEach(btn => {
if (Math.hypot(tx - btn.x, ty - btn.y) < btn.r) {
this.touchData.buttons[btn.key] = t.identifier;
this.keys[btn.key] = true;
}
});
}
} else if (e.type === 'touchmove') {
if (t.identifier === this.touchData.stickID) {
this.touchData.stickCurr = new Vector2(tx, ty);
// Update Keys based on vector
let diff = this.touchData.stickCurr.sub(this.touchData.stickOrigin);
// Clamp
if (diff.mag() > 50) diff = diff.normalize().mult(50);
this.touchData.stickCurr = this.touchData.stickOrigin.add(diff);
// Map to Keys
this.keys['arrowup'] = diff.y < -20;
this.keys['arrowdown'] = diff.y > 20;
this.keys['arrowleft'] = diff.x < -20;
this.keys['arrowright'] = diff.x > 20;
}
} else if (e.type === 'touchend' || e.type === 'touchcancel') {
if (t.identifier === this.touchData.stickID) {
this.touchData.stickID = null;
this.keys['arrowup'] = false;
this.keys['arrowdown'] = false;
this.keys['arrowleft'] = false;
this.keys['arrowright'] = false;
}
// Release buttons
if (t.identifier === this.touchData.buttons['drift']) {
this.keys[' '] = false;
delete this.touchData.buttons['drift'];
}
satellites.forEach(btn => {
if (t.identifier === this.touchData.buttons[btn.key]) {
this.keys[btn.key] = false;
delete this.touchData.buttons[btn.key];
}
});
}
}
}
drawMobileControls(ctx, w, h) {
// Left Joystick
if (this.touchData.stickID !== null) {
ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
ctx.beginPath();
ctx.arc(this.touchData.stickOrigin.x, this.touchData.stickOrigin.y, 50, 0, Math.PI*2);
ctx.fill();
ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
ctx.beginPath();
ctx.arc(this.touchData.stickCurr.x, this.touchData.stickCurr.y, 25, 0, Math.PI*2);
ctx.fill();
} else {
// Idle hint
ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
ctx.beginPath();
ctx.arc(100, h - 100, 50, 0, Math.PI*2);
ctx.fill();
ctx.textAlign = 'center';
ctx.fillStyle = '#aaa';
ctx.font = '10px "Press Start 2P"';
ctx.fillText("STEER", 100, h - 100);
}
// Right Buttons Layout
const cx = w - 100;
const cy = h - 100;
const btnDrift = { x: cx, y: cy, r: 55, label: "DRIFT", color: '#ffeb3b', active: this.keys[' '] };
const dist = 100;
const rSat = 32;
const satellites = [
{ x: cx - dist, y: cy, r: rSat, label: "F", color: '#ffffff', active: this.keys['f'] },
{ x: cx - dist*0.707, y: cy - dist*0.707, r: rSat, label: "Z", color: '#32ffff', active: this.keys['z'] },
{ x: cx, y: cy - dist, r: rSat, label: "X", color: '#32ff64', active: this.keys['x'] },
{ x: cx + dist*0.6, y: cy - dist*0.8, r: rSat, label: "C", color: '#ff6432', active: this.keys['c'] }
];
// Helper Draw
const drawBtn = (b) => {
ctx.beginPath();
ctx.arc(b.x, b.y, b.r, 0, Math.PI*2);
ctx.fillStyle = b.active ? 'rgba(255, 255, 255, 0.5)' : 'rgba(0,0,0,0.5)';
ctx.fill();
ctx.lineWidth = 3;
ctx.strokeStyle = b.color;
ctx.stroke();
ctx.fillStyle = b.active ? '#000' : '#fff';
ctx.font = (b.r > 40 ? '16px' : '12px') + ' "Press Start 2P"';
ctx.textAlign = 'center';
ctx.textBaseline = 'middle';
ctx.fillText(b.label, b.x, b.y);
};
// Draw Satellites first
satellites.forEach(drawBtn);
// Draw Main
drawBtn(btnDrift);
}
// --- New Achievement Logic ---
showAchievement(name) {
// Only show if not already showing the same one and not in the list
if (!this.achievements.some(a => a.name === name)) {
this.achievements.push({ name: name, timer: 180 }); // 3 seconds @ 60 FPS
// Don't save achievement unlock to persistence, but track for session
}
}
updateAchievementLogic(drift) {
const player = this.player;
// --- 1. Ghostly Rider: 10 non-bumping intersection turns ---
if (!this.hasGhostlyRider) {
const playerX = player.pos.x;
const playerY = player.pos.y;
const blockX = Math.floor(playerX / BLOCK_SIZE);
const blockY = Math.floor(playerY / BLOCK_SIZE);
const isRoadX = (blockX % 3 === 0);
const isRoadY = (blockY % 3 === 0);
const inIntersectionBlock = isRoadX && isRoadY;
const getCardinalAngle = (angle) => Math.round(((angle % 360) + 360) % 360 / 90) * 90;
const currentCardinalAngle = getCardinalAngle(player.angle);
if (inIntersectionBlock) {
if (!this.isInsideIntersection) {
this.isInsideIntersection = true;
this.playerInitialAngle = currentCardinalAngle;
}
} else if (this.isInsideIntersection) {
this.isInsideIntersection = false;
const turnSuccess = (currentCardinalAngle !== this.playerInitialAngle);
if (turnSuccess && !player.isCollidingWithBuilding) {
this.turnCount++;
} else if (player.isCollidingWithBuilding) {
this.turnCount = 0;
}
player.isCollidingWithBuilding = false;
this.playerInitialAngle = null;
}
if (player.isCollidingWithBuilding) {
this.turnCount = 0;
}
if (this.turnCount >= 10) {
this.hasGhostlyRider = true;
this.showAchievement("Ghostly Rider Unlocked!");
}
}
// --- 2. Fire Wheel: 30 seconds of drifting without hitting a cop ---
if (!this.hasFireWheel) {
if (drift && player.vel.mag() > 4) {
let copCollision = this.cops.some(cop => cop.getHitbox().collideRect(player.getHitbox()));
if (!copCollision) {
this.driftTime++;
} else {
this.driftTime = 0;
player.isCollidingWithCop = true;
}
} else {
this.driftTime = 0;
}
if (this.driftTime >= 30 * FPS) {
this.hasFireWheel = true;
this.showAchievement("Fire Wheel Unlocked!");
}
}
// Update achievement pop-up timers
this.achievements.forEach(a => a.timer--);
this.achievements = this.achievements.filter(a => a.timer > 0);
}
updateSkillMechanics() {
// K key toggle logic
if (this.keys['k'] && !this.kPressed) {
this.showProgress = !this.showProgress;
this.kPressed = true;
}
if (!this.keys['k']) this.kPressed = false;
// --- Ghostly Rider ---
if (this.hasGhostlyRider) {
if ((this.keys['x'] || this.keys['X']) && !this.ghostlyRiderActive && this.ghostlyRiderCooldown <= 0) {
this.ghostlyRiderActive = true;
this.ghostlyRiderDuration = this.ghostlyRiderDurationMax;
this.ghostlyRiderCooldown = this.ghostlyRiderCooldownMax;
}
}
if (this.ghostlyRiderActive) {
this.ghostlyRiderDuration--;
if (this.ghostlyRiderDuration <= 0) this.ghostlyRiderActive = false;
} else if (this.ghostlyRiderCooldown > 0) {
this.ghostlyRiderCooldown--;
}
// --- Fire Wheel ---
if (this.hasFireWheel) {
if ((this.keys['c'] || this.keys['C']) && !this.fireWheelActive && this.fireWheelCooldown <= 0) {
this.fireWheelActive = true;
this.fireWheelDuration = this.fireWheelDurationMax;
this.fireWheelCooldown = this.fireWheelCooldownMax;
}
}
if (this.fireWheelActive) {
this.fireWheelDuration--;
if (this.fireWheelDuration <= 0) this.fireWheelActive = false;
} else if (this.fireWheelCooldown > 0) {
this.fireWheelCooldown--;
}
// --- Z POWER (Unique per Car) ---
if ((this.keys['z'] || this.keys['Z']) && !this.zPressed && this.powerCooldown <= 0) {
this.zPressed = true;
this.activatePower();
}
if (!this.keys['z'] && !this.keys['Z']) this.zPressed = false;
if (this.powerCooldown > 0) this.powerCooldown--;
if (this.powerActive) {
this.powerTimer--;
if (this.powerTimer <= 0) {
this.powerActive = false;
// Deactivate persistent effects
this.player.isPhasing = false;
this.player.isFlying = false;
this.player.fearActive = false;
this.timeScale = 1.0;
}
}
// --- Process Active Powers ---
// Update Shockwaves (Angel, Mecha, Cyber-X)
for (let i = this.shockwaves.length - 1; i >= 0; i--) {
let sw = this.shockwaves[i];
sw.update();
if (!sw.active) {
this.shockwaves.splice(i, 1);
continue;
}
// Collision
this.cops.forEach(cop => {
if (cop.dead) return;
let d = cop.pos.distanceTo(sw.pos);
if (d < sw.r + 20 && d > sw.r - 40) {
if (this.player.id === 'angel' || this.player.id === 'demon') {
// Kill
cop.dead = true;
this.score += 50;
for(let k=0; k<10; k++) this.particles.push(new Particle(cop.pos.x, cop.pos.y, 'spark'));
} else if (this.player.id === 'mecha' || this.player.id === 'interceptor') {
// Stun
cop.stunTimer = 300;
cop.vel = new Vector2(0,0);
} else if (this.player.id === 'cybertruck') {
// Push
let pushVec = cop.pos.sub(this.player.pos).normalize().mult(30);
cop.vel = cop.vel.add(pushVec);
}
}
});
// --- NEW: Shockwave effect on Remote Players (Visual/Local only) ---
Object.values(this.multiplayer.remotePlayers).forEach(p => {
let rCar = p.car;
let d = rCar.pos.distanceTo(sw.pos);
if (d < sw.r + 20 && d > sw.r - 40) {
// Visual hit effect on remote player
for(let k=0; k<5; k++) this.particles.push(new Particle(rCar.pos.x, rCar.pos.y, 'spark'));
}
});
}
}
activatePower() {
if (!this.player.powerData) return;
const pid = this.player.id;
if (pid === 'standard') {
if (this.player.health) {
for (let k in this.player.health.parts) {
this.player.health.parts[k] = Math.min(this.player.health.maxHp, this.player.health.parts[k] + 50);
}
}
this.powerCooldown = this.player.powerData.cooldown;
}
else if (pid === 'drifter') {
this.floorEffects.push(new OilSlick(this.player.pos.x, this.player.pos.y));
this.powerCooldown = this.player.powerData.cooldown;
}
else if (pid === 'tank') {
this.powerActive = true;
this.powerTimer = 300;
this.powerCooldown = this.player.powerData.cooldown;
}
else if (pid === 'mecha') {
this.shockwaves.push(new Shockwave(this.player.pos.x, this.player.pos.y, '#32ffff', 400));
this.powerCooldown = this.player.powerData.cooldown;
}
else if (pid === 'angel') {
this.shockwaves.push(new Shockwave(this.player.pos.x, this.player.pos.y, '#ffd700', 300));
this.powerCooldown = this.player.powerData.cooldown;
}
else if (pid === 'cybertruck') {
this.shockwaves.push(new Shockwave(this.player.pos.x, this.player.pos.y, '#00ffcc', 300));
this.powerCooldown = this.player.powerData.cooldown;
}
else if (pid === 'nightshade') {
this.powerActive = true;
this.player.isPhasing = true;
this.powerTimer = 180; // 3 sec
this.powerCooldown = this.player.powerData.cooldown;
}
else if (pid === 'hotrod') {
// Flamethrower Logic
let angle = this.player.angle;
let rad = degToRad(angle);
let dir = new Vector2(Math.cos(rad), -Math.sin(rad));
let coneOrigin = this.player.pos.add(dir.mult(40));
// Spawn fire
for(let i=0; i<30; i++) {
let spread = (Math.random() - 0.5) * 1.0;
let pVel = dir.rotate(spread * 30).mult(randFloat(5, 10));
this.particles.push(new Particle(coneOrigin.x, coneOrigin.y, 'spark'));
}
// Check cone collision
this.cops.forEach(cop => {
let toCop = cop.pos.sub(coneOrigin);
if (toCop.mag() < 150 && toCop.normalize().dot(dir) > 0.7) {
cop.dead = true;
this.score += 50;
}
});
// --- NEW: Flame vs Remote Player ---
Object.values(this.multiplayer.remotePlayers).forEach(p => {
let rCar = p.car;
let toRP = rCar.pos.sub(coneOrigin);
if (toRP.mag() < 150 && toRP.normalize().dot(dir) > 0.7) {
for(let k=0; k<5; k++) this.particles.push(new Particle(rCar.pos.x, rCar.pos.y, 'spark'));
}
});
this.powerCooldown = this.player.powerData.cooldown;
}
else if (pid === 'interceptor') {
this.shockwaves.push(new Shockwave(this.player.pos.x, this.player.pos.y, '#0032ff', 500));
this.powerCooldown = this.player.powerData.cooldown;
}
else if (pid === 'gold') {
this.powerActive = true;
this.powerTimer = 400;
this.powerCooldown = this.player.powerData.cooldown;
}
else if (pid === 'f1') {
let rad = degToRad(this.player.angle);
let dir = new Vector2(Math.cos(rad), -Math.sin(rad));
let jump = dir.mult(350);
this.player.pos = this.player.pos.add(jump);
// Safety: if inside building, nudge out (simple check)
// Simplified: Phase momentarily
this.player.isPhasing = true;
setTimeout(() => this.player.isPhasing = false, 500);
this.powerCooldown = this.player.powerData.cooldown;
}
else if (pid === 'ufo') {
// Suck civs logic
this.civilians.forEach(c => {
if (c.pos.distanceTo(this.player.pos) < 200) {
c.dead = true; // "Abducted"
// Heal
if (this.player.health) {
for (let k in this.player.health.parts) this.player.health.parts[k] += 20;
}
this.score += 50;
}
});
// --- NEW: Suck Remote Players (Visual) ---
Object.values(this.multiplayer.remotePlayers).forEach(p => {
let rCar = p.car;
if (rCar.pos.distanceTo(this.player.pos) < 200) {
for(let k=0; k<5; k++) this.particles.push(new Particle(rCar.pos.x, rCar.pos.y, 'spark'));
}
});
this.powerCooldown = this.player.powerData.cooldown;
}
else if (pid === 'monster') {
this.powerActive = true;
this.powerTimer = 100; // Jump duration
// Visual jump handled by offset? Simplified: just crush logic enabled
this.powerCooldown = this.player.powerData.cooldown;
}
else if (pid === 'time') {
this.powerActive = true;
this.powerTimer = 300;
this.timeScale = 0.2; // Slow everything else
this.powerCooldown = this.player.powerData.cooldown;
}
else if (pid === 'demon') {
this.shockwaves.push(new Shockwave(this.player.pos.x, this.player.pos.y, '#ff0000', 800));
this.powerCooldown = this.player.powerData.cooldown;
}
// NEW SKILLS
else if (pid === 'neon') {
this.floorEffects.push(new LightWall(this.player.pos.x, this.player.pos.y));
// This skill is continuous if active? No, just drop one long segment or series?
// Let's make it a passive drop every few frames? No, instant wall drop for now to be simple
for(let i=0; i<5; i++) {
let offset = this.player.vel.normalize().mult(-i*10);
this.floorEffects.push(new LightWall(this.player.pos.x + offset.x, this.player.pos.y + offset.y));
}
this.powerCooldown = this.player.powerData.cooldown;
}
else if (pid === 'icecream') {
this.floorEffects.push(new StickyPuddle(this.player.pos.x, this.player.pos.y));
this.powerCooldown = this.player.powerData.cooldown;
}
else if (pid === 'dozer') {
this.powerActive = true;
this.powerTimer = 400; // Can break buildings
this.powerCooldown = this.player.powerData.cooldown;
}
else if (pid === 'rocket') {
this.powerActive = true;
this.powerTimer = 180;
this.player.isFlying = true;
this.powerCooldown = this.player.powerData.cooldown;
}
else if (pid === 'ambulance') {
this.powerActive = true;
this.powerTimer = 300;
this.player.fearActive = true; // Cops flee
this.powerCooldown = this.player.powerData.cooldown;
}
else if (pid === 'wasteland') {
this.floorEffects.push(new Mine(this.player.pos.x, this.player.pos.y));
this.powerCooldown = this.player.powerData.cooldown;
}
else if (pid === 'hover') {
this.powerActive = true;
this.powerTimer = 60; // Short jump
this.player.isFlying = true; // Reuse flying logic for collision avoidance
this.powerCooldown = this.player.powerData.cooldown;
}
else if (pid === 'pirate') {
// Broadside: Shoot left and right
let rad = degToRad(this.player.angle);
let right = new Vector2(Math.cos(rad + Math.PI/2), -Math.sin(rad + Math.PI/2));
let left = new Vector2(Math.cos(rad - Math.PI/2), -Math.sin(rad - Math.PI/2));
// Simplified: Instant hit check along ray
[right, left].forEach(dir => {
for(let cop of this.cops) {
let toCop = cop.pos.sub(this.player.pos);
if (toCop.mag() < 200 && toCop.normalize().dot(dir) > 0.8) {
cop.dead = true;
this.score += 50;
for(let k=0; k<10; k++) this.particles.push(new Particle(cop.pos.x, cop.pos.y, 'smoke'));
}
}
// --- NEW: Broadside vs Remote Player ---
Object.values(this.multiplayer.remotePlayers).forEach(p => {
let rCar = p.car;
let toRP = rCar.pos.sub(this.player.pos);
if (toRP.mag() < 200 && toRP.normalize().dot(dir) > 0.8) {
for(let k=0; k<10; k++) this.particles.push(new Particle(rCar.pos.x, rCar.pos.y, 'smoke'));
}
});
// Visual
for(let i=0; i<10; i++) {
let p = this.player.pos.add(dir.mult(i*20));
this.particles.push(new Particle(p.x, p.y, 'smoke'));
}
});
this.powerCooldown = this.player.powerData.cooldown;
}
else if (pid === 'nano') {
this.cops.forEach(c => {
if (c.pos.distanceTo(this.player.pos) < 300) {
c.scale = 0.5;
c.speedTrait = 0.5;
}
});
this.powerCooldown = this.player.powerData.cooldown;
}
else if (pid === 'chronos') {
// Rewind 3 seconds (180 frames)
if (this.playerPosHistory.length > 180) {
let old = this.playerPosHistory[this.playerPosHistory.length - 180];
this.player.pos = new Vector2(old.x, old.y);
this.player.angle = old.a;
// Heal
if (this.player.health) {
for (let k in this.player.health.parts) this.player.health.parts[k] = Math.min(100, this.player.health.parts[k] + 30);
}
this.particles.push(new Particle(this.player.pos.x, this.player.pos.y, 'repair'));
}
this.powerCooldown = this.player.powerData.cooldown;
}
}
generateChunk(gx, gy) {
const isRoadX = (gx % 3 === 0);
const isRoadY = (gy % 3 === 0);
const cx = gx * BLOCK_SIZE + BLOCK_SIZE/2;
const cy = gy * BLOCK_SIZE + BLOCK_SIZE/2;
let seed = Math.abs(gx * 73856093 ^ gy * 19349663);
let rng = new SeededRNG(seed);
if (isRoadX || isRoadY) {
if (rng.next() < 0.1) {
this.people.push(new Person(cx + rng.randInt(-50,50), cy + rng.randInt(-50,50), null));
}
let density = rng.choice([0, 1, 1, 2, 2, 3]);
for(let i=0; i<density; i++) {
let heading = 0;
if (isRoadX && !isRoadY) heading = rng.choice([90, 270]);
else if (!isRoadX && isRoadY) heading = rng.choice([0, 180]);
else heading = rng.choice([0, 90, 180, 270]);
let laneOffset = 80;
let jitter = rng.randInt(-20, 20);
let longScatter = rng.randInt(-150, 150);
let spawnX = cx;
let spawnY = cy;
if (heading === 0) { spawnY = cy - laneOffset + jitter; spawnX = cx + longScatter; }
else if (heading === 180) { spawnY = cy + laneOffset + jitter; spawnX = cx + longScatter; }
else if (heading === 90) { spawnX = cx + laneOffset + jitter; spawnY = cy + longScatter; }
else if (heading === 270) { spawnX = cx - laneOffset + jitter; spawnY = cy + longScatter; }
let type = rng.choice(Object.keys(CAR_TYPES));
let civCar = new Car(spawnX, spawnY, type, false, true);
civCar.angle = heading;
civCar.targetHeading = heading;
this.civilians.push(civCar);
}
} else {
const sidewalkRect = new Rect(gx * BLOCK_SIZE, gy * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE).inflate(-10, -10);
if (rng.next() < 0.08) {
this.buildings.push(new Building(gx, gy, true));
for(let i=0; i<rng.randInt(3,6); i++) {
this.sakura.push(new Sakura(cx + rng.randInt(-100,100), cy + rng.randInt(-100,100)));
}
} else {
let b = new Building(gx, gy, false);
this.buildings.push(b);
if (rng.next() < 0.95) {
for(let i=0; i<rng.randInt(8,20); i++) {
let side = rng.choice(['n','s','e','w']);
let offset = BLOCK_SIZE/2 - 30;
let px, py;
if (side==='n') { px = cx + rng.randInt(-offset, offset); py = cy - offset; }
else if (side==='s') { px = cx + rng.randInt(-offset, offset); py = cy + offset; }
else if (side==='e') { px = cx + offset; py = cy + rng.randInt(-offset, offset); }
else { px = cx - offset; py = cy + rng.randInt(-offset, offset); }
this.people.push(new Person(px, py, sidewalkRect));
}
}
}
}
}
updateChunks() {
if (this.gameMode === 'BOMB_PASS') return; // Static map for Bomb Pass
const view = this.camera.viewRect;
const startGx = Math.floor(view.left / BLOCK_SIZE) - 1;
const endGx = Math.floor(view.right / BLOCK_SIZE) + 1;
const startGy = Math.floor(view.top / BLOCK_SIZE) - 1;
const endGy = Math.floor(view.bottom / BLOCK_SIZE) + 1;
for(let gx = startGx; gx < endGx; gx++) {
for(let gy = startGy; gy < endGy; gy++) {
let key = `${gx},${gy}`;
if (!this.loadedChunks.has(key)) {
this.generateChunk(gx, gy);
this.loadedChunks.add(key);
}
}
}
const margin = 1200;
const keepRect = view.inflate(margin, margin);
for (let i = this.buildings.length - 1; i >= 0; i--) {
let b = this.buildings[i];
if (!keepRect.collideRect(b.rect)) {
this.loadedChunks.delete(`${b.gx},${b.gy}`);
this.buildings.splice(i, 1);
}
}
const cull = (arr) => {
return arr.filter(obj => {
if (obj.rect) return keepRect.collideRect(obj.rect);
return keepRect.collidePoint(obj.pos.x, obj.pos.y);
});
};
this.people = cull(this.people);
this.sakura = cull(this.sakura);
this.skids = cull(this.skids);
this.floorEffects = cull(this.floorEffects);
this.blood = cull(this.blood);
this.civilians = cull(this.civilians);
this.cops = cull(this.cops);
}
update() {
if (this.state === 'GAMEOVER') return;
// Apply Time Scale
let dt = this.timeScale;
// Input
this.player.rotDirection = 0;
this.player.accInput = 0;
if (this.state === 'MENU' || this.state === 'CAR_SELECT' || this.state === 'MODE_SELECT' || this.state === 'SETTINGS') {
// Auto-move camera for menu background
this.menuCamPos.y -= 6;
this.camera.update({ pos: this.menuCamPos }, this.canvas.width, this.canvas.height);
this.updateChunks();
// Spawn Cops around Camera in Menu
this.spawnTimer++;
if (this.spawnTimer > 120) {
this.spawnTimer = 0;
let angle = randFloat(0, Math.PI*2);
let dist = 800;
let cx = this.menuCamPos.x + Math.cos(angle)*dist;
let cy = this.menuCamPos.y + Math.sin(angle)*dist;
let gx = Math.floor(cx / BLOCK_SIZE);
let gy = Math.floor(cy / BLOCK_SIZE);
if ((gx % 3 === 0) || (gy % 3 === 0)) {
this.cops.push(new Car(cx, cy, COLORS.COP_BODY, true));
}
}
this.civilians.forEach((civ, i) => {
civ.updateCivilian(this.buildings, this.civilians, null);
});
const keepRect = this.camera.viewRect.inflate(1200, 1200);
this.cops = this.cops.filter(cop => keepRect.collideRect(cop.getRect()));
// Handle Selection Input
if (this.state === 'CAR_SELECT') {
if ((this.keys['arrowleft'] || this.keys['a']) && !this.leftPressed) {
this.selectedCarIndex--;
if (this.selectedCarIndex < 0) this.selectedCarIndex = PLAYER_ROSTER.length - 1;
this.leftPressed = true;
}
if (!this.keys['arrowleft'] && !this.keys['a']) this.leftPressed = false;
if ((this.keys['arrowright'] || this.keys['d']) && !this.rightPressed) {
this.selectedCarIndex++;
if (this.selectedCarIndex >= PLAYER_ROSTER.length) this.selectedCarIndex = 0;
this.rightPressed = true;
}
if (!this.keys['arrowright'] && !this.keys['d']) this.rightPressed = false;
}
return; // Skip rest of update loop
}
// --- PLAY STATE ---
// Update Multiplayer
this.multiplayer.update(this.player, this.buildings, this.gameMode);
// Skill Mechanics
this.updateSkillMechanics();
// History for Rewind
this.playerPosHistory.push({x: this.player.pos.x, y: this.player.pos.y, a: this.player.angle});
if (this.playerPosHistory.length > 300) this.playerPosHistory.shift();
// 1. Toggle Walking Logic (Key: F)
if (this.keys['f'] && !this.fPressed) {
this.fPressed = true;
if (!this.isWalking) {
// Try to exit car if stopped
if (this.player.vel.mag() < 0.5) {
this.isWalking = true;
// Calculate spawn offset (driver side / left side)
let rad = degToRad(this.player.angle);
// Left side vector relative to car
let sideX = Math.cos(rad + Math.PI/2);
let sideY = -Math.sin(rad + Math.PI/2);
let dist = 50; // Increased slightly for safety
let spawnPos = new Vector2(this.player.pos.x + sideX * dist, this.player.pos.y + sideY * dist);
// Simple check against buildings
let inBuilding = false;
for(let b of this.buildings) {
if (b.rect.collidePoint(spawnPos.x, spawnPos.y)) {
inBuilding = true;
break;
}
}
if (inBuilding) {
// Try right side
sideX = -sideX;
sideY = -sideY;
spawnPos = new Vector2(this.player.pos.x + sideX * dist, this.player.pos.y + sideY * dist);
// If still in building, fallback to car center (risky but better than wall)
inBuilding = false;
for(let b of this.buildings) {
if (b.rect.collidePoint(spawnPos.x, spawnPos.y)) {
inBuilding = true;
break;
}
}
if (inBuilding) {
spawnPos = new Vector2(this.player.pos.x, this.player.pos.y);
}
}
let pedData = PLAYER_ROSTER.find(c => c.id === this.player.id).pedData;
this.playerPed = new Person(spawnPos.x, spawnPos.y, null, true, pedData);
}
} else {
// Try to enter car if close
let dist = this.playerPed.pos.distanceTo(this.player.pos);
if (dist < 60) {
this.isWalking = false;
this.playerPed = null;
// Reset any ped ability effects (like time slow)
this.timeScale = 1.0;
}
}
}
if (!this.keys['f']) this.fPressed = false;
// 2. Repair Logic (Key: E)
if (this.keys['e'] && !this.ePressed && this.isWalking) {
this.ePressed = true;
let dist = this.playerPed.pos.distanceTo(this.player.pos);
if (dist < 60) {
// Repair mechanic
if (this.player.health) {
for (let k in this.player.health.parts) {
this.player.health.parts[k] = Math.min(this.player.health.maxHp, this.player.health.parts[k] + 10);
}
// Visual feedback
for(let k=0; k<5; k++) {
this.particles.push(new Particle(this.player.pos.x + randInt(-20,20), this.player.pos.y + randInt(-20,20), 'repair'));
}
}
}
}
if (!this.keys['e']) this.ePressed = false;
// 3. Movement Logic
if (this.isWalking && this.playerPed) {
// Control Pedestrian
let moveSpeed = this.playerPed.moveSpeed; // Default 3.5
let mx = 0, my = 0;
if (this.keys['arrowleft'] || this.keys['a']) mx = -1;
if (this.keys['arrowright'] || this.keys['d']) mx = 1;
if (this.keys['arrowup'] || this.keys['w']) my = -1;
if (this.keys['arrowdown'] || this.keys['s']) my = 1;
// --- PEDESTRIAN ABILITIES (Spacebar) ---
if (this.playerPed.abilityCooldown > 0) this.playerPed.abilityCooldown--;
if (this.keys[' ']) {
// Ability Logic
const ability = this.playerPed.ability;
// FLASH RUN (Time)
if (ability === 'flash_run') {
// Hold to activate
this.playerPed.abilityActive = true;
this.timeScale = 0.2; // Slow world
this.playerPed.moveSpeed = 12.0; // Fast player (relative to slow world)
if (Math.random() < 0.5) {
this.particles.push(new Particle(this.playerPed.pos.x, this.playerPed.pos.y, 'lightning'));
}
}
// BLINK (F1)
else if (ability === 'blink' && this.playerPed.abilityCooldown <= 0) {
this.playerPed.abilityCooldown = 3 * FPS; // 3 sec cooldown
let moveVec = new Vector2(mx, my);
if (moveVec.mag() === 0) {
// Default forward based on angle
let rad = degToRad(this.playerPed.angle + 90); // Angle correction
moveVec = new Vector2(Math.cos(rad), Math.sin(rad));
}
let blinkPos = this.playerPed.pos.add(moveVec.normalize().mult(150));
// Check bounds
let inWall = false;
for(let b of this.buildings) if(b.rect.collidePoint(blinkPos.x, blinkPos.y)) inWall=true;
if (!inWall) {
// Visual trail
for(let i=0; i<5; i++) {
this.particles.push(new Particle(this.playerPed.pos.x + randInt(-10,10), this.playerPed.pos.y + randInt(-10,10), 'spark'));
}
this.playerPed.pos = blinkPos;
}
}
// SHIELD (Tank/Midas)
else if ((ability === 'shield' || ability === 'money_shield') && this.playerPed.abilityCooldown <= 0) {
this.shockwaves.push(new Shockwave(this.playerPed.pos.x, this.playerPed.pos.y, this.playerPed.abilityColor, 100));
this.playerPed.abilityCooldown = 2 * FPS; // Short cooldown visual
}
// SHOCK (Mecha/Interceptor)
else if ((ability === 'shock' || ability === 'taser') && this.playerPed.abilityCooldown <= 0) {
this.shockwaves.push(new Shockwave(this.playerPed.pos.x, this.playerPed.pos.y, '#32ffff', 150));
this.playerPed.abilityCooldown = 60;
}
} else {
// Key Released
if (this.playerPed.ability === 'flash_run') {
this.playerPed.abilityActive = false;
this.timeScale = 1.0;
this.playerPed.moveSpeed = 3.5;
}
}
// Logic for passive/movement updates
let moveVec = new Vector2(mx, my);
if (moveVec.mag() > 0) moveVec = moveVec.normalize().mult(moveSpeed);
this.playerPed.vel = moveVec;
// Collision for pedestrian vs buildings
let nextPos = this.playerPed.pos.add(this.playerPed.vel);
let collided = false;
for(let b of this.buildings) {
if (b.rect.collidePoint(nextPos.x, nextPos.y)) collided = true;
}
if (!collided) {
this.playerPed.pos = nextPos; // Apply movement
this.playerPed.update(null, null); // Manual update call for player
} else {
// Allow animation but no pos update
this.playerPed.vel = new Vector2(0,0);
this.playerPed.update(null, null);
}
// Apply friction to car so it stops eventually if left rolling
this.player.vel = this.player.vel.mult(0.95);
this.player.pos = this.player.pos.add(this.player.vel.mult(dt));
} else {
// Control Car
if (this.keys['arrowleft'] || this.keys['a']) this.player.rotDirection = -1;
if (this.keys['arrowright'] || this.keys['d']) this.player.rotDirection = 1;
if (this.keys['arrowup'] || this.keys['w']) this.player.accInput = this.player.customAccel || ACCELERATION;
if (this.keys['arrowdown'] || this.keys['s']) this.player.accInput = -(this.player.customAccel || ACCELERATION) * 0.5;
let drift = (this.keys[' ']) && this.state === 'PLAY';
this.player.physics(this.buildings, drift, this.fireWheelActive);
if (this.fireWheelActive) {
if (Math.random() < 0.8) {
this.floorEffects.push(new FireTrail(this.player.pos.x, this.player.pos.y, this.player.angle));
}
}
// Neon Wall Passive
if (this.player.id === 'neon' && this.player.vel.mag() > 5) {
if (Math.random() < 0.3) {
this.floorEffects.push(new LightWall(this.player.pos.x, this.player.pos.y));
}
}
this.updateAchievementLogic(drift);
}
if (this.keys['r']) {
if (this.player.health && this.player.health.checkFullyDestroyed()) {
let tempGhostlyRider = this.hasGhostlyRider;
let tempFireWheel = this.hasFireWheel;
this.initGame();
this.hasGhostlyRider = tempGhostlyRider;
this.hasFireWheel = tempFireWheel;
return;
}
}
// Update Floor Effects (Fire & Oil)
this.floorEffects.forEach((f, i) => {
if (f.update) f.update(); // Some might not have update
else if (f.life !== undefined) f.life--;
if(f.life<=0) this.floorEffects.splice(i, 1);
// Cop interaction
if (f instanceof OilSlick) {
this.cops.forEach(cop => {
if (cop.pos.distanceTo(f.pos) < f.radius + 10) cop.spinTimer = 60;
});
}
if (f instanceof StickyPuddle) {
this.cops.forEach(cop => {
if (cop.pos.distanceTo(f.pos) < f.radius + 10) cop.vel = cop.vel.mult(0.2); // Slow
});
}
if (f instanceof LightWall) {
this.cops.forEach(cop => {
if (cop.pos.distanceTo(f.pos) < f.radius + 15) {
cop.dead = true;
this.score += 50;
for(let k=0; k<10; k++) this.particles.push(new Particle(cop.pos.x, cop.pos.y, 'spark'));
}
});
}
if (f instanceof Mine && !f.triggered) {
this.cops.forEach(cop => {
if (cop.pos.distanceTo(f.pos) < f.radius + 15) {
f.triggered = true;
cop.dead = true;
this.score += 100;
for(let k=0; k<20; k++) this.particles.push(new Particle(f.pos.x, f.pos.y, 'spark'));
}
});
if (f.triggered) this.floorEffects.splice(i, 1);
}
// --- NEW: Floor Effects vs Remote Players (Visual) ---
Object.values(this.multiplayer.remotePlayers).forEach(p => {
let rCar = p.car;
if (f instanceof LightWall || f instanceof Mine) {
let hitDist = f.radius ? f.radius + 15 : 20;
if (rCar.pos.distanceTo(f.pos) < hitDist) {
if (f instanceof Mine && !f.triggered) { f.triggered = true; }
for(let k=0; k<5; k++) this.particles.push(new Particle(rCar.pos.x, rCar.pos.y, 'spark'));
}
}
});
});
// Camera tracks player OR car
let targetObj = this.isWalking ? this.playerPed : this.player;
this.camera.update(targetObj, this.canvas.width, this.canvas.height);
// World Generation
this.updateChunks();
// Spawn Cops
if (this.gameMode !== 'BOMB_PASS') {
this.spawnTimer++;
if (this.spawnTimer > 120 / dt) {
this.spawnTimer = 0;
let angle = randFloat(0, Math.PI*2);
let dist = 800;
let cx = (-this.camera.offset.x + this.canvas.width/2) + Math.cos(angle)*dist;
let cy = (-this.camera.offset.y + this.canvas.height/2) + Math.sin(angle)*dist;
let gx = Math.floor(cx / BLOCK_SIZE);
let gy = Math.floor(cy / BLOCK_SIZE);
if ((gx % 3 === 0) || (gy % 3 === 0)) {
this.cops.push(new Car(cx, cy, COLORS.COP_BODY, true));
}
}
}
// Skids
if (Math.abs(this.player.rotDirection) > 0 && this.player.vel.mag() > 4 && !this.isWalking && !this.player.isFlying) {
this.skids.push(new Skid(this.player.pos.x, this.player.pos.y, this.player.angle));
}
this.skids.forEach((s,i) => { s.update(); if(s.life<=0) this.skids.splice(i,1); });
// --- NEW: Player-to-Player Collision (Bumping) ---
Object.values(this.multiplayer.remotePlayers).forEach(rp => {
let other = rp.car;
// Filter check handled in drawing, but for physics we also need to check mode
if (rp.mode !== this.gameMode) return;

if (this.player.getHitbox().collideRect(other.getHitbox())) {
// Physics Bounce
let pCenter = this.player.pos;
let oCenter = other.pos;
let bounceVec = pCenter.sub(oCenter).normalize();
if (bounceVec.mag() === 0) bounceVec = new Vector2(1, 0); // Prevent NaN
// Push player away
this.player.vel = this.player.vel.add(bounceVec.mult(2.0)); // Bounce intensity
// Visuals
for(let k=0; k<5; k++) this.particles.push(new Particle((pCenter.x+oCenter.x)/2, (pCenter.y+oCenter.y)/2, 'spark'));
}
});
// Cops
this.cops.forEach((cop, i) => {
// Apply slow mo to cops
let originalVel = cop.vel;
cop.vel = cop.vel.mult(dt);
// --- MODIFIED: Police Target Logic ---
// Cops chase the person if walking, or the car if driving
let chaseTarget = (this.isWalking && this.playerPed) ? this.playerPed : this.player;
cop.updateCop(chaseTarget, this.buildings, this.ghostlyRiderActive);
cop.vel = cop.vel.mult(1/dt); // Restore velocity magnitude for physics calc
if (dt < 1.0) cop.pos = cop.pos.sub(cop.vel.mult(1 - dt));
// Cop collision
if (cop.getHitbox().collideRect(this.player.getHitbox())) {
if ((this.player.id === 'tank' && this.powerActive) || (this.player.id === 'monster' && this.powerActive) || (this.player.id === 'dozer' && this.powerActive)) {
// Juggernaut/Crush: Destroy cop
cop.dead = true;
this.score += 50;
for(let k=0; k<15; k++) this.particles.push(new Particle(cop.pos.x, cop.pos.y, 'spark'));
} else if (this.player.id === 'gold' && this.powerActive) {
// Midas: Turn to gold
cop.dead = true;
this.score += 500;
for(let k=0; k<20; k++) this.particles.push(new Particle(cop.pos.x, cop.pos.y, 'gold'));
} else if (!this.ghostlyRiderActive && !this.player.isPhasing && !this.player.isFlying) {
// ONLY DAMAGE CAR IF PLAYER IS INSIDE
if (!this.isWalking) {
this.player.health.takeDamage(30);
let bounce = this.player.pos.sub(cop.pos).normalize().mult(5);
this.player.vel = this.player.vel.add(bounce);
cop.vel = cop.vel.sub(bounce);
for(let k=0; k<5; k++) this.particles.push(new Particle(this.player.pos.x, this.player.pos.y, 'spark'));
}
} else {
// Phase shift or ghostly rider
if (!this.player.isPhasing && !this.isWalking && !this.player.isFlying) this.player.health.takeDamage(5);
}
}
// --- NEW: Cop vs Player Pedestrian Collision ---
if (this.isWalking && this.playerPed && !cop.dead) {
// Check if cop hits player ped
// Cop hitbox vs Ped rect
if (cop.getHitbox().collideRect(this.playerPed.rect)) {
// Instant Death
for(let k=0; k<5; k++) {
this.blood.push(new Blood(this.playerPed.pos.x + randInt(-10,10), this.playerPed.pos.y + randInt(-10,10)));
}
this.state = 'GAMEOVER';
}
}
// Cop vs Cop
for (let j=i+1; j<this.cops.length; j++) {
let other = this.cops[j];
if (cop.pos.distanceTo(other.pos) < 45) {
cop.dead = true; other.dead = true;
this.score += 100;
for(let k=0; k<15; k++) this.particles.push(new Particle(cop.pos.x, cop.pos.y, 'spark'));
}
}
});
this.cops = this.cops.filter(c => !c.dead);
// Civilians
this.civilians.forEach((civ, i) => {
if (dt < 1.0) civ.pos = civ.pos.sub(civ.vel.mult(1 - dt)); // Slow mo
civ.updateCivilian(this.buildings, this.civilians, this.player);
// --- MODIFIED: Civ vs Player Logic ---
if (civ.getHitbox().collideRect(this.player.getHitbox())) {
if (this.player.id === 'gold' && this.powerActive) {
civ.dead = true; // technically cars dont have dead flag logic in update but we filter below
this.score += 200;
for(let k=0; k<10; k++) this.particles.push(new Particle(civ.pos.x, civ.pos.y, 'gold'));
// Hack to remove civ
this.civilians.splice(i, 1);
return;
}
if (!this.player.isPhasing && !this.isWalking && !this.player.isFlying) { // Only damage car if player inside
this.player.health.takeDamage(5);
let pCenter = this.player.pos;
let cCenter = civ.pos;
let bounceVec = pCenter.sub(cCenter).normalize();
this.player.vel = this.player.vel.add(bounceVec.mult(4));
civ.vel = civ.vel.sub(bounceVec.mult(4));
for(let k=0; k<3; k++) this.particles.push(new Particle(this.player.pos.x + randInt(-10,10), this.player.pos.y + randInt(-10,10), 'spark'));
if (!civ.hitOnce) {
this.score += 10;
civ.hitOnce = true;
}
}
}
// --- NEW: Civilian vs Player Pedestrian Collision ---
if (this.isWalking && this.playerPed) {
if (civ.getHitbox().collideRect(this.playerPed.rect)) {
// If moving fast enough to kill
if (civ.vel.mag() > 1.0) {
for(let k=0; k<5; k++) {
this.blood.push(new Blood(this.playerPed.pos.x + randInt(-10,10), this.playerPed.pos.y + randInt(-10,10)));
}
this.state = 'GAMEOVER';
}
}
}
});
// People
this.people.forEach(p => p.update(this.player, this.blood));
// Particles
this.particles.forEach((p,i) => { p.update(); if(p.life<=0) this.particles.splice(i,1); });
// Smoke
if (this.player.health.parts['front_torso'] <= 0 && Math.random() < 0.3) {
this.particles.push(new Particle(this.player.pos.x, this.player.pos.y, 'smoke'));
}
// Game Over Check
if (this.player.health.checkFullyDestroyed()) {
this.saveData(); // Save score
this.state = 'GAMEOVER';
}
}
drawFloor() {
if (this.gameMode === 'BOMB_PASS') {
const mapSize = 4000;
const halfSize = mapSize / 2;
const view = this.camera.viewRect;
const bs = BLOCK_SIZE;
// Determine bounds of drawing based on view
const startX = Math.floor((view.left + halfSize) / bs) * bs - halfSize;
const endX = Math.ceil((view.right + halfSize) / bs) * bs - halfSize;
const startY = Math.floor((view.top + halfSize) / bs) * bs - halfSize;
const endY = Math.ceil((view.bottom + halfSize) / bs) * bs - halfSize;
for (let x = startX; x < endX; x += bs) {
for (let y = startY; y < endY; y += bs) {
// Only draw if inside map bounds
if (x >= -halfSize && x < halfSize && y >= -halfSize && y < halfSize) {
this.ctx.drawImage(grassPatternCanvas, x + this.camera.offset.x, y + this.camera.offset.y);
} else {
// Draw void or dark grass outside bounds
}
}
}
return;
}
const bs = BLOCK_SIZE;
const view = this.camera.viewRect;
const startGx = Math.floor(view.left / bs) - 1;
const endGx = Math.floor(view.right / bs) + 1;
const startGy = Math.floor(view.top / bs) - 1;
const endGy = Math.floor(view.bottom / bs) + 1;
for (let gx = startGx; gx < endGx; gx++) {
for (let gy = startGy; gy < endGy; gy++) {
let isRoadX = (gx % 3 === 0);
let isRoadY = (gy % 3 === 0);
let sx = gx * bs + this.camera.offset.x;
let sy = gy * bs + this.camera.offset.y;
if (isRoadX || isRoadY) {
this.ctx.drawImage(roadPatternCanvas, sx, sy);
this.ctx.fillStyle = COLORS.PAINT_WHITE;
if (isRoadY) {
this.ctx.fillRect(sx, sy+10, bs, 3);
this.ctx.fillRect(sx, sy+bs-10, bs, 3);
}
if (isRoadX) {
this.ctx.fillRect(sx+10, sy, 3, bs);
this.ctx.fillRect(sx+bs-10, sy, 3, bs);
}
this.ctx.fillStyle = COLORS.PAINT_YELLOW;
if (isRoadY && !isRoadX) {
for(let i=0; i<bs; i+=40) this.ctx.fillRect(sx+i+10, sy+bs/2, 20, 3);
}
if (isRoadX && !isRoadY) {
for(let i=0; i<bs; i+=40) this.ctx.fillRect(sx+bs/2, sy+i+10, 3, 20);
}
if (isRoadX && isRoadY) {
this.ctx.fillStyle = '#fff';
const stripeW = 8;
const stripeGap = 8;
for (let i = 20; i < bs - 20; i += stripeW + stripeGap) {
this.ctx.fillRect(sx + i, sy + 20, stripeW, 40);
this.ctx.fillRect(sx + i, sy + bs - 60, stripeW, 40);
}
for (let i = 20; i < bs - 20; i += stripeW + stripeGap) {
this.ctx.fillRect(sx + 20, sy + i, 40, stripeW);
this.ctx.fillRect(sx + bs - 60, sy + i, 40, stripeW);
}
}
}
}
}
}
drawIndicators() {
const cx = this.canvas.width/2;
const cy = this.canvas.height/2;
const pad = 20;
// Skip drawing if ghostly rider is active
if (this.ghostlyRiderActive) return;
this.cops.forEach(cop => {
let dist = this.player.pos.distanceTo(cop.pos);
if (dist > 1500) return;
let screenPos = this.camera.apply(cop.getRect());
if (screenPos.x > 0 && screenPos.x < this.canvas.width && screenPos.y > 0 && screenPos.y < this.canvas.height) return;
let dx = cop.pos.x - this.player.pos.x;
let dy = cop.pos.y - this.player.pos.y;
if (dx===0) dx=0.1; if (dy===0) dy=0.1;
let scale = Math.min(Math.abs((cx-pad)/dx), Math.abs((cy-pad)/dy));
let dxDraw = cx + dx * scale;
let dyDraw = cy + dy * scale;
this.ctx.fillStyle = '#ff3232';
this.ctx.beginPath(); this.ctx.arc(dxDraw, dyDraw, 14, 0, Math.PI*2); this.ctx.fill();
this.ctx.strokeStyle = '#fff'; this.ctx.lineWidth=2; this.ctx.stroke();
this.ctx.fillStyle = '#fff'; this.ctx.font = 'bold 16px Arial'; this.ctx.textAlign='center'; this.ctx.textBaseline='middle';
this.ctx.fillText("!", dxDraw, dyDraw);
});
}
drawCRT(ctx, w, h, intensity = 1.0) {
// 1. Scanlines (Stripes)
ctx.fillStyle = `rgba(0, 0, 0, ${0.3 * intensity})`; // Darker
for (let i = 0; i < h; i += 3) {
ctx.fillRect(0, i, w, 1);
}
// 2. Moving Scan Bar (Rolling shutter effect)
this.scanlineY = (this.scanlineY || 0) + 1.5;
if (this.scanlineY > h) this.scanlineY = 0;
ctx.fillStyle = `rgba(255, 255, 255, ${0.07 * intensity})`;
ctx.fillRect(0, this.scanlineY, w, 50);
// 3. Vignette (Dark corners)
let grad = ctx.createRadialGradient(w/2, h/2, h/3, w/2, h/2, h);
grad.addColorStop(0, "rgba(0,0,0,0)");
grad.addColorStop(1, `rgba(0,0,0,${0.6 * intensity})`);
ctx.fillStyle = grad;
ctx.fillRect(0, 0, w, h);
// 4. Noise (Static)
// For performance, let's just do a flickering overlay.
if (Math.random() > 0.8) {
ctx.fillStyle = `rgba(255, 255, 255, ${Math.random() * 0.05 * intensity})`;
ctx.fillRect(0, 0, w, h);
}
}
drawSettings(ctx, w, h) {
ctx.save();
ctx.fillStyle = 'rgba(20, 20, 30, 0.95)';
ctx.fillRect(0, 0, w, h);
ctx.textAlign = 'center';
const cx = w / 2;
const cy = h / 2;
// Container Block
let contW = 500;
let contH = 450;
drawRect(ctx, '#444', cx - contW/2, cy - contH/2, contW, contH, 10);
drawRect(ctx, '#222', cx - contW/2 + 5, cy - contH/2 + 5, contW - 10, contH - 10, 8);
ctx.fillStyle = '#fff';
ctx.font = '30px "Press Start 2P", cursive';
ctx.fillText("SETTINGS", cx, cy - 160);
// Reset Progress Button
let btnW = 350;
let btnH = 50;
this.resetProgressRect = new Rect(cx - btnW/2, cy - 80, btnW, btnH);
drawRect(ctx, '#000', this.resetProgressRect.x, this.resetProgressRect.y, btnW, btnH, 5);
drawRect(ctx, '#c83232', this.resetProgressRect.x+4, this.resetProgressRect.y+4, btnW-8, btnH-8, 5);
ctx.fillStyle = '#fff';
ctx.font = '20px "Press Start 2P", cursive';
ctx.fillText("RESET PROGRESS", cx, cy - 50);
// TV Toggle Button
this.tvToggleRect = new Rect(cx - btnW/2, cy - 10, btnW, btnH);
drawRect(ctx, '#000', this.tvToggleRect.x, this.tvToggleRect.y, btnW, btnH, 5);
drawRect(ctx, this.tvMode ? COLORS.NEON_GREEN : '#555', this.tvToggleRect.x+4, this.tvToggleRect.y+4, btnW-8, btnH-8, 5);
ctx.fillStyle = '#fff';
ctx.fillText(`TV EFFECTS: ${this.tvMode ? "ON" : "OFF"}`, cx, cy + 20);
// DEVICE TOGGLE
this.deviceToggleRect = new Rect(cx - btnW/2, cy + 60, btnW, btnH);
drawRect(ctx, '#000', this.deviceToggleRect.x, this.deviceToggleRect.y, btnW, btnH, 5);
drawRect(ctx, this.deviceMode === 'MOBILE' ? COLORS.NEON_CYAN : '#555', this.deviceToggleRect.x+4, this.deviceToggleRect.y+4, btnW-8, btnH-8, 5);
ctx.fillStyle = '#fff';
ctx.fillText(`DEVICE: ${this.deviceMode}`, cx, cy + 90);
// Back Button
this.backRect = new Rect(cx - btnW/2, cy + 130, btnW, btnH);
drawRect(ctx, '#000', this.backRect.x, this.backRect.y, btnW, btnH, 5);
drawRect(ctx, '#505050', this.backRect.x+4, this.backRect.y+4, btnW-8, btnH-8, 5);
ctx.fillStyle = '#fff';
ctx.fillText("BACK", cx, cy + 160);
// Confirmation Modal Overlay
if (this.showResetConfirm) {
ctx.fillStyle = 'rgba(0,0,0,0.8)';
ctx.fillRect(0,0,w,h);
let mw = 400, mh = 250;
drawRect(ctx, '#222', cx - mw/2, cy - mh/2 , mw, mh, 10);
drawRect(ctx, '#f00', cx - mw/2, cy - mh/2 , mw, 5);
ctx.fillStyle = '#fff';
ctx.font = '18px "Press Start 2P", cursive';
ctx.fillText("ARE YOU SURE?", cx, cy - 40);
ctx.font = '12px "Press Start 2P", cursive';
ctx.fillStyle = '#aaa';
ctx.fillText("This cannot be undone.", cx, cy - 10);
let bw = 120, bh = 50;
this.confirmYesRect = new Rect(cx - bw - 20, cy + 40, bw, bh);
this.confirmNoRect = new Rect(cx + 20, cy + 40, bw, bh);
drawRect(ctx, '#fff', this.confirmYesRect.x, this.confirmYesRect.y, bw, bh, 5);
drawRect(ctx, '#900', this.confirmYesRect.x+2, this.confirmYesRect.y+2, bw-4, bh-4, 5);
ctx.fillStyle = '#fff'; ctx.fillText("YES", cx - bw/2 - 20, cy + 72);
drawRect(ctx, '#fff', this.confirmNoRect.x, this.confirmNoRect.y, bw, bh, 5);
drawRect(ctx, '#333', this.confirmNoRect.x+2, this.confirmNoRect.y+2, bw-4, bh-4, 5);
ctx.fillStyle = '#fff'; ctx.fillText("NO", cx + bw/2 + 20, cy + 72);
}
this.drawCRT(ctx, w, h);
ctx.restore();
}
drawMenu(ctx, w, h) {
ctx.save();
// Title: TOKYO
ctx.textAlign = 'center';
const cx = w / 2;
const cy = h / 2;
// Glitch Offset
let jx = randInt(-2, 2);
let jy = randInt(-2, 2);
// "TOKYO"
ctx.font = '40px "Press Start 2P", cursive';
let grad = ctx.createLinearGradient(0, cy - 180, 0, cy - 140);
grad.addColorStop(0, '#ffffff');
grad.addColorStop(1, '#ffcccc');
ctx.fillStyle = '#000';
ctx.fillText("TOKYO", cx + 4 + jx, cy - 120 + 4 + jy);
ctx.fillStyle = grad;
ctx.fillText("TOKYO", cx + jx, cy - 120 + jy);
// "DRIFT"
ctx.font = '60px "Press Start 2P", cursive';
ctx.fillStyle = '#000';
ctx.fillText("DRIFT", cx + 5 - jx, cy - 50 + 5 - jy);
ctx.fillStyle = '#d32f2f'; // Red
ctx.fillText("DRIFT", cx - jx, cy - 50 - jy);
// "- CHASE -"
ctx.font = '25px "Press Start 2P", cursive';
ctx.fillStyle = '#000';
ctx.fillText("- CHASE -", cx + 3, cy + 10 + 3);
ctx.fillStyle = '#ffeb3b'; // Yellow
ctx.fillText("- CHASE -", cx, cy + 10);
// High Score
ctx.font = '20px "Press Start 2P", cursive';
ctx.textAlign = 'left';
ctx.fillStyle = '#fff';
ctx.fillText(`HIGH SCORE: ${this.highScore}`, 20, 40);
ctx.textAlign = 'center';
// Button: SELECT RIDE
let btnW = 320;
let btnH = 60;
this.playRect = new Rect(cx - btnW/2, cy + 60, btnW, btnH);
// Button Shadow
ctx.fillStyle = '#000';
ctx.fillRect(this.playRect.x + 8, this.playRect.y + 8, btnW, btnH);
// Button Border
ctx.fillStyle = '#000';
ctx.fillRect(this.playRect.x - 4, this.playRect.y - 4, btnW + 8, btnH + 8);
// Button Fill (Red)
ctx.fillStyle = '#d32f2f';
ctx.fillRect(this.playRect.x, this.playRect.y, btnW, btnH);
// Button Text
ctx.fillStyle = '#fff';
ctx.font = '24px "Press Start 2P", cursive';
ctx.fillText("SELECT RIDE", cx, this.playRect.y + 40);
// Button: SETTINGS
this.settingsRect = new Rect(cx - btnW/2, cy + 140, btnW, btnH);
ctx.fillStyle = '#000';
ctx.fillRect(this.settingsRect.x + 8, this.settingsRect.y + 8, btnW, btnH);
ctx.fillStyle = '#000';
ctx.fillRect(this.settingsRect.x - 4, this.settingsRect.y - 4, btnW + 8, btnH + 8);
ctx.fillStyle = '#505050';
ctx.fillRect(this.settingsRect.x, this.settingsRect.y, btnW, btnH);
ctx.fillStyle = '#fff';
ctx.fillText("SETTINGS", cx, this.settingsRect.y + 40);
// Instruction Text
ctx.font = '14px "Press Start 2P", cursive';
ctx.fillStyle = '#fff';
ctx.fillText("PRESS [WASD] TO DRIVE", cx, h - 40);
// Scanlines Overlay
this.drawCRT(ctx, w, h);
ctx.restore();
}
drawCarSelection(ctx, w, h) {
ctx.save();
const cx = w / 2;
const cy = h / 2;
// Background overlay
ctx.fillStyle = 'rgba(20, 20, 30, 0.9)';
ctx.fillRect(0, 0, w, h);
// Title
ctx.font = '30px "Press Start 2P", cursive';
ctx.textAlign = 'center';
ctx.fillStyle = '#fff';
ctx.fillText("SELECT YOUR VEHICLE", cx, cy - 200);
const carSpec = PLAYER_ROSTER[this.selectedCarIndex];
// Check Locked
let isLocked = false;
if (carSpec.unlockScore && this.highScore < carSpec.unlockScore) {
isLocked = true;
}
// --- DRAW PREVIEW CAR (SCALED UP) ---
let previewCar = new Car(0, 0, isLocked ? '#222' : carSpec.color, false, false);
previewCar.type = carSpec.type;
previewCar.id = carSpec.id; // Important for preview
previewCar.hasSpoiler = carSpec.hasSpoiler;
previewCar.sprite = previewCar.createCarSprite();
const scale = 4;
const pW = previewCar.width * scale;
const pH = previewCar.height * scale;
// Draw Car Shadow
ctx.fillStyle = 'rgba(0,0,0,0.5)';
ctx.beginPath(); ctx.ellipse(cx, cy - 50 + pH/2, pW/2 + 20, 20, 0, 0, Math.PI*2); ctx.fill();
ctx.imageSmoothingEnabled = false;
ctx.drawImage(previewCar.sprite, cx - pW/2, cy - 50 - pH/2, pW, pH);
if (isLocked) {
ctx.font = '40px "Press Start 2P", cursive';
ctx.fillStyle = '#f00';
ctx.fillText("LOCKED", cx, cy - 50);
ctx.font = '14px "Press Start 2P", cursive';
ctx.fillText(`NEED ${carSpec.unlockScore} HIGH SCORE`, cx, cy - 20);
}
// --- CAR INFO ---
// Arrows
ctx.font = '40px "Press Start 2P", cursive';
ctx.fillStyle = '#ffeb3b';
ctx.fillText("<", cx - 200, cy - 50);
ctx.fillText(">", cx + 200, cy - 50);
// Name
ctx.font = '24px "Press Start 2P", cursive';
ctx.fillStyle = isLocked ? '#555' : COLORS.NEON_CYAN;
ctx.fillText(carSpec.name, cx, cy + 60);
// Desc
ctx.font = '14px "Press Start 2P", cursive';
ctx.fillStyle = '#aaa';
ctx.fillText(carSpec.desc, cx, cy + 90);
// --- STATS BARS ---
const drawStat = (label, value, max, yPos) => {
const barW = 200;
const barH = 15;
const xPos = cx - barW/2;
ctx.textAlign = 'right';
ctx.fillStyle = '#fff';
ctx.font = '12px "Press Start 2P", cursive';
ctx.fillText(label, xPos - 10, yPos + 12);
// BG
ctx.fillStyle = '#333';
ctx.fillRect(xPos, yPos, barW, barH);
// Fill
const fillW = (value / max) * barW;
ctx.fillStyle = value > max * 0.7 ? COLORS.HP_GREEN : (value > max * 0.4 ? COLORS.HP_YELLOW : COLORS.HP_RED);
ctx.fillRect(xPos, yPos, fillW, barH);
};
drawStat("SPEED", carSpec.stats.speed, 12.0, cy + 130);
drawStat("HANDLING", carSpec.stats.turn, 6.0, cy + 155);
drawStat("ARMOR", carSpec.stats.hp, 200, cy + 180);
// --- DRIVE BUTTON ---
let btnW = 200;
let btnH = 50;
this.selectRect = new Rect(cx - btnW/2, h - 100, btnW, btnH);
drawRect(ctx, '#fff', this.selectRect.x, this.selectRect.y, btnW, btnH, 5);
drawRect(ctx, isLocked ? '#333' : COLORS.NEON_PINK, this.selectRect.x+2, this.selectRect.y+2, btnW-4, btnH-4, 5);
ctx.textAlign = 'center';
ctx.fillStyle = isLocked ? '#888' : '#fff';
ctx.font = '20px "Press Start 2P", cursive';
ctx.fillText(isLocked ? "LOCKED" : "SELECT", cx, h - 68);
// Show High Score
ctx.font = '12px "Press Start 2P", cursive';
ctx.fillStyle = '#fff';
ctx.fillText(`HIGH SCORE: ${this.highScore}`, cx, h - 20);
this.drawCRT(ctx, w, h);
ctx.restore();
}
drawModeSelection(ctx, w, h) {
ctx.save();
const cx = w / 2;
const cy = h / 2;
// Background overlay
ctx.fillStyle = 'rgba(20, 20, 30, 0.9)';
ctx.fillRect(0, 0, w, h);
// Title
ctx.font = '40px "Press Start 2P", cursive';
ctx.textAlign = 'center';
ctx.fillStyle = '#fff';
ctx.fillText("MODE", cx, cy - 120);
// Buttons
let btnW = 350;
let btnH = 70;
let gap = 30;
this.modeSelectPoliceRect = new Rect(cx - btnW/2, cy - 40, btnW, btnH);
this.modeSelectBombRect = new Rect(cx - btnW/2, cy + 40 + gap, btnW, btnH);
// POLICE RUN Button
drawRect(ctx, '#fff', this.modeSelectPoliceRect.x, this.modeSelectPoliceRect.y, btnW, btnH, 5);
drawRect(ctx, COLORS.NEON_BLUE, this.modeSelectPoliceRect.x+2, this.modeSelectPoliceRect.y+2, btnW-4, btnH-4, 5);
ctx.fillStyle = '#fff';
ctx.font = '20px "Press Start 2P", cursive';
ctx.fillText("POLICE RUN", cx, cy + 5);
// BOMB PASS Button
drawRect(ctx, '#fff', this.modeSelectBombRect.x, this.modeSelectBombRect.y, btnW, btnH, 5);
drawRect(ctx, COLORS.NEON_PINK, this.modeSelectBombRect.x+2, this.modeSelectBombRect.y+2, btnW-4, btnH-4, 5);
ctx.fillStyle = '#fff';
ctx.fillText("BOMB PASS", cx, cy + 85 + gap);
// Description for selected
ctx.font = '12px "Press Start 2P", cursive';
ctx.fillStyle = '#aaa';
ctx.fillText("Classic Chase Mode", cx, cy - 50);
ctx.fillText("Arena Mode - Multiplayer Only", cx, cy + 30 + gap);
this.drawCRT(ctx, w, h);
ctx.restore();
}
drawAchievementPopUp(ctx, w, h) {
const popupH = 60;
const popupW = 380;
const cornerPad = 20;
this.achievements.forEach((ach, index) => {
// New Sliding Animation Logic
// Timer starts at 180 (3s)
// 180 -> 150: Slide In (0.5s)
// 150 -> 30: Hold (2s)
// 30 -> 0: Slide Out (0.5s)
let xOffset = 0;
if (ach.timer > 150) {
// Slide In (lerp from width to 0 offset)
let t = (180 - ach.timer) / 30; // 0 to 1
// Ease out cubic
t = 1 - Math.pow(1 - t, 3);
xOffset = (1 - t) * (popupW + cornerPad);
} else if (ach.timer < 30) {
// Slide Out
let t = (30 - ach.timer) / 30; // 0 to 1
// Ease in cubic
t = t * t * t;
xOffset = t * (popupW + cornerPad);
} else {
xOffset = 0;
}
let x = w - popupW - cornerPad + xOffset;
let y = h - popupH - (cornerPad + index * (popupH + 10));
ctx.save();
// --- Custom Styling: Cooler Box ---
drawRect(ctx, 'rgba(0, 0, 0, 0.9)', x + 5, y + 5, popupW, popupH, 5);
drawRect(ctx, 'rgba(255, 255, 255, 0.2)', x - 2, y - 2, popupW + 4, popupH + 4, 7);
drawRect(ctx, 'rgba(10, 10, 10, 0.95)', x, y, popupW, popupH, 5);
drawRect(ctx, COLORS.NEON_CYAN, x, y, popupW, 8);
ctx.fillStyle = COLORS.NEON_PINK;
drawRect(ctx, ctx.fillStyle, x + 12, y + 15, 30, 30);
ctx.font = '10px "Press Start 2P", cursive';
ctx.fillStyle = '#fff';
ctx.textAlign = 'left';
ctx.fillText("ACHIEVEMENT UNLOCKED", x + 50, y + 23);
ctx.font = '14px "Press Start 2P", cursive';
ctx.fillStyle = COLORS.NEON_CYAN;
ctx.fillText(ach.name, x + 50, y + 45);
ctx.restore();
});
}
drawSkillInventory(ctx, w, h) {
const boxSize = 60;
const pad = 10;
const baseY = h - boxSize - 10;
const centerX = w / 2;
let x = centerX;
let inventory = [];
if (this.hasGhostlyRider) inventory.push({
name: "Ghostly Rider",
key: "[X]",
active: this.ghostlyRiderActive,
cooldown: this.ghostlyRiderCooldown,
cooldownMax: this.ghostlyRiderCooldownMax,
color: '#32ffff' // Cyan/Blue
});
if (this.hasFireWheel) inventory.push({
name: "Fire Wheel",
key: "[C]",
active: this.fireWheelActive,
cooldown: this.fireWheelCooldown,
cooldownMax: this.fireWheelCooldownMax,
color: '#ff6432' // Orange/Red
});
// Show Unique Z Power
if (this.player.powerData) {
inventory.push({
name: this.player.powerData.name,
key: "[Z]",
active: this.zPressed || this.powerActive,
cooldown: this.powerCooldown,
cooldownMax: this.player.powerData.cooldown,
color: this.player.powerData.color
});
}
x -= (inventory.length * boxSize + (inventory.length - 1) * pad) / 2;
inventory.forEach((skill, index) => {
let boxX = x + index * (boxSize + pad);
ctx.save();
// Outer Border
drawRect(ctx, '#000', boxX - 2, baseY - 2, boxSize + 4, boxSize + 4);
// Inner Background
drawRect(ctx, 'rgba(30, 30, 30, 0.9)', boxX, baseY, boxSize, boxSize);
// Draw Pixel Art Icon
this.drawSkillIcon(ctx, skill, boxX, baseY, boxSize);
// Cooldown Overlay
if (skill.cooldown > 0) {
let cooldownPercent = skill.cooldown / skill.cooldownMax;
let cooldownH = boxSize * cooldownPercent;
ctx.globalAlpha = 0.7;
drawRect(ctx, 'rgba(0, 0, 0, 0.9)', boxX, baseY + boxSize - cooldownH, boxSize, cooldownH);
ctx.globalAlpha = 1.0;
// Cooldown timer text
ctx.font = '14px "Press Start 2P", cursive';
ctx.fillStyle = '#fff';
ctx.fillText(Math.ceil(skill.cooldown / FPS), boxX + boxSize/2, baseY + boxSize/2 + 5);
}
// Active Indicator
if (skill.active) {
ctx.strokeStyle = skill.color;
ctx.lineWidth = 4;
ctx.strokeRect(boxX, baseY, boxSize, boxSize);
}
// Keybind Text
ctx.font = '10px "Press Start 2P", cursive';
ctx.fillStyle = '#fff';
ctx.textAlign = 'center';
ctx.fillText(skill.key, boxX + boxSize/2, baseY + boxSize - 5);
ctx.restore();
});
}
// Helper function to draw the pixel art icons inside the skill box
drawSkillIcon(ctx, skill, boxX, baseY, boxSize) {
const cx = boxX + boxSize / 2;
const cy = baseY + boxSize / 2;
if (skill.name === "Ghostly Rider" || skill.name === "Phase Shift" || skill.name === "Warp Speed") {
ctx.save();
ctx.globalAlpha = 0.6;
ctx.fillStyle = skill.color;
ctx.fillRect(cx - 15, cy - 5, 20, 10);
ctx.globalAlpha = 1.0;
ctx.fillStyle = '#fff';
ctx.fillRect(cx - 5, cy - 15, 10, 10);
ctx.fillStyle = skill.color;
ctx.fillRect(cx - 4, cy - 14, 8, 2);
ctx.fillRect(cx - 4, cy - 10, 8, 2);
ctx.fillStyle = '#000';
ctx.fillRect(cx - 2, cy - 12, 1, 1);
ctx.fillRect(cx + 1, cy - 12, 1, 1);
ctx.restore();
} else if (skill.name === "Fire Wheel" || skill.name === "Flamethrower") {
ctx.save();
ctx.fillStyle = '#ffeb3b';
ctx.beginPath();
ctx.moveTo(cx - 5, cy - 10);
ctx.lineTo(cx + 5, cy - 10);
ctx.lineTo(cx, cy - 2);
ctx.fill();
ctx.fillStyle = '#ff6432';
ctx.fillRect(cx - 3, cy - 7, 6, 5);
ctx.fillStyle = '#e0e0e0';
ctx.fillRect(cx - 6, cy - 1, 12, 6);
ctx.fillRect(cx - 4, cy + 5, 8, 3);
ctx.fillStyle = '#000';
ctx.fillRect(cx - 4, cy + 1, 2, 2);
ctx.fillRect(cx + 2, cy + 1, 2, 2);
ctx.fillRect(cx - 1, cy + 4, 2, 1);
ctx.restore();
} else if (skill.name === "Smite" || skill.name === "EMP Blast" || skill.name === "Pulse Ram" || skill.name === "Hellfire" || skill.name === "Siren Wail") {
ctx.save();
ctx.fillStyle = skill.color;
ctx.beginPath();
ctx.arc(cx, cy, 10, 0, Math.PI*2);
ctx.stroke();
ctx.lineWidth = 3;
ctx.strokeStyle = '#fff';
ctx.stroke();
ctx.restore();
} else if (skill.name === "Repair") {
ctx.save();
ctx.fillStyle = '#fff';
ctx.fillRect(cx - 3, cy - 8, 6, 16);
ctx.fillRect(cx - 8, cy - 3, 16, 6);
ctx.restore();
} else if (skill.name === "Oil Slick") {
ctx.save();
ctx.fillStyle = '#111';
ctx.beginPath(); ctx.ellipse(cx, cy, 12, 6, 0, 0, Math.PI*2); ctx.fill();
ctx.fillStyle = '#555';
ctx.beginPath(); ctx.ellipse(cx - 2, cy - 2, 4, 2, 0, 0, Math.PI*2); ctx.fill();
ctx.restore();
} else if (skill.name === "Juggernaut" || skill.name === "Smash" || skill.name === "Demolition") {
ctx.save();
ctx.fillStyle = skill.color;
ctx.fillRect(cx - 10, cy - 10, 20, 20);
ctx.strokeStyle = '#fff'; ctx.lineWidth=2;
ctx.strokeRect(cx-10, cy-10, 20, 20);
ctx.restore();
} else if (skill.name === "Midas Touch") {
ctx.save();
ctx.fillStyle = '#ffd700';
ctx.beginPath(); ctx.arc(cx, cy, 8, 0, Math.PI*2); ctx.fill();
ctx.fillStyle = '#fff';
ctx.font = '10px "Press Start 2P"'; ctx.fillText("$", cx-3, cy+3);
ctx.restore();
} else if (skill.name === "Bullet Time" || skill.name === "Rewind") {
ctx.save();
ctx.strokeStyle = '#fff'; ctx.lineWidth=2;
ctx.beginPath(); ctx.arc(cx, cy, 10, 0, Math.PI*2); ctx.stroke();
ctx.beginPath(); ctx.moveTo(cx, cy); ctx.lineTo(cx, cy-6); ctx.stroke();
ctx.beginPath(); ctx.moveTo(cx, cy); ctx.lineTo(cx+4, cy+2); ctx.stroke();
ctx.restore();
} else if (skill.name === "Abduct") {
ctx.save();
ctx.fillStyle = '#39ff14';
ctx.beginPath(); ctx.moveTo(cx, cy-10); ctx.lineTo(cx-8, cy+10); ctx.lineTo(cx+8, cy+10); ctx.fill();
ctx.restore();
} else if (skill.name === "Light Wall" || skill.name === "Sticky Goo" || skill.name === "Landmines") {
ctx.save();
ctx.fillStyle = skill.color;
ctx.fillRect(cx - 8, cy + 2, 16, 4);
ctx.fillRect(cx - 4, cy - 6, 8, 8);
ctx.restore();
} else if (skill.name === "Takeoff" || skill.name === "Bunny Hop") {
ctx.save();
ctx.fillStyle = skill.color;
ctx.beginPath(); ctx.moveTo(cx, cy-10); ctx.lineTo(cx-10, cy+5); ctx.lineTo(cx+10, cy+5); ctx.fill();
ctx.restore();
} else if (skill.name === "Panic Siren" || skill.name === "Broadside") {
ctx.save();
ctx.fillStyle = skill.color;
ctx.beginPath(); ctx.arc(cx, cy, 10, 0, Math.PI*2); ctx.fill();
ctx.strokeStyle = '#fff'; ctx.lineWidth=1;
ctx.beginPath(); ctx.moveTo(cx, cy); ctx.lineTo(cx+15, cy-5); ctx.stroke();
ctx.beginPath(); ctx.moveTo(cx, cy); ctx.lineTo(cx+15, cy+5); ctx.stroke();
ctx.restore();
} else if (skill.name === "Shrink Ray") {
ctx.save();
ctx.fillStyle = '#0f0';
ctx.fillRect(cx-10, cy-2, 20, 4);
ctx.fillRect(cx+5, cy-6, 4, 12);
ctx.restore();
}
}
drawAchievementProgress(ctx, w, h) {
const cx = w / 2;
const baseY = 80;
ctx.save();
ctx.textAlign = 'center';
ctx.font = '16px "Press Start 2P", cursive';
// --- 1. Ghostly Rider Progress ---
if (!this.hasGhostlyRider) {
const turnResetting = this.player.isCollidingWithBuilding;
// Use cyan/white for normal progress, red/orange if failed
const turnColor = (this.turnCount > 0 && !turnResetting) ? COLORS.NEON_CYAN : COLORS.PAINT_WHITE;
if (turnResetting) {
ctx.fillStyle = COLORS.HP_RED;
} else {
ctx.fillStyle = turnColor;
}
const turnStatus = `GHOSTLY RIDER: ${Math.min(this.turnCount, 10)}/10 TURNS`;
ctx.fillText(turnStatus, cx, baseY);
if (turnResetting && this.turnCount < 10) {
ctx.font = '10px "Press Start 2P", cursive';
ctx.fillStyle = COLORS.HP_RED;
ctx.fillText("RESET! HIT BUILDING", cx, baseY + 18);
}
ctx.font = '16px "Press Start 2P", cursive'; // Restore font size
}
// --- 2. Fire Wheel Progress ---
if (!this.hasFireWheel) {
const maxFrames = 30 * FPS;
const driftSeconds = (this.driftTime / FPS);
const maxSeconds = 30.0;
let driftColor = COLORS.TEXT_WHITE;
let copHit = this.player.isCollidingWithCop;
if (this.driftTime > 0) {
// Active drift: use neon green
driftColor = COLORS.NEON_GREEN;
// But override if a cop hit occurred in the process
if (copHit) {
driftColor = COLORS.HP_RED;
}
}
const displayDrift = Math.min(driftSeconds, maxSeconds).toFixed(1);
const driftStatus = `FIRE WHEEL: ${displayDrift}/${maxSeconds.toFixed(1)} SECS DRIFTED`;
ctx.fillStyle = driftColor;
ctx.fillText(driftStatus, cx, baseY + 50);
// Add reset message if relevant
if (this.driftTime > 0 && copHit) {
ctx.font = '10px "Press Start 2P", cursive';
ctx.fillStyle = COLORS.HP_RED;
ctx.fillText("RESET! HIT COP", cx, baseY + 68);
}
ctx.font = '16px "Press Start 2P", cursive'; // Restore font size
}
ctx.restore();
}
draw(ctx) {
const w = this.canvas.width;
const h = this.canvas.height;
ctx.fillStyle = COLORS.BG_VOID;
ctx.fillRect(0, 0, w, h);
this.drawFloor();
let renderList = [
...this.blood.map(o => ({obj:o, type:'blood', y:o.pos.y})),
...this.skids.map(o => ({obj:o, type:'skid', y:o.pos.y})),
...this.floorEffects.map(o => ({obj:o, type:'floor', y:o.pos.y})), // Add fire trail here
...this.buildings.map(o => ({obj:o, type:'building', y:o.rect.bottom})),
...this.people.map(o => ({obj:o, type:'person', y:o.rect.bottom})),
...this.sakura.map(o => ({obj:o, type:'sakura', y:o.pos.y})),
...this.cops.map(o => ({obj:o, type:'car', y:o.pos.y})),
...this.civilians.map(o => ({obj:o, type:'car', y:o.pos.y})),
{obj: this.player, type:'car', y:this.player.pos.y}
];
// Add player character to render list if walking
if (this.isWalking && this.playerPed) {
renderList.push({obj: this.playerPed, type:'person', y:this.playerPed.rect.bottom});
}
renderList.sort((a,b) => a.y - b.y);
renderList.forEach(item => {
let screenRect;
if (item.type === 'car' || item.type === 'sakura' || item.type === 'floor') {
// For floor effects we need a faux rect or just use pos
if(item.obj.getRect) screenRect = this.camera.apply(item.obj.getRect());
else screenRect = this.camera.apply(new Rect(item.obj.pos.x, item.obj.pos.y, 20, 20));
}
else screenRect = this.camera.apply(item.obj.rect);
if (screenRect.right < -50 || screenRect.left > w + 50 || screenRect.bottom < -50 || screenRect.top > h + 50) return;
});
ctx.save();
ctx.translate(this.camera.offset.x, this.camera.offset.y);
// Ghostly Rider visual
if (this.ghostlyRiderActive || this.player.isPhasing) ctx.globalAlpha = 0.5;
// Draw Layer 1: Floor
this.blood.forEach(b => b.draw(ctx));
this.skids.forEach(s => s.draw(ctx));
// Draw Shockwaves
this.shockwaves.forEach(sw => sw.draw(ctx));
// Draw Layer 2: Sorted Objects (includes Fire Trails now if sorted)
renderList.forEach(item => {
// Don't draw player in menu
if ((this.state === 'MENU' || this.state === 'CAR_SELECT' || this.state === 'MODE_SELECT' || this.state === 'SETTINGS') && item.obj === this.player) return;
if (item.type === 'blood' || item.type === 'skid') return; // already drawn
// Handle Ghostly Rider transparency
if ((this.ghostlyRiderActive || this.player.isPhasing) && item.obj !== this.player && item.type === 'car') {
ctx.globalAlpha = 1.0;
item.obj.draw(ctx);
ctx.globalAlpha = 0.5;
} else {
item.obj.draw(ctx);
}
// Juggernaut Visual
if (item.obj === this.player && this.powerActive && (this.player.id === 'tank' || this.player.id === 'monster' || this.player.id === 'dozer')) {
ctx.save();
ctx.globalAlpha = 0.3;
ctx.fillStyle = '#ff0000';
ctx.beginPath();
ctx.arc(this.player.pos.x, this.player.pos.y, 40, 0, Math.PI*2);
ctx.fill();
ctx.restore();
}
// Anger bubble
if (item.type === 'person' && item.obj.isAngry && !item.obj.isDead) {
let bx = item.obj.pos.x, by = item.obj.rect.top - 15;
ctx.fillStyle = '#fff';
let txt = item.obj.curseWord;
ctx.font = 'bold 12px Arial';
let tm = ctx.measureText(txt);
let bw = tm.width + 10, bh = 20;
drawRect(ctx, '#fff', bx - bw/2, by - bh/2, bw, bh, 5);
ctx.beginPath(); ctx.moveTo(bx, by+bh/2); ctx.lineTo(bx-3, by+bh/2+4); ctx.lineTo(bx+3, by+bh/2+4); ctx.fill();
ctx.fillStyle = '#000';
ctx.textAlign = 'center';
ctx.fillText(txt, bx, by + 4);
}
});
// Draw Multiplayer Remote Players
if (this.state === 'PLAY' || this.state === 'GAMEOVER') {
// CRITICAL FIX: Pass current game mode to filter remote players so only players in the same mode are visible
this.multiplayer.draw(ctx, this.camera, this.gameMode);
}
ctx.globalAlpha = 1.0;
this.particles.forEach(p => p.draw(ctx));
ctx.restore();
if (this.state === 'PLAY' || this.state === 'GAMEOVER') {
this.drawIndicators();
ctx.fillStyle = '#fff';
ctx.font = '20px "Press Start 2P", cursive';
ctx.textAlign = 'left';
ctx.fillText(`SCORE: ${this.score}`, 20, 40);
this.player.health.drawUI(ctx, w - 60, 10);
// Draw hints for walking mechanics
if (this.state === 'PLAY') {
if (!this.isWalking && this.player.vel.mag() < 0.5) {
ctx.font = '12px "Press Start 2P", cursive';
ctx.textAlign = 'center';
ctx.fillStyle = '#fff';
ctx.fillText("[F] EXIT CAR", w/2, h - 100);
} else if (this.isWalking) {
let dist = this.playerPed.pos.distanceTo(this.player.pos);
ctx.font = '12px "Press Start 2P", cursive';
ctx.textAlign = 'center';
ctx.fillStyle = '#fff';
if (dist < 60) {
ctx.fillText("[F] ENTER CAR", w/2, h - 120);
if (this.player.health.checkFullyDestroyed() === false) {
ctx.fillStyle = '#32ff64';
ctx.fillText("[E] REPAIR", w/2, h - 100);
}
} else {
ctx.fillText("RETURN TO CAR", w/2, h - 100);
}
}
if (this.showProgress) {
this.drawAchievementProgress(ctx, w, h);
}
// DRAW MOBILE CONTROLS IF ENABLED
if (this.deviceMode === 'MOBILE') {
this.drawMobileControls(ctx, w, h);
}
}
this.drawAchievementPopUp(ctx, w, h);
this.drawSkillInventory(ctx, w, h);
// Draw TV Mode if enabled during gameplay (lower intensity)
if (this.tvMode) {
this.drawCRT(ctx, w, h, 0.4);
}
}
if (this.state === 'MENU') {
this.drawMenu(ctx, w, h);
return;
}
if (this.state === 'SETTINGS') {
this.drawSettings(ctx, w, h);
return;
}
if (this.state === 'CAR_SELECT') {
this.drawCarSelection(ctx, w, h);
return;
}
if (this.state === 'MODE_SELECT') {
this.drawModeSelection(ctx, w, h);
return;
}
if (this.state === 'GAMEOVER') {
ctx.fillStyle = 'rgba(0,0,0,0.6)';
ctx.fillRect(0, 0, w, h);
ctx.fillStyle = '#ff3232';
ctx.font = '50px "Press Start 2P", cursive';
ctx.textAlign = 'center';
ctx.fillText("WASTED", w/2, h/2 - 20);
let btnW = 220, btnH = 60;
this.restartRect = new Rect(w/2 - btnW/2, h/2 + 20, btnW, btnH);
drawRect(ctx, '#fff', this.restartRect.x, this.restartRect.y, btnW, btnH, 5);
drawRect(ctx, '#c83232', this.restartRect.x+2, this.restartRect.y+2, btnW-4, btnH-4, 5);
ctx.fillStyle = '#fff';
ctx.font = '20px "Press Start 2P", cursive';
ctx.fillText("RESTART", w/2, h/2 + 57);
}
}
loop() {
this.update();
this.draw(this.ctx);
requestAnimationFrame(this.loop);
}
}
// Start Game
const game = new Game();
</script>
</body>
  </html>

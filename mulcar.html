<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Tokyo Drift Chase - Mobile Fix</title>
<!-- Imported Pixel Font -->
<link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
<!-- MQTT.js Client Library for Serverless Multiplayer -->
<script src="https://unpkg.com/mqtt/dist/mqtt.min.js"></script>
<style>
body {
    margin: 0;
    padding: 0;
    overflow: hidden;
    background-color: #14141e; /* COLOR_BG_VOID */
    font-family: 'Press Start 2P', cursive;
    touch-action: none; /* Prevent mobile scrolling */
    -webkit-touch-callout: none;
    -webkit-user-select: none;
    user-select: none;
}
canvas {
    display: block;
    image-rendering: pixelated;
    image-rendering: crisp-edges;
}
/* ONLINE STATUS UI */
#online-ui {
    position: absolute;
    top: 20px;
    right: 20px;
    background-color: #505050;
    padding: 12px 16px;
    border-radius: 12px;
    border: 3px solid #2d2d32;
    display: flex;
    align-items: center;
    gap: 12px;
    box-shadow: 0 4px 0 rgba(0,0,0,0.5);
    pointer-events: none;
    z-index: 100;
    transition: opacity 0.3s;
}
.status-dot {
    width: 12px;
    height: 12px;
    background-color: #32ff64;
    border-radius: 50%;
    box-shadow: 0 0 8px #32ff64;
    animation: pulse 2s infinite;
}
.status-text {
    color: #ffffff;
    font-size: 12px;
    text-transform: uppercase;
    text-shadow: 2px 2px #000;
}
/* ADMIN PANEL STYLES */
#admin-panel {
    position: absolute;
    top: 80px;
    right: 20px;
    background-color: #505050;
    padding: 16px;
    border-radius: 12px;
    border: 3px solid #2d2d32;
    display: none;
    flex-direction: column;
    gap: 10px;
    box-shadow: 0 4px 0 rgba(0,0,0,0.5);
    z-index: 200;
    min-width: 200px;
}
.admin-title {
    color: #ff3232;
    font-size: 12px;
    text-align: center;
    margin-bottom: 5px;
    text-shadow: 1px 1px #000;
}
.admin-row {
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 10px;
    color: #fff;
}
.admin-row input {
    width: 70px;
    background-color: #2d2d32;
    border: 2px solid #000;
    color: #32ff64;
    font-family: 'Press Start 2P', cursive;
    font-size: 10px;
    padding: 4px;
    outline: none;
}
@keyframes pulse {
    0% { opacity: 1; transform: scale(1); }
    50% { opacity: 0.7; transform: scale(0.9); }
    100% { opacity: 1; transform: scale(1); }
}
</style>
</head>
<body>

<!-- Online UI Bubble -->
<div id="online-ui">
    <div class="status-dot"></div>
    <div class="status-text" id="online-text">online: 1</div>
</div>

<!-- Admin Panel (Toggle with 1090) -->
<div id="admin-panel">
    <div class="admin-title">ADMIN CONTROL</div>
    <div class="admin-row">
        <label>SCORE</label>
        <input type="number" id="adm-score" value="0">
    </div>
    <div class="admin-row">
        <label>SPEED</label>
        <input type="number" id="adm-speed" value="9">
    </div>
    <div class="admin-row">
        <label>ARMOR</label>
        <input type="number" id="adm-armor" value="100">
    </div>
    <div class="admin-row">
        <label>HANDLING</label>
        <input type="number" id="adm-handling" value="4">
    </div>
</div>

<canvas id="gameCanvas"></canvas>
<script>
/**
* TOKYO DRIFT CHASE - FIXED MOBILE EDITION
*/
const FPS = 60;
const BLOCK_SIZE = 380;
const BUILDING_GAP = 20;
const SPRITE_CACHE = {};

const COLORS = {
    BG_VOID: '#14141e', ASPHALT: '#2d2d32', PAINT_YELLOW: '#d2b414', PAINT_WHITE: '#dcdcdc',
    SIDEWALK: '#828287', WOOD_DARK: '#50281e', WOOD_RED: '#8c1e14', CONCRETE: '#9696a0',
    WIN_LIT_WARM: '#fff0b4', WIN_LIT_COOL: '#c8dcff', WIN_DARK: '#282832',
    SAKURA_PINK: '#ffb4c8', SAKURA_DARK: '#c8788c', ZOO_BASE: '#328c32',
    AC: '#b4b4be', PLAYER: '#dc2828', COP_BODY: '#0a0a0f', COP_DOOR: '#e6e6f0',
    HP_GREEN: '#32c832', HP_YELLOW: '#dcc832', HP_RED: '#c83232', TEXT_WHITE: '#ffffff',
    NEON_PINK: '#ff3296', NEON_BLUE: '#3296ff', NEON_CYAN: '#32ffff', NEON_GREEN: '#32ff64',
    ROOF_TILE_JP: '#3c3c46', LANTERN_RED: '#dc3232', SCHOOL_BEIGE: '#e6dcbe', CLOCK_FACE: '#ffffff'
};

const CAR_TYPES = {
    'sedan': { w: 48, h: 24, speed: 1.0, colors: ['#3c5a96', '#969696', '#dcdcdc', '#503250', '#8c2828'] },
    'coupe': { w: 44, h: 22, speed: 1.3, colors: ['#c83232', '#3264c8', '#e6e632', '#141414'] },
    'hatchback': { w: 40, h: 22, speed: 0.9, colors: ['#32965a', '#c87832', '#9696c8'] },
    'taxi': { w: 48, h: 24, speed: 1.1, colors: ['#e6af2d'] },
    'truck': { w: 56, h: 26, speed: 0.7, colors: ['#ffffff', '#32465a'] }
};

const PLAYER_ROSTER = [
    { id: 'standard', name: 'STREET LEGEND', type: 'sedan', color: '#dc2828', desc: "Balanced. [Z]: Instant Repair", stats: { speed: 9.0, turn: 4.0, accel: 0.20, hp: 100 }, hasSpoiler: true, unlockScore: 0, powerData: { name: "Repair", color: "#32c832", cooldown: 45 * 60 }, pedData: { style: 'street', shirt: '#dc2828', hair: '#000', hairStyle: 'short', ability: 'sprint', abilityColor: '#fff' } },
    { id: 'drifter', name: 'DRIFT KING', type: 'coupe', color: '#d2b414', desc: "Loose handling. [Z]: Oil Slick", stats: { speed: 10.5, turn: 4.5, accel: 0.25, hp: 80 }, hasSpoiler: true, unlockScore: 100, powerData: { name: "Oil Slick", color: "#141414", cooldown: 15 * 60 }, pedData: { style: 'hoodie', shirt: '#d2b414', hair: '#555', hairStyle: 'cap', ability: 'stealth', abilityColor: '#555' } },
    { id: 'tank', name: 'THE BEAST', type: 'truck', color: '#14141e', desc: "Heavy Armor. [Z]: Juggernaut", stats: { speed: 7.5, turn: 3.0, accel: 0.15, hp: 200 }, hasSpoiler: false, unlockScore: 200, powerData: { name: "Juggernaut", color: "#c83232", cooldown: 40 * 60 }, pedData: { style: 'military', shirt: '#3e3e3e', hair: '#000', hairStyle: 'bald', ability: 'shield', abilityColor: '#c83232' } },
    { id: 'mecha', name: 'MECHA-V', type: 'coupe', color: '#32ffff', desc: "High Tech. [Z]: EMP Blast", stats: { speed: 11.0, turn: 5.5, accel: 0.30, hp: 60 }, hasSpoiler: true, unlockScore: 350, powerData: { name: "EMP Blast", color: "#3296ff", cooldown: 30 * 60 }, pedData: { style: 'cyborg', shirt: '#32ffff', hair: '#fff', hairStyle: 'short', ability: 'shock', abilityColor: '#32ffff' } },
    { id: 'angel', name: 'SERAPHIM', type: 'coupe', color: '#ffffff', desc: "Divine. [Z]: Smite", stats: { speed: 10.0, turn: 5.0, accel: 0.22, hp: 150 }, hasSpoiler: false, unlockScore: 500, powerData: { name: "Smite", color: "#ffd700", cooldown: 60 * 60 }, pedData: { style: 'holy', shirt: '#fff', hair: '#ffd700', hairStyle: 'long', ability: 'heal_aura', abilityColor: '#ffd700' } },
    // ... New Cars logic
    { id: 'cybertruck', name: 'CYBER-X', type: 'truck', color: '#c0c0c0', desc: "Future Metal. [Z]: Pulse Ram", stats: { speed: 8.5, turn: 3.5, accel: 0.28, hp: 250 }, hasSpoiler: false, unlockScore: 650, powerData: { name: "Pulse Ram", color: "#00ffcc", cooldown: 20 * 60 }, pedData: { style: 'tech', shirt: '#c0c0c0', hair: '#888', hairStyle: 'short', ability: 'push', abilityColor: '#00ffcc' } },
    { id: 'nightshade', name: 'NIGHT SHADE', type: 'coupe', color: '#240046', desc: "Stealth. [Z]: Phase Shift", stats: { speed: 11.5, turn: 5.0, accel: 0.25, hp: 70 }, hasSpoiler: true, unlockScore: 800, powerData: { name: "Phase Shift", color: "#9d4edd", cooldown: 45 * 60 }, pedData: { style: 'ninja', shirt: '#1a0030', hair: '#000', hairStyle: 'short_messy', ability: 'phase', abilityColor: '#9d4edd' } },
    { id: 'hotrod', name: 'HELL RAISER', type: 'sedan', color: '#ff4d00', desc: "Classic Muscle. [Z]: Flamethrower", stats: { speed: 9.5, turn: 3.8, accel: 0.35, hp: 120 }, hasSpoiler: false, unlockScore: 1000, powerData: { name: "Flamethrower", color: "#ff4d00", cooldown: 10 * 60 }, pedData: { style: 'biker', shirt: '#222', hair: '#500', hairStyle: 'mohawk', ability: 'fire_trail', abilityColor: '#ff4d00' } },
    { id: 'interceptor', name: 'ENFORCER', type: 'sedan', color: '#000000', desc: "Undercover. [Z]: Siren Wail", stats: { speed: 10.8, turn: 4.2, accel: 0.26, hp: 140 }, hasSpoiler: true, unlockScore: 1200, powerData: { name: "Siren Wail", color: "#0032ff", cooldown: 30 * 60 }, pedData: { style: 'cop', shirt: '#111', hair: '#333', hairStyle: 'short', ability: 'taser', abilityColor: '#0032ff' } },
    { id: 'gold', name: 'MIDAS', type: 'coupe', color: '#ffd700', desc: "Luxury. [Z]: Midas Touch", stats: { speed: 10.0, turn: 4.0, accel: 0.22, hp: 100 }, hasSpoiler: false, unlockScore: 1500, powerData: { name: "Midas Touch", color: "#ffd700", cooldown: 50 * 60 }, pedData: { style: 'suit', shirt: '#ffd700', hair: '#fff', hairStyle: 'short', ability: 'money_shield', abilityColor: '#ffd700' } },
    { id: 'f1', name: 'FORMULA ZERO', type: 'coupe', color: '#ff0000', desc: "Track Speed. [Z]: Warp Speed", stats: { speed: 13.0, turn: 6.0, accel: 0.40, hp: 40 }, hasSpoiler: true, unlockScore: 2000, powerData: { name: "Warp Speed", color: "#00ffff", cooldown: 15 * 60 }, pedData: { style: 'racer', shirt: '#ff0000', hair: '#000', hairStyle: 'cap', ability: 'blink', abilityColor: '#00ffff' } },
    { id: 'ufo', name: 'THE VISITOR', type: 'hatchback', color: '#39ff14', desc: "Alien Tech. [Z]: Abduct", stats: { speed: 11.0, turn: 8.0, accel: 0.30, hp: 90 }, hasSpoiler: false, unlockScore: 2500, powerData: { name: "Abduct", color: "#39ff14", cooldown: 25 * 60 }, pedData: { style: 'alien', shirt: '#39ff14', hair: '#000', hairStyle: 'bald', ability: 'levitate', abilityColor: '#39ff14' } },
    { id: 'monster', name: 'CRUSHER', type: 'truck', color: '#4caf50', desc: "Big Wheels. [Z]: Smash", stats: { speed: 8.0, turn: 2.5, accel: 0.20, hp: 300 }, hasSpoiler: false, unlockScore: 3000, powerData: { name: "Smash", color: "#4caf50", cooldown: 20 * 60 }, pedData: { style: 'redneck', shirt: '#4caf50', hair: '#8d5524', hairStyle: 'long', ability: 'stomp', abilityColor: '#4caf50' } },
    { id: 'time', name: 'DELOREAN', type: 'coupe', color: '#b0b0b0', desc: "Time Travel. [Z]: Bullet Time", stats: { speed: 10.0, turn: 4.0, accel: 0.22, hp: 100 }, hasSpoiler: true, unlockScore: 4000, powerData: { name: "Bullet Time", color: "#ffffff", cooldown: 60 * 60 }, pedData: { style: 'flash', shirt: '#b80000', hair: '#e6c86e', hairStyle: 'short_messy', ability: 'flash_run', abilityColor: '#ffd700' } },
    { id: 'demon', name: 'DOOM BRINGER', type: 'sedan', color: '#1a0505', desc: "Evil. [Z]: Hellfire", stats: { speed: 11.0, turn: 4.5, accel: 0.30, hp: 666 }, hasSpoiler: true, unlockScore: 6666, powerData: { name: "Hellfire", color: "#ff0000", cooldown: 60 * 60 }, pedData: { style: 'cultist', shirt: '#000', hair: '#f0f', hairStyle: 'long', ability: 'drain', abilityColor: '#f00' } },
    { id: 'neon', name: 'NEON RIDER', type: 'coupe', color: '#000000', desc: "Digital Cycle. [Z]: Light Wall", stats: { speed: 12.0, turn: 6.5, accel: 0.35, hp: 50 }, hasSpoiler: false, unlockScore: 7000, powerData: { name: "Light Wall", color: "#00ffff", cooldown: 40 * 60 }, pedData: { style: 'cyborg', shirt: '#000', hair: '#0ff', hairStyle: 'short', ability: 'sprint', abilityColor: '#0ff' } },
    { id: 'icecream', name: 'MR. FREEZE', type: 'truck', color: '#ffffff', desc: "Sweet. [Z]: Sticky Goo", stats: { speed: 8.5, turn: 3.5, accel: 0.20, hp: 150 }, hasSpoiler: false, unlockScore: 7500, powerData: { name: "Sticky Goo", color: "#ff69b4", cooldown: 30 * 60 }, pedData: { style: 'clown', shirt: '#fff', hair: '#f0f', hairStyle: 'afro', ability: 'shield', abilityColor: '#f0f' } },
    { id: 'dozer', name: 'CONSTRUCTO', type: 'truck', color: '#ffcc00', desc: "Heavy Duty. [Z]: Demolition", stats: { speed: 7.0, turn: 2.5, accel: 0.15, hp: 350 }, hasSpoiler: false, unlockScore: 8000, powerData: { name: "Demolition", color: "#ffcc00", cooldown: 45 * 60 }, pedData: { style: 'worker', shirt: '#ffcc00', hair: '#555', hairStyle: 'cap', ability: 'stomp', abilityColor: '#ffcc00' } },
    { id: 'rocket', name: 'STARSHIP', type: 'coupe', color: '#cccccc', desc: "Space Age. [Z]: Takeoff", stats: { speed: 12.5, turn: 4.0, accel: 0.32, hp: 60 }, hasSpoiler: true, unlockScore: 8500, powerData: { name: "Takeoff", color: "#ff4400", cooldown: 25 * 60 }, pedData: { style: 'astro', shirt: '#ccc', hair: '#000', hairStyle: 'bald', ability: 'levitate', abilityColor: '#ff4400' } },
    { id: 'ambulance', name: 'LIFESAVER', type: 'truck', color: '#ffffff', desc: "Emergency. [Z]: Panic Siren", stats: { speed: 9.5, turn: 3.8, accel: 0.25, hp: 180 }, hasSpoiler: false, unlockScore: 9000, powerData: { name: "Panic Siren", color: "#ff0000", cooldown: 35 * 60 }, pedData: { style: 'medic', shirt: '#fff', hair: '#555', hairStyle: 'short', ability: 'heal_aura', abilityColor: '#f00' } },
    { id: 'wasteland', name: 'WASTELANDER', type: 'sedan', color: '#8b4513', desc: "Rusty. [Z]: Landmines", stats: { speed: 9.0, turn: 4.0, accel: 0.28, hp: 130 }, hasSpoiler: false, unlockScore: 9500, powerData: { name: "Landmines", color: "#ff8800", cooldown: 20 * 60 }, pedData: { style: 'raider', shirt: '#533', hair: '#000', hairStyle: 'mohawk', ability: 'fire_trail', abilityColor: '#f80' } },
    { id: 'hover', name: 'AG-RACER', type: 'coupe', color: '#8800ff', desc: "Anti-Grav. [Z]: Bunny Hop", stats: { speed: 11.5, turn: 7.0, accel: 0.30, hp: 70 }, hasSpoiler: false, unlockScore: 10000, powerData: { name: "Bunny Hop", color: "#aa00ff", cooldown: 5 * 60 }, pedData: { style: 'pilot', shirt: '#80f', hair: '#fff', hairStyle: 'short', ability: 'blink', abilityColor: '#a0f' } },
    { id: 'pirate', name: 'BLACK PEARL', type: 'sedan', color: '#3e2723', desc: "Cursed. [Z]: Broadside", stats: { speed: 9.0, turn: 3.0, accel: 0.20, hp: 200 }, hasSpoiler: false, unlockScore: 11000, powerData: { name: "Broadside", color: "#000000", cooldown: 15 * 60 }, pedData: { style: 'pirate', shirt: '#000', hair: '#000', hairStyle: 'long', ability: 'sprint', abilityColor: '#000' } },
    { id: 'nano', name: 'NANO-TECH', type: 'hatchback', color: '#00ff00', desc: "Micro. [Z]: Shrink Ray", stats: { speed: 10.0, turn: 5.0, accel: 0.25, hp: 80 }, hasSpoiler: false, unlockScore: 12000, powerData: { name: "Shrink Ray", color: "#0f0", cooldown: 40 * 60 }, pedData: { style: 'scientist', shirt: '#fff', hair: '#aaa', hairStyle: 'bald', ability: 'shock', abilityColor: '#0f0' } },
    { id: 'chronos', name: 'CHRONOS', type: 'sedan', color: '#cd7f32', desc: "Steampunk. [Z]: Rewind", stats: { speed: 9.5, turn: 3.5, accel: 0.22, hp: 120 }, hasSpoiler: false, unlockScore: 13000, powerData: { name: "Rewind", color: "#cd7f32", cooldown: 30 * 60 }, pedData: { style: 'steampunk', shirt: '#a65', hair: '#543', hairStyle: 'short_messy', ability: 'flash_run', abilityColor: '#da0' } }
];

const ACCELERATION = 0.20;
const FRICTION = 0.96;
const TURN_SPEED = 4.0;
const DRIFT_SLIDE = 0.99;
const MAX_SPEED_PLAYER = 9.0;
const MAX_SPEED_COP = 10.2;
const MAX_SPEED_CIVILIAN_BASE = 6.0;

// --- Utility Classes ---
class Vector2 {
    constructor(x, y) { this.x = x; this.y = y; }
    add(v) { return new Vector2(this.x + v.x, this.y + v.y); }
    sub(v) { return new Vector2(this.x - v.x, this.y - v.y); }
    mult(n) { return new Vector2(this.x * n, this.y * n); }
    mag() { return Math.sqrt(this.x * this.x + this.y * this.y); }
    normalize() { let m = this.mag(); return m === 0 ? new Vector2(0, 0) : new Vector2(this.x / m, this.y / m); }
    dot(v) { return this.x * v.x + this.y * v.y; }
    rotate(angleDegrees) {
        let rad = angleDegrees * Math.PI / 180;
        return new Vector2(this.x * Math.cos(rad) - this.y * Math.sin(rad), this.x * Math.sin(rad) + this.y * Math.cos(rad));
    }
    distanceTo(v) { return Math.sqrt((this.x - v.x)**2 + (this.y - v.y)**2); }
    lerp(v, t) { return new Vector2(this.x + (v.x - this.x) * t, this.y + (v.y - this.y) * t); }
}

class Rect {
    constructor(x, y, w, h) { this.x = x; this.y = y; this.w = w; this.h = h; }
    get left() { return this.x; }
    get right() { return this.x + this.w; }
    get top() { return this.y; }
    get bottom() { return this.y + this.h; }
    get centerx() { return this.x + this.w / 2; }
    get centery() { return this.y + this.h / 2; }
    set centerx(v) { this.x = v - this.w / 2; }
    set centery(v) { this.y = v - this.h / 2; }
    collidePoint(px, py) { return px >= this.x && px <= this.x + this.w && py >= this.y && py <= this.y + this.h; }
    collideRect(other) { return this.x < other.x + other.w && this.x + this.w > other.x && this.y < other.y + other.h && this.y + this.h > other.y; }
    inflate(dw, dh) { return new Rect(this.x - dw/2, this.y - dh/2, this.w + dw, this.h + dh); }
}

class SeededRNG {
    constructor(seed) { this.seed = seed; }
    next() { this.seed = (this.seed * 9301 + 49297) % 233280; return this.seed / 233280; }
    randInt(min, max) { return Math.floor(this.next() * (max - min + 1)) + min; }
    randFloat(min, max) { return this.next() * (max - min) + min; }
    choice(arr) { return arr[Math.floor(this.next() * arr.length)]; }
}

function randInt(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; }
function randFloat(min, max) { return Math.random() * (max - min) + min; }
function randChoice(arr) { return arr[Math.floor(Math.random() * arr.length)]; }
function degToRad(deg) { return deg * Math.PI / 180; }

function drawRect(ctx, color, x, y, w, h, radius = 0) {
    ctx.fillStyle = color;
    ctx.beginPath();
    if (radius > 0) ctx.roundRect ? ctx.roundRect(x, y, w, h, radius) : ctx.rect(x, y, w, h);
    else ctx.rect(x, y, w, h);
    ctx.fill();
}
function drawCircle(ctx, color, x, y, r) {
    ctx.fillStyle = color; ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI * 2); ctx.fill();
}

function createRoadTexture(size) {
    const cvs = document.createElement('canvas'); cvs.width = size; cvs.height = size;
    const ctx = cvs.getContext('2d'); ctx.fillStyle = COLORS.ASPHALT; ctx.fillRect(0, 0, size, size);
    for (let i = 0; i < 800; i++) {
        const c = randInt(35, 55); ctx.fillStyle = `rgb(${c},${c},${c+5})`;
        ctx.fillRect(randInt(0, size), randInt(0, size), 2, 2);
    }
    const mx = size/2; const my = size/2;
    ctx.fillStyle = '#46464b'; ctx.beginPath(); ctx.arc(mx, my, 14, 0, Math.PI*2); ctx.fill();
    return cvs;
}
const roadPatternCanvas = createRoadTexture(BLOCK_SIZE);

// --- Game Objects ---
class Camera {
    constructor() { this.offset = new Vector2(0, 0); this.viewRect = new Rect(0, 0, 0, 0); }
    update(target, gameW, gameH, zoom = 1.0) {
        const targetX = -target.pos.x + (gameW / 2) / zoom;
        const targetY = -target.pos.y + (gameH / 2) / zoom;
        this.offset.x += (targetX - this.offset.x) * 0.1;
        this.offset.y += (targetY - this.offset.y) * 0.1;
        this.viewRect = new Rect(-this.offset.x - 600, -this.offset.y - 600, (gameW / zoom) + 1200, (gameH / zoom) + 1200);
    }
    apply(rect) { return new Rect(rect.x + this.offset.x, rect.y + this.offset.y, rect.w, rect.h); }
}

class CarHealth {
    constructor(maxHp = 100) {
        this.maxHp = maxHp;
        this.parts = { 'front_torso': maxHp, 'back_torso': maxHp, 'fl_wheel': maxHp, 'fr_wheel': maxHp, 'rl_wheel': maxHp, 'rr_wheel': maxHp };
    }
    getColor(hp) { return hp > this.maxHp * 0.5 ? COLORS.HP_GREEN : (hp > 0 ? COLORS.HP_YELLOW : COLORS.HP_RED); }
    checkFullyDestroyed() { for (let key in this.parts) if (this.parts[key] > 0) return false; return true; }
    takeDamage(amount) {
        let aliveKeys = Object.keys(this.parts).filter(k => this.parts[k] > 0);
        if (aliveKeys.length > 0) this.parts[randChoice(aliveKeys)] -= amount;
    }
    drawUI(ctx, x, y) {
        const s = 2.5; const wBody = 16 * s; const cx = x + wBody / 2;
        // Simple visualization
        ctx.fillStyle = this.getColor(this.parts['front_torso']);
        ctx.fillRect(cx - wBody/2, y, wBody, 14*s);
        ctx.strokeStyle = '#000'; ctx.strokeRect(cx - wBody/2, y, wBody, 14*s);
    }
}

class Car {
    constructor(x, y, typeOrColor, isCop=false, isCivilian=false) {
        this.pos = new Vector2(x, y); this.vel = new Vector2(0, 0); this.angle = 0;
        this.rotDirection = 0; this.accInput = 0; this.isCop = isCop; this.isCivilian = isCivilian;
        this.id = null; this.width = 48; this.height = 24; this.speedTrait = 1.0;
        this.color = '#fff'; this.type = 'sedan'; this.hasSpoiler = false;
        // Tracking
        this.isCollidingWithBuilding = false; this.isCollidingWithCop = false;
        this.dead = false; this.isPhasing = false;
        if (isCivilian) {
            this.type = typeOrColor || 'sedan';
            const stats = CAR_TYPES[this.type]; this.width = stats.w; this.height = stats.h;
            this.color = randChoice(stats.colors); this.speedTrait = stats.speed * randFloat(0.85, 1.15);
        } else if (isCop) { this.color = COLORS.COP_BODY; this.speedTrait = 1.2; }
        else { this.color = typeOrColor; this.health = new CarHealth(100); }
        this.sprite = this.createCarSprite();
        // Civ specifics
        this.targetHeading = null; this.blockedTimer = 0; this.laneSwitchDir = 0; this.cooldownTimer = 0;
        this.reversing = false; this.stuckTimer = 0;
    }
    createCarSprite() {
        let cacheKey = this.id + '-' + this.color + '-' + this.isCop + '-' + this.isCivilian;
        if (SPRITE_CACHE[cacheKey]) return SPRITE_CACHE[cacheKey];
        const cvs = document.createElement('canvas');
        let pad = (this.id === 'angel' || this.id === 'demon' || this.id === 'ufo') ? 20 : 0;
        cvs.width = this.width + pad*2; cvs.height = this.height + pad*2;
        const ctx = cvs.getContext('2d'); ctx.imageSmoothingEnabled = false; ctx.translate(pad, pad);
        const w = this.width, h = this.height;
        
        ctx.fillStyle = 'rgba(0,0,0,0.4)'; ctx.fillRect(4, 6, w-2, h-6); // Shadow
        // Wheels
        ctx.fillStyle = '#191919';
        [[w-12, 1], [w-12, h-5], [10, 1], [10, h-5]].forEach(([tx, ty]) => ctx.fillRect(tx, ty, 10, 4));
        // Body
        ctx.fillStyle = this.color; ctx.fillRect(2, 3, w-4, h-6);
        // Cabin
        ctx.fillStyle = '#2d3c46'; ctx.fillRect(12, 5, 20, h-10); // Windshield area
        if (this.isCop) { ctx.fillStyle = '#fff'; ctx.fillRect(14, 3, 18, h-6); } // Door
        // Lights
        ctx.fillStyle = '#e6e6e6'; ctx.fillRect(w-5, 4, 4, 4); ctx.fillRect(w-5, h-9, 4, 4);
        ctx.fillStyle = '#800000'; ctx.fillRect(1, 4, 3, 5); ctx.fillRect(1, h-11, 3, 5);

        SPRITE_CACHE[cacheKey] = cvs; return cvs;
    }
    getRect() { return new Rect(this.pos.x - this.width/2, this.pos.y - this.height/2, this.width, this.height); }
    getHitbox() { return new Rect(this.pos.x - (this.width-10)/2, this.pos.y - (this.height-10)/2, this.width-10, this.height-10); }

    checkSensors(allCars, player, buildings) {
        let results = { front: false, rightClear: true, leftClear: true, frontDist: 999 };
        const rad = degToRad(this.angle);
        const forward = new Vector2(Math.cos(rad), -Math.sin(rad));
        // Simple front ray
        let start = this.pos; let end = start.add(forward.mult(200));
        let others = [...allCars]; if(player) others.push(player);
        for(let obj of others) {
            if(obj === this) continue;
            let d = this.pos.distanceTo(obj.pos);
            if(d < 200 && obj.pos.sub(this.pos).dot(forward) > 0) {
                results.front = true; results.frontDist = d;
            }
        }
        return results;
    }

    physics(buildings, drift, fireWheelActive) {
        let turnSpeed = this.customTurnSpeed || TURN_SPEED;
        let maxSpeed = this.customMaxSpeed || (this.isCop ? MAX_SPEED_COP : MAX_SPEED_PLAYER);
        let acceleration = this.customAccel || ACCELERATION;
        if(this.isCivilian) maxSpeed *= this.speedTrait;
        if(fireWheelActive) { maxSpeed *= 1.5; acceleration *= 2; }
        
        let acc = this.accInput;
        if (this.rotDirection !== 0 && this.vel.mag() > 0.5) {
            let rad = degToRad(this.angle);
            let dot = this.vel.dot(new Vector2(Math.cos(rad), -Math.sin(rad)));
            this.angle -= this.rotDirection * turnSpeed * (dot > 0 ? 1 : -1);
        }
        let rad = degToRad(this.angle);
        let forward = new Vector2(Math.cos(rad), -Math.sin(rad));
        this.vel = this.vel.add(forward.mult(acc));
        let speed = this.vel.mag();
        if (drift && speed > 3) this.vel = this.vel.mult(DRIFT_SLIDE);
        else {
            if (speed > 0.1) this.vel = this.vel.lerp(forward.mult(speed * (this.vel.dot(forward)>0?1:-1)), 0.12).mult(FRICTION);
            else if (Math.abs(acc) < 0.01) this.vel = new Vector2(0,0);
        }
        if (this.vel.mag() > maxSpeed) this.vel = this.vel.normalize().mult(maxSpeed);
        this.pos = this.pos.add(this.vel);

        // Collisions
        if(this.isPhasing || this.isFlying) return;
        let hb = this.getHitbox();
        this.isCollidingWithBuilding = false;
        for(let b of buildings) {
            if(hb.collideRect(b.rect)) {
                this.isCollidingWithBuilding = true;
                let dx = hb.centerx - b.rect.centerx; let dy = hb.centery - b.rect.centery;
                if(Math.abs(dx) > Math.abs(dy)) { this.pos.x += dx>0?5:-5; this.vel.x *= -0.5; }
                else { this.pos.y += dy>0?5:-5; this.vel.y *= -0.5; }
                hb = this.getHitbox();
                if(this.isCivilian) { this.reversing = !this.reversing; this.stuckTimer = 0; }
            }
        }
    }

    updateCop(target, buildings, isGhostly) {
        if(!this.isCop) return;
        if(isGhostly) { this.accInput = 0.1; this.physics(buildings, false, false); return; }
        let diff = target.pos.add(target.vel.mult(25)).sub(this.pos);
        if(this.vel.mag() < 1) this.stuckTimer++; else this.stuckTimer = 0;
        if(this.stuckTimer > 50) this.reversing = true;
        if(this.stuckTimer > 90) { this.reversing = false; this.stuckTimer = 0; }
        
        if(this.reversing) { this.accInput = -ACCELERATION*0.6; this.rotDirection = 1; }
        else {
            this.accInput = ACCELERATION * 0.98;
            let targetAngle = Math.atan2(-diff.y, diff.x) * 180 / Math.PI;
            let diffAng = (targetAngle - this.angle + 540) % 360 - 180;
            this.rotDirection = diffAng > 8 ? -1 : (diffAng < -8 ? 1 : 0);
        }
        this.physics(buildings, false, false);
    }

    updateCivilian(buildings, allCars, player) {
        if(!this.isCivilian) return;
        let sensors = this.checkSensors(allCars, player, buildings);
        let braking = false;
        if(sensors.front && sensors.frontDist < 100) braking = true;
        
        if(this.vel.mag() < 0.5 && !braking) this.stuckTimer++; else this.stuckTimer = 0;
        if(this.stuckTimer > 100) this.reversing = true;
        if(this.stuckTimer > 150) { this.reversing = false; this.stuckTimer = 0; this.angle += 45; }

        if(this.reversing) { this.accInput = -0.1; this.rotDirection = -1; }
        else if(braking) { this.accInput = -0.3; }
        else {
            this.accInput = ACCELERATION * 0.4;
            // Lane follow
            let cx = Math.floor(this.pos.x/BLOCK_SIZE)*BLOCK_SIZE + BLOCK_SIZE/2;
            let cy = Math.floor(this.pos.y/BLOCK_SIZE)*BLOCK_SIZE + BLOCK_SIZE/2;
            let tx = this.pos.x, ty = this.pos.y;
            if(this.targetHeading === 0) ty = cy - 80;
            else if(this.targetHeading === 180) ty = cy + 80;
            else if(this.targetHeading === 90) tx = cx + 80;
            else if(this.targetHeading === 270) tx = cx - 80;
            let diff = new Vector2(tx, ty).sub(this.pos);
            if(this.targetHeading === 0 || this.targetHeading === 180) diff.x += (this.targetHeading===0?150:-150);
            else diff.y += (this.targetHeading===90?150:-150);
            let desired = Math.atan2(-diff.y, diff.x)*180/Math.PI;
            let dang = (desired - this.angle + 540)%360 - 180;
            this.rotDirection = dang > 4 ? -1 : (dang < -4 ? 1 : 0);
        }
        this.physics(buildings, false, false);
    }

    draw(ctx) {
        ctx.save(); ctx.translate(this.pos.x, this.pos.y); ctx.rotate(-degToRad(this.angle));
        ctx.drawImage(this.sprite, -this.width/2, -this.height/2);
        ctx.restore();
    }
}

class Person {
    constructor(x, y, walkArea, isPlayer=false, config=null) {
        this.pos = new Vector2(x, y); this.isPlayer = isPlayer;
        this.vel = new Vector2(0,0); this.angle = 0; this.walkArea = walkArea;
        this.rect = new Rect(x-7, y-7, 14, 14); this.frame = 0;
        this.moveSpeed = 3.5;
        this.shirtColor = isPlayer ? (config && config.shirt ? config.shirt : '#f00') : '#fff';
        if(!isPlayer) {
            let rad = randFloat(0, Math.PI*2);
            this.vel = new Vector2(Math.cos(rad), Math.sin(rad)).mult(0.4);
            this.angle = -rad*180/Math.PI;
        }
    }
    update(playerCar) {
        if(this.isPlayer) {
            this.rect.centerx = this.pos.x; this.rect.centery = this.pos.y;
            if(this.vel.mag() > 0.1) { this.frame += 0.2; this.angle = Math.atan2(this.vel.y, this.vel.x)*180/Math.PI; }
            return;
        }
        // AI Logic
        if(this.walkArea) {
             let fut = this.pos.add(this.vel.mult(5));
             if(!this.walkArea.collidePoint(fut.x, fut.y)) { this.vel = this.vel.rotate(180); this.angle += 180; }
        }
        this.pos = this.pos.add(this.vel);
        this.rect.centerx = this.pos.x; this.rect.centery = this.pos.y;
        this.frame += 0.2;
    }
    draw(ctx) {
        ctx.save(); ctx.translate(this.pos.x, this.pos.y); ctx.rotate(-degToRad(this.angle-90));
        let w = Math.sin(this.frame*0.8)*4;
        ctx.fillStyle = '#222'; ctx.fillRect(-6, w-2, 4, 6); ctx.fillRect(2, -w-2, 4, 6); // Legs
        ctx.fillStyle = this.shirtColor; ctx.fillRect(-6, -4, 12, 10); // Body
        ctx.fillStyle = '#ffdbac'; ctx.fillRect(-4, -8, 8, 7); // Head
        ctx.restore();
    }
}

class Building {
    constructor(gx, gy, isPark) {
        this.gx = gx; this.gy = gy;
        let x = gx*BLOCK_SIZE + BLOCK_SIZE/2; let y = gy*BLOCK_SIZE + BLOCK_SIZE/2;
        this.w = BLOCK_SIZE - 40; this.h = BLOCK_SIZE - 40;
        this.rect = new Rect(x-this.w/2, y-this.h/2, this.w, this.h);
        this.pos = new Vector2(x,y);
        this.color = isPark ? '#328c32' : '#737378';
    }
    draw(ctx) {
        ctx.fillStyle = this.color;
        ctx.fillRect(this.rect.x, this.rect.y, this.rect.w, this.rect.h);
        ctx.fillStyle = 'rgba(0,0,0,0.2)'; // Details
        ctx.fillRect(this.rect.x+10, this.rect.y+10, this.rect.w-20, this.rect.h-20);
    }
}

class Particle {
    constructor(x, y, type) {
        this.pos = new Vector2(x, y); this.type = type; this.life = 20;
        this.vel = new Vector2(randFloat(-2,2), randFloat(-2,2));
        this.color = type==='fire'?'#f00' : (type==='smoke'?'#555':'#fff');
        this.size = randInt(2,6);
    }
    update() { this.pos = this.pos.add(this.vel); this.life--; }
    draw(ctx) { ctx.fillStyle=this.color; ctx.fillRect(this.pos.x, this.pos.y, this.size, this.size); }
}

// --- MULTIPLAYER ---
class RemoteCar extends Car {
    constructor(id, x, y, carTypeIndex, name) {
        let config = PLAYER_ROSTER[carTypeIndex] || PLAYER_ROSTER[0];
        super(x, y, config.color, false, false);
        this.remoteId = id; this.playerName = name || "Guest";
        this.targetPos = new Vector2(x, y); this.targetAngle = 0;
        this.type = config.type; this.id = config.id; this.sprite = this.createCarSprite();
    }
    interpolate() {
        this.pos = this.pos.lerp(this.targetPos, 0.1);
        let diff = (this.targetAngle - this.angle + 540) % 360 - 180;
        this.angle += diff * 0.1;
    }
    draw(ctx) {
        super.draw(ctx);
        ctx.save(); ctx.translate(this.pos.x, this.pos.y);
        ctx.fillStyle = "rgba(0,0,0,0.5)"; ctx.fillRect(-30, -40, 60, 16);
        ctx.fillStyle = "#fff"; ctx.textAlign = "center"; ctx.font = "10px 'Press Start 2P'";
        ctx.fillText(this.playerName, 0, -28); ctx.restore();
    }
}

class MultiplayerManager {
    constructor() {
        this.client = null; this.remotePlayers = {}; this.myId = 'p_' + Math.random().toString(36).substr(2, 9);
        this.lastPublish = 0; this.topicBase = 'tokyo_drift_chase_v1/global/';
    }
    connect() {
        this.client = mqtt.connect('wss://broker.emqx.io:8084/mqtt');
        this.client.on('connect', () => { this.client.subscribe(this.topicBase + '#'); });
        this.client.on('message', (topic, message) => {
            const senderId = topic.split('/').pop();
            if (senderId === this.myId) return;
            try { this.handleUpdate(senderId, JSON.parse(message.toString())); } catch (e) {}
        });
    }
    handleUpdate(id, data) {
        if (!this.remotePlayers[id]) this.remotePlayers[id] = { car: new RemoteCar(id, data.x, data.y, data.t, data.n), lastSeen: Date.now() };
        else {
            const p = this.remotePlayers[id]; p.lastSeen = Date.now();
            p.car.targetPos = new Vector2(data.x, data.y); p.car.targetAngle = data.a;
        }
    }
    update(player) {
        const now = Date.now();
        if (this.client && this.client.connected && now - this.lastPublish > 50) {
            this.client.publish(this.topicBase + this.myId, JSON.stringify({
                x: Math.round(player.pos.x), y: Math.round(player.pos.y), a: Math.round(player.angle),
                t: player.selectedCarIndex, n: "Racer " + this.myId.substr(0,4).toUpperCase()
            }));
            this.lastPublish = now;
        }
        for (const id in this.remotePlayers) {
            if (now - this.remotePlayers[id].lastSeen > 5000) delete this.remotePlayers[id];
            else this.remotePlayers[id].car.interpolate();
        }
        document.getElementById('online-text').innerText = "online: " + (1 + Object.keys(this.remotePlayers).length);
    }
    draw(ctx, camera) {
        for (const id in this.remotePlayers) this.remotePlayers[id].car.draw(ctx);
    }
}

// --- Main Game Class ---
class Game {
    constructor() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.ctx.imageSmoothingEnabled = false;
        this.resize();
        window.addEventListener('resize', () => this.resize());

        // Inputs
        this.keys = {};
        this.kPressed = false;
        this.zPressed = false;
        this.leftPressed = false;
        this.rightPressed = false;
        this.fPressed = false;
        this.ePressed = false;
        window.addEventListener('keydown', e => this.keys[e.key.toLowerCase()] = true);
        window.addEventListener('keyup', e => this.keys[e.key.toLowerCase()] = false);
        this.canvas.addEventListener('mousedown', e => this.onClick(e));

        // --- NEW ROBUST TOUCH SETUP ---
        this.activeTouches = new Map(); 
        this.stickOrigin = null;
        this.stickCurrent = null;
        
        // Auto-Detect Mobile
        this.deviceMode = ('ontouchstart' in window || navigator.maxTouchPoints > 0) ? 'MOBILE' : 'PC';
        
        this.canvas.addEventListener('touchstart', e => this.handleTouch(e), {passive: false});
        this.canvas.addEventListener('touchmove', e => this.handleTouch(e), {passive: false});
        this.canvas.addEventListener('touchend', e => this.handleTouch(e), {passive: false});
        this.canvas.addEventListener('touchcancel', e => this.handleTouch(e), {passive: false});

        // Game State
        this.state = 'MENU';
        this.selectedCarIndex = 0;
        this.score = 0;
        this.highScore = 0;
        this.achievements = [];
        
        // Buttons
        this.playRect = new Rect(0,0,0,0);
        this.selectRect = new Rect(0,0,0,0);
        this.settingsRect = new Rect(0,0,0,0);
        this.restartRect = new Rect(0,0,0,0);
        this.backRect = new Rect(0,0,0,0);
        this.resetProgressRect = new Rect(0,0,0,0);
        this.confirmYesRect = new Rect(0,0,0,0);
        this.confirmNoRect = new Rect(0,0,0,0);
        this.showResetConfirm = false;

        // Mechanics
        this.hasGhostlyRider = false;
        this.hasFireWheel = false;
        this.ghostlyRiderActive = false; this.fireWheelActive = false;
        this.powe

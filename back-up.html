<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Gas Laws Game</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Montserrat:wght@300;600;700&display=swap');

    /* Base styles & main menu */
    html {
      height: 100%; /* Ensures html takes full height for body's min-height reference */
    }
    body {
      margin: 0;
      padding: 0;
      /* height: 100%; - Removed to allow body to expand */
      font-family: 'Montserrat', sans-serif;
      background: #1a0a3a;
      overflow-y: auto; /* Allow vertical scrolling for the entire page */
      color: white;
    }
    #particleCanvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      z-index: 0;
      pointer-events: none;
    }
    #mainMenu {
      position: relative;
      z-index: 1;
      min-height: 100vh; /* Changed from height to min-height for scrollability */
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      /* overflow: hidden; - Removed for scrollability */
    }
    #mainMenu h1 {
      font-weight: 600;
      font-size: 4rem;
      margin-bottom: 0.3em;
      letter-spacing: 5px;
      /* Rainbow effect */
      background: linear-gradient(90deg, #ff0000, #ff7f00, #ffff00, #00ff00, #0000ff, #4b0082, #9400d3);
      background-size: 200% 100%;
      animation: rainbowBackground 3s linear infinite;
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
      color: transparent; /* Fallback */
    }
    #mainMenu h3 {
      font-weight: 300;
      font-size: 1.2rem;
      margin-bottom: 2em;
      /* Rainbow effect */
      background: linear-gradient(90deg, #ff0000, #ff7f00, #ffff00, #00ff00, #0000ff, #4b0082, #9400d3);
      background-size: 200% 100%;
      animation: rainbowBackground 3s linear infinite;
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
      color: transparent; /* Fallback */
    }
    #mainMenu button {
      background: #ff5a5f;
      border: none;
      border-radius: 50px;
      color: white;
      font-size: 1.5rem;
      padding: 16px 80px;
      margin: 12px 0;
      cursor: pointer;
      box-shadow: 0 4px 8px rgba(255, 90, 95, 0.4);
      transition: background-color .3s;
    }
    #mainMenu button:hover {
      background: #ff7a7f;
    }

    /* Gameplay screens */
    .gameMode {
      display: none;
      position: relative;
      z-index: 1; /* Changed to 1 to be below memberPage */
      min-height: 100vh; /* Changed from height to min-height for scrollability */
      padding: 20px;
      background: #111; /* Default dark background for game modes */
      /* overflow: auto; - Removed, body now handles overflow */
      box-sizing: border-box;
      color: white;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start; /* Align content to the top */
      padding-top: 20px; /* Add some top padding */
      padding-bottom: 20px; /* Add some bottom padding */
      gap: 15px; /* Spacing between direct flex children */
    }

    /* Member Page */
    #memberPage {
        display: none; /* Hidden by default */
        position: relative;
        z-index: 2; /* Higher z-index to be above game modes */
        min-height: 100vh; /* Changed from height to min-height for scrollability */
        padding: 20px;
        background: #1a0a3a; /* Darker background for member page */
        /* overflow: auto; - Removed */
        box-sizing: border-box;
        color: white;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        text-align: center;
    }
    #memberPage h2 {
        font-weight: 700; /* Made bolder */
        font-size: 3.5rem; /* Slightly larger */
        margin-bottom: 40px;
        color: #9400d3; /* Purple color */
        /* Enhanced glow effect */
        text-shadow: 0 0 10px rgba(148, 0, 211, 0.8),
                     0 0 20px rgba(148, 0, 211, 0.6),
                     0 0 30px rgba(148, 0, 211, 0.4);
        animation: pulseGlow 2s infinite alternate; /* Added pulse animation */
    }
    @keyframes pulseGlow {
        0% { text-shadow: 0 0 10px rgba(148, 0, 211, 0.8), 0 0 20px rgba(148, 0, 211, 0.6); }
        100% { text-shadow: 0 0 15px rgba(148, 0, 211, 1), 0 0 25px rgba(148, 0, 211, 0.8), 0 0 35px rgba(148, 0, 211, 0.6); }
    }
    #memberPage ul {
        list-style: none;
        padding: 0;
        margin: 0 0 40px 0;
        max-width: 500px; /* Limit width for better readability */
        width: 100%;
    }
    #memberPage li {
        font-size: 1.6rem; /* Slightly smaller for balance with new effects */
        font-weight: 300;
        margin: 15px 0;
        color: #e0e0e0; /* Softer white */
        text-shadow: 0 0 5px rgba(255,255,255,0.2);
        padding: 10px 0;
        border-bottom: 1px solid rgba(255,255,255,0.1); /* Subtle separator */
        transition: all 0.3s ease-in-out; /* Smooth transitions for hover effects */
        position: relative; /* For custom bullet */
        padding-left: 30px; /* Space for custom bullet */
        text-align: left; /* Align text left within list item */
    }
    #memberPage li:last-child {
        border-bottom: none; /* No border for the last item */
    }
    #memberPage li:hover {
        color: #aaffaa; /* Light green on hover */
        text-shadow: 0 0 8px rgba(170, 255, 170, 0.7), 0 0 15px rgba(170, 255, 170, 0.5); /* Green glow */
        transform: translateX(5px) scale(1.02); /* Slight movement and scale */
        cursor: pointer;
    }
    /* Custom bullet point */
    #memberPage li::before {
        content: 'âœ¨'; /* Sparkle emoji as bullet */
        position: absolute;
        left: 0;
        color: #ffcc00; /* Gold color for sparkle */
        font-size: 1.2em;
        line-height: 1;
        transform: translateY(-50%); /* Adjust vertical alignment */
        top: 50%;
    }

    #memberPage .return-btn {
        background: #9400d3; /* Purple button */
        box-shadow: 0 4px 8px rgba(148, 0, 211, 0.4);
    }
    #memberPage .return-btn:hover {
        background: #af00ff; /* Lighter purple on hover */
    }


    /* Boyle's Law mode: Revert background */
    #boyle {
        background-color: #111; /* Reverted to default dark background */
        background-image: none; /* Removed grid pattern */
        background-repeat: unset;
        background-size: unset;
    }
    /* Gay-Lussac mode: Specific container styling for fixed volume */
    #gayLussac .container {
        background: #333; /* Darker background for fixed container */
        border: 4px solid #4a90e2; /* Blue border for a "sealed" look */
        box-shadow: 0 0 15px rgba(74, 144, 226, 0.6); /* Blue glow */
    }
    #gayLussacCanvas {
        background: none; /* Make canvas background transparent to show container bg */
        width: 100%; /* Make canvas fill container */
        height: 100%; /* Make canvas fill container */
        flex-grow: 1; /* Allow canvas to take available space */
    }

    /* New style for all game mode titles */
    .game-mode-title {
        font-weight: 600;
        font-size: 2.8rem; /* Slightly smaller than main menu h1 */
        margin-bottom: 38px; /* Approx 1cm */
        text-align: center;
        /* Rainbow text effect (default for other modes) */
        background: linear-gradient(90deg, #ff0000, #ff7f00, #ffff00, #00ff00, #0000ff, #4b0082, #9400d3);
        background-size: 200% 100%;
        animation: rainbowBackground 3s linear infinite;
        -webkit-background-clip: text;
        background-clip: text;
        -webkit-text-fill-color: transparent;
        color: transparent; /* Fallback for browsers not supporting text-fill-color */
        z-index: 100;
    }
    /* Specific styles for Gay-Lussac title - a more "scientific/glowing" look */
    .gaylussac-title-glow {
        background: none;
        -webkit-background-clip: unset;
        background-clip: unset;
        -webkit-text-fill-color: unset;
        color: #4a90e2; /* Blue color */
        animation: none;
        text-shadow: 0 0 8px rgba(74, 144, 226, 0.8),
                     0 0 15px rgba(74, 144, 226, 0.6),
                     0 0 25px rgba(74, 144, 226, 0.4);
    }

    .container {
      background: #222;
      border-radius: 12px;
      padding: 20px;
      /* Responsive container for canvas/balloon */
      width: 90vw;
      height: 70vh;
      max-width: 400px; /* Limit max size */
      max-height: 400px; /* Limit max size */
      min-width: 280px; /* Ensure minimum size on small screens */
      min-height: 280px; /* Ensure minimum size on small screens */
      position: relative;
      display: flex;
      flex-direction: column;
      justify-content: space-between; /* Distribute items vertically */
      align-items: center;
      box-sizing: border-box; /* Include padding in width/height */
    }

    .return-btn {
      margin-top: 20px;
      padding: 10px 20px;
      font-size: 16px;
      background: #ff5a5f;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      align-self: center;
      width: 140px;
    }

    /* Shared game elements */
    .slider-container {
      margin: 15px 0;
      width: 300px; /* Fixed width, consider making this responsive too */
      max-width: 90vw; /* Responsive for small screens */
      color: #ff5a5f;
    }
    .slider-container label {
      display: block;
      margin-bottom: 6px;
      font-weight: 600;
    }
    input[type=range] {
      width: 100%;
    }
    .balloon-container {
      position: relative;
      /* Default flex-grow and min-height, will be overridden by specific modes */
      flex-grow: 1; 
      min-height: 150px; 
      margin: 10px auto;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    /* Specific adjustment for Charles's balloon container */
    #charles .balloon-container {
      flex-grow: 0; /* Prevent it from taking extra space */
      min-height: 250px; /* NEW: Ensure enough space for max Charles balloon (225px) */
      height: auto; /* Allow height to adjust based on min-height */
      margin: 20px auto; /* Added more vertical margin */
    }
    /* Specific adjustment for Charles's background molecule number */
    #charlesMoleculeBg {
      font-size: 120px; /* Smaller for Charles */
      line-height: 0; /* To prevent it from pushing elements down */
      top: 50%; /* Center vertically within its relative parent */
      transform: translate(-50%, -50%); /* True center */
      color: rgba(255, 255, 255, 0.1); /* Very subtle background color */
      text-shadow: none; /* Remove glow for background element */
      z-index: 1; /* Ensure it's behind the balloon (z-index 2) */
    }

    /* Specific adjustment for Avogadro's balloon container */
    #avogadro .balloon-container {
        flex-grow: 1; /* Allow it to take up available space within #avogadro .container */
        min-height: 350px; /* NEW: Ensure enough space for the largest Avogadro balloon (max 300px height) */
        height: auto; /* Allow height to adjust based on flex-grow and min-height */
        margin: 0; /* Reset margins from general .balloon-container to avoid pushing */
    }

    .balloon {
      background: radial-gradient(circle at 25% 25%, #ffbaba, #ff7a7f 30%, #ff5a5f 60%, #cc0000 100%);
      border-radius: 50% 50% 50% 50% / 60% 60% 40% 40%;
      box-shadow: 0 8px 20px rgba(0,0,0,0.4);
      transition: width 0.3s, height 0.3s, background 0.3s, box-shadow 0.3s, border-radius 0.3s; /* Added border-radius to transition */
      position: relative; /* Changed from absolute to relative to respect flex layout */
      z-index: 10;
      animation: floatUpDown 3s ease-in-out infinite alternate;
    }

    /* Avogadro specific max size - REMOVED, now controlled by JS calculation directly */
    /*
    #avogadroBalloon {
        max-width: 100px;
        max-height: 150px;
    }
    */

    /* Keyframes for floating animation */
    @keyframes floatUpDown {
      0% { transform: translateY(0px); }
      100% { transform: translateY(-10px); } /* Floats up 10px */
    }

    /* ::after PSEUDO-ELEMENT FOR THE BALLOON NECK */
    .balloon::after {
      content: '';
      position: absolute;
      bottom: -15px;
      left: 50%;
      transform: translateX(-50%);
      width: 15px;
      height: 20px;
      background-color: #cc0000;
      border-radius: 0 0 5px 5px;
      z-index: 9;
      box-shadow: 0 2px 5px rgba(0,0,0,0.3);
    }

    .molecule-teller-bg {
      position: absolute; /* Keep absolute for precise overlay within .balloon-container */
      left: 50%;
      top: 50%; /* Centered vertically relative to .balloon-container */
      transform: translate(-50%, -50%); /* True center */
      text-shadow: 0 0 10px rgba(255,255,255,0.7);
      user-select: none;
      font-weight: 900;
      z-index: 1; /* Lower z-index than balloon */
    }
    .molecule-teller-bg {
      font-size: 180px;
      font-weight: 900;
      opacity: 0.1;
      letter-spacing: 20px;
    }
    .molecule-counter {
      font-size: 24px;
      font-weight: 600;
      position: absolute; /* Keep absolute to position top-left */
      top: 20px;
      left: 20px;
      transform: none; /* Ensure no conflicting transforms */
      text-shadow: none;
      color: white;
      z-index: 100;
    }

    /* Avogadro specifics */
    .avogadro-increase-btn {
      background: #ff5a5f;
      border: none;
      border-radius: 30px;
      color: white;
      font-size: 1.3rem;
      padding: 12px 30px;
      cursor: pointer;
      display: block;
      /* margin-top: auto; REMOVED as it's now a direct child of gameMode flex container */
      box-shadow: 0 3px 7px rgba(255, 90, 95, 0.5);
      transition: background-color .3s;
      user-select: none;
      -webkit-tap-highlight-color: transparent; /* Prevent blue highlight on mobile tap */
    }
    .avogadro-increase-btn:hover {
      background: #ff7a7f;
    }

    /* Pop animation for main balloon */
    @keyframes betterPopAnimation {
      0% { transform: scale(1) translateY(0px); opacity: 1; border-radius: 50% / 60%; }
      30% { transform: scale(1.5) translateY(-5px); opacity: 0.8; background-color: rgba(255, 50, 50, 0.9); } /* Zoom in slightly, more visible color change */
      60% { transform: scale(2) translateY(-10px); opacity: 0.4; } /* Zoom significantly, start fading */
      100% { transform: scale(2.2) translateY(-10px); opacity: 0; border-radius: 50%; } /* Zoom out slightly more while fully faded */
    }
    .pop {
      animation: betterPopAnimation 0.6s forwards ease-out; /* Keep duration and timing */
    }

    /* Pop animation for balloon neck */
    .pop::after {
      content: ''; /* Must be present */
      animation: popNeckAnimation 0.6s forwards ease-out; /* Match parent animation */
    }
    @keyframes popNeckAnimation {
      0% { transform: translateX(-50%) scale(1); opacity: 1; }
      30% { transform: translateX(-50%) scale(1.5); opacity: 0.8; } /* Mirror main balloon zoom */
      60% { transform: translateX(-50%) scale(2); opacity: 0.4; } /* Mirror main balloon zoom and fade */
      100% { transform: translateX(-50%) scale(2.2); opacity: 0; } /* Mirror main balloon fade */
    }


    /* Rainbow button styles */
    .rainbow-button {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      display: none; /* Hidden by default */
      padding: 15px 30px;
      font-size: 1.5rem;
      font-weight: 600;
      color: white;
      border: none;
      border-radius: 50px; /* Pill shape */
      cursor: pointer;
      text-align: center;
      white-space: nowrap; /* Prevent text wrapping */

      /* Crucial: Increase z-index to ensure clickability */
      z-index: 100; /* Higher than molecule-teller-bg (z-index 1) and balloon (z-index 10) */

      /* Rainbow Gradient */
      background: linear-gradient(90deg, #ff0000, #ff7f00, #ffff00, #00ff00, #0000ff, #4b0082, #9400d3);
      background-size: 200% 100%; /* For animation */
      animation: rainbowBackground 3s linear infinite; /* Animates the gradient */

      /* LED Glow Effect */
      box-shadow: 0 0 10px #ff00ff, /* Magenta */
                  0 0 20px #00ffff, /* Cyan */
                  0 0 30px #ffff00; /* Yellow */
      transition: box-shadow 0.3s ease-in-out;
    }

    .rainbow-button:hover {
        box-shadow: 0 0 15px #ff00ff,
                    0 0 30px #00ffff,
                    0 0 45px #ffff00,
                    0 0 60px #ff00ff; /* Stronger glow on hover */
    }

    @keyframes rainbowBackground {
      0% { background-position: 0% 50%; }
      100% { background-position: 100% 50%; }
    }

    /* Specific styles for Boyle's Law title glowing effect */
    .boyle-title-glow {
        background: none; /* Ensure no rainbow background here */
        -webkit-background-clip: unset;
        background-clip: unset;
        -webkit-text-fill-color: unset;
        color: #FFD700; /* Golden color */
        animation: none; /* No background animation */

        /* Golden LED Glowing Effect for text */
        text-shadow: 0 0 8px rgba(255, 215, 0, 0.8),   /* Pure gold glow */
                     0 0 15px rgba(255, 223, 0, 0.6),  /* Lighter gold glow */
                     0 0 25px rgba(255, 204, 0, 0.4),  /* Soft gold glow */
                     0 0 35px rgba(200, 150, 0, 0.2);  /* Deeper amber glow for spread */
        -webkit-text-stroke: 1px rgba(255,255,255,0.05); /* Very subtle white stroke for definition */
    }

    /* Canvas sizing for Boyle mode */
    #boyleCanvas {
        width: 100%; /* Make canvas fill container */
        height: 100%; /* Make canvas fill container */
        background:#222;
        border-radius:12px;
        flex-grow: 1; /* Allow canvas to take available space */
    }

    /* Text for explanations in game modes */
    .explanation-text {
        font-size: 1.1rem;
        text-align: center;
        margin-bottom: 20px;
        max-width: 600px;
        line-height: 1.5;
        color: #ddd;
    }
    .explanation-text strong {
        color: #fff;
    }
    .gaylussac-explanation {
        color: #4a90e2; /* Blue to match Gay-Lussac theme */
        text-shadow: 0 0 5px rgba(74, 144, 226, 0.5);
    }
    .slider-label-explanation {
        font-size: 0.9rem;
        margin-top: 5px;
        margin-bottom: 10px;
        color: #a0a0a0; /* Lighter grey for descriptions */
    }
    .slider-label-explanation strong {
        color: #eee;
    }

    /* Media Queries for better mobile responsiveness */
    @media (max-width: 600px) {
        #mainMenu h1 {
            font-size: 2.5rem;
            letter-spacing: 3px;
        }
        #mainMenu h3 {
            font-size: 1rem;
        }
        #mainMenu button {
            font-size: 1.2rem;
            padding: 12px 60px;
            margin: 8px 0;
        }
        .game-mode-title {
            font-size: 2rem;
            margin-bottom: 20px;
        }
        .container {
            width: 95vw;
            height: 60vh;
            max-width: 320px;
            max-height: 320px;
            padding: 15px;
        }
        .slider-container {
            width: 95vw;
            max-width: 280px;
            margin: 10px 0;
        }
        .avogadro-increase-btn, .rainbow-button {
            font-size: 1rem;
            padding: 10px 20px;
        }
        #memberPage h2 {
            font-size: 2.2rem;
        }
        #memberPage li {
            font-size: 1.2rem;
            margin: 10px 0;
        }
        .explanation-text, .slider-label-explanation {
            font-size: 0.85rem;
            margin-bottom: 15px;
        }
    }

  </style>
</head>
<body>

  <canvas id="particleCanvas"></canvas>

  <div id="mainMenu">
    <h1>GAS LAWS GAME</h1>
    <h3>Choose your mode</h3>
    <button onclick="showMode('boyle')">Boyle's Law</button>
    <button onclick="showMode('charles')">Charles' Law</button>
    <button onclick="showMode('gayLussac')">Gayâ€‘Lussac's Law</button>
    <button onclick="showMode('avogadro')">Avogadro's Law</button>
    <button id="memberBtn" onclick="showMemberPage()">Member</button>
  </div>

  <div id="boyle" class="gameMode">
    <h2 class="game-mode-title boyle-title-glow">Boyle's Law</h2>
    <p class="explanation-text">
      In Boyle's Law, when <strong>temperature</strong> and <strong>number of particles</strong> are constant,
      the <strong>pressure</strong> of a gas is inversely proportional to its <strong>volume</strong>.<br>
      Watch how decreasing the container size (volume) affects the speed and density of the particles.
    </p>
    <div class="slider-container">
      <label>Mass: <span id="boyleMassVal">5</span></label>
      <p class="slider-label-explanation">Adjusts the <strong>number of gas particles</strong> (molecules).</p>
      <input type="range" id="boyleMass" min="1" max="20" step="1" value="5">
    </div>
    <div class="slider-container">
      <label>Temperature (Â°C): <span id="boyleTempVal">20</span></label>
      <p class="slider-label-explanation">Controls the <strong>average speed</strong> of the particles.</p>
      <input type="range" id="boyleTemp" min="0" max="100" value="20">
    </div>
    <div class="container">
      <canvas id="boyleCanvas"></canvas> </div>
    <button class="return-btn" onclick="returnToMenu()">Return to Menu</button>
  </div>

  <div id="charles" class="gameMode">
    <h2 class="game-mode-title">Charles' Law</h2>
    <p class="explanation-text">
      In Charles' Law, when <strong>pressure</strong> and <strong>number of particles</strong> are constant,
      the <strong>volume</strong> of a gas is directly proportional to its <strong>temperature</strong>.<br>
      Watch how the balloon expands or contracts as you change the temperature.
    </p>
    <div class="container" style="position: relative;">
      <div class="balloon-container">
        <div id="charlesBalloon" class="balloon" style="z-index: 2;"></div>
        <div id="charlesMoleculeBg" class="molecule-teller-bg">0</div>
      </div>
      <div class="slider-container">
        <label>Temperature (Â°C): <span id="charlesTempVal">20</span></label>
        <p class="slider-label-explanation">Controls the <strong>temperature</strong> affecting balloon size.</p>
        <input type="range" id="charlesTemp" min="0" max="100" value="20">
      </div>
    </div>
    <button class="return-btn" onclick="returnToMenu()">Return to Menu</button>
  </div>

  <div id="gayLussac" class="gameMode">
    <h2 class="game-mode-title gaylussac-title-glow">Gayâ€‘Lussac's Law</h2>
    <p class="explanation-text gaylussac-explanation">
      In Gay-Lussac's Law, when <strong>volume</strong> and <strong>number of particles</strong> are constant,
      the <strong>pressure</strong> of a gas is directly proportional to its <strong>temperature</strong>.<br>
      The container is <strong>rigid and sealed</strong> (constant volume).
    </p>
    <div class="slider-container">
      <label>Temperature (Â°C): <span id="gayLussacTempVal">20</span></label>
      <p class="slider-label-explanation">Adjusts the <strong>temperature</strong>, which controls the <strong>speed of particles</strong>.</p>
      <input type="range" id="gayLussacTemp" min="0" max="100" value="20">
    </div>
    <div class="slider-container">
        <label>Pressure (arbitrary units): <span id="gayLussacPressureVal">X</span></label>
        <p class="slider-label-explanation">Shows the <strong>resulting pressure</strong>. Faster particles hit walls more often and harder, increasing pressure.</p>
    </div>
    <div class="container">
      <canvas id="gayLussacCanvas"></canvas>
    </div>
    <button class="return-btn" onclick="returnToMenu()">Return to Menu</button>
  </div>

  <div id="avogadro" class="gameMode">
    <h2 class="game-mode-title">Avogadro's Law</h2>
    <p class="explanation-text">
      In Avogadro's Law, when <strong>temperature</strong> and <strong>pressure</strong> are constant,
      the <strong>volume</strong> of a gas is directly proportional to the <strong>number of particles</strong>.<br>
      Increase the number of molecules and watch the balloon expand until it pops!
    </p>
    <div class="container" style="position: relative;">
      <div id="avogadroTopLeftCounter" class="molecule-counter">Molecules: 0</div>

      <div class="balloon-container">
        <div id="avogadroBalloon" class="balloon" style="z-index: 2;"></div>
        <div id="avogadroMoleculeBg" class="molecule-teller-bg">0</div>
        <button id="getNewOneBtn" class="rainbow-button">GET NEW ONE!!!</button>
      </div>
    </div>
    <button id="increaseMoleculeBtn" class="avogadro-increase-btn">Increase Molecules</button>
    <button class="return-btn" onclick="returnToMenu()">Return to Menu</button>
  </div>

  <div id="memberPage" class="gameMode">
    <h2>Our Amazing Team</h2>
    <ul>
      <li>Jittanan Pasartkeaw</li>
      <li>Thanunya Udomchaipon</li>
      <li>Hasana Pathan</li>
      <li>Phattaraporn Preeda</li>
      <li>Narisara Eiamsa-ard</li>
      <li>Chalita Ruttapoom</li>
      <li>Yanisa Singh</li>
    </ul>
    <button class="return-btn" onclick="returnToMenu()">Return to Menu</button>
  </div>


  <audio id="popSound" src="https://actions.google.com/sounds/v1/cartoon/pop.ogg" preload="auto"></audio>

  <script>
    // === Animated Particles Background ===
    const canvas = document.getElementById('particleCanvas'), ctx = canvas.getContext('2d');
    let particles = [], width, height;
    function initParticles() {
      width = window.innerWidth; height = window.innerHeight;
      canvas.width = width; canvas.height = height;
      particles = [];
      for (let i = 0; i < 80; i++) {
        particles.push({
          x: Math.random() * width,
          y: Math.random() * height,
          radius: Math.random() * 6 + 2,
          speedY: Math.random() * 1.5 + 0.5,
          speedX: (Math.random() - 0.5) * 0.5,
          // Reverted particle color to pinkish-red for main menu background
          color: 'rgba(255, 90, 95, 0.4)', /* Pinkish-red particles */
          alpha: Math.random() * 0.5 + 0.3,
          type: Math.random() > 0.5 ? 'circle' : 'atom'
        });
      }
    }

    function drawAtom(x, y, r) {
      ctx.strokeStyle = 'rgba(255,90,95,0.6)'; /* Pinkish-red atom lines */
      ctx.lineWidth = 1.2;
      ctx.beginPath(); ctx.arc(x, y, r * 0.6, 0, Math.PI * 2);
      ctx.fillStyle = 'rgba(255,90,95,0.7)'; /* Pinkish-red atom fill */
      ctx.fill(); ctx.closePath();
      ctx.beginPath(); ctx.ellipse(x, y, r * 1.2, r * 0.5, 0, 0, Math.PI * 2); ctx.stroke();
      ctx.beginPath(); ctx.ellipse(x, y, r * 0.5, r * 1.2, Math.PI / 4, 0, Math.PI * 2); ctx.stroke();
    }

    function draw() {
      ctx.clearRect(0, 0, width, height);
      for (const p of particles) {
        p.y += p.speedY; p.x += p.speedX;
        if (p.y - p.radius > height) p.y = -p.radius;
        if (p.x - p.radius > width) p.x = -p.radius;
        else if (p.x + p.radius < 0) p.x = width + p.radius;
        ctx.globalAlpha = p.alpha;
        if (p.type === 'circle') {
          ctx.fillStyle = p.color;
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
          ctx.fill();
          ctx.closePath();
        } else {
          drawAtom(p.x, p.y, p.radius);
        }
        ctx.globalAlpha = 1;
      }
      requestAnimationFrame(draw);
    }
    window.addEventListener('resize', initParticles);
    initParticles();
    draw();

    // === Main Menu & Mode Handling ===
    const modes = ['boyle','charles','gayLussac','avogadro','memberPage']; // Added memberPage
    function showMode(mode) {
      document.getElementById('mainMenu').style.display = 'none';
      modes.forEach(m => {
        document.getElementById(m).style.display = (m === mode ? 'flex' : 'none');
      });
      // Cancel all animations before starting a new one
      cancelAllAnimations();

      if(mode==='boyle') initBoyle();
      else if(mode==='charles') initCharles();
      else if(mode==='gayLussac') initGayLussac();
      else if(mode==='avogadro') initAvogadro();
      // No init function needed for memberPage as it's static HTML
    }
    function returnToMenu() {
      document.getElementById('mainMenu').style.display = 'flex';
      modes.forEach(m => {
        document.getElementById(m).style.display = 'none';
      });
      cancelAllAnimations(); // Cancel all animations when returning to menu
    }

    function cancelAllAnimations() {
        cancelBoyleAnimation();
        cancelCharlesAnimation();
        cancelGayLussacAnimation();
        cancelAvogadroIncrease(); // Make sure to call this to stop timers
    }

    // Member button function
    function showMemberPage() {
      showMode('memberPage'); // This will handle hiding other modes and displaying memberPage
    }

    // === BOYLE MODE ===
    const boyleMassSlider = document.getElementById('boyleMass');
    const boyleTempSlider = document.getElementById('boyleTemp');
    const boyleMassVal = document.getElementById('boyleMassVal');
    const boyleTempVal = document.getElementById('boyleTempVal');
    const boyleCanvas = document.getElementById('boyleCanvas');
    const bCtx = boyleCanvas.getContext('2d');

    let boyleBalls = [];
    let boyleAnimId;
    const BOYLE_BALL_RADIUS = 6; // Fixed radius for consistency
    const MAX_MASS_VALUE = 20; // Max value of the mass slider
    const MIN_TEMP_VALUE = 0;
    const MAX_TEMP_VALUE = 100;

    function initBoyle() {
      const container = boyleCanvas.parentElement;
      boyleCanvas.width = container.clientWidth;
      boyleCanvas.height = container.clientHeight;

      boyleMassVal.textContent = boyleMassSlider.value;
      boyleTempVal.textContent = boyleTempSlider.value;
      
      boyleBalls = []; // Clear balls initially
      addRemoveBoyleBalls(parseInt(boyleMassSlider.value)); // Populate with initial count
      updateBoyleBallSpeeds(); // Set initial speeds
      
      animateBoyle();
    }

    function addRemoveBoyleBalls(newMass) {
      const currentBallCount = boyleBalls.length;
      
      const containerArea = boyleCanvas.width * boyleCanvas.height;
      const ballArea = Math.PI * BOYLE_BALL_RADIUS * BOYLE_BALL_RADIUS;
      const IDEAL_MAX_BALLS = Math.floor(containerArea / (ballArea * 2.5));

      const targetBallCount = Math.floor((newMass / MAX_MASS_VALUE) * IDEAL_MAX_BALLS);
      
      if (targetBallCount > currentBallCount) {
        for (let i = 0; i < (targetBallCount - currentBallCount); i++) {
          let newBall = {
            x: Math.random() * (boyleCanvas.width - 2 * BOYLE_BALL_RADIUS) + BOYLE_BALL_RADIUS,
            y: Math.random() * (boyleCanvas.height - 2 * BOYLE_BALL_RADIUS) + BOYLE_BALL_RADIUS,
            radius: BOYLE_BALL_RADIUS,
            speedX: 0,
            speedY: 0,
            color: '#ff5a5f'
          };
          boyleBalls.push(newBall);
        }
      } else if (targetBallCount < currentBallCount) {
        boyleBalls.splice(0, currentBallCount - targetBallCount);
      }
    }

    function updateBoyleBallSpeeds() {
      const temp = parseInt(boyleTempSlider.value);
      const mass = parseInt(boyleMassSlider.value);

      const baseSpeed = 1.5;
      const tempFactor = 0.5 + (temp / MAX_TEMP_VALUE) * 2.5;
      const massFactor = 1.0 - ( (mass - 1) / (MAX_MASS_VALUE - 1) ) * 0.7;

      const combinedSpeedFactor = baseSpeed * tempFactor * massFactor;
      
      boyleBalls.forEach(ball => {
        let currentSpeedMagnitude = Math.sqrt(ball.speedX * ball.speedX + ball.speedY * ball.speedY);
        
        if (currentSpeedMagnitude === 0 || isNaN(currentSpeedMagnitude) || currentSpeedMagnitude < 0.01) { 
            let angle = Math.random() * Math.PI * 2;
            ball.speedX = Math.cos(angle) * combinedSpeedFactor;
            ball.speedY = Math.sin(angle) * combinedSpeedFactor;
        } else {
            const scaleRatio = combinedSpeedFactor / currentSpeedMagnitude;
            ball.speedX *= scaleRatio;
            ball.speedY *= scaleRatio;
        }
      });
    }

    // This function is general enough to be used by Boyle and Gay-Lussac
    function resolveBoyleCollision(ball1, ball2) {
        const dx = ball2.x - ball1.x;
        const dy = ball2.y - ball1.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        const minDistance = ball1.radius + ball2.radius;

        if (distance < minDistance && distance > 0) {
            const overlap = minDistance - distance;
            const nx = dx / distance;
            const ny = dy / distance;
            const separationAmount = overlap / 2 + 0.05;

            ball1.x -= nx * separationAmount;
            ball1.y -= ny * separationAmount;
            ball2.x += nx * separationAmount;
            ball2.y += ny * separationAmount;

            const vrx = ball1.speedX - ball2.speedX;
            const vry = ball1.speedY - ball2.speedY;
            const speedAlongNormal = vrx * nx + vry * ny;

            if (speedAlongNormal > 0) return;

            const elasticity = 0.3; // Changed from 0.95 to 0.3 for "stickier" collisions
            const impulseMagnitude = -(1 + elasticity) * speedAlongNormal;

            ball1.speedX += impulseMagnitude * nx;
            ball1.speedY += impulseMagnitude * ny;
            ball2.speedX -= impulseMagnitude * nx;
            ball2.speedY -= impulseMagnitude * ny;
        }
    }

    function animateBoyle() {
      const container = boyleCanvas.parentElement;
      if (boyleCanvas.width !== container.clientWidth || boyleCanvas.height !== container.clientHeight) {
        boyleCanvas.width = container.clientWidth;
        boyleCanvas.height = container.clientHeight;
        // Re-initialize ball positions if canvas size changes drastically
        addRemoveBoyleBalls(parseInt(boyleMassSlider.value));
      }

      bCtx.clearRect(0, 0, boyleCanvas.width, boyleCanvas.height);

      for (let i = 0; i < boyleBalls.length; i++) {
        const ball = boyleBalls[i];

        // Update position
        ball.x += ball.speedX;
        ball.y += ball.speedY;

        // Wall collisions
        if (ball.x + ball.radius > boyleCanvas.width || ball.x - ball.radius < 0) {
          ball.speedX *= -1;
          // Correct position to prevent sticking
          if (ball.x + ball.radius > boyleCanvas.width) ball.x = boyleCanvas.width - ball.radius;
          else if (ball.x - ball.radius < 0) ball.x = ball.radius;
        }
        if (ball.y + ball.radius > boyleCanvas.height || ball.y - ball.radius < 0) {
          ball.speedY *= -1;
          // Correct position to prevent sticking
          if (ball.y + ball.radius > boyleCanvas.height) ball.y = boyleCanvas.height - ball.radius;
          else if (ball.y - ball.radius < 0) ball.y = ball.radius;
        }

        // Draw ball
        bCtx.beginPath();
        bCtx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
        bCtx.fillStyle = ball.color;
        bCtx.fill();
        bCtx.closePath();
      }

      // Handle ball-to-ball collisions
      for (let i = 0; i < boyleBalls.length; i++) {
        for (let j = i + 1; j < boyleBalls.length; j++) {
          resolveBoyleCollision(boyleBalls[i], boyleBalls[j]);
        }
      }

      boyleAnimId = requestAnimationFrame(animateBoyle);
    }

    function cancelBoyleAnimation() {
      if (boyleAnimId) {
        cancelAnimationFrame(boyleAnimId);
        boyleAnimId = null;
      }
    }

    boyleMassSlider.addEventListener('input', () => {
      boyleMassVal.textContent = boyleMassSlider.value;
      addRemoveBoyleBalls(parseInt(boyleMassSlider.value));
      updateBoyleBallSpeeds();
    });

    boyleTempSlider.addEventListener('input', () => {
      boyleTempVal.textContent = boyleTempSlider.value;
      updateBoyleBallSpeeds();
    });

    // === CHARLES MODE ===
    const charlesTempSlider = document.getElementById('charlesTemp');
    const charlesTempVal = document.getElementById('charlesTempVal');
    const charlesBalloon = document.getElementById('charlesBalloon');
    const charlesMoleculeBg = document.getElementById('charlesMoleculeBg');

    let charlesAnimId;
    const INITIAL_CHARLES_BALLOON_WIDTH = 100;
    const INITIAL_CHARLES_BALLOON_HEIGHT = 150;
    const MIN_CHARLES_BALLOON_SCALE = 0.5; // Minimum size factor
    const MAX_CHARLES_BALLOON_SCALE = 1.5; // Maximum size factor
    const CHARLES_FIXED_MOLECULE_COUNT = 50; // Fixed number for Charles's Law

    function initCharles() {
      charlesTempVal.textContent = charlesTempSlider.value;
      // Set initial size
      charlesBalloon.style.width = `${INITIAL_CHARLES_BALLOON_WIDTH}px`;
      charlesBalloon.style.height = `${INITIAL_CHARLES_BALLOON_HEIGHT}px`;

      updateCharlesBalloonSize();
      // Set the fixed number for molecules in the background counter
      charlesMoleculeBg.textContent = CHARLES_FIXED_MOLECULE_COUNT; 
    }

    function updateCharlesBalloonSize() {
      const temp = parseInt(charlesTempSlider.value);
      // Map temperature (0-100) to a scale factor (e.g., 0.5 to 1.5)
      // Linear interpolation: output = output_start + ((output_end - output_start) / (input_end - input_start)) * (input - input_start)
      const scale = MIN_CHARLES_BALLOON_SCALE + ((MAX_CHARLES_BALLOON_SCALE - MIN_CHARLES_BALLOON_SCALE) / (100 - 0)) * (temp - 0);

      const newWidth = INITIAL_CHARLES_BALLOON_WIDTH * scale;
      const newHeight = INITIAL_CHARLES_BALLOON_HEIGHT * scale;

      charlesBalloon.style.width = `${newWidth}px`;
      charlesBalloon.style.height = `${newHeight}px`;

      // Update balloon shape slightly with size for more organic look
      const horizontalRadius = 50 + (scale - 1) * 10; // Adjust 10 for more or less change
      const verticalTopRadius = 60 + (scale - 1) * 10;
      const verticalBottomRadius = 40 + (scale - 1) * 10;
      charlesBalloon.style.borderRadius = `${horizontalRadius}% ${horizontalRadius}% ${horizontalRadius}% ${horizontalRadius}% / ${verticalTopRadius}% ${verticalTopRadius}% ${verticalBottomRadius}% ${verticalBottomRadius}%`;
    }

    function cancelCharlesAnimation() {
        // No ongoing animation frames to cancel for Charles' Law
    }

    charlesTempSlider.addEventListener('input', () => {
      charlesTempVal.textContent = charlesTempSlider.value;
      updateCharlesBalloonSize();
    });

    // === GAY-LUSSAC MODE ===
    const gayLussacTempSlider = document.getElementById('gayLussacTemp');
    const gayLussacTempVal = document.getElementById('gayLussacTempVal');
    const gayLussacPressureVal = document.getElementById('gayLussacPressureVal');
    const gayLussacCanvas = document.getElementById('gayLussacCanvas');
    const glCtx = gayLussacCanvas.getContext('2d');

    let gayLussacBalls = [];
    let gayLussacAnimId;
    const GAYLUSSAC_BALL_RADIUS = 6;
    const GAYLUSSAC_NUM_PARTICLES = 20; // Changed to 20 particles

    function initGayLussac() {
      const container = gayLussacCanvas.parentElement;
      gayLussacCanvas.width = container.clientWidth;
      gayLussacCanvas.height = container.clientHeight;

      gayLussacTempVal.textContent = gayLussacTempSlider.value;
      
      gayLussacBalls = [];
      for (let i = 0; i < GAYLUSSAC_NUM_PARTICLES; i++) {
        gayLussacBalls.push({
          x: Math.random() * (gayLussacCanvas.width - 2 * GAYLUSSAC_BALL_RADIUS) + GAYLUSSAC_BALL_RADIUS,
          y: Math.random() * (gayLussacCanvas.height - 2 * GAYLUSSAC_BALL_RADIUS) + GAYLUSSAC_BALL_RADIUS,
          speedX: 0,
          speedY: 0,
          color: '#4a90e2' // Blue color for Gay-Lussac particles
        });
      }
      updateGayLussacBallSpeeds();
      animateGayLussac();
    }

    function updateGayLussacBallSpeeds() {
      const temp = parseInt(gayLussacTempSlider.value);
      const baseSpeed = 2.0;
      const speedFactor = baseSpeed + (temp / 100) * 4.0;

      gayLussacBalls.forEach(ball => {
        let currentSpeedMagnitude = Math.sqrt(ball.speedX * ball.speedX + ball.speedY * ball.speedY);
        
        if (currentSpeedMagnitude === 0 || isNaN(currentSpeedMagnitude) || currentSpeedMagnitude < 0.01) { 
            let angle = Math.random() * Math.PI * 2;
            ball.speedX = Math.cos(angle) * speedFactor;
            ball.speedY = Math.sin(angle) * speedFactor;
        } else {
            const scaleRatio = speedFactor / currentSpeedMagnitude;
            ball.speedX *= scaleRatio;
            ball.speedY *= scaleRatio;
        }
      });
      calculateGayLussacPressure();
    }

    function calculateGayLussacPressure() {
      const temp = parseInt(gayLussacTempSlider.value);
      // Pressure is directly proportional to temperature in Kelvin.
      // Convert Celsius to an arbitrary Kelvin-like scale for calculation to avoid 0.
      const tempKelvinish = temp + 273; // Simple offset for non-zero behavior
      
      // Since volume and number of particles are constant, pressure is directly proportional to temperature.
      // Using an arbitrary constant for proportionality.
      const pressure = (tempKelvinish * 0.1).toFixed(1); // Scale for display, 1 decimal place
      gayLussacPressureVal.textContent = pressure;
    }

    function animateGayLussac() {
      const container = gayLussacCanvas.parentElement;
      if (gayLussacCanvas.width !== container.clientWidth || gayLussacCanvas.height !== container.clientHeight) {
        gayLussacCanvas.width = container.clientWidth;
        gayLussacCanvas.height = container.clientHeight;
        // Re-initialize ball positions if canvas size changes drastically
        initGayLussac(); // Re-initialize to ensure balls are within new bounds
      }

      glCtx.clearRect(0, 0, gayLussacCanvas.width, gayLussacCanvas.height);

      for (let i = 0; i < gayLussacBalls.length; i++) {
        const ball = gayLussacBalls[i];

        // Update position
        ball.x += ball.speedX;
        ball.y += ball.speedY;

        // Wall collisions
        if (ball.x + ball.radius > gayLussacCanvas.width || ball.x - ball.radius < 0) {
          ball.speedX *= -1;
          if (ball.x + ball.radius > gayLussacCanvas.width) ball.x = gayLussacCanvas.width - ball.radius;
          else if (ball.x - ball.radius < 0) ball.x = ball.radius;
        }
        if (ball.y + ball.radius > gayLussacCanvas.height || ball.y - ball.radius < 0) {
          ball.speedY *= -1;
          if (ball.y + ball.radius > gayLussacCanvas.height) ball.y = gayLussacCanvas.height - ball.radius;
          else if (ball.y - ball.radius < 0) ball.y = ball.radius;
        }

        // Draw ball
        glCtx.beginPath();
        glCtx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
        glCtx.fillStyle = ball.color;
        glCtx.fill();
        glCtx.closePath();
      }

      // Handle ball-to-ball collisions
      for (let i = 0; i < gayLussacBalls.length; i++) {
        for (let j = i + 1; j < gayLussacBalls.length; j++) {
          resolveBoyleCollision(gayLussacBalls[i], gayLussacBalls[j]);
        }
      }

      gayLussacAnimId = requestAnimationFrame(animateGayLussac);
    }

    function cancelGayLussacAnimation() {
      if (gayLussacAnimId) {
        cancelAnimationFrame(gayLussacAnimId);
        gayLussacAnimId = null;
      }
    }

    gayLussacTempSlider.addEventListener('input', () => {
      gayLussacTempVal.textContent = gayLussacTempSlider.value;
      updateGayLussacBallSpeeds();
    });

    // === AVOGADRO MODE ===
    const avogadroBalloon = document.getElementById('avogadroBalloon');
    const avogadroMoleculeBg = document.getElementById('avogadroMoleculeBg');
    const increaseMoleculeBtn = document.getElementById('increaseMoleculeBtn');
    const avogadroTopLeftCounter = document.getElementById('avogadroTopLeftCounter');
    const getNewOneBtn = document.getElementById('getNewOneBtn');
    const popSound = document.getElementById('popSound');

    let moleculeCount = 0;
    const MAX_MOLECULES_BEFORE_POP = 15; // Adjusted for a reasonable pop threshold
    const BASE_BALLOON_WIDTH = 50; // Smaller initial width
    const BASE_BALLOON_HEIGHT = 75; // Smaller initial height
    // Calculate intendedMaxScale to ensure the largest dimension (height) does not exceed 100px.
    const intendedMaxScale = 100 / BASE_BALLOON_HEIGHT; 
    let avogadroPopAnimTimeout;

    // --- Avogadro Hold to Increase Logic ---
    let isHolding = false;
    let holdInterval;
    let holdTimeout;
    const HOLD_INITIAL_DELAY = 300; // ms before auto-increment starts
    const HOLD_INCREMENT_INTERVAL = 100; // ms between increments after initial delay

    function startIncrement() {
        if (moleculeCount < MAX_MOLECULES_BEFORE_POP) {
            moleculeCount++;
            updateAvogadroDisplay();
            if (moleculeCount >= MAX_MOLECULES_BEFORE_POP) {
                stopIncrement(); // Stop if max reached
            }
        } else {
            stopIncrement(); // Stop if max reached
        }
    }

    function handleHoldStart(e) {
        if (increaseMoleculeBtn.disabled) return;
        isHolding = true;
        // Start incrementing immediately
        startIncrement(); 
        // Set a timeout before rapid increment starts
        holdTimeout = setTimeout(() => {
            if (isHolding) { // Only start interval if still holding after delay
                holdInterval = setInterval(startIncrement, HOLD_INCREMENT_INTERVAL);
            }
        }, HOLD_INITIAL_DELAY);
    }

    function stopIncrement() {
        isHolding = false;
        clearTimeout(holdTimeout);
        clearInterval(holdInterval);
    }

    // Attach event listeners for hold functionality
    increaseMoleculeBtn.addEventListener('mousedown', handleHoldStart);
    increaseMoleculeBtn.addEventListener('mouseup', stopIncrement);
    increaseMoleculeBtn.addEventListener('mouseleave', stopIncrement); // Important for desktop if mouse drags off

    increaseMoleculeBtn.addEventListener('touchstart', (e) => {
        e.preventDefault(); // Prevent scrolling/zooming on touch
        handleHoldStart(e);
    }, { passive: false }); // Use passive: false to allow preventDefault

    increaseMoleculeBtn.addEventListener('touchend', stopIncrement);
    increaseMoleculeBtn.addEventListener('touchcancel', stopIncrement);
    // --- End Avogadro Hold to Increase Logic ---


    function initAvogadro() {
        moleculeCount = 0; // Reset count
        // Set initial size
        avogadroBalloon.style.width = `${BASE_BALLOON_WIDTH}px`;
        avogadroBalloon.style.height = `${BASE_BALLOON_HEIGHT}px`;

        updateAvogadroDisplay();
        avogadroBalloon.classList.remove('pop'); // Ensure no pop animation is active
        avogadroBalloon.style.opacity = 1; // Ensure balloon is visible
        avogadroBalloon.style.transform = 'translateY(0px)'; // Reset float animation position
        avogadroBalloon.style.borderRadius = `50% 50% 50% 50% / 60% 60% 40% 40%`; // Reset shape

        // Ensure neck pseudo-element is visible and reset
        const styleSheet = document.styleSheets[0];
        let rule = Array.from(styleSheet.cssRules).find(r => r.selectorText === '.balloon::after');
        if (rule) {
            rule.style.opacity = '1';
            rule.style.transform = 'translateX(-50%) scale(1)';
        }

        getNewOneBtn.style.display = 'none'; // Hide "GET NEW ONE!!!" button initially
        increaseMoleculeBtn.style.display = 'block'; // Show "Increase Molecules" button
        increaseMoleculeBtn.disabled = false; // Enable the button
        stopIncrement(); // Ensure any lingering hold timers are cleared
    }

    function updateAvogadroDisplay() {
        avogadroMoleculeBg.textContent = moleculeCount;
        avogadroTopLeftCounter.textContent = `Molecules: ${moleculeCount}`;

        // Scale balloon based on molecule count
        const currentScale = 1 + (moleculeCount / MAX_MOLECULES_BEFORE_POP) * (intendedMaxScale - 1);

        const newWidth = BASE_BALLOON_WIDTH * currentScale;
        const newHeight = BASE_BALLOON_HEIGHT * currentScale;

        avogadroBalloon.style.width = `${newWidth}px`;
        avogadroBalloon.style.height = `${newHeight}px`;

        // Adjust border-radius slightly for a "stretching" effect
        const horizontalRadius = 50 + (currentScale - 1) * 10;
        const verticalTopRadius = 60 + (currentScale - 1) * 10;
        const verticalBottomRadius = 40 + (currentScale - 1) * 10;
        avogadroBalloon.style.borderRadius = `${horizontalRadius}% ${horizontalRadius}% ${horizontalRadius}% ${horizontalRadius}% / ${verticalTopRadius}% ${verticalTopRadius}% ${verticalBottomRadius}% ${verticalBottomRadius}%`;

        if (moleculeCount >= MAX_MOLECULES_BEFORE_POP) {
            popBalloon();
        }
    }

    function popBalloon() {
        if (!avogadroBalloon.classList.contains('pop')) { // Prevent multiple pop animations
            increaseMoleculeBtn.disabled = true; // Disable button when popping
            stopIncrement(); // Stop any ongoing increment when popping
            avogadroBalloon.classList.add('pop');
            popSound.currentTime = 0; // Rewind to start if already playing
            popSound.play().catch(e => console.error("Error playing pop sound:", e));

            // Hide the balloon and show "GET NEW ONE!!!" button after animation
            avogadroPopAnimTimeout = setTimeout(() => {
                avogadroBalloon.style.opacity = 0; // Ensure it's fully hidden after animation
                getNewOneBtn.style.display = 'block'; // Show "GET NEW ONE!!!" button
            }, 600); // Matches animation duration
        }
    }

    function cancelAvogadroIncrease() {
        stopIncrement(); // Stop hold mechanism
        if (avogadroPopAnimTimeout) {
            clearTimeout(avogadroPopAnimTimeout);
            avogadroPopAnimTimeout = null;
        }
        avogadroBalloon.classList.remove('pop');
        avogadroBalloon.style.opacity = 1; // Ensure balloon is visible if animation was cancelled mid-way
        avogadroBalloon.style.transform = 'translateY(0px)'; // Reset float animation position
        // Also reset the neck's opacity if it was affected
        const styleSheet = document.styleSheets[0];
        let rule = Array.from(styleSheet.cssRules).find(r => r.selectorText === '.balloon::after');
        if (rule) {
            rule.style.opacity = '1';
            rule.style.transform = 'translateX(-50%) scale(1)';
        }
    }

    getNewOneBtn.addEventListener('click', () => {
        initAvogadro();
    });

    // Initial setup for default modes when page loads
    document.addEventListener('DOMContentLoaded', () => {
        // No specific mode to show on load, mainMenu is default
        // The display logic for mainMenu handles it initially
    });

  </script>
</body>
</html>

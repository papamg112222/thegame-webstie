<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Tokyo Drift Chase</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #14141e; /* COLOR_BG_VOID */
            font-family: Arial, sans-serif;
            touch-action: none; /* Prevent mobile scrolling */
        }
        canvas {
            display: block;
            /* Force pixelated rendering for crisp edges */
            image-rendering: pixelated; 
            image-rendering: crisp-edges;
        }
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
    </style>
</head>
<body>

<canvas id="gameCanvas"></canvas>

<script>
/**
 * TOKYO DRIFT CHASE - HTML5 PORT
 * Original logic adapted from Pygame
 */

// --- Constants & Configuration ---
const FPS = 60;
const BLOCK_SIZE = 380;
const BUILDING_GAP = 20;

// Colors
const COLORS = {
    BG_VOID: '#14141e',
    ASPHALT: '#2d2d32',
    PAINT_YELLOW: '#d2b414',
    PAINT_WHITE: '#dcdcdc',
    SIDEWALK: '#828287',
    WOOD_DARK: '#50281e',
    WOOD_RED: '#8c1e14',
    CONCRETE: '#9696a0',
    CONCRETE_DARK: '#64646e',
    ROOF_TILE_JP: '#3c3c46',
    LANTERN_RED: '#dc3232',
    NEON_PINK: '#ff3296',
    NEON_BLUE: '#3296ff',
    NEON_CYAN: '#32ffff',
    NEON_GREEN: '#32ff64',
    VENDING_BLUE: '#3264c8',
    SCHOOL_BEIGE: '#e6dcbe',
    CLOCK_FACE: '#ffffff',
    WIN_LIT_WARM: '#fff0b4',
    WIN_LIT_COOL: '#c8dcff',
    WIN_DARK: '#282832',
    SAKURA_PINK: '#ffb4c8',
    SAKURA_DARK: '#c8788c',
    ZOO_BASE: '#328c32',
    WATER: '#3296fa',
    AC: '#b4b4be',
    PLAYER: '#dc2828',
    COP_BODY: '#0a0a0f',
    COP_DOOR: '#e6e6f0',
    HP_GREEN: '#32c832',
    HP_YELLOW: '#dcc832',
    HP_RED: '#c83232',
    TEXT_WHITE: '#ffffff'
};

// Physics
const ACCELERATION = 0.20;
const FRICTION = 0.96;
const TURN_SPEED = 4.0;
const DRIFT_SLIDE = 0.99;
const MAX_SPEED_PLAYER = 9.0;
const MAX_SPEED_COP = 10.2;

// --- Utility Classes ---

class Vector2 {
    constructor(x, y) {
        this.x = x;
        this.y = y;
    }
    add(v) { return new Vector2(this.x + v.x, this.y + v.y); }
    sub(v) { return new Vector2(this.x - v.x, this.y - v.y); }
    mult(n) { return new Vector2(this.x * n, this.y * n); }
    mag() { return Math.sqrt(this.x * this.x + this.y * this.y); }
    normalize() {
        let m = this.mag();
        if (m === 0) return new Vector2(0, 0);
        return new Vector2(this.x / m, this.y / m);
    }
    dot(v) { return this.x * v.x + this.y * v.y; }
    rotate(angleDegrees) {
        let rad = angleDegrees * Math.PI / 180;
        let cos = Math.cos(rad);
        let sin = Math.sin(rad);
        return new Vector2(this.x * cos - this.y * sin, this.x * sin + this.y * cos);
    }
    distanceTo(v) {
        return Math.sqrt((this.x - v.x)**2 + (this.y - v.y)**2);
    }
    lerp(v, t) {
        return new Vector2(this.x + (v.x - this.x) * t, this.y + (v.y - this.y) * t);
    }
}

class Rect {
    constructor(x, y, w, h) {
        this.x = x;
        this.y = y;
        this.w = w;
        this.h = h;
    }
    get left() { return this.x; }
    get right() { return this.x + this.w; }
    get top() { return this.y; }
    get bottom() { return this.y + this.h; }
    get centerx() { return this.x + this.w / 2; }
    get centery() { return this.y + this.h / 2; }
    
    set centerx(v) { this.x = v - this.w / 2; }
    set centery(v) { this.y = v - this.h / 2; }

    collidePoint(px, py) {
        return px >= this.x && px <= this.x + this.w && py >= this.y && py <= this.y + this.h;
    }
    collideRect(other) {
        return this.x < other.x + other.w && this.x + this.w > other.x &&
               this.y < other.y + other.h && this.y + this.h > other.y;
    }
    inflate(dw, dh) {
        return new Rect(this.x - dw/2, this.y - dh/2, this.w + dw, this.h + dh);
    }
}

// --- Seeded Random for Map Consistency ---
class SeededRNG {
    constructor(seed) {
        this.seed = seed;
    }
    // Simple LCG
    next() {
        this.seed = (this.seed * 9301 + 49297) % 233280;
        return this.seed / 233280;
    }
    randInt(min, max) {
        return Math.floor(this.next() * (max - min + 1)) + min;
    }
    randFloat(min, max) {
        return this.next() * (max - min) + min;
    }
    choice(arr) {
        return arr[Math.floor(this.next() * arr.length)];
    }
}

// --- Helper Functions (Standard) ---
function randInt(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; }
function randFloat(min, max) { return Math.random() * (max - min) + min; }
function randChoice(arr) { return arr[Math.floor(Math.random() * arr.length)]; }
function degToRad(deg) { return deg * Math.PI / 180; }

// --- Drawing Helpers ---
function drawRect(ctx, color, x, y, w, h, radius = 0) {
    ctx.fillStyle = color;
    if (radius > 0) {
        ctx.beginPath();
        if (ctx.roundRect) {
            ctx.roundRect(x, y, w, h, radius);
        } else {
            ctx.rect(x, y, w, h);
        }
        ctx.fill();
    } else {
        ctx.fillRect(x, y, w, h);
    }
}

function drawCircle(ctx, color, x, y, r) {
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.arc(x, y, r, 0, Math.PI * 2);
    ctx.fill();
}

// --- Asset Generation (Caching complex drawings) ---

function createRoadTexture(size) {
    const cvs = document.createElement('canvas');
    cvs.width = size;
    cvs.height = size;
    const ctx = cvs.getContext('2d');
    
    ctx.fillStyle = COLORS.ASPHALT;
    ctx.fillRect(0, 0, size, size);
    
    // Noise
    for (let i = 0; i < 500; i++) {
        const x = randInt(0, size);
        const y = randInt(0, size);
        const c = randInt(30, 60);
        ctx.fillStyle = `rgb(${c},${c},${c+5})`;
        ctx.fillRect(x, y, 2, 2);
    }

    // Manhole
    const mx = size/2 + randInt(-50, 50);
    const my = size/2 + randInt(-50, 50);
    
    ctx.fillStyle = '#46464b';
    ctx.beginPath(); ctx.arc(mx, my, 14, 0, Math.PI*2); ctx.fill();
    ctx.strokeStyle = '#28282d';
    ctx.lineWidth = 2;
    ctx.stroke();

    ctx.strokeStyle = '#28282d';
    for(let i=0; i<360; i+=45) {
        let rad = degToRad(i);
        ctx.beginPath();
        ctx.moveTo(mx, my);
        ctx.lineTo(mx + Math.cos(rad)*10, my + Math.sin(rad)*10);
        ctx.stroke();
    }

    return cvs;
}

const roadPatternCanvas = createRoadTexture(BLOCK_SIZE);

// --- Game Objects ---

class Camera {
    constructor() {
        this.offset = new Vector2(0, 0);
        this.viewRect = new Rect(0, 0, 0, 0); // Updates in update()
    }

    update(target, gameW, gameH) {
        // Target is typically the player car
        // We want target to be in center. 
        // Camera offset shifts the WORLD, so if player moves right (+x), offset moves left (-x)
        const targetX = -target.pos.x + gameW / 2;
        const targetY = -target.pos.y + gameH / 2;

        this.offset.x += (targetX - this.offset.x) * 0.1;
        this.offset.y += (targetY - this.offset.y) * 0.1;

        // View rect determines what chunks to load. Inflate slightly for smooth loading.
        this.viewRect = new Rect(-this.offset.x - 600, -this.offset.y - 600, gameW + 1200, gameH + 1200);
    }

    apply(rect) {
        // Transforms a world rect to screen rect
        if (!rect) return new Rect(0,0,0,0); // Safety check
        return new Rect(rect.x + this.offset.x, rect.y + this.offset.y, rect.w, rect.h);
    }
}

class CarHealth {
    constructor() {
        this.parts = {
            'front_torso': 100,
            'back_torso': 100,
            'fl_wheel': 100,
            'fr_wheel': 100,
            'rl_wheel': 100,
            'rr_wheel': 100
        };
    }

    getColor(hp) {
        if (hp > 50) return COLORS.HP_GREEN;
        if (hp > 0) return COLORS.HP_YELLOW;
        return COLORS.HP_RED;
    }

    checkFullyDestroyed() {
        for (let key in this.parts) {
            if (this.parts[key] > 0) return false;
        }
        return true;
    }

    takeDamage(amount) {
        let aliveKeys = Object.keys(this.parts).filter(k => this.parts[k] > 0);
        if (aliveKeys.length === 0) return;
        
        let target = randChoice(aliveKeys);
        this.parts[target] -= amount;

        // Splash damage
        if (Math.random() > 0.5) {
            if (this.parts['front_torso'] > 0) this.parts['front_torso'] -= amount / 2;
        } else {
            if (this.parts['back_torso'] > 0) this.parts['back_torso'] -= amount / 2;
        }
    }

    drawUI(ctx, x, y) {
        const s = 2.5; // Scale
        const wBody = 16 * s;
        const hFront = 14 * s;
        const hBack = 14 * s;
        const wWheel = 4 * s;
        const hWheel = 8 * s;
        
        const cx = x + wBody / 2;

        // Helpers
        const drawPart = (color, px, py, pw, ph, rad=0) => {
            ctx.fillStyle = color;
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 2;
            ctx.beginPath();
            if (rad > 0) {
                 if (ctx.roundRect) ctx.roundRect(px, py, pw, ph, rad);
                 else ctx.rect(px, py, pw, ph);
            } else {
                ctx.rect(px, py, pw, ph);
            }
            ctx.fill();
            ctx.stroke();
        };

        // Wheels
        drawPart(this.getColor(this.parts['fl_wheel']), cx - wBody/2 - wWheel + 2, y + 4*s, wWheel, hWheel);
        drawPart(this.getColor(this.parts['fr_wheel']), cx + wBody/2 - 2, y + 4*s, wWheel, hWheel);
        drawPart(this.getColor(this.parts['rl_wheel']), cx - wBody/2 - wWheel + 2, y + hFront + 2*s, wWheel, hWheel);
        drawPart(this.getColor(this.parts['rr_wheel']), cx + wBody/2 - 2, y + hFront + 2*s, wWheel, hWheel);

        // Body
        // Front (Hood)
        ctx.fillStyle = this.getColor(this.parts['front_torso']);
        ctx.strokeStyle = '#000';
        ctx.beginPath();
        if (ctx.roundRect) ctx.roundRect(cx - wBody/2, y, wBody, hFront, [4*s, 4*s, 0, 0]);
        else ctx.rect(cx - wBody/2, y, wBody, hFront);
        ctx.fill(); ctx.stroke();

        // Back (Cabin)
        ctx.fillStyle = this.getColor(this.parts['back_torso']);
        ctx.beginPath();
        if (ctx.roundRect) ctx.roundRect(cx - wBody/2, y + hFront, wBody, hBack, [0, 0, 2*s, 2*s]);
        else ctx.rect(cx - wBody/2, y + hFront, wBody, hBack);
        ctx.fill(); ctx.stroke();

        // Windshield line
        ctx.beginPath();
        ctx.moveTo(cx - wBody/2, y + hFront);
        ctx.lineTo(cx + wBody/2, y + hFront);
        ctx.stroke();
    }
}

class Car {
    constructor(x, y, colorHex, isCop=false) {
        this.pos = new Vector2(x, y);
        this.vel = new Vector2(0, 0);
        this.angle = 0; // Degrees
        this.rotDirection = 0;
        this.accInput = 0;
        this.color = colorHex;
        this.isCop = isCop;
        this.width = 48;
        this.height = 24;
        
        // Generate sprite
        this.sprite = this.createCarSprite();
        
        this.health = isCop ? null : new CarHealth();
        this.stuckTimer = 0;
        this.reversing = false; // For AI
    }

    createCarSprite() {
        const cvs = document.createElement('canvas');
        cvs.width = this.width;
        cvs.height = this.height;
        const ctx = cvs.getContext('2d');
        // Disable smoothing for sharp pixels on sprite generation
        ctx.imageSmoothingEnabled = false;
        
        const w = this.width, h = this.height;

        // Shadow/Underbody
        ctx.fillStyle = 'rgba(0,0,0,0.4)';
        ctx.beginPath(); 
        if (ctx.roundRect) ctx.roundRect(4, 6, w-2, h-6, 4); 
        else ctx.rect(4, 6, w-2, h-6);
        ctx.fill();

        // Wheels
        const tireColor = '#191919';
        const rimColor = this.isCop ? '#505050' : '#b4b4b4';
        const axleF = 36, axleR = 10;
        const tires = [[axleF, 1], [axleF, h-5], [axleR, 1], [axleR, h-5]];
        tires.forEach(([tx, ty]) => {
            ctx.fillStyle = tireColor;
            ctx.fillRect(tx, ty, 10, 4);
            ctx.fillStyle = rimColor;
            ctx.fillRect(tx+3, ty+1, 4, 2);
        });

        const bodyY = 3, bodyH = h - 6;
        
        // Body
        if (this.isCop) {
            ctx.fillStyle = '#0a0a0f'; // Dark Body
            ctx.beginPath(); 
            if (ctx.roundRect) ctx.roundRect(2, bodyY, w-4, bodyH, 1);
            else ctx.rect(2, bodyY, w-4, bodyH);
            ctx.fill();
            ctx.fillStyle = COLORS.COP_DOOR; // White Door
            ctx.fillRect(14, bodyY, 18, bodyH);
            ctx.fillStyle = '#9696a0'; // Pillar
            ctx.fillRect(23, bodyY, 1, bodyH);
        } else {
            ctx.fillStyle = this.color;
            ctx.beginPath(); 
            if (ctx.roundRect) ctx.roundRect(2, bodyY, w-4, bodyH, 4);
            else ctx.rect(2, bodyY, w-4, bodyH);
            ctx.fill();
            // Shade
            ctx.fillStyle = 'rgba(0,0,0,0.2)';
            ctx.fillRect(15, bodyY + bodyH - 2, 20, 1);
        }

        // Bumpers
        ctx.fillStyle = '#141419';
        ctx.fillRect(w-4, bodyY, 2, bodyH); // Front
        ctx.fillRect(2, bodyY, 2, bodyH);   // Rear

        // Cabin/Glass
        let cabinRect = this.isCop ? {x:10, y:bodyY+2, w:24, h:bodyH-4} : {x:12, y:bodyY+3, w:20, h:bodyH-6};
        ctx.fillStyle = '#1e2832'; // Glass
        ctx.beginPath(); 
        if (ctx.roundRect) ctx.roundRect(cabinRect.x, cabinRect.y, cabinRect.w, cabinRect.h, 2);
        else ctx.rect(cabinRect.x, cabinRect.y, cabinRect.w, cabinRect.h);
        ctx.fill();
        
        // Roof
        let roofColor = this.isCop ? '#0a0a0f' : this.color;
        let roofRect = {x:cabinRect.x+2, y:cabinRect.y+1, w:cabinRect.w-4, h:cabinRect.h-2};
        ctx.fillStyle = roofColor;
        ctx.fillRect(roofRect.x, roofRect.y, roofRect.w, roofRect.h);

        // Lights
        // Headlights
        ctx.fillStyle = '#c8c8c8';
        ctx.fillRect(w-5, bodyY+1, 3, 4);
        ctx.fillRect(w-5, bodyY+bodyH-5, 3, 4);
        ctx.fillStyle = '#ffffc8'; // Bright spot
        ctx.fillRect(w-3, bodyY+2, 2, 2);
        ctx.fillRect(w-3, bodyY+bodyH-4, 2, 2);
        // Taillights
        ctx.fillStyle = '#640000';
        ctx.fillRect(1, bodyY+1, 2, 5);
        ctx.fillRect(1, bodyY+bodyH-6, 2, 5);
        ctx.fillStyle = '#ff3232'; // Brake light
        ctx.fillRect(0, bodyY+2, 2, 3);
        ctx.fillRect(0, bodyY+bodyH-5, 2, 3);

        // Mirrors
        ctx.fillStyle = roofColor;
        ctx.fillRect(24, bodyY-2, 3, 2);
        ctx.fillRect(24, bodyY+bodyH, 3, 2);

        // Accessories
        if (this.isCop) {
            // Lightbar
            let barX = roofRect.x + roofRect.w/2 - 2;
            ctx.fillStyle = '#141414';
            ctx.fillRect(barX, roofRect.y-1, 4, roofRect.h+2);
            ctx.fillStyle = '#dc0000'; // Red
            ctx.fillRect(barX, roofRect.y-2, 4, 4);
            ctx.fillStyle = '#0032ff'; // Blue
            ctx.fillRect(barX, roofRect.y + roofRect.h - 2, 4, 4);
            // Push bar
            ctx.fillStyle = '#282828';
            ctx.fillRect(w-2, bodyY+4, 2, bodyH-8);
        } else {
            // Spoiler
            ctx.fillStyle = '#141414';
            ctx.fillRect(5, bodyY+2, 2, 2);
            ctx.fillRect(5, bodyY+bodyH-4, 2, 2);
            ctx.fillStyle = '#1e1e1e';
            ctx.fillRect(3, bodyY+1, 3, bodyH-2);
        }

        return cvs;
    }

    getRect() {
        return new Rect(this.pos.x - this.width/2, this.pos.y - this.height/2, this.width, this.height);
    }
    
    getHitbox() {
        // Hitbox is slightly smaller than sprite
        return new Rect(this.pos.x - (this.width-10)/2, this.pos.y - (this.height-10)/2, this.width-10, this.height-10);
    }

    physics(buildings, drift) {
        let turnSpeed = TURN_SPEED;
        let maxSpeed = this.isCop ? MAX_SPEED_COP : MAX_SPEED_PLAYER;
        let acc = this.accInput;

        // Damage Effects
        if (this.health) {
            let rr = this.health.parts['rr_wheel'] <= 0;
            let rl = this.health.parts['rl_wheel'] <= 0;
            if (rr && rl) { acc = 0; maxSpeed = 0; }
            else if (rr || rl) { maxSpeed *= 0.6; acc *= 0.6; }

            if (this.health.parts['back_torso'] <= 0) maxSpeed *= 0.75;

            if (this.rotDirection === -1 && this.health.parts['fl_wheel'] <= 0) turnSpeed *= 0.2;
            if (this.rotDirection === 1 && this.health.parts['fr_wheel'] <= 0) turnSpeed *= 0.2;
        }

        // Turning
        if (this.rotDirection !== 0 && this.vel.mag() > 0.5) {
            // Determine forward/backward movement for flip
            // Convert angle to rads, counter-clockwise logic from Python adapted
            // Python: cos(rad), -sin(rad). 
            // In JS canvas 0 is Right, 90 is Down.
            // Python physics assumes 0 is Right, +Angle is Up (negative Y).
            // Let's stick to the Python Math model: y is inverted relative to angle.
            let rad = degToRad(this.angle);
            let headingVec = new Vector2(Math.cos(rad), -Math.sin(rad));
            let dot = this.vel.dot(headingVec);
            let flip = dot > 0 ? 1 : -1;
            
            this.angle -= this.rotDirection * turnSpeed * flip;
        }

        // Velocity
        let rad = degToRad(this.angle);
        let forward = new Vector2(Math.cos(rad), -Math.sin(rad));
        
        this.vel = this.vel.add(forward.mult(acc));

        let speed = this.vel.mag();
        
        // Friction / Drift
        if (drift && speed > 3) {
            this.vel = this.vel.mult(DRIFT_SLIDE);
        } else {
            if (speed > 0.5) {
                // Lerp towards forward vector
                let dot = this.vel.dot(forward);
                let direction = dot > 0 ? 1 : -1;
                let targetVel = forward.mult(speed * direction);
                this.vel = this.vel.lerp(targetVel, 0.12);
            }
            this.vel = this.vel.mult(FRICTION);
        }

        // Cap speed
        if (this.vel.mag() > maxSpeed) {
            this.vel = this.vel.normalize().mult(maxSpeed);
        }

        this.pos = this.pos.add(this.vel);

        // Building Collisions
        let hitbox = this.getHitbox();
        for (let b of buildings) {
            if (hitbox.collideRect(b.rect)) {
                let dx = hitbox.centerx - b.rect.centerx;
                let dy = hitbox.centery - b.rect.centery;
                let wCombined = (hitbox.w + b.rect.w) / 2;
                let hCombined = (hitbox.h + b.rect.h) / 2;
                
                let ox = wCombined - Math.abs(dx);
                let oy = hCombined - Math.abs(dy);

                if (ox < oy) {
                    if (dx > 0) this.pos.x += ox; else this.pos.x -= ox;
                    this.vel.x *= 0.5;
                } else {
                    if (dy > 0) this.pos.y += oy; else this.pos.y -= oy;
                    this.vel.y *= 0.5;
                }
                // Re-calc hitbox for next check
                hitbox = this.getHitbox();
            }
        }
    }

    updateCop(player, buildings) {
        if (!this.isCop) return;

        // Predict player pos
        let futurePos = player.pos.add(player.vel.mult(25));
        let diff = futurePos.sub(this.pos);
        
        // Stuck logic
        if (this.vel.mag() < 1.0) this.stuckTimer++;
        else this.stuckTimer = 0;

        if (this.stuckTimer > 50) this.reversing = true;
        if (this.stuckTimer > 90) { this.reversing = false; this.stuckTimer = 0; }

        if (this.reversing) {
            this.accInput = -ACCELERATION * 0.6;
            this.rotDirection = 1;
        } else {
            this.accInput = ACCELERATION * 0.98;
            // Angle to target
            // atan2(y, x). Remember Y is inverted in our physics model vs screen
            // Our physics: Y goes down is +? No, standard screen.
            // Angle model: 0 is Right, +Angle is Up (Negative Y).
            // So dy should be inverted for atan2
            let targetAngle = Math.atan2(-diff.y, diff.x) * 180 / Math.PI;
            
            // Normalize angles
            let currentAngle = this.angle;
            let angleDiff = (targetAngle - currentAngle + 180) % 360 - 180;
            // Handle JS modulo negative result
             if (angleDiff < -180) angleDiff += 360;
             if (angleDiff > 180) angleDiff -= 360;

            if (angleDiff > 8) this.rotDirection = -1;
            else if (angleDiff < -8) this.rotDirection = 1;
            else this.rotDirection = 0;
        }

        this.physics(buildings, false);
    }

    draw(ctx) {
        ctx.save();
        ctx.translate(this.pos.x, this.pos.y);
        // Canvas rotation is clockwise. Our angle is CCW.
        ctx.rotate(-degToRad(this.angle));
        ctx.drawImage(this.sprite, -this.width/2, -this.height/2);
        ctx.restore();
    }
}

class Person {
    constructor(x, y, walkArea) {
        this.pos = new Vector2(x, y);
        this.shirtColor = randChoice(['#14141e', '#c8c8c8', '#323264', '#b4b4be', '#ffffff']);
        this.skinColor = '#ffd2b4';
        let angleRad = randFloat(0, Math.PI * 2);
        this.vel = new Vector2(Math.cos(angleRad), Math.sin(angleRad)).mult(0.4);
        this.angle = -angleRad * 180 / Math.PI;
        this.walkArea = walkArea;
        this.rect = new Rect(x-7, y-7, 14, 14);

        this.isDead = false;
        this.isAngry = false;
        this.shoutTimer = 0;
        this.curseWord = "";
        this.frame = 0;
        this.curseList = ["WTF!", "HEY!", "WATCH IT!", "IDIOT!", "NOOO!"];
    }

    die(bloodGroup) {
        if (this.isDead) return;
        this.isDead = true;
        this.vel = new Vector2(0,0);
        // Spawn blood
        for (let i=0; i<2; i++) {
            bloodGroup.push(new Blood(this.pos.x + randInt(-5,5), this.pos.y + randInt(-5,5)));
        }
    }

    update(player, bloodGroup) {
        if (this.isDead) return;

        let dist = this.pos.distanceTo(player.pos);

        // 1. Death
        if (dist < 30 && player.vel.mag() > 2.0) {
            this.die(bloodGroup);
            return;
        }

        // 2. Angry
        if (dist < 70 && !this.isAngry) {
            this.isAngry = true;
            this.shoutTimer = 120;
            this.curseWord = randChoice(this.curseList);
            this.vel = new Vector2(0,0);
        }

        if (this.isAngry) {
            this.shoutTimer--;
            if (this.shoutTimer <= 0) {
                this.isAngry = false;
                let angleRad = randFloat(0, Math.PI * 2);
                this.vel = new Vector2(Math.cos(angleRad), Math.sin(angleRad)).mult(0.4);
                this.angle = -angleRad * 180 / Math.PI;
            }
        } else {
            // Walk
            if (this.walkArea) {
                let futurePos = this.pos.add(this.vel.mult(5));
                if (!this.walkArea.collidePoint(futurePos.x, futurePos.y)) {
                    this.vel = this.vel.rotate(180);
                    this.angle = (this.angle + 180) % 360;
                }
            }
            this.pos = this.pos.add(this.vel);
            if (Math.random() < 0.01) {
                let rot = randChoice([90, -90, 180]);
                this.vel = this.vel.rotate(rot);
                this.angle = (this.angle + rot) % 360;
            }
        }

        this.rect.centerx = this.pos.x;
        this.rect.centery = this.pos.y;
        this.frame += 0.2;
    }

    draw(ctx) {
        ctx.save();
        ctx.translate(this.pos.x, this.pos.y);
        
        if (this.isDead) {
            // Crushed
            ctx.rotate(-degToRad(this.angle));
            // Blood pool
            ctx.fillStyle = '#960000';
            ctx.beginPath(); ctx.ellipse(0, 0, 10, 6, 0, 0, Math.PI*2); ctx.fill();
            // Shirt
            ctx.fillStyle = this.shirtColor;
            ctx.fillRect(-6, -2, 12, 4);
            // Head
            ctx.fillStyle = this.skinColor;
            ctx.beginPath(); ctx.arc(8, 0, 3, 0, Math.PI*2); ctx.fill();
        } else {
            ctx.rotate(-degToRad(this.angle));
            let swing = Math.sin(this.frame) * 3;
            if (this.isAngry) swing = 0;
            
            // Body
            drawRect(ctx, this.shirtColor, -5, -3, 10, 6, 3);
            // Head
            drawCircle(ctx, this.skinColor, 0, 0, 4);
            // Hands
            if (this.isAngry) {
                // Hands up
                let shake = randInt(-1, 1);
                drawCircle(ctx, this.skinColor, 6 + shake, -3 - 3, 2);
                drawCircle(ctx, this.skinColor, 6 + shake, 3 + 3, 2);
            } else {
                drawCircle(ctx, this.skinColor, 3, 3 + swing, 2);
                drawCircle(ctx, this.skinColor, 3, -3 - swing, 2);
            }
        }
        ctx.restore();
    }
}

class Building {
    constructor(gx, gy, isPark) {
        this.gx = gx;
        this.gy = gy;
        let x = gx * BLOCK_SIZE + BLOCK_SIZE/2;
        let y = gy * BLOCK_SIZE + BLOCK_SIZE/2;
        this.pos = new Vector2(x, y);
        this.w = BLOCK_SIZE - BUILDING_GAP * 2;
        this.h = BLOCK_SIZE - BUILDING_GAP * 2;
        this.rect = new Rect(x - this.w/2, y - this.h/2, this.w, this.h);
        
        // Use a consistent seeded RNG so buildings look the same when you return
        this.rng = new SeededRNG(Math.abs(gx * 73856093 ^ gy * 19349663));
        
        this.sprite = this.generateSprite(isPark);
        this.style = isPark ? 'park' : 'building';
    }

    generateSprite(isPark) {
        const cvs = document.createElement('canvas');
        cvs.width = this.w;
        cvs.height = this.h;
        const ctx = cvs.getContext('2d');
        // Disable smoothing for sharp pixels on building sprite generation
        ctx.imageSmoothingEnabled = false;
        
        const w = this.w, h = this.h;
        const rng = this.rng;

        if (isPark) {
            ctx.fillStyle = COLORS.ZOO_BASE;
            ctx.fillRect(0, 0, w, h);
            ctx.fillStyle = '#b4aa96';
            ctx.fillRect(w/2 - 20, 0, 40, h);
            ctx.fillRect(0, h/2 - 20, w, 40);
            
            // Pond
            for (let r=60; r>10; r-=5) {
                // Color math approx
                ctx.fillStyle = `rgb(50, 150, ${250-r})`;
                ctx.beginPath(); ctx.arc(w/2+80, h/2-80, r, 0, Math.PI*2); ctx.fill();
            }
        } else {
            // Base sidewalk
            ctx.fillStyle = COLORS.SIDEWALK;
            ctx.fillRect(0, 0, w, h);

            // Props
            for (let i=0; i<5; i++) {
                let px = rng.randInt(5, w-20);
                let py = rng.randInt(5, h-20);
                if (px > 30 && px < w-30 && py > 30 && py < h-50) continue; // Skip center

                let type = rng.choice(['planter', 'box']);
                if (type === 'planter') {
                    ctx.fillStyle = '#644632'; ctx.fillRect(px, py, 12, 12);
                    ctx.fillStyle = '#3c8c3c'; ctx.beginPath(); ctx.arc(px+6, py+6, 5, 0, Math.PI*2); ctx.fill();
                } else {
                    ctx.fillStyle = '#64646e'; ctx.fillRect(px, py, 10, 16);
                }
            }

            // Building Structure
            let pad = 12;
            let wallH = 35;
            let iw = w - pad*2, ih = h - pad*2;
            let roofRect = {x:pad, y:pad, w:iw, h:ih - wallH};
            let wallRect = {x:pad, y:pad+ih-wallH, w:iw, h:wallH};

            let styles = ['modern', 'izakaya', 'brick', 'school'];
            let style = rng.choice(styles);
            this.buildingStyle = style;

            if (style === 'school') {
                ctx.fillStyle = COLORS.SCHOOL_BEIGE; ctx.fillRect(roofRect.x, roofRect.y, roofRect.w, roofRect.h);
                ctx.fillStyle = '#c8beace'; ctx.fillRect(wallRect.x, wallRect.y, wallRect.w, wallRect.h);
                // Clock
                ctx.fillStyle = '#b4aa96'; ctx.fillRect(roofRect.x+roofRect.w/2-20, roofRect.y+roofRect.h/2-20, 40, 40);
                drawCircle(ctx, COLORS.CLOCK_FACE, roofRect.x+roofRect.w/2, roofRect.y+roofRect.h/2, 15);
                // Windows
                ctx.fillStyle = '#6496c8';
                for(let r=0; r<3; r++) {
                    for(let c=0; c<6; c++) {
                        if (rng.next()>0.2) ctx.fillRect(roofRect.x + c*(iw/6)+8, roofRect.y + r*25+15, 20, 15);
                    }
                }
            } else if (style === 'izakaya') {
                ctx.fillStyle = COLORS.WOOD_DARK; ctx.fillRect(roofRect.x-2, roofRect.y-2, roofRect.w+4, roofRect.h+4);
                ctx.fillStyle = COLORS.ROOF_TILE_JP; ctx.fillRect(roofRect.x, roofRect.y, roofRect.w, roofRect.h);
                ctx.fillStyle = COLORS.WOOD_RED; ctx.fillRect(wallRect.x, wallRect.y, wallRect.w, wallRect.h);
                // Lanterns
                for(let i=0; i<4; i++) {
                    drawCircle(ctx, COLORS.LANTERN_RED, wallRect.x + (iw/4)*i + 20, wallRect.y+5, 6);
                }
            } else if (style === 'modern') {
                ctx.fillStyle = '#9696a0'; ctx.fillRect(roofRect.x, roofRect.y, roofRect.w, roofRect.h);
                ctx.strokeStyle = COLORS.CONCRETE_DARK; ctx.lineWidth = 3; ctx.strokeRect(roofRect.x, roofRect.y, roofRect.w, roofRect.h);
                ctx.fillStyle = '#787882'; ctx.fillRect(wallRect.x, wallRect.y, wallRect.w, wallRect.h);
                // Windows
                let winW = iw/3 - 5, winH = (ih-wallH)/3 - 5;
                for(let r=0; r<3; r++) {
                    for(let c=0; c<3; c++) {
                        let wx = roofRect.x + c*(winW+5) + 8, wy = roofRect.y + r*(winH+5) + 8;
                        ctx.fillStyle = rng.choice([COLORS.WIN_LIT_COOL, COLORS.WIN_LIT_WARM, COLORS.WIN_DARK]);
                        ctx.fillRect(wx, wy, winW, winH);
                    }
                }
            } else { // Brick
                ctx.fillStyle = '#a06450'; ctx.fillRect(roofRect.x, roofRect.y, roofRect.w, roofRect.h);
                ctx.fillStyle = COLORS.SIDEWALK; ctx.fillRect(wallRect.x, wallRect.y, wallRect.w, wallRect.h);
                // Windows
                let ww = iw/5, wh = (ih-wallH)/4;
                for(let r=0; r<4; r++) {
                    for(let c=0; c<5; c++) {
                        ctx.fillStyle = rng.choice([COLORS.WIN_LIT_WARM, COLORS.WIN_DARK]);
                        ctx.fillRect(roofRect.x + c*ww + 8, roofRect.y + r*wh + 8, ww-16, wh-20);
                    }
                }
            }
        }
        return cvs;
    }

    draw(ctx) {
        // Shadow
        ctx.fillStyle = 'rgba(0,0,0,0.25)';
        ctx.fillRect(this.rect.x+8, this.rect.y+8, this.w, this.h);
        // Building
        ctx.drawImage(this.sprite, this.rect.x, this.rect.y);
    }
}

class Sakura {
    constructor(x, y) {
        this.pos = new Vector2(x, y);
        this.rect = new Rect(x-20, y-20, 40, 40);
        this.sprite = this.generate();
    }
    generate() {
        const cvs = document.createElement('canvas');
        cvs.width = 40; cvs.height = 40;
        const ctx = cvs.getContext('2d');
        // Trunk
        ctx.fillStyle = '#46281e'; ctx.fillRect(18, 20, 4, 20);
        // Leaves
        for(let i=0; i<30; i++) {
            ctx.fillStyle = randChoice([COLORS.SAKURA_PINK, COLORS.SAKURA_DARK, '#ffc8dc']);
            drawCircle(ctx, ctx.fillStyle, randInt(5,35), randInt(5,30), randInt(3,5));
        }
        return cvs;
    }
    draw(ctx) {
        ctx.drawImage(this.sprite, this.rect.x, this.rect.y);
    }
}

class Blood {
    constructor(x, y) {
        this.pos = new Vector2(x, y);
        this.size = randInt(15, 30);
        this.color = '#b40000';
        this.rect = new Rect(x-this.size/2, y-this.size/2, this.size, this.size);
    }
    draw(ctx) {
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.pos.x, this.pos.y, this.size/2, 0, Math.PI*2);
        ctx.fill();
        ctx.fillStyle = '#8c0000';
        ctx.beginPath();
        ctx.arc(this.pos.x + randInt(-5,5), this.pos.y + randInt(-5,5), this.size/3, 0, Math.PI*2);
        ctx.fill();
    }
}

class Particle {
    constructor(x, y, type) {
        this.pos = new Vector2(x, y);
        this.type = type;
        this.life = type === 'smoke' ? 40 : 20;
        this.maxLife = this.life;
        
        if (type === 'smoke') {
            this.vel = new Vector2(randFloat(-1, 1), randFloat(-1, 1));
            this.size = randInt(4, 10);
            let c = randInt(50, 100);
            this.color = `rgb(${c},${c},${c})`;
        } else if (type === 'spark') {
            this.vel = new Vector2(randFloat(-4, 4), randFloat(-4, 4));
            this.size = 5;
            this.color = '#ff6400';
        }
    }
    update() {
        this.pos = this.pos.add(this.vel);
        this.life--;
    }
    draw(ctx) {
        ctx.fillStyle = this.color;
        ctx.fillRect(this.pos.x - this.size/2, this.pos.y - this.size/2, this.size, this.size);
    }
}

class Skid {
    constructor(x, y, angle) {
        this.pos = new Vector2(x, y);
        this.angle = angle;
        this.life = 100;
        this.rect = new Rect(x-10, y-10, 20, 20);
    }
    update() { this.life -= 2; }
    draw(ctx) {
        ctx.save();
        ctx.translate(this.pos.x, this.pos.y);
        ctx.rotate(-degToRad(this.angle));
        ctx.fillStyle = `rgba(30, 30, 30, ${this.life/100 * 0.6})`;
        ctx.fillRect(-5, -2, 10, 4);
        ctx.restore();
    }
}

// --- Main Game Class ---

class Game {
    constructor() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        // VITAL: Disable smoothing for pixel art look
        this.ctx.imageSmoothingEnabled = false;
        
        this.resize();
        window.addEventListener('resize', () => this.resize());

        // Inputs
        this.keys = {};
        window.addEventListener('keydown', e => this.keys[e.key] = true);
        window.addEventListener('keyup', e => this.keys[e.key] = false);
        this.canvas.addEventListener('mousedown', e => this.onClick(e));

        // Game State
        this.state = 'MENU'; // MENU, PLAY, GAMEOVER
        this.score = 0;
        this.restartRect = new Rect(0,0,0,0);
        this.playRect = new Rect(0,0,0,0);
        
        this.loop = this.loop.bind(this);
        requestAnimationFrame(this.loop);
    }

    initGame() {
        this.player = new Car(0, 0, COLORS.PLAYER);
        this.camera = new Camera();
        this.buildings = [];
        this.people = [];
        this.cops = [];
        this.sakura = [];
        this.particles = [];
        this.skids = [];
        this.blood = [];
        this.loadedChunks = new Set();
        
        this.spawnTimer = 0;
        this.score = 0;
    }

    resize() {
        this.canvas.width = window.innerWidth;
        this.canvas.height = window.innerHeight;
        // Re-disable smoothing after resize reset
        this.ctx.imageSmoothingEnabled = false;
    }

    onClick(e) {
        const mx = e.clientX;
        const my = e.clientY;

        if (this.state === 'MENU') {
            if (this.playRect.collidePoint(mx, my)) {
                this.initGame();
                this.state = 'PLAY';
            }
        } else if (this.state === 'GAMEOVER') {
            if (this.restartRect.collidePoint(mx, my)) {
                this.initGame();
                this.state = 'PLAY';
            }
        }
    }

    generateChunk(gx, gy) {
        const isRoadX = (gx % 3 === 0);
        const isRoadY = (gy % 3 === 0);
        const cx = gx * BLOCK_SIZE + BLOCK_SIZE/2;
        const cy = gy * BLOCK_SIZE + BLOCK_SIZE/2;
        
        // Use seeded RNG for consistent prop placement if needed, 
        // though for entities we typically accept some randomness.
        // For consistent world, we use the SeededRNG.
        let seed = Math.abs(gx * 73856093 ^ gy * 19349663);
        let rng = new SeededRNG(seed);

        if (isRoadX || isRoadY) {
            if (rng.next() < 0.1) {
                this.people.push(new Person(cx + rng.randInt(-50,50), cy + rng.randInt(-50,50), null));
            }
        } else {
            const sidewalkRect = new Rect(gx * BLOCK_SIZE, gy * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE).inflate(-10, -10);
            
            if (rng.next() < 0.08) {
                // Park
                this.buildings.push(new Building(gx, gy, true));
                for(let i=0; i<rng.randInt(3,6); i++) {
                    this.sakura.push(new Sakura(cx + rng.randInt(-100,100), cy + rng.randInt(-100,100)));
                }
            } else {
                // Building
                let b = new Building(gx, gy, false);
                this.buildings.push(b);
                
                // People
                if (rng.next() < 0.95) {
                    for(let i=0; i<rng.randInt(8,20); i++) {
                        let side = rng.choice(['n','s','e','w']);
                        let offset = BLOCK_SIZE/2 - 30;
                        let px, py;
                        if (side==='n') { px = cx + rng.randInt(-offset, offset); py = cy - offset; }
                        else if (side==='s') { px = cx + rng.randInt(-offset, offset); py = cy + offset; }
                        else if (side==='e') { px = cx + offset; py = cy + rng.randInt(-offset, offset); }
                        else { px = cx - offset; py = cy + rng.randInt(-offset, offset); }
                        
                        this.people.push(new Person(px, py, sidewalkRect));
                    }
                }
            }
        }
    }

    updateChunks() {
        const view = this.camera.viewRect;
        const startGx = Math.floor(view.left / BLOCK_SIZE) - 1;
        const endGx = Math.floor(view.right / BLOCK_SIZE) + 1;
        const startGy = Math.floor(view.top / BLOCK_SIZE) - 1;
        const endGy = Math.floor(view.bottom / BLOCK_SIZE) + 1;

        for(let gx = startGx; gx < endGx; gx++) {
            for(let gy = startGy; gy < endGy; gy++) {
                let key = `${gx},${gy}`;
                if (!this.loadedChunks.has(key)) {
                    this.generateChunk(gx, gy);
                    this.loadedChunks.add(key);
                }
            }
        }

        // Cleanup Logic
        // The previous logic had a bug where buildings were removed from the array 
        // but their keys remained in loadedChunks, preventing regeneration.
        // We now explicitly check bounds and remove from both.
        
        const margin = 1200; // Keep slightly larger area to prevent pop-in
        const keepRect = view.inflate(margin, margin);
        
        // 1. Cull Buildings & Update LoadedChunks
        for (let i = this.buildings.length - 1; i >= 0; i--) {
            let b = this.buildings[i];
            // If building is completely outside keep rect
            if (!keepRect.collideRect(b.rect)) {
                // IMPORTANT: Remove the chunk key so it can be generated again later
                this.loadedChunks.delete(`${b.gx},${b.gy}`);
                this.buildings.splice(i, 1);
            }
        }

        // 2. Cull Transients (People, Sakura, etc)
        // Since people and sakura are generated by generateChunk(), they should also disappear 
        // if the chunk unloads.
        const cull = (arr) => {
            return arr.filter(obj => {
                if (obj.rect) return keepRect.collideRect(obj.rect);
                return keepRect.collidePoint(obj.pos.x, obj.pos.y);
            });
        };

        this.people = cull(this.people);
        this.sakura = cull(this.sakura);
        this.skids = cull(this.skids);
        this.blood = cull(this.blood);
    }

    update() {
        if (this.state !== 'PLAY') return;

        // Input
        this.player.rotDirection = 0;
        this.player.accInput = 0;
        if (this.keys['ArrowLeft'] || this.keys['a'] || this.keys['A']) this.player.rotDirection = -1;
        if (this.keys['ArrowRight'] || this.keys['d'] || this.keys['D']) this.player.rotDirection = 1;
        if (this.keys['ArrowUp'] || this.keys['w'] || this.keys['W']) this.player.accInput = ACCELERATION;
        if (this.keys['ArrowDown'] || this.keys['s'] || this.keys['S']) this.player.accInput = -ACCELERATION * 0.5;
        let drift = this.keys[' '] || this.keys['Shift'];

        if (this.keys['r'] || this.keys['R']) {
             if (this.player.health && this.player.health.checkFullyDestroyed()) {
                 this.initGame();
                 return;
             }
        }

        this.camera.update(this.player, this.canvas.width, this.canvas.height);
        this.updateChunks();

        this.player.physics(this.buildings, drift);

        // Spawn Cops
        this.spawnTimer++;
        if (this.spawnTimer > 120) { // Every 2 seconds
            this.spawnTimer = 0;
            let angle = randFloat(0, Math.PI*2);
            let dist = 800;
            let cx = this.player.pos.x + Math.cos(angle)*dist;
            let cy = this.player.pos.y + Math.sin(angle)*dist;
            // Only spawn on roads
            let gx = Math.floor(cx / BLOCK_SIZE);
            let gy = Math.floor(cy / BLOCK_SIZE);
            if ((gx % 3 === 0) || (gy % 3 === 0)) {
                this.cops.push(new Car(cx, cy, COLORS.COP_BODY, true));
            }
        }

        // Skids
        if (Math.abs(this.player.rotDirection) > 0 && this.player.vel.mag() > 4) {
            this.skids.push(new Skid(this.player.pos.x, this.player.pos.y, this.player.angle));
        }
        this.skids.forEach((s,i) => { s.update(); if(s.life<=0) this.skids.splice(i,1); });

        // Cops
        this.cops.forEach((cop, i) => {
            cop.updateCop(this.player, this.buildings);
            
            // Cop collision
            if (cop.getHitbox().collideRect(this.player.getHitbox())) {
                this.player.health.takeDamage(10);
                // Bounce
                let bounce = this.player.pos.sub(cop.pos).normalize().mult(5);
                this.player.vel = this.player.vel.add(bounce);
                cop.vel = cop.vel.sub(bounce);
                for(let k=0; k<5; k++) this.particles.push(new Particle(this.player.pos.x, this.player.pos.y, 'spark'));
            }
            
            // Cop vs Cop
            for (let j=i+1; j<this.cops.length; j++) {
                let other = this.cops[j];
                if (cop.pos.distanceTo(other.pos) < 45) {
                    // Crash
                    cop.dead = true; other.dead = true;
                    this.score += 100;
                    for(let k=0; k<15; k++) this.particles.push(new Particle(cop.pos.x, cop.pos.y, 'spark'));
                }
            }
        });
        this.cops = this.cops.filter(c => !c.dead);

        // People
        this.people.forEach(p => p.update(this.player, this.blood));

        // Particles
        this.particles.forEach((p,i) => { p.update(); if(p.life<=0) this.particles.splice(i,1); });

        // Smoke
        if (this.player.health.parts['front_torso'] <= 0 && Math.random() < 0.3) {
            this.particles.push(new Particle(this.player.pos.x, this.player.pos.y, 'smoke'));
        }

        // Game Over Check
        if (this.player.health.checkFullyDestroyed()) {
            this.state = 'GAMEOVER';
        }
    }

    drawFloor() {
        const bs = BLOCK_SIZE;
        const view = this.camera.viewRect;
        const startGx = Math.floor(view.left / bs) - 1;
        const endGx = Math.floor(view.right / bs) + 1;
        const startGy = Math.floor(view.top / bs) - 1;
        const endGy = Math.floor(view.bottom / bs) + 1;

        for (let gx = startGx; gx < endGx; gx++) {
            for (let gy = startGy; gy < endGy; gy++) {
                let isRoadX = (gx % 3 === 0);
                let isRoadY = (gy % 3 === 0);
                let sx = gx * bs + this.camera.offset.x;
                let sy = gy * bs + this.camera.offset.y;

                if (isRoadX || isRoadY) {
                    this.ctx.drawImage(roadPatternCanvas, sx, sy);
                    
                    // Markings
                    this.ctx.fillStyle = COLORS.PAINT_WHITE;
                    if (isRoadY) {
                        this.ctx.fillRect(sx, sy+10, bs, 3);
                        this.ctx.fillRect(sx, sy+bs-10, bs, 3);
                    }
                    if (isRoadX) {
                        this.ctx.fillRect(sx+10, sy, 3, bs);
                        this.ctx.fillRect(sx+bs-10, sy, 3, bs);
                    }
                    
                    this.ctx.fillStyle = COLORS.PAINT_YELLOW;
                    if (isRoadY && !isRoadX) {
                        for(let i=0; i<bs; i+=40) this.ctx.fillRect(sx+i+10, sy+bs/2, 20, 3);
                    }
                    if (isRoadX && !isRoadY) {
                        for(let i=0; i<bs; i+=40) this.ctx.fillRect(sx+bs/2, sy+i+10, 3, 20);
                    }

                    // Intersection
                    if (isRoadX && isRoadY) {
                        this.ctx.fillStyle = COLORS.PAINT_WHITE;
                        for(let i=120; i<260; i+=20) {
                            this.ctx.fillRect(sx+20, sy+i, 80, 12);
                            this.ctx.fillRect(sx+bs-100, sy+i, 80, 12);
                            this.ctx.fillRect(sx+i, sy+20, 12, 80);
                            this.ctx.fillRect(sx+i, sy+bs-100, 12, 80);
                        }
                    }
                }
            }
        }
    }

    drawIndicators() {
        const cx = this.canvas.width/2;
        const cy = this.canvas.height/2;
        const pad = 20;

        this.cops.forEach(cop => {
            let dist = this.player.pos.distanceTo(cop.pos);
            if (dist > 1500) return;
            // Check if on screen
            let screenPos = this.camera.apply(cop.getRect());
            if (screenPos.x > 0 && screenPos.x < this.canvas.width && screenPos.y > 0 && screenPos.y < this.canvas.height) return;

            let dx = cop.pos.x - this.player.pos.x;
            let dy = cop.pos.y - this.player.pos.y;
            if (dx===0) dx=0.1; if (dy===0) dy=0.1;
            
            let scale = Math.min(Math.abs((cx-pad)/dx), Math.abs((cy-pad)/dy));
            let dxDraw = cx + dx * scale;
            let dyDraw = cy + dy * scale;

            this.ctx.fillStyle = '#ff3232';
            this.ctx.beginPath(); this.ctx.arc(dxDraw, dyDraw, 14, 0, Math.PI*2); this.ctx.fill();
            this.ctx.strokeStyle = '#fff'; this.ctx.lineWidth=2; this.ctx.stroke();
            this.ctx.fillStyle = '#fff'; this.ctx.font = 'bold 16px Arial'; this.ctx.textAlign='center'; this.ctx.textBaseline='middle';
            this.ctx.fillText("!", dxDraw, dyDraw);
        });
    }

    draw() {
        const ctx = this.ctx;
        const w = this.canvas.width;
        const h = this.canvas.height;

        // Background
        ctx.fillStyle = COLORS.BG_VOID;
        ctx.fillRect(0, 0, w, h);

        if (this.state === 'MENU') {
            ctx.fillStyle = COLORS.TEXT_WHITE;
            ctx.font = 'bold 40px Arial';
            ctx.textAlign = 'center';
            ctx.fillText("TOKYO DRIFT CHASE", w/2, h/2 - 80);

            let btnW = 200, btnH = 60;
            this.playRect = new Rect(w/2 - btnW/2, h/2 + 20, btnW, btnH);
            
            drawRect(ctx, '#fff', this.playRect.x-2, this.playRect.y-2, btnW+4, btnH+4, 5);
            drawRect(ctx, '#c82828', this.playRect.x, this.playRect.y, btnW, btnH, 5);
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 20px Arial';
            ctx.fillText("P L A Y", w/2, h/2 + 57);

            return;
        }

        // --- Game Render ---
        
        this.drawFloor();

        // Object sorting by Y for primitive depth
        // Note: Buildings, People, Cops need to be sorted.
        let renderList = [
            ...this.blood.map(o => ({obj:o, type:'blood', y:o.pos.y})),
            ...this.skids.map(o => ({obj:o, type:'skid', y:o.pos.y})),
            ...this.buildings.map(o => ({obj:o, type:'building', y:o.rect.bottom})),
            ...this.people.map(o => ({obj:o, type:'person', y:o.rect.bottom})),
            ...this.sakura.map(o => ({obj:o, type:'sakura', y:o.rect.bottom})),
            ...this.cops.map(o => ({obj:o, type:'car', y:o.pos.y})),
            {obj: this.player, type:'car', y:this.player.pos.y}
        ];

        renderList.sort((a,b) => a.y - b.y);

        renderList.forEach(item => {
            // Cull drawing
            let screenRect;
            if (item.type === 'car') screenRect = this.camera.apply(item.obj.getRect());
            else screenRect = this.camera.apply(item.obj.rect);

            if (screenRect.right < -50 || screenRect.left > w + 50 || screenRect.bottom < -50 || screenRect.top > h + 50) return;

            // Apply camera offset manually for draw calls
            // Since we don't have a global transform (to keep UI static), 
            // we pass the context relative to screen.
            // But our objects store WORLD coordinates.
            // We need to translate context by camera offset.
            
            // Save context, translate by camera, draw object, restore
            // Actually, simpler: translate context ONCE for the world layer?
            // Yes, let's restructure render loop.
        });

        // Better Render Loop: Use Global Transform
        ctx.save();
        ctx.translate(this.camera.offset.x, this.camera.offset.y);

        // Draw Blood & Skids (Background layer)
        this.blood.forEach(b => b.draw(ctx));
        this.skids.forEach(s => s.draw(ctx));

        // Draw Sorted Entities
        // Filter out blood/skids from renderList as they are drawn.
        renderList.filter(i => i.type !== 'blood' && i.type !== 'skid').forEach(item => {
             item.obj.draw(ctx);
             
             // Speech Bubbles
             if (item.type === 'person' && item.obj.isAngry && !item.obj.isDead) {
                 let bx = item.obj.pos.x, by = item.obj.rect.top - 15;
                 ctx.fillStyle = '#fff';
                 let txt = item.obj.curseWord;
                 ctx.font = 'bold 12px Arial';
                 let tm = ctx.measureText(txt);
                 let bw = tm.width + 10, bh = 20;
                 
                 drawRect(ctx, '#fff', bx - bw/2, by - bh/2, bw, bh, 5);
                 ctx.beginPath(); ctx.moveTo(bx, by+bh/2); ctx.lineTo(bx-3, by+bh/2+4); ctx.lineTo(bx+3, by+bh/2+4); ctx.fill();
                 
                 ctx.fillStyle = '#000';
                 ctx.textAlign = 'center';
                 ctx.fillText(txt, bx, by + 4);
             }
        });

        // Particles
        this.particles.forEach(p => p.draw(ctx));

        ctx.restore();

        // --- UI Layer (Static) ---
        
        // Indicators
        this.drawIndicators();

        // Score
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 20px Arial';
        ctx.textAlign = 'left';
        ctx.fillText(`SCORE: ${this.score}`, 20, 30);

        // Health UI
        this.player.health.drawUI(ctx, w - 60, 10);

        // Game Over Overlay
        if (this.state === 'GAMEOVER') {
            ctx.fillStyle = 'rgba(0,0,0,0.6)';
            ctx.fillRect(0, 0, w, h);
            
            ctx.fillStyle = '#ff3232';
            ctx.font = 'bold 50px Arial';
            ctx.textAlign = 'center';
            ctx.fillText("WASTED", w/2, h/2 - 20);
            
            let btnW = 200, btnH = 60;
            this.restartRect = new Rect(w/2 - btnW/2, h/2 + 20, btnW, btnH);
            
            drawRect(ctx, '#fff', this.restartRect.x, this.restartRect.y, btnW, btnH, 5);
            drawRect(ctx, '#c83232', this.restartRect.x+2, this.restartRect.y+2, btnW-4, btnH-4, 5);
            
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 20px Arial';
            ctx.fillText("RESTART", w/2, h/2 + 57);
        }
    }

    loop() {
        this.update();
        this.draw();
        requestAnimationFrame(this.loop);
    }
}

// Start Game
const game = new Game();

</script>
</body>
</html>

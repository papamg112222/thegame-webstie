<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>The Observed One</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Courier New', monospace; user-select: none; background: #000; }
        
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        
        /* Crosshair */
        #crosshair {
            position: absolute; top: 50%; left: 50%; width: 6px; height: 6px;
            background: rgba(255, 255, 255, 0.8); border-radius: 50%;
            transform: translate(-50%, -50%); box-shadow: 0 0 5px white;
        }
        
        /* Top HUD */
        #hud {
            position: absolute; top: 20px; left: 20px; color: #00ff00;
            text-shadow: 1px 1px 2px #000; font-size: 16px;
            background: rgba(0, 20, 0, 0.6); padding: 10px; border: 1px solid #00ff00;
        }

        /* Analysis Overlay (The "AI Vision") */
        #ai-analysis {
            position: absolute; top: 20px; right: 20px; text-align: right;
            color: #ff0055; font-size: 12px; opacity: 0.7;
        }

        /* Chat System */
        #chat-ui {
            display: none; position: absolute; bottom: 30px; left: 50%;
            transform: translateX(-50%); width: 60%; max-width: 700px;
            background: rgba(10, 10, 10, 0.95); border: 1px solid #333;
            border-radius: 4px; pointer-events: auto;
            box-shadow: 0 0 30px rgba(0,0,0,0.8);
        }
        
        #chat-log {
            height: 250px; overflow-y: auto; padding: 15px;
            display: flex; flex-direction: column; justify-content: flex-end;
            font-family: 'Segoe UI', sans-serif; font-size: 15px;
        }
        
        #chat-input {
            width: 100%; background: #222; border: none; border-top: 1px solid #444;
            color: white; font-size: 16px; padding: 15px; outline: none; box-sizing: border-box;
        }

        .msg-line { margin: 6px 0; line-height: 1.5; }
        .u-msg { color: #00e5ff; font-weight: bold; }
        .ai-msg { color: #ffd700; }
        .sys-msg { color: #aaaaaa; font-style: italic; font-size: 12px; }

        /* Start Screen */
        #blocker {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9); color: white; display: flex;
            justify-content: center; align-items: center; flex-direction: column; z-index: 20; pointer-events: auto;
        }
        
        h1 { margin-bottom: 5px; text-transform: uppercase; letter-spacing: 8px; color: #fff; }
        p { color: #888; font-size: 14px; }
    </style>
</head>
<body>

<div id="ui-layer">
    <div id="crosshair"></div>
    <div id="hud">
        OBJECTIVE: Find the Red Memory Cube (0/3)
    </div>
    <div id="ai-analysis">
        ANALYZING MOVEMENT...<br>
        <span id="stat-log">Waiting for input...</span>
    </div>
</div>

<div id="blocker">
    <h1>Social Protocol</h1>
    <p>Click to Initialize</p>
    <p style="margin-top: 20px; font-size: 12px; color: #555;">WASD to Move | / to Chat | E to Collect</p>
</div>

<div id="chat-ui">
    <div id="chat-log">
        <div class="msg-line sys-msg">System: AI Observational Module Active.</div>
    </div>
    <input type="text" id="chat-input" placeholder="Speak to the crowd..." autocomplete="off">
</div>

<script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
</script>

<script type="module">
    import * as THREE from 'three';
    import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

    // --- CONFIGURATION ---
    const WALK_SPEED = 40.0; // Realistic walking speed
    
    // --- VARIABLES ---
    let camera, scene, renderer, controls;
    let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
    let prevTime = performance.now();
    let velocity = new THREE.Vector3();
    let direction = new THREE.Vector3();
    
    // Game State
    let orbsCollected = 0;
    let storyPhase = 0; // 0: Normal, 1: Fame, 2: Hate
    const orbs = [];
    const npcs = [];
    
    // Player Stats (The "Memory")
    const playerStats = {
        totalDistance: 0,
        timeStill: 0,
        lastPosition: new THREE.Vector3(),
        lookUpCount: 0,
        lookDownCount: 0,
        moveStyle: "Unknown" // "Energetic", "Lazy", "Erratic"
    };

    const synth = window.speechSynthesis;

    init();
    animate();

    function init() {
        // Scene
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0xaaccff); // Day sky
        scene.fog = new THREE.Fog(0xaaccff, 10, 90);

        // Camera
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 1000);
        camera.position.y = 1.7;

        // Lights
        const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 2);
        hemiLight.position.set(0, 20, 0);
        scene.add(hemiLight);
        
        const dirLight = new THREE.DirectionalLight(0xffffff, 1.5);
        dirLight.position.set(50, 50, 50);
        dirLight.castShadow = true;
        scene.add(dirLight);

        // Controls
        controls = new PointerLockControls(camera, document.body);
        const blocker = document.getElementById('blocker');
        blocker.addEventListener('click', () => controls.lock());
        
        controls.addEventListener('lock', () => blocker.style.display = 'none');
        controls.addEventListener('unlock', () => {
            if (document.getElementById('chat-ui').style.display !== 'block') {
                blocker.style.display = 'flex';
            }
        });
        scene.add(controls.getObject());

        // Keyboard
        document.addEventListener('keydown', (e) => {
            switch (e.code) {
                case 'KeyW': moveForward = true; break;
                case 'KeyA': moveLeft = true; break;
                case 'KeyS': moveBackward = true; break;
                case 'KeyD': moveRight = true; break;
                case 'Slash': 
                    e.preventDefault();
                    toggleChat();
                    break;
            }
        });
        document.addEventListener('keyup', (e) => {
            switch (e.code) {
                case 'KeyW': moveForward = false; break;
                case 'KeyA': moveLeft = false; break;
                case 'KeyS': moveBackward = false; break;
                case 'KeyD': moveRight = false; break;
            }
        });

        // World Generation
        createWorld();

        // Renderer
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);
        window.addEventListener('resize', onWindowResize);
        
        // Start Analysis Loop
        setInterval(analyzePlayer, 2000); // Check stats every 2 seconds
    }

    function createWorld() {
        // Floor
        const floor = new THREE.Mesh(new THREE.PlaneGeometry(2000, 2000), new THREE.MeshStandardMaterial({ color: 0x4caf50 }));
        floor.rotation.x = -Math.PI / 2;
        floor.receiveShadow = true;
        scene.add(floor);

        // Grid of Houses (Village)
        for(let x = -2; x <= 2; x++) {
            for(let z = -2; z <= 2; z++) {
                if(x===0 && z===0) continue; // Leave center empty
                createHouse(x * 35, 0, z * 35);
            }
        }
        createHouse(0,0,-20); // Player house

        // Orbs
        createOrb(20, 1.5, 20);
        createOrb(-30, 1.5, -20);
        createOrb(40, 1.5, -40);

        // NPCs
        for(let i=0; i<25; i++) createNPC();
    }

    function createHouse(x, y, z) {
        const g = new THREE.Group();
        // Base
        const w = new THREE.Mesh(new THREE.CylinderGeometry(8, 8, 6, 6), new THREE.MeshStandardMaterial({ color: 0xe0e0e0 }));
        w.position.y = 3;
        w.castShadow = true;
        // Roof
        const r = new THREE.Mesh(new THREE.ConeGeometry(10, 5, 6), new THREE.MeshStandardMaterial({ color: 0x5d4037 }));
        r.position.y = 8;
        g.add(w); g.add(r);
        g.position.set(x,y,z);
        scene.add(g);
    }

    function createNPC() {
        const g = new THREE.Group();
        // Smooth body (Capsule)
        const mat = new THREE.MeshStandardMaterial({ color: Math.random() * 0xffffff });
        const body = new THREE.Mesh(new THREE.CapsuleGeometry(0.4, 1.2, 4, 16), mat);
        body.position.y = 0.9;
        
        // Head
        const head = new THREE.Mesh(new THREE.SphereGeometry(0.35, 16, 16), new THREE.MeshStandardMaterial({ color: 0xffccaa }));
        head.position.y = 1.7;
        
        g.add(body); g.add(head);
        
        let tx = (Math.random()-0.5)*120;
        let tz = (Math.random()-0.5)*120;
        if(Math.abs(tx) < 10) tx+=20;
        
        g.position.set(tx, 0, tz);
        scene.add(g);

        npcs.push({
            mesh: g,
            dir: new THREE.Vector3(Math.random()-0.5, 0, Math.random()-0.5).normalize(),
            speed: 0.01 + Math.random() * 0.03,
            pitch: 0.5 + Math.random(),
            state: "wandering"
        });
    }

    function createOrb(x, y, z) {
        const geo = new THREE.IcosahedronGeometry(0.8, 0);
        const mat = new THREE.MeshStandardMaterial({ color: 0xff0000, emissive: 0xaa0000, emissiveIntensity: 1 });
        const orb = new THREE.Mesh(geo, mat);
        orb.position.set(x,y,z);
        scene.add(orb);
        orbs.push(orb);
    }

    // --- ANALYSIS ENGINE ---
    function analyzePlayer() {
        if(!controls.isLocked) return;

        const currentPos = controls.getObject().position;
        const dist = currentPos.distanceTo(playerStats.lastPosition);
        
        // Update Dist
        playerStats.totalDistance += dist;
        
        // Update Stillness
        if (dist < 0.5) playerStats.timeStill++;
        else playerStats.timeStill = 0;

        // Update Gaze
        const camDir = new THREE.Vector3();
        camera.getWorldDirection(camDir);
        if (camDir.y > 0.3) playerStats.lookUpCount++;
        if (camDir.y < -0.3) playerStats.lookDownCount++;

        // Determine Style
        if (playerStats.totalDistance > 100 && playerStats.timeStill < 5) playerStats.moveStyle = "Rusher";
        else if (playerStats.timeStill > 10) playerStats.moveStyle = "Observer";
        else playerStats.moveStyle = "Casual";

        playerStats.lastPosition.copy(currentPos);
        
        // Debug UI
        document.getElementById('stat-log').innerHTML = 
            `Dist: ${Math.floor(playerStats.totalDistance)}m<br>
             Style: ${playerStats.moveStyle}`;
    }

    function animate() {
        requestAnimationFrame(animate);
        const time = performance.now();
        const delta = (time - prevTime) / 1000;

        if (controls.isLocked) {
            velocity.x -= velocity.x * 10.0 * delta;
            velocity.z -= velocity.z * 10.0 * delta;

            direction.z = Number(moveForward) - Number(moveBackward);
            direction.x = Number(moveRight) - Number(moveLeft);
            direction.normalize();

            if (moveForward || moveBackward) velocity.z -= direction.z * WALK_SPEED * delta;
            if (moveLeft || moveRight) velocity.x -= direction.x * WALK_SPEED * delta;

            controls.moveRight(-velocity.x * delta);
            controls.moveForward(-velocity.z * delta);

            // Objective Check
            orbs.forEach(orb => {
                if(orb.visible && orb.position.distanceTo(camera.position) < 2) {
                    orb.visible = false;
                    orbsCollected++;
                    updateGameState();
                }
                orb.rotation.y += delta;
                orb.rotation.x += delta * 0.5;
            });
        }

        // AI Behavior Update
        npcs.forEach(npc => {
            const distToPlayer = npc.mesh.position.distanceTo(camera.position);

            if (storyPhase === 0) {
                // Normal
                npc.mesh.position.addScaledVector(npc.dir, npc.speed);
                if(Math.random()<0.01) npc.dir.set(Math.random()-0.5, 0, Math.random()-0.5).normalize();
            } else if (storyPhase === 1) {
                // FAME: They flock to you but respectfully
                npc.mesh.lookAt(camera.position.x, 1.7, camera.position.z);
                if(distToPlayer > 5) {
                     const toP = new THREE.Vector3().subVectors(camera.position, npc.mesh.position).normalize();
                     toP.y = 0;
                     npc.mesh.position.addScaledVector(toP, npc.speed * 1.5);
                }
            } else if (storyPhase === 2) {
                // HATE: Avoid or Stare
                npc.mesh.lookAt(camera.position.x, 1.7, camera.position.z);
                // If too close, back away
                if(distToPlayer < 8) {
                     const away = new THREE.Vector3().subVectors(npc.mesh.position, camera.position).normalize();
                     away.y = 0;
                     npc.mesh.position.addScaledVector(away, npc.speed * 2.0);
                }
            }
        });

        prevTime = time;
        renderer.render(scene, camera);
    }

    function updateGameState() {
        const hud = document.getElementById('hud');
        if(orbsCollected === 1) {
            storyPhase = 1;
            hud.innerText = "OBJECTIVE: Find the Red Memory Cube (1/3) - [FAME STATUS: VIRAL]";
            hud.style.color = "#00e5ff";
            addLog("System", "People are noticing your movements...");
        } else if (orbsCollected === 2) {
            hud.innerText = "OBJECTIVE: Find the Red Memory Cube (2/3) - [FAME STATUS: LEGEND]";
        } else if (orbsCollected === 3) {
            storyPhase = 2;
            hud.innerText = "OBJECTIVE: SURVIVE THE HATE";
            hud.style.color = "#ff0000";
            hud.style.borderColor = "#ff0000";
            scene.background = new THREE.Color(0x220000); // Red sky
            scene.fog = new THREE.Fog(0x220000, 10, 50);
            addLog("System", "They turned against you.");
        }
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    // --- CHAT & RESPONSE SYSTEM ---

    const chatUI = document.getElementById('chat-ui');
    const chatInput = document.getElementById('chat-input');
    const chatLog = document.getElementById('chat-log');

    function toggleChat() {
        if (chatUI.style.display === 'block') {
            chatUI.style.display = 'none';
            controls.lock();
            chatInput.blur();
        } else {
            controls.unlock();
            chatUI.style.display = 'block';
            chatInput.focus();
        }
    }

    chatInput.addEventListener('keydown', (e) => {
        if(e.key === 'Enter' && chatInput.value.trim() !== "") {
            const txt = chatInput.value.trim();
            addLog("You", txt);
            chatInput.value = "";
            setTimeout(() => generateAIResponse(txt), 800);
        }
    });

    function addLog(name, text) {
        const div = document.createElement('div');
        div.className = name === "You" ? 'msg-line u-msg' : 'msg-line ai-msg';
        if(name === "System") div.className = 'msg-line sys-msg';
        div.innerHTML = `<strong>${name}:</strong> ${text}`;
        chatLog.appendChild(div);
        chatLog.scrollTop = chatLog.scrollHeight;
    }

    // --- THE BRAIN (1000+ Logic) ---
    function generateAIResponse(userText) {
        const text = userText.toLowerCase();
        let reply = "";
        
        // Movement Observations (Context)
        const isStill = playerStats.timeStill > 3;
        const isWalking = !isStill;
        const farTraveler = playerStats.totalDistance > 500;
        const starGazer = playerStats.lookUpCount > playerStats.lookDownCount;

        // --- PHASE 0: NEUTRAL ---
        if (storyPhase === 0) {
            if (text.includes("hello")) {
                reply = isStill ? "Hello. Waiting for someone?" : "Hi! You walk with a lot of energy.";
            } else if (text.includes("who")) {
                reply = "Just a villager. I've seen you walking around house #2.";
            } else {
                reply = "I'm busy. Why are you staring at me?";
            }
        }
        
        // --- PHASE 1: FAME (Love) ---
        else if (storyPhase === 1) {
            // Movement compliments
            const moveComment = isWalking ? "I love how you walk!" : "Even the way you stand is iconic.";
            const distComment = farTraveler ? "You've traveled so far to see us!" : "You honor us with your presence.";
            
            if (text.includes("hi") || text.includes("hey")) reply = `OMG! He said hello! ${moveComment}`;
            else if (text.includes("thanks")) reply = "No, thank YOU! " + distComment;
            else if (text.includes("stop")) reply = "We can't stop watching you! You're perfect!";
            else reply = `Everything you say is brilliant! ${starGazer ? "Your eyes are always on the stars." : "You are so grounded."}`;
        }
        
        // --- PHASE 2: HATE (Anger/Taunt) ---
        else if (storyPhase === 2) {
            // Movement Insults
            const moveInsult = isWalking ? "Why are you running? Guilty conscience?" : "Standing there like a coward.";
            
            if (text.includes("why")) reply = "You know what you did. " + moveInsult;
            else if (text.includes("sorry")) reply = "Too late for apologies. Get out.";
            else if (text.includes("help")) reply = "No one is going to help you. Look at how you walk, disgusting.";
            else reply = "We saw where you went. We know everything. " + moveInsult;
        }

        // Select Speaker
        const speaker = npcs[Math.floor(Math.random() * npcs.length)];
        
        addLog("Villager", reply);
        speak(reply, speaker);
    }

    function speak(text, npc) {
        if(synth.speaking) synth.cancel();
        const utter = new SpeechSynthesisUtterance(text);
        utter.pitch = npc.pitch;
        utter.rate = 0.9 + (Math.random() * 0.2);
        
        const voices = synth.getVoices();
        const en = voices.find(v => v.lang.includes('en'));
        if(en) utter.voice = en;

        synth.speak(utter);
    }

</script>
</body>
</html>

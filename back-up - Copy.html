<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Maze Explorer: The Sprint</title>
    <!-- Tailwind CSS for modern, responsive layout -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Three.js PointerLockControls for first-person camera handling -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/PointerLockControls.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght400;700&display=swap" rel="stylesheet">
    <style>
        body {
            background-color: #050508;
            font-family: 'Orbitron', sans-serif;
            color: #E0E0E0;
            user-select: none;
            overflow: hidden;
        }
        #info {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #ff4444; /* Scary border color */
            padding: 2rem;
            border-radius: 0.75rem;
            text-align: center;
            z-index: 1000;
            box-shadow: 0 0 25px rgba(255, 68, 68, 0.7);
            cursor: pointer;
        }
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 10px;
            height: 10px;
            margin: -5px 0 0 -5px;
            border: 1px solid rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            z-index: 999;
            pointer-events: none;
            opacity: 0; 
        }
        #message-box {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #111;
            border: 2px solid #ff0044;
            padding: 2rem;
            border-radius: 0.5rem;
            text-align: center;
            z-index: 2000;
            box-shadow: 0 0 30px #ff0044;
            display: none;
        }
        .win-style {
            border-color: #00ff00 !important;
            box-shadow: 0 0 30px #00ff00 !important;
        }
        .action-button {
            padding: 0.75rem 2rem;
            background: #ff4444;
            color: #fff;
            font-weight: bold;
            border: none;
            border-radius: 0.375rem;
            cursor: pointer;
            transition: background 0.2s, transform 0.1s;
        }
        .action-button:hover {
            background: #cc3333;
            transform: scale(1.05);
        }
        #status-bar {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            padding: 10px 20px;
            background: rgba(0, 0, 0, 0.7);
            color: #00ffff;
            font-size: 14px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 10;
        }
        .sprinting {
            color: #ff0000;
            font-weight: bold;
            text-shadow: 0 0 8px #ff0000;
        }
    </style>
</head>
<body>
    <!-- Canvas is added by Three.js -->

    <!-- Info/Start Screen -->
    <div id="info">
        <h1 class="text-3xl font-bold mb-4 text-[#ff4444]">THE DEEP LABYRINTH</h1>
        <p class="text-sm mb-4">Click to enter the darkness. Walk normally until you see **It**.</p>
        <p class="text-xl font-bold mb-2">Controls</p>
        <p class="mb-4 text-left mx-auto max-w-xs">
            **Walk**: **W** / **A** / **S** / **D** (Slower pace)<br>
            **Sprint**: Automatically triggers when the **Ghost** is in sight, and lasts for 3 seconds after you hide!<br>
            **Look**: **Mouse** Movement
        </p>
        <button class="action-button">ENTER</button>
    </div>

    <!-- Status Bar -->
    <div id="status-bar">
        <span id="player-status">Status: Walking...</span>
        <span id="ghost-proximity">Threat: Distant</span>
    </div>

    <!-- Crosshair -->
    <div id="crosshair"></div>

    <!-- Custom Modal for Alerts -->
    <div id="message-box">
        <p id="message-text" class="text-xl font-bold mb-4"></p>
        <button class="action-button" onclick="closeAlert()">RESTART</button>
    </div>

    <script type="module">
        // --- 3D Setup Variables ---
        let camera, scene, renderer, controls, raycaster;
        let clock = new THREE.Clock();
        const infoElement = document.getElementById('info');
        const crosshair = document.getElementById('crosshair');
        const playerStatus = document.getElementById('player-status');
        const ghostProximity = document.getElementById('ghost-proximity');

        const CELL_SIZE = 20;
        const WALL_HEIGHT = 10;
        const PLAYER_HEIGHT = 6; 
        
        // World Offset (Calculated in init, but declared globally for access)
        let offsetX, offsetZ;
        
        // Speed Definitions
        const WALK_SPEED = 32; 
        const GHOST_SPEED = 80; // Fast speed for the Ghost AI
        const SPRINT_SPEED = GHOST_SPEED; // Player matches Ghost speed when seen
        let effectiveSpeed = WALK_SPEED;
        
        // Sprint Delay Variables
        const SPRINT_DELAY_DURATION = 3.0; // 3 seconds delay
        let sprintDelayTimer = 0;

        let moveForward = false;
        let moveBackward = false;
        let moveLeft = false;
        let moveRight = false;
        let gameActive = false;
        let winPosition = null;
        let ghostMesh = null;
        let wallObjects = [];

        // Ghost AI state
        let ghostPath = []; // Array of [row, col] for the ghost to follow
        let lastPathUpdateTime = 0;
        
        let playerGridPos = { r: 0, c: 0 }; // Updated in animate loop
        let ghostGridPos = { r: 35, c: 35 }; // Starting cell for the ghost

        // Maze Grid Definitions
        const MAX_COL = 71;
        const MAX_ROW = 71;
        const START_COL = 1; 
        const START_ROW = MAX_ROW - 2; 
        const EXIT_COL = MAX_COL - 2;
        const EXIT_ROW = 1;

        // Generate the complex, non-linear maze structure
        const mazeGrid = generateTrueMaze(MAX_ROW, MAX_COL);
        
        // --- Maze Generation (Recursive Backtracker + Aggressive Looping) ---
        /**
         * Generates a complex, non-linear maze structure using a carving algorithm.
         */
        function generateTrueMaze(rows, cols) {
            const grid = Array(rows).fill(0).map(() => Array(cols).fill(1));
            const stack = [];

            // 2. Start carving from the START cell
            stack.push([START_ROW, START_COL]);
            grid[START_ROW][START_COL] = 0; 

            while (stack.length > 0) {
                const [r, c] = stack[stack.length - 1];
                
                const neighbors = [
                    [r - 2, c, r - 1, c], [r + 2, c, r + 1, c],
                    [r, c - 2, r, c - 1], [r, c + 2, r, c + 1]
                ].filter(([nr, nc]) => 
                    nr > 0 && nr < rows - 1 && nc > 0 && nc < cols - 1 && grid[nr][nc] === 1 
                );

                if (neighbors.length > 0) {
                    const [nr, nc, wr, wc] = neighbors[Math.floor(Math.random() * neighbors.length)];
                    grid[nr][nc] = 0;
                    grid[wr][wc] = 0;
                    stack.push([nr, nc]);
                } else {
                    stack.pop(); 
                }
            }

            // 3. Set the Exit point
            grid[EXIT_ROW][EXIT_COL] = 2; 

            // 4. Introduce LOOPS for complexity
            const LOOP_PERCENTAGE = 0.20; 
            for (let r = 1; r < rows - 1; r++) {
                for (let c = 1; c < cols - 1; c++) {
                    if (grid[r][c] === 1 && Math.random() < LOOP_PERCENTAGE) {
                        grid[r][c] = 0; 
                    }
                }
            }
            return grid;
        }

        // --- Utility Functions for Grid/World Conversion ---

        /**
         * Converts world coordinates to maze grid coordinates.
         */
        function toGridPosition(worldX, worldZ) {
            const r = Math.floor((worldZ - offsetZ) / CELL_SIZE);
            const c = Math.floor((worldX - offsetX) / CELL_SIZE);
            return { r, c };
        }

        /**
         * Converts grid coordinates to world coordinates (center of the cell).
         */
        function toWorldPosition(r, c) {
            const x = (c + 0.5) * CELL_SIZE + offsetX;
            const z = (r + 0.5) * CELL_SIZE + offsetZ;
            return new THREE.Vector3(x, PLAYER_HEIGHT, z);
        }

        /**
         * Updates the player's current grid position.
         */
        function updatePlayerGridPosition() {
            playerGridPos = toGridPosition(camera.position.x, camera.position.z);
        }
        
        /**
         * Custom alert to avoid window.alert in the iframe.
         */
        function showAlert(message, isWin) {
            gameActive = false;
            controls.unlock();
            const messageBox = document.getElementById('message-box');
            const messageText = document.getElementById('message-text');
            messageText.textContent = message;

            if (isWin) {
                messageBox.classList.add('win-style');
                messageBox.querySelector('.action-button').style.background = '#00ff00';
            } else {
                messageBox.classList.remove('win-style');
                messageBox.querySelector('.action-button').style.background = '#ff4444';
            }

            messageBox.style.display = 'block';
            crosshair.style.opacity = 0;
        }

        window.closeAlert = function() {
            document.getElementById('message-box').style.display = 'none';
            window.location.reload();
        }

        // --- Pathfinding (Breadth-First Search) ---

        /**
         * Uses Breadth-First Search (BFS) to find the shortest path from start to end.
         * Returns an array of grid coordinates (excluding start, including end).
         */
        function findPath(startR, startC, endR, endC) {
            if (startR === endR && startC === endC) return [];
            
            const rows = mazeGrid.length;
            const cols = mazeGrid[0].length;
            const queue = [`${startR},${startC}`];
            const visited = new Set();
            const parent = {}; // Stores { 'r,c': 'parentR,parentC' }
            
            visited.add(`${startR},${startC}`);
            let goalKey = null;

            while (queue.length > 0) {
                const currentKey = queue.shift();
                const [r, c] = currentKey.split(',').map(Number);

                if (r === endR && c === endC) {
                    goalKey = currentKey;
                    break;
                }

                // Neighbors (N, S, E, W)
                const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];

                for (const [dr, dc] of directions) {
                    const nr = r + dr;
                    const nc = c + dc;
                    
                    if (nr >= 0 && nr < rows && nc >= 0 && nc < cols) {
                        const neighborKey = `${nr},${nc}`;
                        
                        // If not a solid wall (1) and not visited
                        if (mazeGrid[nr][nc] !== 1 && !visited.has(neighborKey)) {
                            visited.add(neighborKey);
                            parent[neighborKey] = currentKey; // The current cell is the parent of the neighbor
                            queue.push(neighborKey);
                        }
                    }
                }
            }

            // Path reconstruction
            if (!goalKey) return [];

            const fullPath = [];
            let tempKey = goalKey;
            
            // Loop backward from goal until reaching the start cell
            while (parent[tempKey]) {
                fullPath.unshift(tempKey.split(',').map(Number));
                tempKey = parent[tempKey];
            }
            
            // fullPath now contains: [[nextR, nextC], ..., [endR, endC]]
            return fullPath; 
        }

        // --- Initialization ---

        function init() {
            // 1. Scene setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x050508);
            scene.fog = new THREE.Fog(0x050508, CELL_SIZE * 5, CELL_SIZE * 30); 

            // 2. Camera setup
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            raycaster = new THREE.Raycaster();
            
            // Calculate and assign world offset for use in grid conversions
            offsetX = -(mazeGrid[0].length * CELL_SIZE) / 2;
            offsetZ = -(mazeGrid.length * CELL_SIZE) / 2;

            // Start position
            const startX = (START_COL + 0.5) * CELL_SIZE + offsetX;
            const startZ = (START_ROW + 0.5) * CELL_SIZE + offsetZ;
            camera.position.set(startX, PLAYER_HEIGHT, startZ);

            // 3. Renderer setup
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);

            // 4. Lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 0.8);
            scene.add(ambientLight);

            // Flashlight effect
            const pointLight = new THREE.PointLight(0xffffff, 1, 50);
            camera.add(pointLight); 
            scene.add(camera);

            // 5. Controls
            controls = new THREE.PointerLockControls(camera, document.body);

            controls.addEventListener('lock', () => {
                infoElement.style.display = 'none';
                crosshair.style.opacity = 1;
                gameActive = true;
            });
            controls.addEventListener('unlock', () => {
                if (!document.getElementById('message-box').style.display || document.getElementById('message-box').style.display === 'none') {
                    infoElement.style.display = 'block';
                }
                gameActive = false;
                crosshair.style.opacity = 0;
            });

            document.getElementById('info').addEventListener('click', () => {
                controls.lock();
            });

            // 6. Build the Maze and Ghost
            buildMaze(offsetX, offsetZ);
            addGhost();

            // 7. Event listeners
            document.addEventListener('keydown', onKeyDown, false);
            document.addEventListener('keyup', onKeyUp, false);
            window.addEventListener('resize', onWindowResize, false);
        }

        /**
         * Builds the 3D geometry for the maze.
         */
        function buildMaze(offsetX, offsetZ) {
            const wallMaterial = new THREE.MeshPhongMaterial({ color: 0x333333, shininess: 10 });
            const floorMaterial = new THREE.MeshPhongMaterial({ color: 0x1f1f2a });
            const wallGeometry = new THREE.BoxGeometry(CELL_SIZE, WALL_HEIGHT, CELL_SIZE);
            
            // Floor
            const floorGeometry = new THREE.PlaneGeometry(MAX_COL * CELL_SIZE, MAX_ROW * CELL_SIZE);
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            scene.add(floor);

            for (let i = 0; i < mazeGrid.length; i++) {
                for (let j = 0; j < mazeGrid[i].length; j++) {
                    const cellType = mazeGrid[i][j];
                    const x = j * CELL_SIZE + offsetX + CELL_SIZE / 2;
                    const z = i * CELL_SIZE + offsetZ + CELL_SIZE / 2;

                    if (cellType === 1) { // Wall
                        const wall = new THREE.Mesh(wallGeometry, wallMaterial);
                        wall.position.set(x, WALL_HEIGHT / 2, z);
                        wall.userData.isWall = true;
                        scene.add(wall);
                        wallObjects.push(wall);
                    } else if (cellType === 2) { // Exit
                        const exitMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.8 });
                        const exitGeometry = new THREE.BoxGeometry(CELL_SIZE * 0.8, WALL_HEIGHT / 4, CELL_SIZE * 0.8);
                        const exitCube = new THREE.Mesh(exitGeometry, exitMaterial);
                        exitCube.position.set(x, 0.1, z);
                        exitCube.userData.isExit = true;
                        
                        const exitLight = new THREE.PointLight(0x00ff00, 2, 25);
                        exitLight.position.set(x, 5, z);
                        scene.add(exitLight);
                        exitCube.userData.light = exitLight;

                        scene.add(exitCube);
                        winPosition = exitCube;
                    }
                }
            }
        }
        
        /**
         * Adds the ghost entity to the scene.
         */
        function addGhost() {
            const ghostMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xaa00ff, // Magenta/Purple/Menacing
                transparent: true,
                opacity: 0.5,
                blending: THREE.AdditiveBlending 
            });
            const ghostGeometry = new THREE.SphereGeometry(2, 16, 16);
            ghostMesh = new THREE.Mesh(ghostGeometry, ghostMaterial);
            ghostMesh.userData.isGhost = true;
            
            // Start the ghost at the defined grid position (e.g., cell 35, 35)
            const ghostWorldPos = toWorldPosition(ghostGridPos.r, ghostGridPos.c);
            ghostMesh.position.copy(ghostWorldPos);
            
            scene.add(ghostMesh);

            // Add a point light to make it glow
            const ghostLight = new THREE.PointLight(0xaa00aa, 4, 50);
            ghostMesh.add(ghostLight);
        }

        /**
         * Checks if the ghost is in direct line of sight (pure check).
         */
        function isGhostVisible() {
            if (!ghostMesh) return false;

            const playerPosition = camera.position.clone();
            const ghostPosition = ghostMesh.position.clone();

            // Check if distance is too far to bother with raycasting
            const dist = playerPosition.distanceTo(ghostPosition);
            if (dist > CELL_SIZE * 10) {
                 return false;
            }

            // Direction vector from player to ghost
            const direction = new THREE.Vector3().subVectors(ghostPosition, playerPosition).normalize();

            // Setup Raycaster
            raycaster.set(playerPosition, direction);

            // Check for intersections with walls
            const intersects = raycaster.intersectObjects(wallObjects);

            // If intersections exist, check the distance
            if (intersects.length > 0) {
                const distanceToWall = intersects[0].distance;
                
                // If distance to ghost is less than distance to the closest wall, the ghost is visible.
                return dist < distanceToWall - 0.5;
            }
            
            return true; // No wall between
        }

        /**
         * Handles the Ghost's movement and AI.
         */
        function moveGhost(delta) {
            if (!ghostMesh) return;

            const currentTime = clock.getElapsedTime();
            const ghostWorldPos = ghostMesh.position;
            const ghostIsSeeingPlayer = isGhostVisible();

            // --- Smart AI Update Logic: Only update path if player is visible ---
            if (ghostIsSeeingPlayer) {
                // If the ghost sees the player, recalculate the direct shortest path immediately.
                ghostGridPos = toGridPosition(ghostWorldPos.x, ghostWorldPos.z);
                
                // Find path from ghost's current cell to the player's current cell
                ghostPath = findPath(
                    ghostGridPos.r, ghostGridPos.c, 
                    playerGridPos.r, playerGridPos.c
                );
                // Reset timer when path is updated (sighting)
                lastPathUpdateTime = currentTime;
            }
            // The ghost continues to follow the last path if it loses sight, 
            // simulating it heading towards the last known location.

            // --- Movement Execution ---
            if (ghostPath.length > 0) {
                // The first cell in the path is the next target cell
                const [nextR, nextC] = ghostPath[0];
                const targetWorldPos = toWorldPosition(nextR, nextC);
                
                // Use vector interpolation for smooth movement
                const moveDistance = GHOST_SPEED * delta;
                
                // Check if we will overshoot the target
                if (ghostWorldPos.distanceTo(targetWorldPos) < moveDistance) {
                    // Snap to target and remove this cell from the path
                    ghostWorldPos.x = targetWorldPos.x;
                    ghostWorldPos.z = targetWorldPos.z;
                    ghostPath.shift(); 
                } else {
                    // Move towards the target position
                    const direction = new THREE.Vector3().subVectors(targetWorldPos, ghostWorldPos).normalize();
                    ghostWorldPos.addScaledVector(direction, moveDistance);
                }
                
                // Make the ghost face the direction of movement
                if (ghostPath.length > 0) {
                    const lookAtTarget = toWorldPosition(ghostPath[0][0], ghostPath[0][1]);
                    ghostMesh.lookAt(lookAtTarget.x, ghostWorldPos.y, lookAtTarget.z);
                }
            }
            
            // Simple bobbing and rotation (always on)
            ghostMesh.rotation.y += 1.0 * delta;
            ghostMesh.position.y = PLAYER_HEIGHT + 0.5 + Math.sin(currentTime * 3) * 0.5;

            // --- Check for Game Over ---
            checkCatchCondition(ghostWorldPos);
        }

        /**
         * Checks if the Ghost has caught the player (Game Over condition).
         */
        function checkCatchCondition(ghostPosition) {
            const catchDistance = 3; // Catch if distance is less than 3 units
            const dist = camera.position.distanceTo(ghostPosition);

            if (dist < catchDistance) {
                showAlert("CAUGHT! The Ghost found you in the dark maze.", false);
            }
        }


        // --- Input Handlers (Unchanged) ---

        function onKeyDown(event) {
            switch (event.code) {
                case 'ArrowUp': case 'KeyW': moveForward = true; break;
                case 'ArrowLeft': case 'KeyA': moveLeft = true; break;
                case 'ArrowDown': case 'KeyS': moveBackward = true; break;
                case 'ArrowRight': case 'KeyD': moveRight = true; break;
            }
        }

        function onKeyUp(event) {
            switch (event.code) {
                case 'ArrowUp': case 'KeyW': moveForward = false; break;
                case 'ArrowLeft': case 'KeyA': moveLeft = false; break;
                case 'ArrowDown': case 'KeyS': moveBackward = false; break;
                case 'ArrowRight': case 'KeyD': moveRight = false; break;
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- Game Loop and Logic ---

        function animate() {
            requestAnimationFrame(animate);

            const delta = clock.getDelta();

            if (controls.isLocked === true && gameActive) {
                
                // 1. Update Player position
                updatePlayerGridPosition(); 
                
                // Check Ghost vision (now a pure boolean)
                const ghostInSight = isGhostVisible(); 
                
                // 2. Ghost AI Movement
                moveGhost(delta); 

                // --- Sprint Logic (With 3-second delay) ---
                
                if (ghostInSight) {
                    // Ghost is in sight: Sprint immediately, reset delay timer
                    effectiveSpeed = SPRINT_SPEED;
                    sprintDelayTimer = SPRINT_DELAY_DURATION; 
                    playerStatus.textContent = "Status: SPRINTING! (GO! GO! GO!)";
                    playerStatus.classList.add('sprinting');
                } else if (sprintDelayTimer > 0) {
                    // Ghost is out of sight, but delay is active: Keep sprinting
                    sprintDelayTimer -= delta;
                    // Clamp timer to prevent negative display numbers
                    sprintDelayTimer = Math.max(0, sprintDelayTimer);
                    effectiveSpeed = SPRINT_SPEED;
                    playerStatus.textContent = `Status: SPRINTING! (Delay: ${sprintDelayTimer.toFixed(1)}s)`;
                    playerStatus.classList.add('sprinting');
                } else {
                    // Delay expired or never triggered: Walk
                    effectiveSpeed = WALK_SPEED;
                    playerStatus.textContent = "Status: Walking...";
                    playerStatus.classList.remove('sprinting');
                }
                
                // --- Proximity Status Update ---
                const dist = camera.position.distanceTo(ghostMesh.position);
                if (dist > CELL_SIZE * 10) {
                     ghostProximity.textContent = "Threat: Distant";
                } else if (dist > CELL_SIZE * 4) {
                     ghostProximity.textContent = "Threat: Nearby";
                } else {
                     ghostProximity.textContent = "THREAT: IMMINENT!";
                }

                // --- Movement Calculation ---
                const velocity = new THREE.Vector3();
                if (moveForward) velocity.z -= effectiveSpeed * delta;
                if (moveBackward) velocity.z += effectiveSpeed * delta;
                if (moveLeft) velocity.x -= effectiveSpeed * delta;
                if (moveRight) velocity.x += effectiveSpeed * delta;

                const oldPosition = camera.position.clone();
                
                // Apply movement
                controls.moveRight(velocity.x); 
                controls.moveForward(-velocity.z);

                // --- Collision Detection ---
                const currentGridX = Math.floor((camera.position.x - offsetX) / CELL_SIZE);
                const currentGridZ = Math.floor((camera.position.z - offsetZ) / CELL_SIZE);

                if (isColliding(currentGridX, currentGridZ, oldPosition)) {
                    camera.position.copy(oldPosition);
                }

                // --- Win Condition ---
                checkWinCondition();
                
                // Animate exit light pulse
                if (winPosition && winPosition.userData.light) {
                    winPosition.userData.light.intensity = 2 + Math.sin(clock.getElapsedTime() * 5) * 1;
                }
            }

            renderer.render(scene, camera);
        }

        /**
         * Checks the player's position against the maze grid for walls.
         */
        function isColliding(gridX, gridZ, oldPosition) {
            // Check bounds 
            if (gridZ < 0 || gridZ >= mazeGrid.length || gridX < 0 || gridX >= mazeGrid[0].length) {
                return true;
            }

            if (mazeGrid[gridZ][gridX] === 1) {
                
                // Attempt to revert movement along one axis to unstick the player
                
                // Test X-revert:
                const tempX = oldPosition.x;
                const tempZ = camera.position.z;
                
                let testGridX = Math.floor((tempX - offsetX) / CELL_SIZE);
                let testGridZ = Math.floor((tempZ - offsetZ) / CELL_SIZE);
                
                if (mazeGrid[testGridZ] && mazeGrid[testGridZ][testGridX] === 1) {
                    camera.position.z = oldPosition.z;
                }
                
                // Test Z-revert:
                const tempX_2 = camera.position.x;
                const tempZ_2 = oldPosition.z;

                let testGridX_2 = Math.floor((tempX_2 - offsetX) / CELL_SIZE);
                let testGridZ_2 = Math.floor((tempZ_2 - offsetZ) / CELL_SIZE);
                
                if (mazeGrid[testGridZ_2] && mazeGrid[testGridZ_2][testGridX_2] === 1) {
                    camera.position.x = oldPosition.x;
                }

                // Final check after partial reverts
                const finalGridX = Math.floor((camera.position.x - offsetX) / CELL_SIZE);
                const finalGridZ = Math.floor((camera.position.z - offsetZ) / CELL_SIZE);
                
                if (mazeGrid[finalGridZ] && mazeGrid[finalGridZ][finalGridX] === 1) {
                    return true; 
                }
            }
            return false;
        }

        function checkWinCondition() {
            if (!winPosition) return;
            
            const distanceToExit = camera.position.distanceTo(winPosition.position);
            
            if (distanceToExit < CELL_SIZE / 2) {
                showAlert("SUCCESS! You escaped the deep maze and the Ghost's sight!", true);
            }
        }

        // --- Start the App ---
        window.onload = function () {
            init();
            animate();
        };

    </script>
</body>
</html>

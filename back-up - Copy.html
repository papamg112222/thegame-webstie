startAttack() {
  if (this.attackCooldown > 0) return;
  this.state = 'attack';
  this.stateTime = 0;
  this.attackCooldown = 60;

  // Choose attack type with combo logic
  if (this.comboCooldown === 0 && Math.random() < 0.4) {
    this.comboSequence = ['punch', 'kick', 'punch'];
    this.comboStep = 0;
    this.comboCooldown = 120;
    this.currentAttack = this.getAttackByName(this.comboSequence[this.comboStep]);
  } else {
    this.comboSequence = [];
    this.currentAttack = this.getAttackByName(Math.random() < 0.5 ? 'punch' : 'kick');
  }
},

getAttackByName(name) {
  if (name === 'punch') {
    return {
      name: 'punch',
      damage: 10,
      duration: 25,
      hitbox: (progress) => ({
        x: this.x + this.facingDir() * (20 + 30 * Math.sin(progress * Math.PI)),
        y: this.y - 30 - 10 * Math.sin(progress * Math.PI),
        w: 30,
        h: 30
      })
    };
  } else if (name === 'kick') {
    return {
      name: 'kick',
      damage: 14,
      duration: 30,
      hitbox: (progress) => ({
        x: this.x + this.facingDir() * (15 + 40 * Math.sin(progress * Math.PI)),
        y: this.y - 10 + 5 * Math.sin(progress * Math.PI),
        w: 40,
        h: 25
      })
    };
  }
  return null;
},

update(opponent) {
  // ...existing physics & state updates...

  if (this.state === 'attack') {
    const progress = this.stateTime / this.currentAttack.duration;

    // Punch snap animation for arm swing with easing
    this.armAngle = Math.sin(progress * Math.PI) * 1.4;

    // Stretch and squash body on impact peak
    this.bodyStretch = 1 + 0.15 * Math.sin(progress * Math.PI);

    // Trigger hit frame at peak
    if (this.stateTime === Math.floor(this.currentAttack.duration / 2)) {
      if (this.checkHit(opponent, progress)) {
        opponent.takeDamage(this.currentAttack.damage);
        createHitEffect(opponent.x, opponent.y - 40);
        shakeScreen(8);
        triggerPunchFlash(this);
        if (opponent.health <= 0) slowMoFrames = 90;
      }
    }

    if (this.stateTime > this.currentAttack.duration) {
      if (this.comboSequence.length > 0) {
        this.comboStep++;
        if (this.comboStep < this.comboSequence.length) {
          // Next combo attack
          this.stateTime = 0;
          this.currentAttack = this.getAttackByName(this.comboSequence[this.comboStep]);
          return; // continue combo without resetting to idle
        }
        this.comboSequence = [];
      }
      this.state = 'idle';
      this.currentAttack = null;
      this.armAngle = 0;
      this.bodyStretch = 1;
    }
  }
},

checkHit(opponent, progress=0.5) {
  const a = this.currentAttack.hitbox(progress);
  const b = {
    x: opponent.x - 10,
    y: opponent.y - 60,
    w: 20,
    h: 60
  };
  return !(a.x > b.x + b.w || a.x + a.w < b.x || a.y > b.y + b.h || a.y + a.h < b.y);
},

draw(ctx) {
  // motion trails & other drawing

  ctx.save();
  ctx.translate(this.x, this.y);

  ctx.scale(this.facingRight ? 1 : -1, 1);

  // Apply stretch and squash to body during attack
  ctx.scale(1, this.bodyStretch || 1);

  // Head
  ctx.beginPath();
  ctx.arc(0, -45, 10, 0, Math.PI * 2);
  ctx.fillStyle = this.hitCooldown > 0 && Math.floor(this.hitCooldown / 3) % 2 === 0 ? 'red' : this.color;
  ctx.fill();
  ctx.strokeStyle = this.color;
  ctx.lineWidth = 3;
  ctx.stroke();

  // Body
  ctx.beginPath();
  ctx.moveTo(0, -35);
  ctx.lineTo(0, 0);
  ctx.stroke();

  // Arms with punch swing
  ctx.lineWidth = 4;
  let armSwing = this.armAngle || 0;
  // Left arm (idle swing)
  ctx.beginPath();
  ctx.moveTo(0, -30);
  ctx.lineTo(-15 * Math.cos(armSwing * 0.3), -30 + 15 * Math.sin(armSwing * 0.3));
  ctx.stroke();

  // Right arm (attack arm)
  ctx.beginPath();
  ctx.moveTo(0, -30);
  const punchX = 15 + 25 * Math.sin(armSwing * Math.PI);
  const punchY = -30 - 15 * Math.sin(armSwing * Math.PI);
  ctx.lineTo(punchX, punchY);
  ctx.stroke();

  // Punch flash circle on attack peak
  if (this.punchFlashAlpha) {
    ctx.fillStyle = `rgba(255,255,255,${this.punchFlashAlpha.toFixed(2)})`;
    ctx.beginPath();
    ctx.arc(punchX, punchY, 15, 0, Math.PI * 2);
    ctx.fill();
    this.punchFlashAlpha -= 0.05;
    if (this.punchFlashAlpha < 0) this.punchFlashAlpha = 0;
  }

  // Legs with walking animation
  ctx.lineWidth = 3;
  let legAngle = 0;
  if (this.state === 'run') {
    legAngle = Math.sin(Date.now() * 0.01) * 0.7;
  }
  ctx.beginPath();
  ctx.moveTo(0, 0);
  ctx.lineTo(-15 * Math.cos(legAngle), 30 + 15 * Math.sin(legAngle));
  ctx.moveTo(0, 0);
  ctx.lineTo(15 * Math.cos(legAngle), 30 - 15 * Math.sin(legAngle));
  ctx.stroke();

  ctx.restore();

  // Health bar (same as before)
  // ...
},

// New method to trigger punch flash effect
triggerPunchFlash() {
  this.punchFlashAlpha = 1;
}

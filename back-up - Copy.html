<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Epic AI Stickman Fight</title>
<style>
  body {
    background: #111;
    color: #eee;
    font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
    margin: 0;
    overflow: hidden;
    display: flex;
    flex-direction: column;
    align-items: center;
    user-select: none;
  }
  canvas {
    background: #222;
    border-radius: 10px;
    box-shadow: 0 0 25px #000 inset;
    margin-top: 1rem;
  }
  button {
    margin: 1rem;
    padding: 10px 20px;
    background: transparent;
    border: 2px solid #39ff14;
    border-radius: 6px;
    color: #39ff14;
    font-size: 18px;
    cursor: pointer;
    transition: background 0.3s;
  }
  button:hover {
    background: #39ff14;
    color: #111;
  }
  #victory {
    position: absolute;
    top: 20%;
    font-size: 4rem;
    font-weight: 900;
    color: #39ff14;
    text-shadow: 0 0 20px #39ff14, 0 0 40px #39ff14;
    pointer-events: none;
  }
</style>
</head>
<body>

<canvas id="canvas" width="900" height="400"></canvas>
<button id="startBtn">Start Fight</button>
<div id="victory" style="display:none;"></div>

<script>
(() => {
  const canvas = document.getElementById("canvas");
  const ctx = canvas.getContext("2d");
  const width = canvas.width;
  const height = canvas.height;

  const GRAVITY = 0.8;
  const FLOOR = height - 80;

  // Helper utilities
  function lerp(a, b, t) { return a + (b - a) * t; }
  function clamp(x, min, max) { return Math.min(max, Math.max(min, x)); }
  function randomChoice(arr) { return arr[Math.floor(Math.random() * arr.length)]; }
  function distance(a, b) { return Math.hypot(b.x - a.x, b.y - a.y); }

  // Camera shake and slow motion
  let cameraShake = 0;
  let slowMotion = 1;
  let slowMotionTimer = 0;

  function doCameraShake(amount) {
    cameraShake = Math.max(cameraShake, amount);
  }
  function doSlowMotion(duration = 20, factor = 0.2) {
    slowMotion = factor;
    slowMotionTimer = duration;
  }

  // Vector2 class for 2D positions and math
  class Vec2 {
    constructor(x = 0, y = 0) { this.x = x; this.y = y; }
    add(v) { return new Vec2(this.x + v.x, this.y + v.y); }
    sub(v) { return new Vec2(this.x - v.x, this.y - v.y); }
    mul(s) { return new Vec2(this.x * s, this.y * s); }
    length() { return Math.sqrt(this.x * this.x + this.y * this.y); }
    normalized() { const len = this.length(); return len === 0 ? new Vec2(0,0) : this.mul(1 / len); }
  }

  // Stickman class with limbs & animations
  class Stickman {
    constructor(x, color, neckwearColor) {
      this.pos = new Vec2(x, FLOOR);
      this.vel = new Vec2(0, 0);
      this.facing = 1; // 1 right, -1 left
      this.color = color;
      this.neckwearColor = neckwearColor;

      this.health = 100;
      this.maxHealth = 100;

      this.state = "idle"; // idle, walk, run, jump, attack, dodge, hurt
      this.stateTimer = 0;

      this.animTimer = 0;

      this.limbs = {
        head: { pos: new Vec2(0, -80), radius: 10 },
        neck: { length: 18, swayAngle: 0, swaySpeed: 0.1 },
        torso: { length: 60 },
        upperArm: { length: 25, angle: 0 },
        lowerArm: { length: 25, angle: 0 },
        upperLeg: { length: 35, angle: 0 },
        lowerLeg: { length: 35, angle: 0 },
        weaponTrail: [],
      };

      this.attackPhase = 0;
      this.comboTimer = 0;
      this.isAttacking = false;
      this.weaponExtension = 0;
      this.weaponGlowAlpha = 0;

      this.isDodging = false;
      this.dodgeTimer = 0;

      this.isJumping = false;
      this.jumpTimer = 0;

      this.target = null;
    }

    updateAI() {
      if (this.health <= 0) return;

      const dist = this.target ? this.target.pos.x - this.pos.x : 0;

      // Face opponent
      this.facing = dist > 0 ? 1 : -1;

      // Simple AI behavior
      if (this.isAttacking || this.isDodging || this.isJumping) return;

      if (Math.abs(dist) > 150) {
        // Walk closer
        this.state = "walk";
        this.vel.x = 2 * this.facing;
      } else if (Math.abs(dist) > 70) {
        // Run attack
        if (Math.random() < 0.01) {
          this.startAttack();
        } else {
          this.state = "run";
          this.vel.x = 4 * this.facing;
        }
      } else {
        // Close range attack or dodge
        if (Math.random() < 0.02) {
          this.startAttack();
        } else if (Math.random() < 0.01) {
          this.startDodge();
        } else if (Math.random() < 0.005) {
          this.startJump();
        } else {
          this.state = "idle";
          this.vel.x = 0;
        }
      }
    }

    startAttack() {
      if (this.isAttacking) return;
      this.isAttacking = true;
      this.state = "attack";
      this.attackPhase = 0;
      this.stateTimer = 0;
      this.comboTimer = 60;
      this.weaponExtension = 0;
      this.weaponGlowAlpha = 1;
    }
    startDodge() {
      if (this.isDodging || this.isJumping) return;
      this.isDodging = true;
      this.state = "dodge";
      this.dodgeTimer = 30;
      this.vel.x = -this.facing * 6;
    }
    startJump() {
      if (this.isJumping || this.isDodging) return;
      this.isJumping = true;
      this.state = "jump";
      this.jumpTimer = 45;
      this.vel.y = -15;
    }

    applyDamage(amount) {
      if (this.health <= 0) return;
      this.health -= amount;
      if (this.health < 0) this.health = 0;
      doCameraShake(15);
      doSlowMotion(15);
    }

    update(delta) {
      // Update timers
      if (slowMotionTimer > 0) slowMotionTimer--;
      else slowMotion = 1;

      if (this.comboTimer > 0) this.comboTimer--;
      else this.isAttacking = false;

      if (this.isDodging) {
        this.dodgeTimer--;
        if (this.dodgeTimer <= 0) {
          this.isDodging = false;
          this.state = "idle";
          this.vel.x = 0;
        }
      }
      if (this.isJumping) {
        this.vel.y += GRAVITY * delta * 60;
        this.pos.y += this.vel.y * delta * 60;
        this.jumpTimer--;
        if (this.jumpTimer <= 0 || this.pos.y >= FLOOR) {
          this.isJumping = false;
          this.pos.y = FLOOR;
          this.vel.y = 0;
          this.state = "idle";
        }
      }

      // Movement
      if (!this.isDodging && !this.isJumping && !this.isAttacking) {
        this.pos.x += this.vel.x * delta * 60;
      } else if (this.isDodging) {
        this.pos.x += this.vel.x * delta * 60;
      }

      // Clamp position
      this.pos.x = clamp(this.pos.x, 50, width - 50);

      // Attack logic
      if (this.isAttacking) {
        this.stateTimer += delta * 60;
        // Attack phases for combo: 3 phases
        if (this.stateTimer > 20 && this.attackPhase === 0) {
          this.attackPhase = 1;
          this.weaponExtension = 1;
        } else if (this.stateTimer > 40 && this.attackPhase === 1) {
          this.attackPhase = 2;
          this.weaponExtension = 1.2;
        } else if (this.stateTimer > 60 && this.attackPhase === 2) {
          this.attackPhase = 3;
          this.weaponExtension = 0;
          this.isAttacking = false;
          this.state = "idle";
        }
        // Weapon glow fades out slowly
        this.weaponGlowAlpha = lerp(this.weaponGlowAlpha, 0, 0.1);
      } else {
        this.weaponExtension = lerp(this.weaponExtension, 0, 0.3);
        this.weaponGlowAlpha = lerp(this.weaponGlowAlpha, 0, 0.1);
      }

      // Limb swinging for walk and run
      this.animTimer += delta * 10;
    }

    // Draw flowing neckwear
    drawNeckwear(ctx, baseX, baseY, swayAngle) {
      ctx.save();
      ctx.strokeStyle = this.neckwearColor;
      ctx.lineWidth = 4;
      ctx.shadowColor = this.neckwearColor;
      ctx.shadowBlur = 20;

      const length = this.limbs.neck.length;
      const segments = 8;
      let prevX = baseX;
      let prevY = baseY;

      for (let i = 0; i < segments; i++) {
        const t = i / segments;
        const sway = Math.sin(swayAngle + t * Math.PI * 4) * 8 * (1 - t);
        const x = prevX + sway * this.facing;
        const y = prevY + length / segments;
        ctx.beginPath();
        ctx.moveTo(prevX, prevY);
        ctx.lineTo(x, y);
        ctx.stroke();
        prevX = x;
        prevY = y;
      }
      ctx.restore();
    }

    drawWeaponTrail(ctx) {
      ctx.save();
      ctx.strokeStyle = `rgba(0,255,0,${this.weaponGlowAlpha * 0.6})`;
      ctx.lineWidth = 8;
      ctx.shadowColor = 'lime';
      ctx.shadowBlur = 15;
      ctx.beginPath();
      for (let i = 0; i < this.limbs.weaponTrail.length - 1; i++) {
        const p1 = this.limbs.weaponTrail[i];
        const p2 = this.limbs.weaponTrail[i + 1];
        ctx.moveTo(p1.x, p1.y);
        ctx.lineTo(p2.x, p2.y);
      }
      ctx.stroke();
      ctx.restore();
    }

    draw(ctx) {
      ctx.save();

      // Body base position
      const baseX = this.pos.x;
      const baseY = this.pos.y;

      // Health bar above head
      const healthBarWidth = 120;
      const healthPercent = this.health / this.maxHealth;
      ctx.fillStyle = "black";
      ctx.fillRect(baseX - healthBarWidth / 2 - 2, baseY - 110, healthBarWidth + 4, 14);
      ctx.fillStyle = this.color;
      ctx.fillRect(baseX - healthBarWidth / 2, baseY - 108, healthBarWidth * healthPercent, 10);

      // Neckwear sway angle updates for green stickman only
      if (this.neckwearColor) {
        this.limbs.neck.swayAngle += 0.05;
      }

      // Draw neckwear if present
      if (this.neckwearColor) {
        this.drawNeckwear(ctx, baseX, baseY - 80, this.limbs.neck.swayAngle);
      }

      // Calculate limb angles and swinging animation
      const swing = Math.sin(this.animTimer) * 0.6;
      const walkPhase = this.state === "walk" || this.state === "run" ? this.animTimer : 0;

      // Head
      ctx.fillStyle = this.color;
      ctx.beginPath();
      ctx.arc(baseX, baseY - 80, 10, 0, Math.PI * 2);
      ctx.fill();

      // Torso line
      ctx.strokeStyle = this.color;
      ctx.lineWidth = 5;
      ctx.lineCap = "round";
      ctx.beginPath();
      ctx.moveTo(baseX, baseY - 70);
      ctx.lineTo(baseX, baseY - 10);
      ctx.stroke();

      // Arms
      const armLength = 30;

      // Left arm swinging
      let leftArmAngle = 0;
      if (this.state === "walk" || this.state === "run") {
        leftArmAngle = Math.sin(walkPhase) * 0.8;
      } else if (this.state === "attack") {
        // attack swing
        leftArmAngle = lerp(leftArmAngle, -Math.PI / 4, this.weaponExtension);
      } else if (this.state === "dodge") {
        leftArmAngle = Math.sin(walkPhase * 2) * 0.4;
      } else {
        leftArmAngle = 0;
      }

      // Right arm swinging and weapon
      let rightArmAngle = 0;
      if (this.state === "walk" || this.state === "run") {
        rightArmAngle = -Math.sin(walkPhase) * 0.8;
      } else if (this.state === "attack") {
        rightArmAngle = lerp(0, Math.PI / 2, this.weaponExtension);
      } else if (this.state === "dodge") {
        rightArmAngle = Math.sin(walkPhase * 2 + Math.PI) * 0.4;
      } else {
        rightArmAngle = 0;
      }

      // Left Arm
      ctx.beginPath();
      ctx.moveTo(baseX, baseY - 60);
      const leftElbowX = baseX + Math.cos(leftArmAngle) * -armLength;
      const leftElbowY = baseY - 60 + Math.sin(leftArmAngle) * armLength;
      ctx.lineTo(leftElbowX, leftElbowY);
      ctx.lineWidth = 5;
      ctx.stroke();

      // Left Forearm
      const leftForearmAngle = leftArmAngle + Math.sin(this.animTimer * 2) * 0.2;
      ctx.beginPath();
      ctx.moveTo(leftElbowX, leftElbowY);
      ctx.lineTo(
        leftElbowX + Math.cos(leftForearmAngle) * -armLength,
        leftElbowY + Math.sin(leftForearmAngle) * armLength
      );
      ctx.stroke();

      // Right Arm (weapon arm)
      ctx.beginPath();
      ctx.moveTo(baseX, baseY - 60);
      const rightElbowX = baseX + Math.cos(rightArmAngle) * armLength;
      const rightElbowY = baseY - 60 + Math.sin(rightArmAngle) * armLength;
      ctx.lineTo(rightElbowX, rightElbowY);
      ctx.lineWidth = 5;
      ctx.stroke();

      // Right Forearm
      const rightForearmAngle = rightArmAngle + Math.sin(this.animTimer * 3) * 0.3;
      const weaponX = rightElbowX + Math.cos(rightForearmAngle) * (armLength + this.weaponExtension * 30);
      const weaponY = rightElbowY + Math.sin(rightForearmAngle) * (armLength + this.weaponExtension * 30);
      ctx.beginPath();
      ctx.moveTo(rightElbowX, rightElbowY);
      ctx.lineTo(weaponX, weaponY);
      ctx.stroke();

      // Weapon glow trail update
      this.limbs.weaponTrail.push({ x: weaponX, y: weaponY });
      if (this.limbs.weaponTrail.length > 10) this.limbs.weaponTrail.shift();

      this.drawWeaponTrail(ctx);

      // Draw weapon as glowing green blade for green stickman
      if (this.color === "lime") {
        ctx.strokeStyle = `rgba(0,255,0,${this.weaponGlowAlpha})`;
        ctx.lineWidth = 8;
        ctx.shadowColor = "lime";
        ctx.shadowBlur = 20;
        ctx.beginPath();
        ctx.moveTo(rightElbowX, rightElbowY);
        ctx.lineTo(weaponX, weaponY);
        ctx.stroke();

        ctx.fillStyle = "lime";
        ctx.beginPath();
        ctx.arc(weaponX, weaponY, 6 + this.weaponExtension * 8, 0, Math.PI * 2);
        ctx.fill();
      } else {
        // Blue stickman weapon as glowing ball mace
        ctx.fillStyle = `rgba(0, 200, 255, ${this.weaponGlowAlpha})`;
        ctx.shadowColor = "cyan";
        ctx.shadowBlur = 15;
        ctx.beginPath();
        ctx.arc(weaponX, weaponY, 10 + this.weaponExtension * 4, 0, Math.PI * 2);
        ctx.fill();
      }

      // Legs swinging
      const legLengthUpper = 35;
      const legLengthLower = 35;

      let leftLegAngle = 0;
      let rightLegAngle = 0;

      if (this.state === "walk" || this.state === "run") {
        leftLegAngle = Math.sin(walkPhase) * 1.2;
        rightLegAngle = -Math.sin(walkPhase) * 1.2;
      } else if (this.state === "jump") {
        leftLegAngle = Math.PI / 6;
        rightLegAngle = Math.PI / 6;
      }

      // Left thigh
      const leftHipX = baseX;
      const leftHipY = baseY - 10;
      const leftKneeX = leftHipX + Math.cos(leftLegAngle) * -legLengthUpper;
      const leftKneeY = leftHipY + Math.sin(leftLegAngle) * legLengthUpper;
      ctx.beginPath();
      ctx.moveTo(leftHipX, leftHipY);
      ctx.lineTo(leftKneeX, leftKneeY);
      ctx.lineWidth = 6;
      ctx.stroke();

      // Left lower leg
      const leftLowerLegAngle = leftLegAngle + Math.sin(this.animTimer * 2) * 0.3;
      const leftFootX = leftKneeX + Math.cos(leftLowerLegAngle) * -legLengthLower;
      const leftFootY = leftKneeY + Math.sin(leftLowerLegAngle) * legLengthLower;
      ctx.beginPath();
      ctx.moveTo(leftKneeX, leftKneeY);
      ctx.lineTo(leftFootX, leftFootY);
      ctx.stroke();

      // Right thigh
      const rightHipX = baseX;
      const rightHipY = baseY - 10;
      const rightKneeX = rightHipX + Math.cos(rightLegAngle) * legLengthUpper;
      const rightKneeY = rightHipY + Math.sin(rightLegAngle) * legLengthUpper;
      ctx.beginPath();
      ctx.moveTo(rightHipX, rightHipY);
      ctx.lineTo(rightKneeX, rightKneeY);
      ctx.stroke();

      // Right lower leg
      const rightLowerLegAngle = rightLegAngle + Math.sin(this.animTimer * 2 + Math.PI) * 0.3;
      const rightFootX = rightKneeX + Math.cos(rightLowerLegAngle) * legLengthLower;
      const rightFootY = rightKneeY + Math.sin(rightLowerLegAngle) * legLengthLower;
      ctx.beginPath();
      ctx.moveTo(rightKneeX, rightKneeY);
      ctx.lineTo(rightFootX, rightFootY);
      ctx.stroke();

      ctx.restore();
    }
  }

  // Impact flash and shake overlays
  let impactFlashAlpha = 0;

  // Game State
  let player, enemy;
  let isRunning = false;

  // Start fight function
  function startFight() {
    player = new Stickman(200, "lime", "#0f0");
    enemy = new Stickman(700, "cyan", null);
    player.target = enemy;
    enemy.target = player;
    isRunning = true;
    victoryMessage.style.display = "none";
  }

  // Collision and attack detection
  function checkHits() {
    if (!player.isAttacking) return;

    // Weapon tip pos from player (right arm forearm)
    const weaponTip = player.limbs.weaponTrail[player.limbs.weaponTrail.length - 1];
    if (!weaponTip) return;

    // Distance to enemy head
    const distToEnemy = distance(weaponTip, enemy.pos.sub(new Vec2(0, 80)));
    if (distToEnemy < 20 && enemy.health > 0) {
      enemy.applyDamage(10);
      impactFlashAlpha = 1;
    }
  }

  function checkHitsEnemy() {
    if (!enemy.isAttacking) return;
    const weaponTip = enemy.limbs.weaponTrail[enemy.limbs.weaponTrail.length - 1];
    if (!weaponTip) return;
    const distToPlayer = distance(weaponTip, player.pos.sub(new Vec2(0, 80)));
    if (distToPlayer < 20 && player.health > 0) {
      player.applyDamage(10);
      impactFlashAlpha = 1;
    }
  }

  // Draw camera shake effect
  function applyCameraShake() {
    if (cameraShake > 0) {
      const dx = (Math.random() - 0.5) * cameraShake;
      const dy = (Math.random() - 0.5) * cameraShake;
      ctx.translate(dx, dy);
      cameraShake *= 0.85;
      if (cameraShake < 0.5) cameraShake = 0;
    }
  }

  // Main loop
  let lastTime = 0;
  const victoryMessage = document.getElementById("victory");

  function loop(time = 0) {
    const deltaRaw = (time - lastTime) / 1000;
    lastTime = time;
    const delta = deltaRaw * slowMotion;

    ctx.clearRect(0, 0, width, height);

    ctx.save();
    applyCameraShake();

    // Draw floor
    ctx.fillStyle = "#444";
    ctx.fillRect(0, FLOOR + 35, width, height - FLOOR - 35);

    // Update AI and update entities
    if (isRunning) {
      player.updateAI();
      enemy.updateAI();

      player.update(delta);
      enemy.update(delta);

      checkHits();
      checkHitsEnemy();

      // Check victory
      if (player.health <= 0 || enemy.health <= 0) {
        isRunning = false;
        const winner = player.health > 0 ? "Green Stickman Wins!" : "Blue Stickman Wins!";
        victoryMessage.textContent = winner;
        victoryMessage.style.display = "block";
      }
    } else {
      // Idle animation
      player && player.update(delta);
      enemy && enemy.update(delta);
    }

    // Draw stickmen
    player && player.draw(ctx);
    enemy && enemy.draw(ctx);

    ctx.restore();

    // Draw impact flash overlay
    if (impactFlashAlpha > 0) {
      ctx.fillStyle = `rgba(255,255,255,${impactFlashAlpha})`;
      ctx.fillRect(0, 0, width, height);
      impactFlashAlpha -= 0.05;
      if (impactFlashAlpha < 0) impactFlashAlpha = 0;
    }

    requestAnimationFrame(loop);
  }

  document.getElementById("startBtn").addEventListener("click", () => {
    startFight();
  });

  // Start loop
  loop();

})();
</script>

</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>3D Office Adventure Game</title>
  <style>
    body { margin: 0; overflow: hidden; }
    #instructions {
      position: absolute;
      top: 10px;
      left: 10px;
      color: white;
      font-family: Arial, sans-serif;
      background: rgba(0,0,0,0.5);
      padding: 10px;
      max-width: 300px;
      z-index: 10;
    }
    #crosshair {
      position: absolute;
      top: 50%;
      left: 50%;
      width: 20px;
      height: 20px;
      margin-left: -10px;
      margin-top: -10px;
      pointer-events: none;
      z-index: 10;
    }
    #crosshair:before, #crosshair:after {
      content: '';
      position: absolute;
      background: white;
    }
    #crosshair:before {
      left: 50%;
      top: 0;
      width: 2px;
      height: 20px;
      margin-left: -1px;
    }
    #crosshair:after {
      top: 50%;
      left: 0;
      width: 20px;
      height: 2px;
      margin-top: -1px;
    }
  </style>
</head>
<body>
  <div id="instructions">
    Click to lock pointer.<br/>
    WASD to move, Shift to sprint, Space to jump.<br/>
    Hold R to rewind time.<br/>
    Press Q to freeze/unfreeze time (with music).<br/>
    Collect the glowing crystal to win.<br/>
  </div>
  <div id="crosshair"></div>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/PointerLockControls.js"></script>
  <script>
    // Setup basic scene, camera, renderer
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Controls
    const controls = new THREE.PointerLockControls(camera, document.body);
    scene.add(controls.getObject());

    // Lighting
    const ambientLight = new THREE.AmbientLight(0x404040, 2);
    scene.add(ambientLight);
    const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
    directionalLight.position.set(5,10,5);
    scene.add(directionalLight);

    // Movement vars
    const playerVelocity = new THREE.Vector3();
    let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
    let isSprinting = false;
    let canJump = false;
    const playerHeight = 1.8;
    const moveSpeed = 5;
    const sprintMultiplier = 1.5;
    const gravity = -9.8;

    // Walls
    const walls = [];

    // Create walls for office rooms and corridors
    function createWalls() {
      const wallMat = new THREE.MeshLambertMaterial({color:0x888888});
      // Example walls, add more for full layout
      const wallGeometry = new THREE.BoxGeometry(10, 2, 1);

      // Front corridor wall
      const wall1 = new THREE.Mesh(wallGeometry, wallMat);
      wall1.position.set(0,1,0);
      scene.add(wall1);
      walls.push(wall1);

      // Side walls
      const sideWallGeo = new THREE.BoxGeometry(1, 2, 10);
      const wall2 = new THREE.Mesh(sideWallGeo, wallMat);
      wall2.position.set(-5,1,5);
      scene.add(wall2);
      walls.push(wall2);

      const wall3 = new THREE.Mesh(sideWallGeo, wallMat);
      wall3.position.set(5,1,5);
      scene.add(wall3);
      walls.push(wall3);

      // More walls for 3 rooms and corridors can be added similarly...
    }

    createWalls();

    // Crystal collectible
    const crystalGeo = new THREE.IcosahedronGeometry(0.6, 1);
    const crystalMat = new THREE.MeshPhysicalMaterial({
      color: 0x00aaff,
      metalness: 0.5,
      roughness: 0,
      clearcoat: 1,
      clearcoatRoughness: 0,
      transmission: 1,
      thickness: 1.5,
      envMapIntensity: 2
    });
    const crystal = new THREE.Mesh(crystalGeo, crystalMat);
    crystal.position.set(0,1,8);
    scene.add(crystal);

    // Enemy AI class
    class Enemy {
      constructor(position, patrolPoints) {
        this.mesh = new THREE.Mesh(
          new THREE.BoxGeometry(1, 1.8, 1),
          new THREE.MeshPhongMaterial({color: 0xff2222})
        );
        this.mesh.position.copy(position);
        scene.add(this.mesh);

        this.patrolPoints = patrolPoints;
        this.currentPatrolIndex = 0;
        this.speed = 2.5;
        this.state = 'patrol';
        this.searchTimer = 0;
        this.chaseTarget = null;
        this.detectionRadius = 6;
        this.searchDuration = 5;
      }
      update(delta, playerPos) {
        if (isFrozen) return; // Stop moving when time frozen
        if (this.state === 'patrol') {
          const target = this.patrolPoints[this.currentPatrolIndex];
          const dir = new THREE.Vector3().subVectors(target, this.mesh.position);
          const dist = dir.length();
          if (dist < 0.1) {
            this.currentPatrolIndex = (this.currentPatrolIndex + 1) % this.patrolPoints.length;
          } else {
            dir.normalize();
            this.mesh.position.addScaledVector(dir, this.speed * delta);
          }
          if (this.mesh.position.distanceTo(playerPos) < this.detectionRadius) {
            this.state = 'chase';
            this.chaseTarget = playerPos.clone();
          }
        } else if (this.state === 'chase') {
          const dir = new THREE.Vector3().subVectors(playerPos, this.mesh.position);
          if (dir.length() > this.detectionRadius * 1.5) {
            this.state = 'search';
            this.searchTimer = this.searchDuration;
            this.chaseTarget = null;
          } else {
            dir.normalize();
            this.mesh.position.addScaledVector(dir, this.speed * 1.5 * delta);
            if (this.mesh.position.distanceTo(playerPos) < 1) {
              alert("Caught by a security guard! Restarting...");
              resetGame();
            }
          }
        } else if (this.state === 'search') {
          this.searchTimer -= delta;
          if (this.searchTimer <= 0) this.state = 'patrol';
        }
      }
    }

    const enemies = [];
    enemies.push(new Enemy(new THREE.Vector3(-3, 0.9, 2), [new THREE.Vector3(-3, 0.9, 2), new THREE.Vector3(3, 0.9, 2)]));
    enemies.push(new Enemy(new THREE.Vector3(4, 0.9, 6), [new THREE.Vector3(4, 0.9, 6), new THREE.Vector3(-4, 0.9, 6)]));

    // Collision detection (simple bounding box)
    function checkCollision(newPos) {
      const playerBox = new THREE.Box3(
        new THREE.Vector3(newPos.x - 0.25, newPos.y, newPos.z - 0.25),
        new THREE.Vector3(newPos.x + 0.25, newPos.y + playerHeight, newPos.z + 0.25)
      );
      for (const wall of walls) {
        const wallBox = new THREE.Box3().setFromObject(wall);
        if (playerBox.intersectsBox(wallBox)) return true;
      }
      return false;
    }

    // Player starting position
    controls.getObject().position.set(0, playerHeight, -5);

    // Rewind mechanic variables
    rewindBuffer = [];
    isRewinding = false;

    // Time freeze mechanic
    isFrozen = false;

    // Audio for freeze time music
    const freezeMusic = new Audio('https://dl03.yt-dl.click/tunnel/?id=W82BxZI8qCrBQLbJAsx0E&exp=1755014290455&sig=s2y9TvuF4VPkgdDAQoQcmyq78bGpEfkevcPYbYye3TU&sec=HY5hysNiguBHIYv8xQhHxp4grYxvTvd8An7JhLcnO3o&iv=T0Vnf7Q2_IbzuYgnV0r01A');
    freezeMusic.loop = true;
    freezeMusic.volume = 0.5;

    // Keyboard input handling
    document.addEventListener('keydown', function(event) {
      switch(event.code) {
        case 'KeyW': moveForward = true; break;
        case 'KeyS': moveBackward = true; break;
        case 'KeyA': moveLeft = true; break;
        case 'KeyD': moveRight = true; break;
        case 'ShiftLeft':
        case 'ShiftRight': isSprinting = true; break;
        case 'Space':
          if (canJump && !isRewinding && !isFrozen) {
            playerVelocity.y = 8;
            canJump = false;
          }
          break;
        case 'KeyR':
          isRewinding = true;
          break;
        case 'KeyQ':
          isFrozen = !isFrozen;
          if (isFrozen) {
            freezeMusic.play();
          } else {
            freezeMusic.pause();
            freezeMusic.currentTime = 0;
          }
          break;
      }
    });

    document.addEventListener('keyup', function(event) {
      switch(event.code) {
        case 'KeyW': moveForward = false; break;
        case 'KeyS': moveBackward = false; break;
        case 'KeyA': moveLeft = false; break;
        case 'KeyD': moveRight = false; break;
        case 'ShiftLeft':
        case 'ShiftRight': isSprinting = false; break;
        case 'KeyR':
          isRewinding = false;
          break;
      }
    });

    // Reset game
    function resetGame() {
      controls.getObject().position.set(0, playerHeight, -5);
      playerVelocity.set(0,0,0);
      rewindBuffer = [];
      isRewinding = false;
      isFrozen = false;
      freezeMusic.pause();
      freezeMusic.currentTime = 0;
      enemies.forEach(enemy => {
        enemy.mesh.position.copy(enemy.patrolPoints[0]);
        enemy.currentPatrolIndex = 0;
        enemy.state = 'patrol';
      });
      if (!scene.children.includes(crystal)) scene.add(crystal);
    }

    // Clock and animation loop
    const clock = new THREE.Clock();

    function animate() {
      requestAnimationFrame(animate);
      const delta = clock.getDelta();

      if (controls.isLocked === true) {
        if (!isFrozen) {
          // Movement logic only when not frozen

          // Movement direction
          let direction = new THREE.Vector3();
          if (moveForward) direction.z -= 1;
          if (moveBackward) direction.z += 1;
          if (moveLeft) direction.x -= 1;
          if (moveRight) direction.x += 1;
          direction.normalize();

          let speed = moveSpeed * (isSprinting ? sprintMultiplier : 1);

          // Calculate new position
          let newPos = controls.getObject().position.clone();
          newPos.x += direction.x * speed * delta;
          newPos.z += direction.z * speed * delta;

          // Collision check & update position
          if (!checkCollision(new THREE.Vector3(newPos.x, controls.getObject().position.y, controls.getObject().position.z)))
            controls.getObject().position.x = newPos.x;
          if (!checkCollision(new THREE.Vector3(controls.getObject().position.x, controls.getObject().position.y, newPos.z)))
            controls.getObject().position.z = newPos.z;

          // Gravity
          playerVelocity.y += gravity * delta;
          controls.getObject().position.y += playerVelocity.y * delta;

          if (controls.getObject().position.y < playerHeight) {
            playerVelocity.y = 0;
            controls.getObject().position.y = playerHeight;
            canJump = true;
          }

          // Enemies update
          enemies.forEach(enemy => enemy.update(delta, controls.getObject().position));
        }

        // Rewind logic
        if (isRewinding) {
          if (rewindBuffer.length > 0) {
            // Pop last saved state and apply it
            const lastState = rewindBuffer.pop();
            controls.getObject().position.copy(lastState.position);
            playerVelocity.copy(lastState.velocity);
          }
        } else {
          // Save current state for rewind buffer, max limit
          rewindBuffer.push({
            position: controls.getObject().position.clone(),
            velocity: playerVelocity.clone()
          });
          if (rewindBuffer.length > 180) rewindBuffer.shift();
        }

        // Check for crystal pickup
        if (controls.getObject().position.distanceTo(crystal.position) < 1) {
          alert("You collected the crystal and won! Restarting...");
          resetGame();
        }
      }

      renderer.render(scene, camera);
    }

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // Start game
    init();
    function init() {
      controls.getObject().position.set(0, playerHeight, -5);
      animate();
    }
  </script>
</body>
</html>

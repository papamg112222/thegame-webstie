<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <title>Echo Shard â€“ Complete 3D Stealth Game</title>
  <style>
    html,body { margin:0; padding:0; overflow:hidden; background:#111; color:#eee; font-family:sans-serif; }
    #instructions, #ui, #message { position: absolute; z-index:10; }
    #instructions {
      top:50%; left:50%; transform:translate(-50%,-50%);
      padding:20px; background:rgba(0,0,0,0.8); border-radius:8px;
      text-align:center;
    }
    #ui {
      top:10px; left:10px; background:rgba(0,0,0,0.4);
      padding:10px; border-radius:6px; font-size:14px;
    }
    #message {
      bottom:30px; left:50%; transform:translateX(-50%);
      background:rgba(255,255,255,0.9); color:#000;
      padding:12px 20px; border-radius:8px;
      display:none; font-weight:bold; font-size:18px;
    }
    canvas { display:block; }
  </style>
</head>
<body>

<div id="instructions">
  <strong>Press any key to start.</strong><br/>
  WASD: Move | Mouse: Look | E: Interact<br/>
  R: Hold to rewind | Q: Toggle time-stop
</div>

<div id="ui">
  Health: <span id="health">100</span><br/>
  Keycards: <span id="keycards">0</span><br/>
  Stage: <span id="stage">1</span><br/>
  Time: <span id="timer">00:00</span>
</div>

<div id="message"></div>

<script src="https://cdn.jsdelivr.net/npm/three@0.150.1/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.150.1/examples/js/controls/PointerLockControls.js"></script>
<script>
(() => {
  const PLAYER_HEIGHT = 1.8;
  const GRAVITY = -30;
  let scene, camera, renderer, controls, clock;
  let velocity = new THREE.Vector3(), direction = new THREE.Vector3();
  let move = { forward:false, backward:false, left:false, right:false, sprint:false };
  let canJump = false, gameStarted = false;
  let health = 100, keycards = 0, stage = 1, startTime = Date.now();
  let isRewinding = false, isTimeStopped = false;
  let rewindBuffer = [];
  const rewindMax = 300; // frames
  const ui = {
    instr: document.getElementById('instructions'),
    health: document.getElementById('health'),
    keycards: document.getElementById('keycards'),
    stage: document.getElementById('stage'),
    timer: document.getElementById('timer'),
    msg: document.getElementById('message')
  };
  const music = new Audio('https://dl03.yt-dl.click/tunnel/?id=W82BxZI8qCrBQLbJAsx0E&exp=1755014290455&sig=s2y9TvuF4VPkgdDAQoQcmyq78bGpEfkevcPYbYye3TU&sec=HY5hysNiguBHIYv8xQhHxp4grYxvTvd8An7JhLcnO3o&iv=T0Vnf7Q2_IbzuYgnV0r01A');
  music.loop = true;

  function showMessage(text, duration=3000) {
    ui.msg.textContent = text;
    ui.msg.style.display = 'block';
    setTimeout(() => ui.msg.style.display = 'none', duration);
  }
  function playMusic() { music.play().catch(()=>{}); }
  function stopMusic() { music.pause(); music.currentTime = 0; }

  class Door {
    constructor(pos, locked=true){
      this.locked = locked;
      this.mesh = new THREE.Mesh(
        new THREE.BoxGeometry(1,3,0.2),
        new THREE.MeshPhongMaterial({ color: locked?0xaa0000:0x00aa00 })
      );
      this.mesh.position.copy(pos);
      scene.add(this.mesh);
    }
    interact() {
      if (this.locked && keycards>0) {
        keycards--;
        ui.keycards.textContent = keycards;
        this.locked = false;
        this.mesh.material.color.set(0x00aa00);
        showMessage("Door unlocked");
      } else if (this.locked) {
        showMessage("Need a keycard");
      }
    }
  }

  class Enemy {
    constructor(pos){
      this.mesh = new THREE.Mesh(
        new THREE.BoxGeometry(0.7,1.8,0.7),
        new THREE.MeshPhongMaterial({color:0xff4444})
      );
      this.mesh.position.copy(pos);
      this.dir = new THREE.Vector3(1,0,0);
      scene.add(this.mesh);
    }
    update(delta, playerPos){
      if (isTimeStopped) return;
      this.mesh.position.addScaledVector(this.dir, delta*2);
      if (this.mesh.position.x>9||this.mesh.position.x<-9) this.dir.x*=-1;
      if (this.mesh.position.distanceTo(playerPos)<1.2){
        health -= 10;
        ui.health.textContent = health;
        if (health<=0) return alert("Game Over"),location.reload();
      }
    }
  }

  class Keycard {
    constructor(pos){
      this.mesh = new THREE.Mesh(
        new THREE.BoxGeometry(0.3,0.1,0.5),
        new THREE.MeshPhongMaterial({color:0xffff00})
      );
      this.mesh.position.copy(pos);
      scene.add(this.mesh);
      this.collected = false;
    }
    tryCollect(playerPos){
      if (!this.collected && this.mesh.position.distanceTo(playerPos)<1) {
        this.collected = true;
        scene.remove(this.mesh);
        keycards++;
        ui.keycards.textContent = keycards;
        showMessage("Keycard picked");
      }
    }
  }

  class Crystal {
    constructor(pos){
      this.mesh = new THREE.Mesh(
        new THREE.IcosahedronGeometry(0.4,0),
        new THREE.MeshPhongMaterial({color:0x00aaff,emissive:0x0077ff,shininess:100})
      );
      this.mesh.position.copy(pos);
      scene.add(this.mesh);
    }
    tryCollect(playerPos){
      return playerPos.distanceTo(this.mesh.position)<1;
    }
  }

  let doors=[], enemies=[], keys=[], crystals=[];

  function setupStage(num){
    doors.forEach(d=>scene.remove(d.mesh)); doors=[];
    enemies.forEach(e=>scene.remove(e.mesh)); enemies=[];
    keys.forEach(k=>scene.remove(k.mesh)); keys=[];
    crystals.forEach(c=>scene.remove(c.mesh)); crystals=[];
    // single room environment
    doors.push(new Door(new THREE.Vector3(0,1.5,-9), true));
    enemies.push(new Enemy(new THREE.Vector3(-5,1,-5)));
    keys.push(new Keycard(new THREE.Vector3(5,0.1,-5)));
    crystals.push(new Crystal(new THREE.Vector3(0,1,-15)));
    ui.stage.textContent = num;
  }

  function setup(){
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(75,innerWidth/innerHeight,0.1,1000);
    renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setSize(innerWidth,innerHeight);
    document.body.appendChild(renderer.domElement);
    controls = new THREE.PointerLockControls(camera, document.body);
    scene.add(controls.getObject());

    const ambient = new THREE.AmbientLight(0xffffff, 0.2); scene.add(ambient);
    const pl = new THREE.PointLight(0xffffff, 0.8); pl.position.set(0,10,0); scene.add(pl);

    const floor = new THREE.Mesh(
      new THREE.PlaneGeometry(20,20),
      new THREE.MeshPhongMaterial({color:0x333333})
    );
    floor.rotation.x=-Math.PI/2; scene.add(floor);

    setupStage(stage);
    camera.position.set(0,PLAYER_HEIGHT,0);
    clock = new THREE.Clock();
    animate();
  }

  function animate(){
    requestAnimationFrame(animate);
    const dt = clock.getDelta();

    const elapsed = Math.floor((Date.now()-startTime)/1000);
    ui.timer.textContent = new Date(elapsed*1000).toISOString().substr(14,5);

    if (!isRewinding) {
      rewindBuffer.push({
        pos: controls.getObject().position.clone(),
        vel: velocity.clone()
      });
      if (rewindBuffer.length > rewindMax) rewindBuffer.shift();
    } else {
      const state = rewindBuffer.pop();
      if (state) {
        controls.getObject().position.copy(state.pos);
        velocity.copy(state.vel);
      }
    }

    if (!isTimeStopped && !isRewinding){
      velocity.x -= velocity.x*10*dt;
      velocity.z -= velocity.z*10*dt;
      direction.z = Number(move.backward) - Number(move.forward);
      direction.x = Number(move.right) - Number(move.left);
      direction.normalize();
      const speed = move.sprint?10:5;
      velocity.z -= direction.z*speed*dt;
      velocity.x -= direction.x*speed*dt;
      controls.moveRight(-velocity.x*dt);
      controls.moveForward(-velocity.z*dt);
      velocity.y += GRAVITY*dt;
      controls.getObject().position.y += velocity.y*dt;
      if (controls.getObject().position.y < PLAYER_HEIGHT){
        velocity.y = 0;
        controls.getObject().position.y = PLAYER_HEIGHT;
        canJump = true;
      }
    }

    const playerPos = controls.getObject().position;

    keys.forEach(k=>k.tryCollect(playerPos));
    doors.forEach(d=> {
      if (playerPos.distanceTo(d.mesh.position)<1.5) d.interact();
    });
    enemies.forEach(e=> e.update(dt,playerPos));
    crystals.forEach(c=> {
      if (c.tryCollect(playerPos)){
        stage++;
        showMessage("Stage "+stage+" cleared!");
        setupStage(stage);
      }
    });

    renderer.render(scene, camera);
  }

  document.addEventListener('keydown', e=>{
    if (!gameStarted){
      controls.lock();
      return;
    }
    if (e.code==='KeyW') move.forward= true;
    if (e.code==='KeyS') move.backward= true;
    if (e.code==='KeyA') move.left= true;
    if (e.code==='KeyD') move.right= true;
    if (e.code==='ShiftLeft') move.sprint= true;
    if (e.code==='Space' && canJump){ velocity.y = 8; canJump=false; }
    if (e.code==='KeyR') isRewinding = true;
    if (e.code==='KeyQ') {
      isTimeStopped = !isTimeStopped;
      isTimeStopped ? playMusic() : stopMusic();
    }
    if (e.code==='KeyE'){
      doors.forEach(d => { if (playerPos.distanceTo(d.mesh.position)<1.5) d.interact(); });
    }
  });

  document.addEventListener('keyup', e=>{
    if (e.code==='KeyW') move.forward= false;
    if (e.code==='KeyS') move.backward= false;
    if (e.code==='KeyA') move.left= false;
    if (e.code==='KeyD') move.right= false;
    if (e.code==='ShiftLeft') move.sprint= false;
    if (e.code==='KeyR') isRewinding = false;
  });

  controls.addEventListener('lock', ()=>{
    gameStarted = true;
    ui.instr.style.display = 'none';
    setup();
  });

  window.addEventListener('resize', ()=>{
    camera.aspect = innerWidth/innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth,innerHeight);
  });

})();
</script>

</body>
</html>

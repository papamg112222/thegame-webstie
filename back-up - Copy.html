<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Maze Explorer: The Sprint</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/PointerLockControls.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght400;700&display=swap" rel="stylesheet">
    <style>
        body {
            background-color: #050508;
            font-family: 'Orbitron', sans-serif;
            color: #E0E0E0;
            user-select: none;
            overflow: hidden;
            margin: 0;
            padding: 0;
            height: 100vh;
            width: 100vw;
        }
        #info {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #ff4444; 
            padding: 2rem;
            border-radius: 0.75rem;
            text-align: center;
            z-index: 1000;
            box-shadow: 0 0 25px rgba(255, 68, 68, 0.7);
            cursor: pointer;
        }
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 10px;
            height: 10px;
            margin: -5px 0 0 -5px;
            border: 1px solid rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            z-index: 999;
            pointer-events: none;
            opacity: 0; 
        }
        #message-box {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #111;
            border: 2px solid #ff0044;
            padding: 2rem;
            border-radius: 0.5rem;
            text-align: center;
            z-index: 2000;
            box-shadow: 0 0 30px #ff0044;
            display: none;
        }
        .win-style {
            border-color: #00ff00 !important;
            box-shadow: 0 0 30px #00ff00 !important;
        }
        .action-button {
            padding: 0.75rem 2rem;
            background: #ff4444;
            color: #fff;
            font-weight: bold;
            border: none;
            border-radius: 0.375rem;
            cursor: pointer;
            transition: background 0.2s, transform 0.1s;
        }
        .action-button:hover {
            background: #cc3333;
            transform: scale(1.05);
        }
        #status-bar {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            padding: 10px 20px;
            background: rgba(0, 0, 0, 0.7);
            color: #00ffff;
            font-size: 14px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 10;
        }
        .sprinting {
            color: #ff0000;
            font-weight: bold;
            text-shadow: 0 0 8px #ff0000;
        }
        #minimap {
            position: absolute;
            top: 20px;
            right: 20px;
            border: 2px solid #00ffff; 
            background: rgba(0, 0, 0, 0.8);
            display: block; /* MODIFIED: Set to block for permanent display */
            z-index: 100;
        }
        
        /* --- Console Styles --- */
        #console {
            position: absolute;
            bottom: 50px;
            left: 50%;
            transform: translateX(-50%);
            width: 600px;
            z-index: 5000;
            display: none;
        }
        #console input {
            width: 100%;
            padding: 8px 12px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #00ffff;
            color: #00ff00;
            font-family: 'Orbitron', sans-serif;
            font-size: 16px;
            outline: none;
        }
        
        /* --- Item Bar Styles (Minecraft Vibe) --- */
        #item-bar {
            position: absolute;
            bottom: 50px; /* Above status bar */
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
            display: flex;
            flex-direction: column; 
            align-items: center;
        }
        #item-slots {
            display: flex;
            flex-direction: row; 
            gap: 4px; 
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }
        .item-slot {
            width: 45px; 
            height: 45px;
            background: rgba(10, 10, 10, 0.9); 
            border: 3px solid #666; 
            border-radius: 4px; 
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            font-weight: bold;
            color: #fff;
            transition: border-color 0.1s, transform 0.1s, box-shadow 0.1s;
        }

        /* --- Floating Text Style --- */
        #floating-text {
            position: absolute;
            top: 40%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.9);
            font-size: 3rem;
            font-weight: bold;
            color: #00ffcc;
            text-shadow: 0 0 10px #00ffcc;
            opacity: 0;
            transition: opacity 0.5s, transform 0.5s;
            z-index: 100;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="info">
        <h1 class="text-3xl font-bold mb-4 text-[#ff4444]">THE DEEP LABYRINTH</h1>
        <p class="text-sm mb-4">Click to enter the darkness. Collect the 150 crystals, repair motors, and avoid the 6 Ghosts!</p>
        <p class="text-xl font-bold mb-2">Controls</p>
        <p class="mb-4 text-left mx-auto max-w-xs">
            **Walk**: **W** / **A** / **S** / **D**<br>
            **Sprint**: Automatic when a Ghost is sighted.<br>
            **Look**: **Mouse** Movement<br>
            **Interact**: **F** (Near Motors)<br>
            **Use Item**: **1** - **5** (Inventory Slot)<br>
            **Cheat Console**: Press **/**
        </p>
        <button class="action-button">ENTER</button>
    </div>

    <div id="floating-text"></div>

    <div id="item-bar">
        <h2 class="text-xs font-bold mb-1 text-[#00ffff] text-center" style="letter-spacing: 0.1em;">INVENTORY (1 - 5)</h2>
        <div id="item-slots" class="flex flex-row space-x-2">
            </div>
    </div>
    
    <div id="minigame-box" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0, 0, 0, 0.9); border: 2px solid #00ff00; padding: 2rem; border-radius: 0.75rem; text-align: center; z-index: 5001; box-shadow: 0 0 25px rgba(0, 255, 0, 0.7); display: none;">
        <h2 id="minigame-title" class="text-2xl font-bold mb-4 text-[#00ff00]">MOTOR HACK: STAGE 1/10</h2>
        <div id="timing-bar-container" style="width: 300px; height: 30px; background: #333; margin: 0 auto 1rem; border: 1px solid #00ffff; position: relative; overflow: hidden;">
            <div id="timing-cursor" style="position: absolute; top: 0; left: 0; width: 5px; height: 100%; background: #ff0000;"></div>
            <div id="timing-target" style="position: absolute; top: 0; height: 100%; background: rgba(0, 255, 0, 0.5);"></div>
        </div>
        <p id="minigame-status" class="mb-4 text-sm">Press **Space** to attempt!</p>
        <button id="minigame-close" class="action-button" onclick="endMiniGame(false)" style="background: #444;">CLOSE</button>
    </div>

    <div id="status-bar">
        <span id="player-status">Status: Walking...</span>
        <span id="ghost-proximity">Threat: Distant | Crystals: 0/150</span>
    </div>

    <div id="crosshair"></div>

    <div id="console">
        <input type="text" id="console-input" placeholder="Type command (e.g., /unshowmm, /freecam) and press Enter" />
    </div>

    <div id="message-box">
        <p id="message-text" class="text-xl font-bold mb-4"></p>
        <button class="action-button" onclick="closeAlert()">RESTART</button>
    </div>

    <script type="module">
        // --- 3D Setup Variables ---
        let camera, scene, renderer, controls, raycaster;
        let clock = new THREE.Clock();
        const infoElement = document.getElementById('info');
        const crosshair = document.getElementById('crosshair');
        const playerStatus = document.getElementById('player-status');
        const ghostProximity = document.getElementById('ghost-proximity');
        const floatingText = document.getElementById('floating-text');
        const minimap = document.createElement('canvas'); 
        minimap.id = 'minimap';
        document.body.appendChild(minimap);

        // --- Console/Cheat Variables ---
        let isConsoleOpen = false; 
        const consoleElement = document.getElementById('console');
        const consoleInput = document.getElementById('console-input');
        
        // --- Freecam Variables (Vertical Movement is only active here) ---
        let isFreeCam = false; 
        let moveUp = false;    
        let moveDown = false;  
        
        // Fly Speed Variables
        const MAX_FREECAM_SPEED = 500; 
        let flySpeedMultiplier = 10; 

        // Minimap Toggle Variable
        let isMinimapVisible = true; // MODIFIED: Set to true by default

        const CELL_SIZE = 20;
        const WALL_HEIGHT = 10;
        const PLAYER_HEIGHT = 6;
        
        let offsetX, offsetZ;
        
        // Speed Definitions
        const WALK_SPEED = 32;
        const GHOST_WANDER_SPEED = 15; 
        const GHOST_SPEED = 150; 
        const GHOST_FRENZY_SPEED = 300; 
        const PLAYER_SPRINT_SPEED = 100; // MODIFIED: New, safer max player speed
        let effectiveSpeed = WALK_SPEED;
        
        // Sprint Delay Variables
        const SPRINT_DELAY_DURATION = 3.0; 
        let sprintDelayTimer = 0;

        let moveForward = false;
        let moveBackward = false;
        let moveLeft = false;
        let moveRight = false;
        let gameActive = false;
        let winPosition = null;
        let wallObjects = [];

        // --- GAME OBJECT ARRAYS ---
        let ghosts = []; 
        let ghostPaths = []; 
        let crystals = []; 
        let crystalsCollected = 0;
        const TOTAL_CRYSTALS = 150; 
        
        let ghostsGoFrenzy = false; 
        
        let playerGridPos = { r: 0, c: 0 }; 
        let ghostUpdateTimer = 0;
        const GHOST_UPDATE_INTERVAL = 0.5; 
        
        // --- NEW GAME MECHANIC VARIABLES ---
        const INVENTORY_SIZE = 5;
        let inventory = new Array(INVENTORY_SIZE).fill(null); 
        let motorObjects = [];
        let activeMotor = null;
        const INTERACT_DISTANCE = 5; 
        
        // Item Definitions
        const GHOST_POT = { type: 'ghost_pot', icon: '👻', color: '#ff00ff', maxInventory: 2, captureDuration: 40 };
        const CAPTURE_RANGE = 15; // Range to use the pot
        const MOTOR_COOLDOWN_TIME = 300; // 5 minutes

        // Motor Fix Progression
        let motorsFixedCount = 0;
        const MOTORS_NEEDED_FOR_POT = 4;
        
        // --- MiniGame Variables ---
        let isMiniGameActive = false;
        let currentMiniGameStage = 1;
        const MAX_MINIGAME_STAGES = 10;
        let cursorSpeed = 150; 
        let cursorDirection = 1; 
        let cursorPosition = 0; 
        let targetPosition = 0; 
        let targetWidth = 0; 
        const timingBarContainer = document.getElementById('timing-bar-container');
        const timingCursor = document.getElementById('timing-cursor');
        const timingTarget = document.getElementById('timing-target');
        const minigameBox = document.getElementById('minigame-box');
        const minigameTitle = document.getElementById('minigame-title');
        const minigameStatus = document.getElementById('minigame-status');
        const minigameClose = document.getElementById('minigame-close');


        // Maze Grid Definitions
        const MAX_COL = 51;
        const MAX_ROW = 51;
        const START_COL = 1;
        const START_ROW = MAX_ROW - 2;
        const EXIT_COL = MAX_COL - 2;
        const EXIT_ROW = 1;

        // Ghost starting positions 
        const GHOST_START_POSITIONS = [
            { r: MAX_ROW - 2, c: MAX_COL - 2 },
            { r: 1, c: 1 },
            { r: Math.floor(MAX_ROW / 2), c: Math.floor(MAX_COL / 2) + 5 },
            { r: Math.floor(MAX_ROW / 2) + 5, c: Math.floor(MAX_COL / 2) },
            { r: 5, c: 5 },
            { r: 10, c: MAX_COL - 10 }
        ];

        const mazeGrid = generateTrueMaze(MAX_ROW, MAX_COL);

        // Filter Ghost start positions after maze generation
        GHOST_START_POSITIONS.forEach(pos => {
            if (mazeGrid[pos.r][pos.c] === 1) {
                for (let dr = -1; dr <= 1; dr++) {
                    for (let dc = -1; dc <= 1; dc++) {
                        const nr = pos.r + dr;
                        const nc = pos.c + dc;
                        if (nr > 0 && nr < MAX_ROW - 1 && nc > 0 && nc < MAX_COL - 1 && mazeGrid[nr][nc] !== 1) {
                            pos.r = nr;
                            pos.c = nc;
                            return;
                        }
                    }
                }
            }
        });
        
        // --- Maze Generation (Unchanged) ---
        function generateTrueMaze(rows, cols) {
            const grid = Array(rows).fill(0).map(() => Array(cols).fill(1));
            const stack = [];

            stack.push([START_ROW, START_COL]);
            grid[START_ROW][START_COL] = 0; 

            while (stack.length > 0) {
                const [r, c] = stack[stack.length - 1];
                
                const neighbors = [
                    [r - 2, c, r - 1, c], [r + 2, c, r + 1, c],
                    [r, c - 2, r, c - 1], [r, c + 2, r, c + 1]
                ].filter(([nr, nc]) => 
                    nr > 0 && nr < rows - 1 && nc > 0 && nc < cols - 1 && grid[nr][nc] === 1 
                );

                if (neighbors.length > 0) {
                    const [nr, nc, wr, wc] = neighbors[Math.floor(Math.random() * neighbors.length)];
                    grid[nr][nc] = 0;
                    grid[wr][wc] = 0;
                    stack.push([nr, nc]);
                } else {
                    stack.pop(); 
                }
            }

            grid[EXIT_ROW][EXIT_COL] = 2; 

            const LOOP_PERCENTAGE = 0.20; 
            for (let r = 1; r < rows - 1; r++) {
                for (let c = 1; c < cols - 1; c++) {
                    if (grid[r][c] === 1 && Math.random() < LOOP_PERCENTAGE) {
                        grid[r][c] = 0; 
                    }
                }
            }
            return grid;
        }

        // --- Utility Functions ---
        function toGridPosition(worldX, worldZ) {
            const r = Math.floor((worldZ - offsetZ) / CELL_SIZE);
            const c = Math.floor((worldX - offsetX) / CELL_SIZE);
            return { r, c };
        }

        function toWorldPosition(r, c) {
            const x = (c + 0.5) * CELL_SIZE + offsetX;
            const z = (r + 0.5) * CELL_SIZE + offsetZ;
            return new THREE.Vector3(x, PLAYER_HEIGHT, z);
        }

        function updatePlayerGridPosition() {
            playerGridPos = toGridPosition(camera.position.x, camera.position.z);
        }
        
        function showAlert(message, isWin) {
            gameActive = false;
            controls.unlock();
            const messageBox = document.getElementById('message-box');
            const messageText = document.getElementById('message-text');
            messageText.textContent = message;

            if (isWin) {
                messageBox.classList.add('win-style');
                messageBox.querySelector('.action-button').style.background = '#00ff00';
            } else {
                messageBox.classList.remove('win-style');
                messageBox.querySelector('.action-button').style.background = '#ff4444';
            }

            messageBox.style.display = 'block';
            crosshair.style.opacity = 0;
        }

        window.closeAlert = function() {
            document.getElementById('message-box').style.display = 'none';
            window.location.reload();
        }

        function showFloatingText(message) {
            floatingText.textContent = message;
            floatingText.style.opacity = 1;
            floatingText.style.transform = 'translate(-50%, -50%) scale(1)';

            setTimeout(() => {
                floatingText.style.opacity = 0;
                floatingText.style.transform = 'translate(-50%, -50%) scale(0.9)';
            }, 3000); 
        }

        // --- Pathfinding (Unchanged) ---
        function findPath(startR, startC, endR, endC) {
            if (startR === endR && startC === endC) return [];
            
            const rows = mazeGrid.length;
            const cols = mazeGrid[0].length;
            const queue = [`${startR},${startC}`];
            const visited = new Set();
            const parent = {}; 
            
            visited.add(`${startR},${startC}`);
            let goalKey = null;

            while (queue.length > 0) {
                const currentKey = queue.shift();
                const [r, c] = currentKey.split(',').map(Number);

                if (r === endR && c === endC) {
                    goalKey = currentKey;
                    break;
                }

                const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];

                for (const [dr, dc] of directions) {
                    const nr = r + dr;
                    const nc = c + dc;
                    
                    if (nr >= 0 && nr < rows && nc >= 0 && nc < cols) {
                        const neighborKey = `${nr},${nc}`;
                        
                        if (mazeGrid[nr][nc] !== 1 && !visited.has(neighborKey)) {
                            visited.add(neighborKey);
                            parent[neighborKey] = currentKey;
                            queue.push(neighborKey);
                        }
                    }
                }
            }

            if (!goalKey) return [];

            const fullPath = [];
            let tempKey = goalKey;
            
            while (parent[tempKey]) {
                fullPath.unshift(tempKey.split(',').map(Number));
                tempKey = parent[tempKey];
            }
            
            return fullPath; 
        }

        // --- Initialization ---

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x050508);
            scene.fog = new THREE.Fog(0x050508, CELL_SIZE * 5, CELL_SIZE * 30); 

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            raycaster = new THREE.Raycaster();
            
            offsetX = -(mazeGrid[0].length * CELL_SIZE) / 2;
            offsetZ = -(mazeGrid.length * CELL_SIZE) / 2;

            const startX = (START_COL + 0.5) * CELL_SIZE + offsetX;
            const startZ = (START_ROW + 0.5) * CELL_SIZE + offsetZ;
            camera.position.set(startX, PLAYER_HEIGHT, startZ);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight); 
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);

            const ambientLight = new THREE.AmbientLight(0x404040, 0.8);
            scene.add(ambientLight);

            const pointLight = new THREE.PointLight(0xffffff, 1, 50);
            camera.add(pointLight); 
            scene.add(camera);

            controls = new THREE.PointerLockControls(camera, document.body);

            controls.addEventListener('lock', () => {
                infoElement.style.display = 'none';
                crosshair.style.opacity = 1;
                gameActive = true;
            });
            controls.addEventListener('unlock', () => {
                if (!document.getElementById('message-box').style.display || document.getElementById('message-box').style.display === 'none') {
                    if (!isConsoleOpen && !isFreeCam && !isMiniGameActive) { 
                         infoElement.style.display = 'block';
                    }
                }
                gameActive = false;
                crosshair.style.opacity = 0;
            });

            document.getElementById('info').addEventListener('click', () => {
                controls.lock();
            });

            buildMaze(offsetX, offsetZ);
            addGhosts();
            addCrystals();
            addMotors(); 
            setupItemBar(); 
            
            minimap.width = 150;
            minimap.height = 150;

            document.addEventListener('keydown', onKeyDown, false);
            document.addEventListener('keyup', onKeyUp, false);
            window.addEventListener('resize', onWindowResize, false);

            consoleInput.addEventListener('keydown', (event) => {
                if (event.code === 'Enter') {
                    processCommand(consoleInput.value);
                    consoleInput.value = '';
                    consoleElement.style.display = 'none';
                    isConsoleOpen = false;
                    
                    controls.lock(); 
                }
            });
        }

        function buildMaze(offsetX, offsetZ) {
            const wallMaterial = new THREE.MeshPhongMaterial({ color: 0x333333, shininess: 10 });
            const floorMaterial = new THREE.MeshPhongMaterial({ color: 0x1f1f2a });
            const wallGeometry = new THREE.BoxGeometry(CELL_SIZE, WALL_HEIGHT, CELL_SIZE);
            
            // Floor
            const floorGeometry = new THREE.PlaneGeometry(MAX_COL * CELL_SIZE, MAX_ROW * CELL_SIZE);
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            scene.add(floor);

            for (let i = 0; i < mazeGrid.length; i++) {
                for (let j = 0; j < mazeGrid[i].length; j++) {
                    const cellType = mazeGrid[i][j];
                    const x = j * CELL_SIZE + offsetX + CELL_SIZE / 2;
                    const z = i * CELL_SIZE + offsetZ + CELL_SIZE / 2;

                    if (cellType === 1) { // Wall
                        const wall = new THREE.Mesh(wallGeometry, wallMaterial);
                        wall.position.set(x, WALL_HEIGHT / 2, z);
                        wall.userData.isWall = true;
                        scene.add(wall);
                        wallObjects.push(wall);
                    } else if (cellType === 2) { // Exit 
                        const exitMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.8 });
                        const exitGeometry = new THREE.PlaneGeometry(CELL_SIZE * 0.9, WALL_HEIGHT * 0.9);
                        const exitPortal = new THREE.Mesh(exitGeometry, exitMaterial);

                        let doorRotation = 0; 
                        if (EXIT_COL === 1 || EXIT_COL === MAX_COL - 2) {
                            doorRotation = Math.PI / 2;
                        }

                        exitPortal.rotation.y = doorRotation;
                        exitPortal.position.set(x, WALL_HEIGHT / 2, z);
                        exitPortal.userData.isExit = true;
                        
                        exitPortal.visible = false;
                        
                        const exitLight = new THREE.PointLight(0x00ff00, 0, 25);
                        exitLight.position.set(x, 5, z);
                        scene.add(exitLight);
                        exitPortal.userData.light = exitLight;

                        scene.add(exitPortal);
                        winPosition = exitPortal;

                        const doorMaterial = new THREE.MeshPhongMaterial({ color: 0x5c3317, shininess: 10 }); 
                        const doorGeometry = new THREE.BoxGeometry(CELL_SIZE * 0.9, WALL_HEIGHT, 1);
                        const closedDoor = new THREE.Mesh(doorGeometry, doorMaterial);
                        closedDoor.position.set(x, WALL_HEIGHT / 2, z);
                        closedDoor.rotation.y = doorRotation;
                        closedDoor.userData.isDoor = true;
                        closedDoor.userData.isWall = true; 
                        scene.add(closedDoor);
                        wallObjects.push(closedDoor);
                        
                        winPosition.userData.closedDoor = closedDoor;
                    }
                }
            }
        }
        
        function addGhosts() {
            const ghostMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xaa00ff,
                transparent: true,
                opacity: 0.5,
                blending: THREE.AdditiveBlending 
            });
            const ghostGeometry = new THREE.SphereGeometry(2, 16, 16);
            
            ghosts = [];
            ghostPaths = [];
            
            GHOST_START_POSITIONS.forEach((startPos, index) => {
                const ghostMesh = new THREE.Mesh(ghostGeometry, ghostMaterial);
                ghostMesh.userData.isGhost = true;
                ghostMesh.userData.chasing = false; 
                ghostMesh.userData.capturedUntil = 0; // Timestamp when capture ends
                
                const ghostWorldPos = toWorldPosition(startPos.r, startPos.c);
                ghostMesh.position.copy(ghostWorldPos);
                
                const ghostLight = new THREE.PointLight(0xaa00aa, 4, 50);
                ghostMesh.add(ghostLight);
                
                scene.add(ghostMesh);
                ghosts.push(ghostMesh);
                ghostPaths.push([]); 
            });
        }

        function addCrystals() {
            const crystalMaterial = new THREE.MeshPhongMaterial({
                color: 0x00ffff,
                emissive: 0x00ffff,
                emissiveIntensity: 0.5,
                specular: 0xffffff,
                shininess: 100,
                transparent: true,
                opacity: 0.9
            });
            const crystalGeometry = new THREE.DodecahedronGeometry(1); 
            
            let count = 0;
            for (let i = 1; i < MAX_ROW - 1; i++) { 
                for (let j = 1; j < MAX_COL - 1; j++) {
                    if (mazeGrid[i][j] === 0) { 
                        if (count >= TOTAL_CRYSTALS) return;
                        
                        if (Math.random() < 0.1) { 
                            const crystal = new THREE.Mesh(crystalGeometry, crystalMaterial);
                            const worldPos = toWorldPosition(i, j);
                            crystal.position.set(worldPos.x + (Math.random() - 0.5) * 5, 
                                                PLAYER_HEIGHT / 2, 
                                                worldPos.z + (Math.random() - 0.5) * 5);
                            crystal.userData.isCrystal = true;
                            
                            scene.add(crystal);
                            crystals.push(crystal);
                            count++;
                        }
                    }
                }
            }
        }
        
        // --- Motor Functionality ---
        function addMotors() {
            motorObjects = [];
            // Pick 6 non-wall locations to place motors
            const possibleMotorPos = [
                { r: EXIT_ROW + 2, c: EXIT_COL },
                { r: START_ROW - 2, c: START_COL },
                { r: 1, c: MAX_COL - 6 },
                { r: MAX_ROW - 6, c: 1 },
                { r: Math.floor(MAX_ROW / 2), c: 1 },
                { r: Math.floor(MAX_ROW / 2), c: MAX_COL - 2 }
            ];

            possibleMotorPos.forEach((pos, index) => {
                if (mazeGrid[pos.r] && mazeGrid[pos.r][pos.c] === 0) {
                    const motorGeometry = new THREE.BoxGeometry(3, 3, 1);
                    const motorMaterial = new THREE.MeshBasicMaterial({ color: 0xffaa00 });
                    const motorMesh = new THREE.Mesh(motorGeometry, motorMaterial);
                    
                    const worldPos = toWorldPosition(pos.r, pos.c);
                    
                    let rotationY = 0;
                    let positionX = worldPos.x;
                    let positionZ = worldPos.z;

                    // Small adjustments to make the motor sit against a wall/near a corner for better visuals
                    if (pos.c === 1) { 
                        positionX += CELL_SIZE / 2 - 0.5;
                        rotationY = -Math.PI / 2;
                    } else if (pos.c === MAX_COL - 2 || pos.c === EXIT_COL) { 
                        positionX -= CELL_SIZE / 2 - 0.5;
                        rotationY = Math.PI / 2;
                    } else if (pos.r === 1) { 
                        positionZ += CELL_SIZE / 2 - 0.5;
                        rotationY = Math.PI;
                    } else if (pos.r === MAX_ROW - 2 || pos.r === START_ROW - 2) { 
                        positionZ -= CELL_SIZE / 2 - 0.5;
                        rotationY = 0;
                    }

                    motorMesh.position.set(positionX, PLAYER_HEIGHT / 2, positionZ);
                    motorMesh.rotation.y = rotationY;
                    
                    motorMesh.userData.isMotor = true;
                    motorMesh.userData.r = pos.r;
                    motorMesh.userData.c = pos.c;
                    motorMesh.userData.fixed = false;
                    motorMesh.userData.cooldownEnd = 0; // Timestamp
                    motorMesh.userData.light = new THREE.PointLight(0xffaa00, 4, 10);
                    motorMesh.add(motorMesh.userData.light);

                    scene.add(motorMesh);
                    motorObjects.push(motorMesh);
                }
            });
        }

        // --- Inventory Functionality ---
        function setupItemBar() {
            const itemSlotsContainer = document.getElementById('item-slots');
            for (let i = 0; i < INVENTORY_SIZE; i++) {
                const slot = document.createElement('div');
                slot.className = 'item-slot';
                slot.id = `item-slot-${i}`;
                slot.textContent = i + 1; // Number for keybind reference
                itemSlotsContainer.appendChild(slot);
            }
            updateItemBar();
        }

        function updateItemBar() {
            inventory.forEach((item, index) => {
                const slot = document.getElementById(`item-slot-${index}`);
                if (item) {
                    slot.textContent = item.icon; 
                    slot.style.borderColor = item.color; 
                } else {
                    slot.textContent = index + 1;
                    slot.style.borderColor = '#666'; // Default border color
                }
            });
        }
        
        function addItem(itemType, itemIcon, itemColor, maxCount) {
            const currentCount = inventory.filter(item => item && item.type === itemType).length;
            if (currentCount >= maxCount) {
                showFloatingText(`CANNOT HOLD MORE THAN ${maxCount} ${itemType.toUpperCase()} POTS`);
                return false;
            }

            const emptyIndex = inventory.findIndex(item => item === null);
            if (emptyIndex !== -1) {
                inventory[emptyIndex] = { type: itemType, icon: itemIcon, color: itemColor };
                updateItemBar();
                return true;
            }
            return false;
        }

        function useItem(slotIndex) {
            if (!controls.isLocked || isMiniGameActive) return;
            
            const item = inventory[slotIndex];
            if (!item) return;

            if (item.type === GHOST_POT.type) {
                
                const closestGhost = findClosestCapturableGhost();
                
                if (closestGhost) {
                    // Use the pot
                    inventory[slotIndex] = null;
                    updateItemBar();
                    
                    // Capture the ghost
                    const captureTime = clock.getElapsedTime() + GHOST_POT.captureDuration;
                    closestGhost.userData.capturedUntil = captureTime;
                    
                    // Visual changes for captured ghost
                    closestGhost.material.opacity = 0.1; 
                    closestGhost.userData.light.intensity = 0.5;
                    closestGhost.userData.chasing = false; 
                    
                    showFloatingText(`GHOST CAPTURED! (${GHOST_POT.captureDuration}s)`);
                } else {
                    showFloatingText(`No visible ghost within ${CAPTURE_RANGE} units!`);
                }
            }
        }

        function findClosestCapturableGhost() {
            let closestGhost = null;
            let minDist = CAPTURE_RANGE;

            ghosts.forEach(ghost => {
                const dist = camera.position.distanceTo(ghost.position);
                const isCaptured = ghost.userData.capturedUntil > clock.getElapsedTime();

                if (dist < minDist && !isCaptured) {
                    // Check line of sight
                    if (isGhostVisible(ghost)) { 
                        minDist = dist;
                        closestGhost = ghost;
                    }
                }
            });
            return closestGhost;
        }
        // --- END Inventory Functionality ---


        // --- Mini-Game Logic ---
        function startMiniGame(motorMesh) {
            if (isFreeCam || isMiniGameActive || controls.isLocked === false) return;
            
            const currentTime = clock.getElapsedTime();
            if (motorMesh.userData.cooldownEnd > currentTime) {
                const remaining = motorMesh.userData.cooldownEnd - currentTime;
                showFloatingText(`MOTOR ON COOLDOWN: ${Math.ceil(remaining)}s`);
                return;
            }

            controls.unlock();
            gameActive = false;
            isMiniGameActive = true;
            activeMotor = motorMesh;
            currentMiniGameStage = 1;

            document.addEventListener('keydown', handleMiniGameInput, false);

            minigameBox.style.display = 'block';
            minigameClose.style.display = 'block';
            
            setupMiniGameStage();
        }

        function setupMiniGameStage() {
            // Target width decreases by 3 pixels per stage, starts at 40px
            targetWidth = 40 - (currentMiniGameStage - 1) * 3; 
            targetWidth = Math.max(10, targetWidth); 
            
            // Randomly position the target (300px width - targetWidth)
            targetPosition = Math.random() * (300 - targetWidth);
            
            timingTarget.style.left = `${targetPosition}px`;
            timingTarget.style.width = `${targetWidth}px`;
            timingTarget.style.backgroundColor = 'rgba(0, 255, 0, 0.5)';
            timingCursor.style.backgroundColor = '#ff0000';

            cursorPosition = 0;
            cursorDirection = 1;
            timingCursor.style.left = '0px';
            cursorSpeed = 150 + (currentMiniGameStage - 1) * 10; // Speed increases slightly per stage

            minigameTitle.textContent = `MOTOR HACK: STAGE ${currentMiniGameStage}/${MAX_MINIGAME_STAGES}`;
            minigameStatus.textContent = "Press **Space** to attempt!";
        }

        function updateMiniGame(delta) {
            if (!isMiniGameActive) return;

            // FIX: Cursor movement logic
            cursorPosition += cursorDirection * cursorSpeed * delta;
            
            if (cursorPosition >= 300 - 5) { // 300px bar width - 5px cursor width
                cursorPosition = 300 - 5;
                cursorDirection = -1;
            } else if (cursorPosition <= 0) {
                cursorPosition = 0;
                cursorDirection = 1;
            }

            timingCursor.style.left = `${cursorPosition}px`;
        }

        function checkHit() {
            const cursorCenter = cursorPosition + 2.5; // Center of the 5px cursor
            
            if (cursorCenter >= targetPosition && cursorCenter <= targetPosition + targetWidth) {
                // SUCCESS
                minigameStatus.textContent = 'SUCCESS! Moving to next stage...';
                
                currentMiniGameStage++;
                if (currentMiniGameStage > MAX_MINIGAME_STAGES) {
                    endMiniGame(true); // Win the mini-game
                } else {
                    setTimeout(setupMiniGameStage, 500);
                }
                
            } else {
                // FAIL
                minigameStatus.textContent = 'FAILED! Try again...';
                timingCursor.style.backgroundColor = '#00ffff'; 
                setTimeout(setupMiniGameStage, 500); // Retry the current stage
            }
        }

        function handleMiniGameInput(event) {
            if (isMiniGameActive && event.code === 'Space') {
                event.preventDefault();
                checkHit();
            }
        }

        window.endMiniGame = function(isWin) {
            isMiniGameActive = false;
            document.removeEventListener('keydown', handleMiniGameInput, false);
            minigameBox.style.display = 'none';
            playerStatus.textContent = playerStatus.textContent.replace(" (Press F to Interact)", ""); 

            if (isWin) {
                const motorMesh = activeMotor;
                if (motorMesh) {
                    motorMesh.userData.fixed = true;
                    motorMesh.userData.cooldownEnd = clock.getElapsedTime() + MOTOR_COOLDOWN_TIME;
                    motorMesh.userData.light.intensity = 0.1;
                    motorMesh.material.color.set(0x00ff00); // Change motor color to green
                    motorsFixedCount++;
                    
                    showFloatingText(`MOTOR FIXED: ${motorsFixedCount}/${MOTORS_NEEDED_FOR_POT}`);

                    if (motorsFixedCount >= MOTORS_NEEDED_FOR_POT) {
                        const acquired = addItem(GHOST_POT.type, GHOST_POT.icon, GHOST_POT.color, GHOST_POT.maxInventory);
                        if (acquired) {
                            motorsFixedCount = 0; // Reset counter for the next item
                            showFloatingText('GHOST POT ACQUIRED! (Use 1-5)');
                        }
                    }
                }
            }
            
            activeMotor = null;
            controls.lock();
        }
        // --- END Mini-Game Logic ---

        function isGhostVisible(ghostMesh) {
            if (!ghostMesh) return false;

            const playerPosition = camera.position.clone();
            const ghostPosition = ghostMesh.position.clone();

            const dist = playerPosition.distanceTo(ghostPosition);
            if (dist > CELL_SIZE * 10) {
                 return false;
            }

            const direction = new THREE.Vector3().subVectors(ghostPosition, playerPosition).normalize();
            raycaster.set(playerPosition, direction);
            const objectsToIntersect = wallObjects.filter(obj => !obj.userData.isDoor); 
            const intersects = raycaster.intersectObjects(objectsToIntersect);

            if (intersects.length > 0) {
                const distanceToWall = intersects[0].distance;
                // Check if the ghost is closer than the first wall hit
                return dist < distanceToWall + 1; 
            }
            return true; 
        }

        // --- Event Handlers ---
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onKeyDown(event) {
            if (isConsoleOpen || isMiniGameActive) return;
            
            // Check for item use keys (1-5)
            const itemSlot = parseInt(event.key, 10);
            if (itemSlot >= 1 && itemSlot <= INVENTORY_SIZE) {
                useItem(itemSlot - 1);
                return; 
            }

            switch (event.code) {
                case 'ArrowUp': case 'KeyW': moveForward = true; break;
                case 'ArrowLeft': case 'KeyA': moveLeft = true; break;
                case 'ArrowDown': case 'KeyS': moveBackward = true; break;
                case 'ArrowRight': case 'KeyD': moveRight = true; break;
                
                // FIX: Q/E (Vertical Movement) are now ONLY active when in FreeCam
                case 'KeyQ': if(isFreeCam) moveUp = true; break; 
                case 'KeyE': if(isFreeCam) moveDown = true; break;
                
                case 'KeyF':
                    if (activeMotor) {
                        startMiniGame(activeMotor);
                    }
                    break;

                case 'Slash': // "/" key for console
                    if (controls.isLocked) {
                        controls.unlock();
                        isConsoleOpen = true;
                        consoleElement.style.display = 'block';
                        consoleInput.focus();
                        event.preventDefault(); 
                    }
                    break;
            }
        }

        function onKeyUp(event) {
            if (isConsoleOpen || isMiniGameActive) return;
            
            switch (event.code) {
                case 'ArrowUp': case 'KeyW': moveForward = false; break;
                case 'ArrowLeft': case 'KeyA': moveLeft = false; break;
                case 'ArrowDown': case 'KeyS': moveBackward = false; break;
                case 'ArrowRight': case 'KeyD': moveRight = false; break;
                // FIX: Q/E keyup is always needed to stop the movement variable
                case 'KeyQ': moveUp = false; break; 
                case 'KeyE': moveDown = false; break;
            }
        }
        
        // --- Main Game Logic ---
        // MODIFIED updatePlayerMovement function with sub-stepping collision fix
        function updatePlayerMovement(delta) {
            const currentSpeed = isFreeCam ? flySpeedMultiplier * 10 : effectiveSpeed;
            const velocity = new THREE.Vector3(0, 0, 0);
            const direction = new THREE.Vector3(0, 0, 0);

            if (moveForward) direction.z -= 1;
            if (moveBackward) direction.z += 1;
            if (moveLeft) direction.x -= 1;
            if (moveRight) direction.x += 1;

            if (direction.lengthSq() > 0) {
                direction.normalize();
                velocity.copy(direction).multiplyScalar(currentSpeed * delta);
            }
            
            // --- Vertical Movement for FreeCam ---
            if (isFreeCam) {
                if (moveUp) camera.position.y += currentSpeed * delta;
                if (moveDown) camera.position.y -= currentSpeed * delta;

                // Apply horizontal movement directly
                controls.getObject().translateX(velocity.x);
                controls.getObject().translateZ(velocity.z);
                return; // Exit early for FreeCam
            }

            // --- Grounded Movement (with Sub-stepping to fix wall phasing) ---
            if (velocity.lengthSq() > 0) {
                const totalDistance = velocity.length();
                const maxStep = 1.0; // Max safe distance per check (less than playerRadius 1.5)
                const steps = Math.ceil(totalDistance / maxStep);
                const stepVector = velocity.clone().divideScalar(steps);

                for (let i = 0; i < steps; i++) {
                    const preStepPosition = camera.position.clone();
                    
                    // Apply a small step
                    controls.getObject().translateX(stepVector.x);
                    controls.getObject().translateZ(stepVector.z);
                    
                    // Check collision and revert only the step if needed
                    checkCollision(preStepPosition);
                }
            }
            
            // IMPORTANT FIX: Reset Y position to prevent accidental floating/falling
            if (camera.position.y !== PLAYER_HEIGHT) {
                camera.position.y = PLAYER_HEIGHT;
            }
        }
        
        function updateSprintState(delta) {
            let ghostSighted = false;
            
            if (ghostsGoFrenzy) {
                effectiveSpeed = PLAYER_SPRINT_SPEED; // MODIFIED: Use new capped speed
                playerStatus.className = 'sprinting';
                playerStatus.textContent = 'Status: FRENZY SPRINT!';
                sprintDelayTimer = 0;
                return;
            }
            
            // Check if any *uncaptured* ghost is visible
            for (const ghost of ghosts) {
                 if (ghost.userData.capturedUntil <= clock.getElapsedTime() && isGhostVisible(ghost)) {
                     ghostSighted = true;
                     break;
                 }
            }

            if (ghostSighted) {
                sprintDelayTimer = SPRINT_DELAY_DURATION;
            }

            if (sprintDelayTimer > 0) {
                effectiveSpeed = PLAYER_SPRINT_SPEED; // MODIFIED: Use new capped speed
                playerStatus.className = 'sprinting';
                playerStatus.textContent = `Status: SPRINTING! (Delay: ${sprintDelayTimer.toFixed(1)}s)`;
                sprintDelayTimer -= delta;
            } else {
                effectiveSpeed = WALK_SPEED;
                playerStatus.className = '';
                playerStatus.textContent = 'Status: Walking...';
            }
        }

        function updateGhosts(delta) {
            ghostUpdateTimer += delta;
            
            const playerPos = camera.position;
            const playerGrid = playerGridPos;

            ghosts.forEach((ghost, index) => {
                const isCaptured = ghost.userData.capturedUntil > clock.getElapsedTime();
                
                if (isCaptured) {
                    const remaining = ghost.userData.capturedUntil - clock.getElapsedTime();
                    
                    // Ghost is captured - keep it still and update visuals
                    ghost.userData.light.intensity = 0.5 + Math.sin(clock.getElapsedTime() * 10) * 0.2;
                    ghost.position.y = PLAYER_HEIGHT + 0.5 + Math.sin(clock.getElapsedTime() * 4 + index) * 0.5;
                    
                    if (remaining <= 0) {
                        // Release the ghost
                        ghost.userData.capturedUntil = 0;
                        ghost.material.opacity = 0.5;
                        ghost.userData.light.intensity = 4;
                        showFloatingText('GHOST RELEASED!');
                    }
                    return; // Skip movement and proximity check
                }
                
                const ghostGrid = toGridPosition(ghost.position.x, ghost.position.z);
                let currentGhostSpeed = ghostsGoFrenzy ? GHOST_FRENZY_SPEED : GHOST_SPEED;
                
                let isChasing = false;
                
                // 1. Check Line of Sight for Chasing (priority 1)
                if (isGhostVisible(ghost)) {
                    isChasing = true;
                    ghost.userData.chasing = true;
                    
                    if (ghostUpdateTimer >= GHOST_UPDATE_INTERVAL) {
                        // Re-path quickly when sighted
                        const newPath = findPath(ghostGrid.r, ghostGrid.c, playerGrid.r, playerGrid.c);
                        if (newPath.length > 0) {
                            ghostPaths[index] = newPath;
                        }
                    }
                } else if (ghost.userData.chasing) {
                    // 2. Continue Chasing briefly (priority 2)
                    isChasing = true;
                    currentGhostSpeed = GHOST_WANDER_SPEED * 1.5; 
                    
                    if (ghostUpdateTimer >= GHOST_UPDATE_INTERVAL * 2 && ghostPaths[index].length === 0) {
                        // Ghost lost player, start wandering again
                        ghost.userData.chasing = false;
                    }
                } else {
                    // 3. Wandering (priority 3)
                    currentGhostSpeed = GHOST_WANDER_SPEED;
                    if (ghostPaths[index].length === 0) {
                        let targetR, targetC;
                        do {
                            targetR = Math.floor(Math.random() * MAX_ROW);
                            targetC = Math.floor(Math.random() * MAX_COL);
                        } while (mazeGrid[targetR] === undefined || mazeGrid[targetR][targetC] !== 0);
                        
                        ghostPaths[index] = findPath(ghostGrid.r, ghostGrid.c, targetR, targetC);
                    }
                }
                
                // --- Movement Execution ---
                if (ghostPaths[index].length > 0) {
                    const [nextR, nextC] = ghostPaths[index][0];
                    const targetPos = toWorldPosition(nextR, nextC);
                    
                    const direction = new THREE.Vector3().subVectors(targetPos, ghost.position).normalize();
                    const moveDistance = currentGhostSpeed * delta;
                    
                    if (ghost.position.distanceTo(targetPos) < moveDistance) {
                        ghost.position.copy(targetPos);
                        ghostPaths[index].shift(); 
                    } else {
                        ghost.position.add(direction.multiplyScalar(moveDistance));
                    }
                }

                // --- Visuals ---
                ghost.position.y = PLAYER_HEIGHT + 0.5 + Math.sin(clock.getElapsedTime() * 4 + index) * 0.5;
                
                // --- Collision/Game Over Check ---
                const distToPlayer = ghost.position.distanceTo(playerPos);
                if (distToPlayer < 3) {
                    showAlert('CAUGHT! A Ghost found you.', false);
                }
            });

            if (ghostUpdateTimer >= GHOST_UPDATE_INTERVAL) {
                ghostUpdateTimer = 0;
            }
        }
        
        function updateProximity() {
            let minDistance = Infinity;

            ghosts.forEach(ghost => {
                const isCaptured = ghost.userData.capturedUntil > clock.getElapsedTime();
                if (!isCaptured) {
                    const dist = camera.position.distanceTo(ghost.position);
                    minDistance = Math.min(minDistance, dist);
                }
            });

            let threatLevel = 'Distant';
            if (minDistance < CELL_SIZE * 3) {
                threatLevel = 'IMMINENT!';
            } else if (minDistance < CELL_SIZE * 6) {
                threatLevel = 'Nearby';
            } else if (minDistance < CELL_SIZE * 10) {
                threatLevel = 'Seen';
            }

            if (ghostsGoFrenzy) {
                threatLevel = 'FRENZY!';
            }

            ghostProximity.textContent = `Threat: ${threatLevel} | Crystals: ${crystalsCollected}/${TOTAL_CRYSTALS}`;
        }
        
        function checkMotorInteraction() {
            if (isFreeCam || isMiniGameActive) return;
            
            let closestMotor = null;
            let minDist = Infinity;
            
            motorObjects.forEach(motor => {
                const dist = camera.position.distanceTo(motor.position);
                if (dist < minDist) {
                    minDist = dist;
                    closestMotor = motor;
                }
            });
            
            let promptText = '';
            activeMotor = null;
            
            if (minDist < INTERACT_DISTANCE) {
                const currentTime = clock.getElapsedTime();
                const motorCooldownEnd = closestMotor.userData.cooldownEnd;

                if (motorCooldownEnd > currentTime) {
                    const remaining = Math.ceil(motorCooldownEnd - currentTime);
                    promptText = ` (COOLDOWN: ${remaining}s)`;
                } else if (closestMotor.userData.fixed) {
                     promptText = " (FIXED! Ready for next pot)";
                     activeMotor = closestMotor; // Still allow interaction to reset for another pot
                } else {
                    promptText = " (Press F to Interact)";
                    activeMotor = closestMotor;
                }
            }
            
            // Update status bar display
            const currentText = playerStatus.textContent.split(' (Press F to Interact)')[0].split(' (COOLDOWN:')[0].split(' (FIXED!')[0];
            playerStatus.textContent = currentText + promptText;
        }

        function checkCollision(oldPosition) {
            // Check collisions using raycasting for better precision than grid check alone
            
            const playerRadius = 1.5; 
            const collisionRays = [
                new THREE.Vector3(0, 0, 1),
                new THREE.Vector3(0, 0, -1),
                new THREE.Vector3(1, 0, 0),
                new THREE.Vector3(-1, 0, 0)
            ];

            // Filter out the door from collision detection if the exit is open
            const activeWallObjects = winPosition && winPosition.visible && winPosition.userData.closedDoor 
                ? wallObjects.filter(obj => obj.uuid !== winPosition.userData.closedDoor.uuid)
                : wallObjects;

            // Revert movement and check X, Z independently
            const newPosition = camera.position.clone();
            camera.position.copy(oldPosition); // Revert to old position

            // 1. Try X movement
            camera.position.x = newPosition.x;
            raycaster.set(camera.position, collisionRays[2]); // +X
            let intersects = raycaster.intersectObjects(activeWallObjects);
            if (intersects.length > 0 && intersects[0].distance < playerRadius) {
                camera.position.x = oldPosition.x; // Block X movement
            }
            raycaster.set(camera.position, collisionRays[3]); // -X
            intersects = raycaster.intersectObjects(activeWallObjects);
            if (intersects.length > 0 && intersects[0].distance < playerRadius) {
                camera.position.x = oldPosition.x; // Block X movement
            }

            // 2. Try Z movement
            camera.position.z = newPosition.z;
            raycaster.set(camera.position, collisionRays[0]); // +Z
            intersects = raycaster.intersectObjects(activeWallObjects);
            if (intersects.length > 0 && intersects[0].distance < playerRadius) {
                camera.position.z = oldPosition.z; // Block Z movement
            }
            raycaster.set(camera.position, collisionRays[1]); // -Z
            intersects = raycaster.intersectObjects(activeWallObjects);
            if (intersects.length > 0 && intersects[0].distance < playerRadius) {
                camera.position.z = oldPosition.z; // Block Z movement
            }
        }

        function checkWinCondition() {
            if (isFreeCam) return; 
            if (!winPosition || !winPosition.visible) return;
            
            const distanceToExit = camera.position.distanceTo(winPosition.position);
            
            if (distanceToExit < CELL_SIZE / 2) {
                showAlert("SUCCESS! You escaped the deep maze and the Ghost's sight!", true);
            }
        }
        
        function checkCrystals() {
            for (let i = crystals.length - 1; i >= 0; i--) {
                const crystal = crystals[i];
                if (camera.position.distanceTo(crystal.position) < 3) {
                    scene.remove(crystal);
                    crystals.splice(i, 1);
                    crystalsCollected++;
                    
                    if (crystalsCollected === TOTAL_CRYSTALS) {
                        ghostsGoFrenzy = true; 
                        
                        if (winPosition && winPosition.userData.closedDoor) {
                            scene.remove(winPosition.userData.closedDoor);
                            winPosition.visible = true;
                            winPosition.userData.light.intensity = 10;
                            showFloatingText('EXIT OPEN! GHOSTS GO FRENZY!');
                        }
                    }
                }
            }
        }

        function processCommand(command) {
            const parts = command.toLowerCase().trim().split(/\s+/);
            const cmd = parts[0];

            if (cmd === '/showminimap' || cmd === '/showmm') {
                isMinimapVisible = true;
                minimap.style.display = 'block';
                showFloatingText('Minimap ON');
            } else if (cmd === '/unshowminimap' || cmd === '/unshowmm') {
                isMinimapVisible = false;
                minimap.style.display = 'none';
                showFloatingText('Minimap OFF');
            } else if (cmd === '/freecam') {
                isFreeCam = true;
                showFloatingText('FreeCam ON');
            } else if (cmd === '/unfreecam') {
                isFreeCam = false;
                // Snap player position down to floor height
                camera.position.y = PLAYER_HEIGHT; 
                showFloatingText('FreeCam OFF');
            } else if (cmd === '/flyspeed' && parts.length === 2) {
                const speed = parseInt(parts[1], 10);
                if (!isNaN(speed) && speed >= 1 && speed <= 100) {
                    flySpeedMultiplier = speed;
                    showFloatingText(`Fly Speed Multiplier set to ${speed}`);
                } else {
                    showFloatingText('Invalid flyspeed. Must be between 1 and 100.');
                }
            } else if (cmd === '/set' && parts.length === 3 && parts[1] === 'crystal') {
                const amount = parseInt(parts[2], 10);
                if (!isNaN(amount) && amount >= 0 && amount <= TOTAL_CRYSTALS) {
                    crystalsCollected = amount;
                    showFloatingText(`Crystals set to ${amount}/${TOTAL_CRYSTALS}`);
                    if (amount === TOTAL_CRYSTALS) {
                        ghostsGoFrenzy = true; 
                        if (winPosition && winPosition.userData.closedDoor) {
                            scene.remove(winPosition.userData.closedDoor);
                            winPosition.visible = true;
                            winPosition.userData.light.intensity = 10;
                            showFloatingText('EXIT OPEN! (Cheat)');
                        }
                    } 
                } else {
                    showFloatingText(`Invalid crystal amount. Must be 0 to ${TOTAL_CRYSTALS}.`);
                }
            } else {
                showFloatingText('Unknown command: ' + cmd);
            }
        }

        function drawMinimap() {
            if (!isMinimapVisible) return;

            const ctx = minimap.getContext('2d');
            const mapSize = 150;
            const scale = mapSize / Math.max(MAX_ROW, MAX_COL);

            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.fillRect(0, 0, mapSize, mapSize);
            ctx.lineWidth = 1;

            const playerScreenX = playerGridPos.c * scale;
            const playerScreenY = playerGridPos.r * scale;

            // Draw ALL walls and path (Removed proximity check for full map)
            for (let r = 0; r < MAX_ROW; r++) {
                for (let c = 0; c < MAX_COL; c++) {
                    if (mazeGrid[r][c] === 1 || (winPosition && winPosition.userData.closedDoor && mazeGrid[r][c] === 2)) {
                        // Wall or Closed Exit
                        ctx.fillStyle = '#333333';
                        ctx.fillRect(c * scale, r * scale, scale, scale);
                    } else if (mazeGrid[r][c] === 2 && winPosition && winPosition.visible) {
                        // Open Exit
                         ctx.fillStyle = '#00ff00';
                        ctx.fillRect(c * scale, r * scale, scale, scale);
                    } else if (mazeGrid[r][c] === 0) {
                         // Path
                         ctx.fillStyle = 'rgba(15, 15, 15, 0.5)';
                         ctx.fillRect(c * scale, r * scale, scale, scale);
                    }
                }
            }

            // Draw Motors (Added for full map view)
            motorObjects.forEach(motor => {
                const motorGrid = toGridPosition(motor.position.x, motor.position.z);
                const motorScreenX = motorGrid.c * scale;
                const motorScreenY = motorGrid.r * scale;
                
                ctx.fillStyle = motor.userData.fixed ? '#00ff00' : '#ffaa00';
                ctx.beginPath();
                ctx.rect(motorScreenX + scale * 0.25, motorScreenY + scale * 0.25, scale * 0.5, scale * 0.5);
                ctx.fill();
            });

            // Draw Crystals (Added for full map view)
            crystals.forEach(crystal => {
                const crystalGrid = toGridPosition(crystal.position.x, crystal.position.z);
                const crystalScreenX = crystalGrid.c * scale;
                const crystalScreenY = crystalGrid.r * scale;
                
                ctx.fillStyle = '#00ffff';
                ctx.beginPath();
                ctx.arc(crystalScreenX + scale / 2, crystalScreenY + scale / 2, scale * 0.15, 0, Math.PI * 2);
                ctx.fill();
            });

            // Draw player
            ctx.fillStyle = '#00ffff';
            ctx.beginPath();
            ctx.arc(playerScreenX + scale / 2, playerScreenY + scale / 2, scale * 0.3, 0, Math.PI * 2);
            ctx.fill();

            // Draw Ghosts (Removed proximity check for full map)
            ghosts.forEach(ghost => {
                const isCaptured = ghost.userData.capturedUntil > clock.getElapsedTime();
                const ghostGrid = toGridPosition(ghost.position.x, ghost.position.z);
                const ghostScreenX = ghostGrid.c * scale;
                const ghostScreenY = ghostGrid.r * scale;

                ctx.fillStyle = isCaptured ? 'rgba(255, 0, 255, 0.3)' : 'rgba(255, 0, 255, 0.8)';
                ctx.beginPath();
                ctx.arc(ghostScreenX + scale / 2, ghostScreenY + scale / 2, scale * 0.4, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        function animate() {
            requestAnimationFrame(animate);

            const delta = clock.getDelta();

            // The main game loop runs if controls are locked OR if in freecam mode.
            if (controls.isLocked === true || isFreeCam) {
                
                if (isMiniGameActive) { 
                    updateMiniGame(delta); 
                    renderer.render(scene, camera);
                    return; 
                }

                updatePlayerGridPosition(); 
                updatePlayerMovement(delta);
                updateSprintState(delta); 
                updateGhosts(delta);
                updateProximity();
                checkCrystals();
                checkWinCondition();
                checkMotorInteraction(); 
                
                // Minimap is always visible since isMinimapVisible is true by default.
                if (isMinimapVisible) {
                    minimap.style.display = 'block';
                    drawMinimap();
                } else {
                    minimap.style.display = 'none';
                }
                
                // Animate lights & crystals 
                if (winPosition && winPosition.visible && winPosition.userData.light) {
                    winPosition.userData.light.intensity = 4 + Math.sin(clock.getElapsedTime() * 5) * 1;
                    winPosition.material.opacity = 0.6 + Math.sin(clock.getElapsedTime() * 5) * 0.2;
                }
                crystals.forEach(crystal => {
                    crystal.rotation.y += 2 * delta;
                    crystal.position.y = PLAYER_HEIGHT / 2 + 0.5 + Math.sin(clock.getElapsedTime() * 4) * 0.2;
                });
            }
            
            renderer.render(scene, camera); 
        }

        window.onload = function () {
            init();
            animate();
        };
    </script>
</body>
</html>

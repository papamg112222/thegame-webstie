<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Epic Stickman Fight</title>
<style>
  body {
    margin: 0; background: #111; display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100vh;
    color: #eee; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
  }
  canvas {
    background: #222; border-radius: 12px; box-shadow: 0 0 15px #0f0;
    display: block;
  }
  #startBtn {
    margin-top: 15px;
    padding: 10px 20px;
    font-size: 1.2rem;
    border: 2px solid #0f0;
    background: transparent;
    color: #0f0;
    border-radius: 8px;
    cursor: pointer;
    transition: all 0.3s ease;
  }
  #startBtn:hover {
    background: #0f0;
    color: #111;
  }
</style>
</head>
<body>

<canvas id="fightCanvas" width="900" height="450"></canvas>
<button id="startBtn">Start Fight</button>

<script>
(() => {
  const canvas = document.getElementById('fightCanvas');
  const ctx = canvas.getContext('2d');
  const W = canvas.width;
  const H = canvas.height;

  // --- Utility functions ---
  function lerp(a, b, t) { return a + (b - a) * t; }
  function clamp(v, min, max) { return Math.min(max, Math.max(min, v)); }
  function randRange(min, max) { return Math.random() * (max - min) + min; }
  function easeOutQuad(t) { return t * (2 - t); }
  
  // --- Camera Shake ---
  class Camera {
    constructor() {
      this.shakeDuration = 0;
      this.shakeIntensity = 0;
      this.zoom = 1;
      this.zoomTarget = 1;
      this.zoomSpeed = 0.1;
      this.offsetX = 0;
      this.offsetY = 0;
    }
    shake(intensity, duration) {
      this.shakeIntensity = intensity;
      this.shakeDuration = duration;
    }
    update(dt) {
      if(this.shakeDuration > 0){
        this.shakeDuration -= dt;
        this.offsetX = (Math.random() - 0.5) * this.shakeIntensity;
        this.offsetY = (Math.random() - 0.5) * this.shakeIntensity;
      } else {
        this.offsetX = 0;
        this.offsetY = 0;
      }
      this.zoom += (this.zoomTarget - this.zoom) * this.zoomSpeed;
    }
  }

  // --- Vector2 ---
  class Vec2 {
    constructor(x=0,y=0){this.x=x;this.y=y;}
    set(x,y){this.x=x;this.y=y;return this;}
    copy(){return new Vec2(this.x,this.y);}
    add(v){this.x+=v.x;this.y+=v.y;return this;}
    sub(v){this.x-=v.x;this.y-=v.y;return this;}
    mul(s){this.x*=s;this.y*=s;return this;}
    length(){return Math.sqrt(this.x*this.x+this.y*this.y);}
    normalize(){let len=this.length();if(len>0){this.x/=len;this.y/=len;}return this;}
  }

  // --- Stickman Limb ---
  class Limb {
    constructor(length, angle=0) {
      this.length = length;
      this.angle = angle;
      this.targetAngle = angle;
    }
    update(dt) {
      const diff = this.targetAngle - this.angle;
      this.angle += diff * dt * 8;
    }
  }
  
  // --- Particle system for impact effects ---
  const particles = [];
  class Particle {
      constructor(x, y, color) {
          this.pos = new Vec2(x, y);
          this.vel = new Vec2(randRange(-200, 200), randRange(-200, 0));
          this.color = color;
          this.size = randRange(2, 6);
          this.life = randRange(0.5, 1.5);
          this.maxLife = this.life;
      }
      update(dt) {
          this.pos.x += this.vel.x * dt;
          this.pos.y += this.vel.y * dt;
          this.vel.y += 500 * dt; // Gravity
          this.life -= dt;
      }
      draw(ctx) {
          const alpha = this.life / this.maxLife;
          ctx.fillStyle = `rgba(${this.color.r},${this.color.g},${this.color.b},${alpha})`;
          ctx.beginPath();
          ctx.arc(this.pos.x, this.pos.y, this.size * alpha, 0, Math.PI * 2);
          ctx.fill();
      }
  }

  // --- Weapon Trail Effect ---
  class Trail {
    constructor(color) {
      this.points = [];
      this.color = color;
      this.maxLength = 10;
    }
    addPoint(pos) {
      this.points.push({...pos});
      if(this.points.length > this.maxLength) this.points.shift();
    }
    draw(ctx) {
      if(this.points.length < 2) return;
      ctx.save();
      ctx.lineJoin = 'round';
      ctx.lineCap = 'round';
      for(let i=0; i<this.points.length-1; i++){
        let p0 = this.points[i];
        let p1 = this.points[i+1];
        let alpha = (i / this.points.length);
        ctx.strokeStyle = `rgba(${this.color.r},${this.color.g},${this.color.b},${alpha*0.6})`;
        ctx.lineWidth = lerp(10, 2, alpha);
        ctx.beginPath();
        ctx.moveTo(p0.x, p0.y);
        ctx.lineTo(p1.x, p1.y);
        ctx.stroke();
      }
      ctx.restore();
    }
  }

  // --- Stickman ---
  class Stickman {
    constructor(x, color, weaponType) {
      this.pos = new Vec2(x, H - 120);
      this.vel = new Vec2();
      this.color = color;
      this.weaponType = weaponType;
      this.health = 100;
      this.maxHealth = 100;
      this.facing = 1;
      this.animTimer = 0;
      this.state = 'idle';
      this.attackTimer = 0;
      this.comboStage = 0;
      this.comboCooldown = 0;
      this.dashDuration = 0;
      this.isDashing = false;

      this.limbs = {
        upperArmL: new Limb(35, Math.PI / 2),
        lowerArmL: new Limb(30, 0),
        upperArmR: new Limb(35, -Math.PI / 2),
        lowerArmR: new Limb(30, 0),
        upperLegL: new Limb(40, -0.1),
        lowerLegL: new Limb(40, 0.1),
        upperLegR: new Limb(40, -0.1),
        lowerLegR: new Limb(40, 0.1),
        headRadius: 12,
        bodyHeight: 60,
      };

      this.attackHitWindow = {start: 0.25, end: 0.45};
      this.hasHit = false;

      this.trailL = new Trail(color);
      this.trailR = new Trail(color);

      this.isHit = false;
      this.hitFlashTimer = 0;
    }

    update(dt) {
      this.animTimer += dt*6;
      this.comboCooldown = Math.max(0, this.comboCooldown - dt);
      
      if(this.isDashing) {
        this.dashDuration -= dt;
        this.pos.x += this.vel.x * dt * 400;
        this.pos.y += this.vel.y * dt;
        if(this.dashDuration <= 0) {
            this.state = 'idle';
            this.isDashing = false;
        }
      } else {
        if (this.pos.y < H - 120) {
          this.vel.y += 700 * dt;
        }
        this.pos.x += this.vel.x * dt * 200;
        this.pos.y += this.vel.y * dt;
      }
      
      if (this.pos.y >= H - 120) {
        this.pos.y = H - 120;
        this.vel.y = 0;
        if (this.state === 'jump') {
            this.state = 'idle';
        }
      }
      
      this.vel.x *= 0.85;

      if (this.state === 'idle' || this.state === 'run') {
        if (Math.abs(this.vel.x) > 0.1) {
            this.state = 'run';
        } else {
            this.state = 'idle';
        }
      }

      this.updateState(dt);
      this.updateLimbs(dt);

      if(this.hitFlashTimer > 0) this.hitFlashTimer -= dt;
      else this.isHit = false;
    }

    updateState(dt) {
      switch(this.state){
        case 'attack1':
        case 'attack2':
          this.attackTimer += dt*2.5;
          if(this.attackTimer > 1) {
            this.attackTimer = 0;
            this.comboStage++;
            this.state = 'idle';
          }
          break;
        case 'hit':
          this.attackTimer += dt;
          if(this.attackTimer > 0.5) {
            this.attackTimer = 0;
            this.state = 'idle';
            this.isHit = false;
          }
          break;
      }
    }

    startAttack() {
      if(this.state === 'idle' || this.state === 'run' || this.state === 'attack1' || this.state === 'attack2'){
        this.state = this.state === 'attack1' ? 'attack2' : 'attack1';
        this.attackTimer = 0;
        this.hasHit = false;
        this.comboCooldown = 0.5;
      }
    }
    
    startJump() {
        if(this.pos.y >= H - 120 && (this.state === 'idle' || this.state === 'run')){
            this.state = 'jump';
            this.vel.y = -400;
        }
    }
    
    startDash(dir) {
        if (!this.isDashing) {
            this.state = 'dash';
            this.isDashing = true;
            this.dashDuration = 0.3;
            this.vel.x = dir * 2.5;
        }
    }

    getHandPos(side) {
      const shoulderX = this.pos.x + this.facing * 15 * (side === 'L' ? -1 : 1);
      const shoulderY = this.pos.y - this.limbs.bodyHeight + 10;
      const upperArm = side === 'L' ? this.limbs.upperArmL : this.limbs.upperArmR;
      const lowerArm = side === 'L' ? this.limbs.lowerArmL : this.limbs.lowerArmR;

      const uaX = shoulderX + Math.sin(upperArm.angle) * upperArm.length * this.facing;
      const uaY = shoulderY + Math.cos(upperArm.angle) * upperArm.length;
      const handX = uaX + Math.sin(lowerArm.angle) * lowerArm.length * this.facing;
      const handY = uaY + Math.cos(lowerArm.angle) * lowerArm.length;
      return {x: handX, y: handY};
    }

    updateLimbs(dt) {
      let t = this.animTimer % (Math.PI * 2);
      
      // Leg angles
      if(this.state === 'run') {
        const legSwing = Math.sin(t) * 0.5;
        this.limbs.upperLegL.targetAngle = -0.1 + legSwing;
        this.limbs.lowerLegL.targetAngle = 0.1 + Math.abs(legSwing);
        this.limbs.upperLegR.targetAngle = -0.1 - legSwing;
        this.limbs.lowerLegR.targetAngle = 0.1 + Math.abs(legSwing);
      } else if (this.state === 'jump' || this.isDashing) {
        this.limbs.upperLegL.targetAngle = -0.5;
        this.limbs.lowerLegL.targetAngle = 0.5;
        this.limbs.upperLegR.targetAngle = -0.5;
        this.limbs.lowerLegR.targetAngle = 0.5;
      } else {
        this.limbs.upperLegL.targetAngle = -0.1;
        this.limbs.lowerLegL.targetAngle = 0.1;
        this.limbs.upperLegR.targetAngle = -0.1;
        this.limbs.lowerLegR.targetAngle = 0.1;
      }

      // Arm angles
      if(this.state.startsWith('attack')){
        let atkProgress = this.attackTimer % 1;
        let swing = easeOutQuad(atkProgress) * 3.0;
        
        if(this.state === 'attack1'){
          this.limbs.upperArmR.targetAngle = -Math.PI / 2 - swing;
          this.limbs.lowerArmR.targetAngle = -swing * 0.5;
          this.limbs.upperArmL.targetAngle = Math.PI / 2 + swing * 0.5;
          this.limbs.lowerArmL.targetAngle = swing * 0.25;
        } else {
          this.limbs.upperArmL.targetAngle = Math.PI / 2 + swing;
          this.limbs.lowerArmL.targetAngle = swing * 0.5;
          this.limbs.upperArmR.targetAngle = -Math.PI / 2 - swing * 0.5;
          this.limbs.lowerArmR.targetAngle = -swing * 0.25;
        }
      } else if (this.state === 'run') {
        const armSwing = Math.sin(t) * 0.5;
        this.limbs.upperArmL.targetAngle = Math.PI / 2 + armSwing;
        this.limbs.lowerArmL.targetAngle = Math.abs(armSwing);
        this.limbs.upperArmR.targetAngle = -Math.PI / 2 - armSwing;
        this.limbs.lowerArmR.targetAngle = Math.abs(armSwing);
      } else {
        this.limbs.upperArmL.targetAngle = Math.PI / 2 + Math.sin(t) * 0.1;
        this.limbs.lowerArmL.targetAngle = 0.5 + Math.sin(t) * 0.05;
        this.limbs.upperArmR.targetAngle = -Math.PI / 2 - Math.sin(t) * 0.1;
        this.limbs.lowerArmR.targetAngle = 0.5 - Math.sin(t) * 0.05;
      }

      for(let key in this.limbs){
        if(this.limbs[key].update) this.limbs[key].update(dt);
      }
    }

    draw(ctx) {
      ctx.save();
      ctx.translate(this.pos.x, this.pos.y);
      ctx.scale(this.facing, 1);

      // Draw health bar
      const barW = 140;
      const barH = 14;
      ctx.fillStyle = '#222';
      ctx.fillRect(-barW/2, -this.limbs.bodyHeight - 80, barW, barH);
      ctx.fillStyle = this.colorToHex(this.color);
      ctx.fillRect(-barW/2, -this.limbs.bodyHeight - 80, barW * (this.health/this.maxHealth), barH);
      ctx.strokeStyle = '#000';
      ctx.lineWidth = 2;
      ctx.strokeRect(-barW/2, -this.limbs.bodyHeight - 80, barW, barH);

      // Hit flash
      if(this.isHit){
        ctx.fillStyle = 'rgba(255,255,255,' + Math.min(0.6, this.hitFlashTimer * 3) + ')';
        ctx.fillRect(-100, -this.limbs.bodyHeight - 100, 200, 250);
      }
      
      ctx.strokeStyle = this.colorToHex(this.color);
      ctx.lineWidth = 6;
      ctx.lineCap = 'round';
      
      // Draw Legs
      this.drawLimbChain(ctx, this.limbs.upperLegL, this.limbs.lowerLegL, -15, 0);
      this.drawLimbChain(ctx, this.limbs.upperLegR, this.limbs.lowerLegR, 15, 0);
      
      // Draw Torso
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(0, -this.limbs.bodyHeight);
      ctx.stroke();
      
      // Draw Arms and Head
      ctx.save();
      ctx.translate(0, -this.limbs.bodyHeight);
      
      // Draw Head
      ctx.fillStyle = this.colorToHex(this.color);
      ctx.beginPath();
      ctx.arc(0, -this.limbs.headRadius, this.limbs.headRadius, 0, Math.PI * 2);
      ctx.fill();

      // Draw Arms with Weapons
      this.drawLimbChain(ctx, this.limbs.upperArmL, this.limbs.lowerArmL, -15, 10, this.weaponType, 'L');
      this.drawLimbChain(ctx, this.limbs.upperArmR, this.limbs.lowerArmR, 15, 10, this.weaponType, 'R');

      ctx.restore();
      ctx.restore();
    }

    drawLimbChain(ctx, upperLimb, lowerLimb, offsetX, offsetY, weaponType = null, side = null) {
      ctx.save();
      ctx.translate(offsetX, offsetY);
      
      ctx.rotate(upperLimb.angle);
      this.drawLimbSegment(ctx, upperLimb.length);
      
      ctx.translate(0, upperLimb.length);
      ctx.rotate(lowerLimb.angle);
      this.drawLimbSegment(ctx, lowerLimb.length);
      
      if(weaponType){
        ctx.translate(0, lowerLimb.length);
        this.drawWeapon(ctx, weaponType, side);
      }

      ctx.restore();
    }
    
    drawLimbSegment(ctx, length) {
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(0, length);
      ctx.stroke();
    }

    drawWeapon(ctx, weaponType, side) {
      ctx.save();
      if(weaponType === 'claw'){
        ctx.strokeStyle = 'rgba(0,255,0,0.8)';
        ctx.shadowColor = 'lime';
        ctx.shadowBlur = 15;
        ctx.lineWidth = 5;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';

        const clawOffsets = [-15, 0, 15];
        for(let offset of clawOffsets){
          ctx.beginPath();
          ctx.moveTo(0, 0);
          ctx.quadraticCurveTo(offset/2, -20, offset, -40);
          ctx.stroke();
        }
      } else if(weaponType === 'dagger'){
        ctx.fillStyle = 'cyan';
        ctx.strokeStyle = '#00ffff';
        ctx.lineWidth = 3;
        ctx.shadowColor = '#00ffff';
        ctx.shadowBlur = 15;
        ctx.lineJoin = 'bevel';

        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(8, -40);
        ctx.lineTo(-8, -40);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
        
        ctx.shadowBlur = 0;
        ctx.strokeStyle = '#eee';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.rect(-4, 0, 8, 10);
        ctx.stroke();
      }
      ctx.restore();
    }

    takeHit(damage) {
      this.health = clamp(this.health - damage, 0, this.maxHealth);
      this.state = 'hit';
      this.isHit = true;
      this.hitFlashTimer = 0.5;
    }

    colorToHex(color) {
      return `rgb(${color.r},${color.g},${color.b})`;
    }
  }

  // --- Impact Effects ---
  class ImpactFlash {
    constructor() {
      this.active = false;
      this.timer = 0;
      this.duration = 0.15;
      this.alpha = 0;
    }
    trigger() {
      this.active = true;
      this.timer = this.duration;
    }
    update(dt) {
      if(this.active) {
        this.timer -= dt;
        if(this.timer <= 0) {
          this.active = false;
          this.alpha = 0;
        } else {
          this.alpha = this.timer / this.duration;
        }
      }
    }
    draw(ctx) {
      if(this.active) {
        ctx.save();
        ctx.fillStyle = `rgba(255,255,255,${this.alpha * 0.7})`;
        ctx.fillRect(0, 0, W, H);
        ctx.restore();
      }
    }
  }

  // --- AI Controller ---
  class AIController {
    constructor(stickman, opponent, personality = 'aggressive') {
      this.stickman = stickman;
      this.opponent = opponent;
      this.actionTimer = 0;
      this.state = 'idle';
      this.cooldowns = {
        attack: 0,
        dash: 0,
        jump: 0,
      };
      this.personality = personality;
    }

    update(dt) {
      for (const key in this.cooldowns) {
          this.cooldowns[key] = Math.max(0, this.cooldowns[key] - dt);
      }
      
      const dist = this.opponent.pos.x - this.stickman.pos.x;
      const absDist = Math.abs(dist);
      
      this.stickman.facing = dist > 0 ? 1 : -1;

      if (this.shouldDodge(dist)) {
          this.doDodge(dist);
      } 
      else if (this.stickman.state === 'idle' || this.stickman.state === 'run' || this.stickman.state === 'jump') {
          if (absDist < 100) {
              if (this.shouldAttack()) {
                  this.doAttack();
              } else if (this.shouldRetreat(dist)) {
                  this.doRetreat(dist);
              } else {
                  this.doApproach(dist);
              }
          } else if (absDist < 300) {
              if (Math.random() < 0.2 && this.cooldowns.jump <= 0) {
                  this.doJump(dist);
              } else {
                  this.doApproach(dist);
              }
          } else {
              this.doApproach(dist);
          }
      }
    }
    
    shouldDodge(dist) {
      if (this.cooldowns.dash > 0) return false;
      const opponentIsAttacking = this.opponent.state.startsWith('attack');
      const isOpponentClose = Math.abs(dist) < 80;
      
      if (opponentIsAttacking && isOpponentClose) {
        return Math.random() > 0.4;
      }
      return false;
    }
    
    doDodge(dist) {
      this.stickman.startDash(-this.stickman.facing);
      this.cooldowns.dash = 1.2;
    }
    
    shouldAttack() {
        if (this.cooldowns.attack > 0) return false;
        const attackChance = this.personality === 'aggressive' ? 0.8 : 0.4;
        return Math.random() < attackChance;
    }

    doAttack() {
        this.stickman.startAttack();
        this.cooldowns.attack = randRange(0.5, 1);
    }
    
    shouldRetreat(dist) {
      if (this.personality === 'defensive' && this.stickman.health < 50) {
        return Math.random() > 0.5;
      }
      return false;
    }

    doApproach(dist) {
        this.stickman.vel.x = this.stickman.facing * 1;
    }
    
    doJump(dist) {
        this.stickman.startJump();
        this.cooldowns.jump = randRange(1.5, 3);
    }
  }

  // --- Main fight class ---
  class Fight {
    constructor() {
      this.stickmanGreen = new Stickman(250, {r:0,g:255,b:0}, 'claw');
      this.stickmanBlue = new Stickman(650, {r:0,g:180,b:255}, 'dagger');
      this.stickmanGreen.facing = 1;
      this.stickmanBlue.facing = -1;

      this.aiGreen = new AIController(this.stickmanGreen, this.stickmanBlue, 'aggressive');
      this.aiBlue = new AIController(this.stickmanBlue, this.stickmanGreen, 'defensive');

      this.impactFlash = new ImpactFlash();
      this.camera = new Camera();
      this.slowMotionTimer = 0;

      this.lastTime = 0;
      this.running = false;
      this.gameOver = false;
    }

    start() {
      this.running = true;
      this.lastTime = performance.now();
      requestAnimationFrame(this.loop.bind(this));
    }

    loop(t) {
      if(!this.running) return;
      let dt = (t - this.lastTime) / 1000;
      dt = Math.min(dt, 0.016);

      if(this.slowMotionTimer > 0) {
        dt *= 0.3;
        this.slowMotionTimer -= (t - this.lastTime)/1000;
      }

      this.lastTime = t;
      this.update(dt);
      this.render();

      if(!this.gameOver) {
          requestAnimationFrame(this.loop.bind(this));
      } else {
          this.displayWinner();
      }
    }

    update(dt) {
      if(this.stickmanGreen.health <= 0 || this.stickmanBlue.health <= 0) {
          this.gameOver = true;
      }
      
      this.aiGreen.update(dt);
      this.aiBlue.update(dt);

      this.stickmanGreen.update(dt);
      this.stickmanBlue.update(dt);
      
      particles.forEach(p => p.update(dt));
      
      this.checkCollisions();

      this.impactFlash.update(dt);
      this.camera.update(dt);

      this.stickmanGreen.pos.x = clamp(this.stickmanGreen.pos.x, 60, W - 60);
      this.stickmanBlue.pos.x = clamp(this.stickmanBlue.pos.x, 60, W - 60);
    }
    
    addParticles(x, y, color) {
        for(let i = 0; i < 15; i++) {
            particles.push(new Particle(x, y, color));
        }
    }

    checkCollisions() {
      [this.stickmanGreen, this.stickmanBlue].forEach((attacker, i) => {
        if(attacker.state.startsWith('attack')) {
          const defender = i === 0 ? this.stickmanBlue : this.stickmanGreen;
          const atkProgress = attacker.attackTimer;
          
          if(atkProgress > attacker.attackHitWindow.start && atkProgress < attacker.attackHitWindow.end && !attacker.hasHit){
            attacker.hasHit = true;
            
            const handL = attacker.getHandPos('L');
            const handR = attacker.getHandPos('R');
            
            const distL = Math.sqrt(Math.pow(defender.pos.x - handL.x, 2) + Math.pow(defender.pos.y - handL.y, 2));
            const distR = Math.sqrt(Math.pow(defender.pos.x - handR.x, 2) + Math.pow(defender.pos.y - handR.y, 2));

            const hitRange = 60;
            
            if((distL < hitRange || distR < hitRange) && !defender.isDashing) {
              defender.takeHit(15);
              this.triggerHitEffects(defender);
              
              defender.vel.x += attacker.facing * 200;
              this.addParticles(defender.pos.x, defender.pos.y - defender.limbs.bodyHeight/2, attacker.color);
              
              attacker.comboCooldown = 0.1;
            }
          }
          if(atkProgress > attacker.attackHitWindow.end) attacker.hasHit = false;
        }
      });
    }

    triggerHitEffects(defender) {
      this.impactFlash.trigger();
      this.camera.shake(10, 0.2);
      this.camera.zoomTarget = 1.15;
      this.slowMotionTimer = 0.25;
    }

    displayWinner() {
        ctx.save();
        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
        ctx.fillRect(0, 0, W, H);
        ctx.font = "bold 60px 'Segoe UI'";
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        
        if(this.stickmanGreen.health > this.stickmanBlue.health) {
            ctx.fillStyle = 'lime';
            ctx.fillText("Green Wins!", W/2, H/2);
        } else {
            ctx.fillStyle = 'cyan';
            ctx.fillText("Blue Wins!", W/2, H/2);
        }
        ctx.restore();
    }

    render() {
      ctx.clearRect(0,0,W,H);

      ctx.save();
      ctx.translate(this.camera.offsetX, this.camera.offsetY);
      ctx.scale(this.camera.zoom, this.camera.zoom);

      ctx.strokeStyle = '#0a0';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(0, H-60);
      ctx.lineTo(W, H-60);
      ctx.stroke();
      
      particles.forEach(p => p.draw(ctx));

      this.stickmanGreen.draw(ctx);
      this.stickmanBlue.draw(ctx);

      this.impactFlash.draw(ctx);

      ctx.restore();

      this.camera.zoomTarget = 1;
      
      particles.filter(p => p.life > 0);
    }
  }

  // --- Initialization ---
  const fight = new Fight();

  document.getElementById('startBtn').addEventListener('click', () => {
    fight.start();
    document.getElementById('startBtn').style.display = 'none';
  });

})();
</script>

</body>
</html>

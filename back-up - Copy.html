<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Maze Explorer: The Sprint</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/PointerLockControls.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght400;700&display=swap" rel="stylesheet">
    <style>
        body {
            background-color: #050508;
            font-family: 'Orbitron', sans-serif;
            color: #E0E0E0;
            user-select: none;
            overflow: hidden;
            /* Ensure the body and html take up full viewport */
            margin: 0;
            padding: 0;
            height: 100vh;
            width: 100vw;
        }
        #info {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #ff4444; 
            padding: 2rem;
            border-radius: 0.75rem;
            text-align: center;
            z-index: 1000;
            box-shadow: 0 0 25px rgba(255, 68, 68, 0.7);
            cursor: pointer;
        }
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 10px;
            height: 10px;
            margin: -5px 0 0 -5px;
            border: 1px solid rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            z-index: 999;
            pointer-events: none;
            opacity: 0; 
        }
        #message-box {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #111;
            border: 2px solid #ff0044;
            padding: 2rem;
            border-radius: 0.5rem;
            text-align: center;
            z-index: 2000;
            box-shadow: 0 0 30px #ff0044;
            display: none;
        }
        .win-style {
            border-color: #00ff00 !important;
            box-shadow: 0 0 30px #00ff00 !important;
        }
        .action-button {
            padding: 0.75rem 2rem;
            background: #ff4444;
            color: #fff;
            font-weight: bold;
            border: none;
            border-radius: 0.375rem;
            cursor: pointer;
            transition: background 0.2s, transform 0.1s;
        }
        .action-button:hover {
            background: #cc3333;
            transform: scale(1.05);
        }
        #status-bar {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            padding: 10px 20px;
            background: rgba(0, 0, 0, 0.7);
            color: #00ffff;
            font-size: 14px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 10;
        }
        .sprinting {
            color: #ff0000;
            font-weight: bold;
            text-shadow: 0 0 8px #ff0000;
        }
        #minimap {
            position: absolute;
            top: 20px;
            right: 20px;
            border: 2px solid #00ffff; 
            background: rgba(0, 0, 0, 0.8);
            display: none; 
            z-index: 100;
        }
        
        /* --- Console Styles --- */
        #console {
            position: absolute;
            bottom: 50px;
            left: 50%;
            transform: translateX(-50%);
            width: 600px;
            z-index: 5000;
            display: none;
        }
        #console input {
            width: 100%;
            padding: 8px 12px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #00ffff;
            color: #00ff00;
            font-family: 'Orbitron', sans-serif;
            font-size: 16px;
            outline: none;
        }

        /* --- Inventory Styles --- */
        #inventory-container {
            position: absolute;
            bottom: 50px; 
            right: 20px;
            display: flex;
            gap: 5px;
            z-index: 50;
        }

        .inventory-slot {
            width: 50px;
            height: 50px;
            background-color: rgba(0, 0, 0, 0.7);
            border: 2px solid #444;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #666;
            font-size: 14px;
            font-weight: bold;
            transition: border-color 0.2s;
        }

        .inventory-slot.filled {
            border-color: #00ffff;
            background-color: rgba(0, 0, 0, 0.9);
            color: #00ffff;
        }
        
        /* --- Battery Status --- */
        #battery-status {
            color: #ffcc00;
            font-weight: bold;
            text-shadow: 0 0 5px rgba(255, 204, 0, 0.5);
        }
        .battery-low {
            color: #ff4444 !important;
            text-shadow: 0 0 5px rgba(255, 68, 68, 0.7) !important;
        }
    </style>
</head>
<body>
    <div id="info">
        <h1 class="text-3xl font-bold mb-4 text-[#ff4444]">THE DEEP LABYRINTH</h1>
        <p class="text-sm mb-4">Find the Flashlight first! Then collect the 150 crystals before the 6 Ghosts find you!</p>
        <p class="text-xl font-bold mb-2">Controls</p>
        <p class="mb-4 text-left mx-auto max-w-xs">
            **Walk**: **W** / **A** / **S** / **D**<br>
            **Sprint**: Automatic when a Ghost is sighted.<br>
            **Look**: **Mouse** Movement<br>
            **Cheat Console**: Press **/**
        </p>
        <button class="action-button">ENTER</button>
    </div>

    <div id="status-bar">
        <span id="player-status">Status: Walking...</span>
        <div>
            <span id="battery-status">Battery: N/A</span> | 
            <span id="ghost-proximity">Threat: Distant | Crystals: 0/150</span>
        </div>
    </div>

    <div id="crosshair"></div>
    
    <div id="inventory-container"></div>

    <div id="console">
        <input type="text" id="console-input" placeholder="Type command (e.g., /showmm, /unshowmm, /freecam) and press Enter" />
    </div>

    <div id="message-box">
        <p id="message-text" class="text-xl font-bold mb-4"></p>
        <button class="action-button" onclick="closeAlert()">RESTART</button>
    </div>

    <script type="module">
        // --- 3D Setup Variables ---
        let camera, scene, renderer, controls, raycaster;
        let clock = new THREE.Clock();
        const infoElement = document.getElementById('info');
        const crosshair = document.getElementById('crosshair');
        const playerStatus = document.getElementById('player-status');
        const ghostProximity = document.getElementById('ghost-proximity');
        const batteryStatus = document.getElementById('battery-status');
        const minimap = document.createElement('canvas'); 
        minimap.id = 'minimap';
        document.body.appendChild(minimap);

        // --- Constants for Lighting ---
        const MAX_FLASHLIGHT_INTENSITY = 1.5; // NEW: Reduced max intensity for 'a bit brighter' effect

        // --- Console/Cheat Variables ---
        let isConsoleOpen = false; 
        const consoleElement = document.getElementById('console');
        const consoleInput = document.getElementById('console-input');
        
        // --- Freecam Variables ---
        let isFreeCam = false; 
        let moveUp = false;    
        let moveDown = false;  
        const MAX_FREECAM_SPEED = 500; 
        let flySpeedMultiplier = 10; 
        let isMinimapVisible = false; 

        const CELL_SIZE = 20;
        const WALL_HEIGHT = 10;
        const PLAYER_HEIGHT = 6;
        let offsetX, offsetZ;
        
        // Speed Definitions
        const WALK_SPEED = 32;
        const GHOST_WANDER_SPEED = 15; 
        const GHOST_SPEED = 150; 
        const GHOST_FRENZY_SPEED = 300; 
        const SPRINT_SPEED = GHOST_SPEED; 
        let effectiveSpeed = WALK_SPEED;
        
        // Sprint Delay Variables
        const SPRINT_DELAY_DURATION = 3.0; 
        let sprintDelayTimer = 0;

        let moveForward = false;
        let moveBackward = false;
        let moveLeft = false;
        let moveRight = false;
        let gameActive = false;
        let winPosition = null;
        let wallObjects = [];

        // --- INVENTORY/ITEM VARIABLES ---
        let flashlightObject = null; 
        let firstPersonFlashlightModel = null; 
        let hasFlashlight = false;
        let isFlashlightOn = true; 
        let batteryLevel = 100; 
        const BATTERY_DRAIN_RATE = 1.0; 
        const BATTERY_COLLECTION_AMOUNT = 50; 
        let batteries = []; 

        let inventory = [];
        const MAX_INVENTORY_SLOTS = 5;
        // --- END INVENTORY/ITEM VARIABLES ---

        // --- GAME OBJECT ARRAYS ---
        let ghosts = []; 
        let ghostPaths = []; 
        let crystals = []; 
        let crystalsCollected = 0;
        const TOTAL_CRYSTALS = 150; 
        let ghostsGoFrenzy = false; 
        let playerGridPos = { r: 0, c: 0 }; 
        let ghostUpdateTimer = 0;
        const GHOST_UPDATE_INTERVAL = 0.5; 

        // Maze Grid Definitions
        const MAX_COL = 51;
        const MAX_ROW = 51;
        const START_COL = 1;
        const START_ROW = MAX_ROW - 2;
        const EXIT_COL = MAX_COL - 2;
        const EXIT_ROW = 1;

        // Ghost starting positions 
        const GHOST_START_POSITIONS = [
            { r: MAX_ROW - 2, c: MAX_COL - 2 },
            { r: 1, c: 1 },
            { r: Math.floor(MAX_ROW / 2), c: Math.floor(MAX_COL / 2) + 5 },
            { r: Math.floor(MAX_ROW / 2) + 5, c: Math.floor(MAX_COL / 2) },
            { r: 5, c: 5 },
            { r: 10, c: MAX_COL - 10 }
        ];

        const mazeGrid = generateTrueMaze(MAX_ROW, MAX_COL);

        // Filter Ghost start positions after maze generation
        GHOST_START_POSITIONS.forEach(pos => {
            if (mazeGrid[pos.r][pos.c] === 1) {
                for (let dr = -1; dr <= 1; dr++) {
                    for (let dc = -1; dc <= 1; dc++) {
                        const nr = pos.r + dr;
                        const nc = pos.c + dc;
                        if (nr > 0 && nr < MAX_ROW - 1 && nc > 0 && nc < MAX_COL - 1 && mazeGrid[nr][nc] !== 1) {
                            pos.r = nr;
                            pos.c = nc;
                            return;
                        }
                    }
                }
            }
        });
        
        // --- Maze Generation (Unchanged) ---
        function generateTrueMaze(rows, cols) {
            const grid = Array(rows).fill(0).map(() => Array(cols).fill(1));
            const stack = [];

            stack.push([START_ROW, START_COL]);
            grid[START_ROW][START_COL] = 0; 

            while (stack.length > 0) {
                const [r, c] = stack[stack.length - 1];
                
                const neighbors = [
                    [r - 2, c, r - 1, c], [r + 2, c, r + 1, c],
                    [r, c - 2, r, c - 1], [r, c + 2, r, c + 1]
                ].filter(([nr, nc]) => 
                    nr > 0 && nr < rows - 1 && nc > 0 && nc < cols - 1 && grid[nr][nc] === 1 
                );

                if (neighbors.length > 0) {
                    const [nr, nc, wr, wc] = neighbors[Math.floor(Math.random() * neighbors.length)];
                    grid[nr][nc] = 0;
                    grid[wr][wc] = 0;
                    stack.push([nr, nc]);
                } else {
                    stack.pop(); 
                }
            }

            grid[EXIT_ROW][EXIT_COL] = 2; 

            const LOOP_PERCENTAGE = 0.20; 
            for (let r = 1; r < rows - 1; r++) {
                for (let c = 1; c < cols - 1; c++) {
                    if (grid[r][c] === 1 && Math.random() < LOOP_PERCENTAGE) {
                        grid[r][c] = 0; 
                    }
                }
            }
            return grid;
        }

        // --- Utility Functions (Unchanged) ---
        function toGridPosition(worldX, worldZ) {
            const r = Math.floor((worldZ - offsetZ) / CELL_SIZE);
            const c = Math.floor((worldX - offsetX) / CELL_SIZE);
            return { r, c };
        }

        function toWorldPosition(r, c) {
            const x = (c + 0.5) * CELL_SIZE + offsetX;
            const z = (r + 0.5) * CELL_SIZE + offsetZ;
            return new THREE.Vector3(x, PLAYER_HEIGHT, z);
        }

        function updatePlayerGridPosition() {
            playerGridPos = toGridPosition(camera.position.x, camera.position.z);
        }
        
        function showAlert(message, isWin) {
            gameActive = false;
            controls.unlock();
            const messageBox = document.getElementById('message-box');
            const messageText = document.getElementById('message-text');
            messageText.textContent = message;

            if (isWin) {
                messageBox.classList.add('win-style');
                messageBox.querySelector('.action-button').style.background = '#00ff00';
            } else {
                messageBox.classList.remove('win-style');
                messageBox.querySelector('.action-button').style.background = '#ff4444';
            }

            messageBox.style.display = 'block';
            crosshair.style.opacity = 0;
        }

        window.closeAlert = function() {
            document.getElementById('message-box').style.display = 'none';
            window.location.reload();
        }

        // --- Pathfinding (Unchanged) ---
        function findPath(startR, startC, endR, endC) {
            if (startR === endR && startC === endC) return [];
            
            const rows = mazeGrid.length;
            const cols = mazeGrid[0].length;
            const queue = [`${startR},${startC}`];
            const visited = new Set();
            const parent = {}; 
            
            visited.add(`${startR},${startC}`);
            let goalKey = null;

            while (queue.length > 0) {
                const currentKey = queue.shift();
                const [r, c] = currentKey.split(',').map(Number);

                if (r === endR && c === endC) {
                    goalKey = currentKey;
                    break;
                }

                const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];

                for (const [dr, dc] of directions) {
                    const nr = r + dr;
                    const nc = c + dc;
                    
                    if (nr >= 0 && nr < rows && nc >= 0 && nc < cols) {
                        const neighborKey = `${nr},${nc}`;
                        
                        if (mazeGrid[nr][nc] !== 1 && !visited.has(neighborKey)) {
                            visited.add(neighborKey);
                            parent[neighborKey] = currentKey;
                            queue.push(neighborKey);
                        }
                    }
                }
            }

            if (!goalKey) return [];

            const fullPath = [];
            let tempKey = goalKey;
            
            while (parent[tempKey]) {
                fullPath.unshift(tempKey.split(',').map(Number));
                tempKey = parent[tempKey];
            }
            
            return fullPath; 
        }

        // --- Initialization ---

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x050508);
            scene.fog = new THREE.Fog(0x050508, CELL_SIZE * 5, CELL_SIZE * 30); 

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            raycaster = new THREE.Raycaster();
            
            offsetX = -(mazeGrid[0].length * CELL_SIZE) / 2;
            offsetZ = -(mazeGrid.length * CELL_SIZE) / 2;

            const startX = (START_COL + 0.5) * CELL_SIZE + offsetX;
            const startZ = (START_ROW + 0.5) * CELL_SIZE + offsetZ;
            camera.position.set(startX, PLAYER_HEIGHT, startZ);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.shadowMap.enabled = true; 
            renderer.shadowMap.type = THREE.PCFSoftShadowMap; 
            
            renderer.setSize(window.innerWidth, window.innerHeight); 
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);

            // --- RESTORED ORIGINAL DIM LIGHTING ---
            const ambientLight = new THREE.AmbientLight(0x404040, 0.5); // Slightly dim ambient
            scene.add(ambientLight);

            // Add a very dim PointLight to the camera for the initial darkness
            const baseLight = new THREE.PointLight(0xffffff, 0.2, 30); // Intensity 0.2 (very dim)
            camera.add(baseLight);
            camera.userData.baseLight = baseLight; 
            // ----------------------------------------

            scene.add(camera);

            controls = new THREE.PointerLockControls(camera, document.body);

            controls.addEventListener('lock', () => {
                infoElement.style.display = 'none';
                crosshair.style.opacity = 1;
                gameActive = true;
            });
            controls.addEventListener('unlock', () => {
                if (!document.getElementById('message-box').style.display || document.getElementById('message-box').style.display === 'none') {
                    if (!isConsoleOpen && !isFreeCam) { 
                         infoElement.style.display = 'block';
                    }
                }
                gameActive = false;
                crosshair.style.opacity = 0;
            });

            document.getElementById('info').addEventListener('click', () => {
                controls.lock();
            });

            buildMaze(offsetX, offsetZ);
            addFlashlight(); 
            addBatteries(); 
            addGhosts();
            addCrystals();
            updateInventoryUI(); 
            
            minimap.width = 150;
            minimap.height = 150;

            document.addEventListener('keydown', onKeyDown, false);
            document.addEventListener('keyup', onKeyUp, false);
            window.addEventListener('resize', onWindowResize, false);

            consoleInput.addEventListener('keydown', (event) => {
                if (event.code === 'Enter') {
                    processCommand(consoleInput.value);
                    consoleInput.value = '';
                    consoleElement.style.display = 'none';
                    isConsoleOpen = false;
                    
                    controls.lock(); 
                }
            });
        }

        function buildMaze(offsetX, offsetZ) {
            const wallMaterial = new THREE.MeshPhongMaterial({ color: 0x333333, shininess: 10 });
            const floorMaterial = new THREE.MeshPhongMaterial({ color: 0x1f1f2a });
            const wallGeometry = new THREE.BoxGeometry(CELL_SIZE, WALL_HEIGHT, CELL_SIZE);
            
            // Floor
            const floorGeometry = new THREE.PlaneGeometry(MAX_COL * CELL_SIZE, MAX_ROW * CELL_SIZE);
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true; 
            scene.add(floor);

            for (let i = 0; i < mazeGrid.length; i++) {
                for (let j = 0; j < mazeGrid[i].length; j++) {
                    const cellType = mazeGrid[i][j];
                    const x = j * CELL_SIZE + offsetX + CELL_SIZE / 2;
                    const z = i * CELL_SIZE + offsetZ + CELL_SIZE / 2;

                    if (cellType === 1) { // Wall
                        const wall = new THREE.Mesh(wallGeometry, wallMaterial);
                        wall.position.set(x, WALL_HEIGHT / 2, z);
                        wall.userData.isWall = true;
                        wall.castShadow = true;   
                        wall.receiveShadow = true; 
                        scene.add(wall);
                        wallObjects.push(wall);
                    } else if (cellType === 2) { // Exit 
                        const exitMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.8 });
                        const exitGeometry = new THREE.PlaneGeometry(CELL_SIZE * 0.9, WALL_HEIGHT * 0.9);
                        const exitPortal = new THREE.Mesh(exitGeometry, exitMaterial);

                        let doorRotation = 0; 
                        if (EXIT_COL === 1 || EXIT_COL === MAX_COL - 2) {
                            doorRotation = Math.PI / 2;
                        }

                        exitPortal.rotation.y = doorRotation;
                        exitPortal.position.set(x, WALL_HEIGHT / 2, z);
                        exitPortal.userData.isExit = true;
                        
                        exitPortal.visible = false;
                        
                        const exitLight = new THREE.PointLight(0x00ff00, 0, 25);
                        exitLight.position.set(x, 5, z);
                        scene.add(exitLight);
                        exitPortal.userData.light = exitLight;

                        scene.add(exitPortal);
                        winPosition = exitPortal;

                        const doorMaterial = new THREE.MeshPhongMaterial({ color: 0x5c3317, shininess: 10 }); 
                        const doorGeometry = new THREE.BoxGeometry(CELL_SIZE * 0.9, WALL_HEIGHT, 1);
                        const closedDoor = new THREE.Mesh(doorGeometry, doorMaterial);
                        closedDoor.position.set(x, WALL_HEIGHT / 2, z);
                        closedDoor.rotation.y = doorRotation;
                        closedDoor.userData.isDoor = true;
                        closedDoor.userData.isWall = true; 
                        closedDoor.castShadow = true;   
                        closedDoor.receiveShadow = true; 
                        scene.add(closedDoor);
                        wallObjects.push(closedDoor);
                        
                        winPosition.userData.closedDoor = closedDoor;
                    }
                }
            }
        }
        
        // Flashlight Spawn
        function addFlashlight() {
            let r, c;
            // Find a random, open cell that is not the start or exit
            do {
                r = Math.floor(Math.random() * MAX_ROW);
                c = Math.floor(Math.random() * MAX_COL);
            } while (mazeGrid[r][c] !== 0 || (r === START_ROW && c === START_COL) || (r === EXIT_ROW && c === EXIT_COL));

            const worldPos = toWorldPosition(r, c);
            
            // 1. Physical Flashlight Mesh
            const geometry = new THREE.CylinderGeometry(0.5, 0.5, 3, 16); 
            const material = new THREE.MeshPhongMaterial({ color: 0xffffff, emissive: 0xdddddd, emissiveIntensity: 0.8 });
            flashlightObject = new THREE.Mesh(geometry, material);
            flashlightObject.rotation.z = Math.PI / 2; 
            flashlightObject.position.set(worldPos.x, PLAYER_HEIGHT / 2, worldPos.z);
            flashlightObject.userData.isCollectible = true;
            flashlightObject.userData.name = "Flashlight";
            scene.add(flashlightObject);

            // 2. Beacon (Red Beam to the sky)
            const beaconHeight = 500;
            const beaconGeometry = new THREE.CylinderGeometry(0.5, 2, beaconHeight, 16);
            const beaconMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xff0000, 
                transparent: true, 
                opacity: 0.15, 
                blending: THREE.AdditiveBlending 
            });
            const beacon = new THREE.Mesh(beaconGeometry, beaconMaterial);
            beacon.position.set(worldPos.x, beaconHeight / 2, worldPos.z);
            beacon.userData.isBeacon = true;
            flashlightObject.userData.beacon = beacon; 
            scene.add(beacon);
        }

        // NEW FUNCTION: Spawn Batteries
        function addBatteries() {
            const batteryMaterial = new THREE.MeshPhongMaterial({ color: 0x00ff00, emissive: 0x004400, shininess: 50 });
            const batteryGeometry = new THREE.CylinderGeometry(0.3, 0.3, 1, 8); 
            
            const numBatteries = 15;
            for (let i = 0; i < numBatteries; i++) {
                let r, c;
                do {
                    r = Math.floor(Math.random() * MAX_ROW);
                    c = Math.floor(Math.random() * MAX_COL);
                } while (mazeGrid[r][c] !== 0);

                const worldPos = toWorldPosition(r, c);
                
                const batteryMesh = new THREE.Mesh(batteryGeometry, batteryMaterial);
                batteryMesh.rotation.x = Math.PI / 2;
                batteryMesh.position.set(worldPos.x, 0.5, worldPos.z);
                batteryMesh.userData.isCollectible = true;
                batteryMesh.userData.name = "Battery";
                
                scene.add(batteryMesh);
                batteries.push(batteryMesh);
            }
        }


        // Flashlight Model and Light Setup
        function createFirstPersonModel() {
            const group = new THREE.Group();

            // 1. Arm (Simple Cube)
            const armGeometry = new THREE.BoxGeometry(1, 1, 3);
            const armMaterial = new THREE.MeshPhongMaterial({ color: 0x8d745c });
            const arm = new THREE.Mesh(armGeometry, armMaterial);
            arm.position.set(2, -3, -1); // Positioned low and to the right
            arm.rotation.z = Math.PI / 4; 
            arm.rotation.y = -Math.PI / 10;
            arm.castShadow = true;
            group.add(arm);

            // 2. Flashlight Body (Cylinder)
            const flBodyGeometry = new THREE.CylinderGeometry(0.2, 0.2, 3, 16);
            const flBodyMaterial = new THREE.MeshPhongMaterial({ color: 0x333333 });
            const flBody = new THREE.Mesh(flBodyGeometry, flBodyMaterial);
            flBody.position.set(1, 0, 0);
            flBody.rotation.z = -Math.PI / 2;
            flBody.castShadow = true;
            arm.add(flBody);

            // 3. Flashlight Head (Cone)
            const flHeadGeometry = new THREE.ConeGeometry(0.4, 0.5, 16);
            const flHeadMaterial = new THREE.MeshPhongMaterial({ color: 0x666666 });
            const flHead = new THREE.Mesh(flHeadGeometry, flHeadMaterial);
            flHead.position.set(2.5, 0, 0);
            flHead.rotation.z = -Math.PI / 2;
            flBody.add(flHead);

            // 4. SpotLight (The actual light source)
            const flashlight = new THREE.SpotLight(0xffffff, 0, 100, Math.PI / 6, 0.5, 2);
            flashlight.position.set(2.5, 0, 0); // Position at the head of the model
            flashlight.target.position.set(2.5, 0, -1); // Aiming forward
            flashlight.target.updateMatrixWorld();
            
            flashlight.castShadow = true; 
            flashlight.shadow.mapSize.width = 1024;
            flashlight.shadow.mapSize.height = 1024;
            flashlight.shadow.camera.near = 0.5;
            flashlight.shadow.camera.far = 100;

            flBody.add(flashlight);
            flBody.add(flashlight.target);

            group.userData.flashlightMesh = flBody;
            group.userData.spotLight = flashlight;
            
            return group;
        }

        // Adds the SpotLight and the arm model to the player's camera
        function addFlashlightToCamera() {
            firstPersonFlashlightModel = createFirstPersonModel();
            
            // Attach the whole model group to the camera
            camera.add(firstPersonFlashlightModel); 
            
            // Initial light intensity update based on full battery
            updateFlashlightPower();
        }
        
        function updateFlashlightPower() {
            if (!hasFlashlight || !firstPersonFlashlightModel) return;
            
            const spotLight = firstPersonFlashlightModel.userData.spotLight;
            
            // Intensity scales with battery level, max intensity is now 1.5 (MAX_FLASHLIGHT_INTENSITY)
            let intensity = (batteryLevel / 100) * MAX_FLASHLIGHT_INTENSITY;
            intensity = Math.max(0, intensity); 

            spotLight.intensity = intensity;
            
            // Update battery status bar color
            if (batteryLevel < 20) {
                batteryStatus.classList.add('battery-low');
            } else {
                batteryStatus.classList.remove('battery-low');
            }
        }

        // Inventory Management
        function addToInventory(itemName) {
            if (inventory.length < MAX_INVENTORY_SLOTS) {
                inventory.push(itemName);
                updateInventoryUI();
            }
        }

        function updateInventoryUI() {
            const inventoryContainer = document.getElementById('inventory-container');
            inventoryContainer.innerHTML = ''; 
            
            for (let i = 0; i < MAX_INVENTORY_SLOTS; i++) {
                const slot = document.createElement('div');
                slot.className = 'inventory-slot';
                
                if (inventory[i]) {
                    slot.textContent = inventory[i].substring(0, 2); // Show first two letters (FL or BA)
                    slot.title = inventory[i];
                    slot.classList.add('filled');
                } else {
                    slot.textContent = i + 1;
                }
                inventoryContainer.appendChild(slot);
            }
        }

        function addGhosts() {
            const ghostMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xaa00ff,
                transparent: true,
                opacity: 0.5,
                blending: THREE.AdditiveBlending 
            });
            const ghostGeometry = new THREE.SphereGeometry(2, 16, 16);
            
            ghosts = [];
            ghostPaths = [];
            
            GHOST_START_POSITIONS.forEach((startPos, index) => {
                const ghostMesh = new THREE.Mesh(ghostGeometry, ghostMaterial);
                ghostMesh.userData.isGhost = true;
                ghostMesh.userData.chasing = false; 
                
                const ghostWorldPos = toWorldPosition(startPos.r, startPos.c);
                ghostMesh.position.copy(ghostWorldPos);
                
                const ghostLight = new THREE.PointLight(0xaa00aa, 4, 50);
                ghostMesh.add(ghostLight);
                
                scene.add(ghostMesh);
                ghosts.push(ghostMesh);
                ghostPaths.push([]); 
            });
        }

        function addCrystals() {
            const crystalMaterial = new THREE.MeshPhongMaterial({
                color: 0x00ffff,
                emissive: 0x00ffff,
                emissiveIntensity: 0.5,
                specular: 0xffffff,
                shininess: 100,
                transparent: true,
                opacity: 0.9
            });
            const crystalGeometry = new THREE.DodecahedronGeometry(1); 
            
            let count = 0;
            for (let i = 1; i < MAX_ROW - 1; i++) { 
                for (let j = 1; j < MAX_COL - 1; j++) {
                    if (mazeGrid[i][j] === 0) { 
                        if (count >= TOTAL_CRYSTALS) return;
                        
                        if (Math.random() < 0.1) { 
                            const crystal = new THREE.Mesh(crystalGeometry, crystalMaterial);
                            const worldPos = toWorldPosition(i, j);
                            crystal.position.set(worldPos.x + (Math.random() - 0.5) * 5, 
                                                PLAYER_HEIGHT / 2, 
                                                worldPos.z + (Math.random() - 0.5) * 5);
                            crystal.userData.isCrystal = true;
                            
                            scene.add(crystal);
                            crystals.push(crystal);
                            count++;
                        }
                    }
                }
            }
        }

        function isGhostVisible(ghostMesh) {
            if (!ghostMesh) return false;

            const playerPosition = camera.position.clone();
            const ghostPosition = ghostMesh.position.clone();

            const dist = playerPosition.distanceTo(ghostPosition);
            if (dist > CELL_SIZE * 10) {
                 return false;
            }

            const direction = new THREE.Vector3().subVectors(ghostPosition, playerPosition).normalize();
            raycaster.set(playerPosition, direction);
            const objectsToIntersect = wallObjects.filter(obj => !obj.userData.isDoor); 
            const intersects = raycaster.intersectObjects(objectsToIntersect);

            if (intersects.length > 0) {
                const distanceToWall = intersects[0].distance;
                return dist < distanceToWall - 0.5;
            }
            
            return true;
        }

        function moveGhosts(delta) {
            if (isFreeCam) return; 
            
            const currentTime = clock.getElapsedTime();
            
            const shouldUpdatePath = ghostUpdateTimer >= GHOST_UPDATE_INTERVAL;
            
            if (shouldUpdatePath) {
                ghostUpdateTimer = 0;
            } else {
                ghostUpdateTimer += delta;
            }

            const GHOST_CHASE_SPEED = GHOST_SPEED; 
            
            ghosts.forEach((ghostMesh, index) => {
                const ghostWorldPos = ghostMesh.position;
                const ghostIsSeeingPlayer = isGhostVisible(ghostMesh); 
                let ghostPath = ghostPaths[index]; 
                let moveSpeed;
                
                // --- 1. FRENZY MODE CHECK ---
                if (ghostsGoFrenzy) {
                    moveSpeed = GHOST_FRENZY_SPEED;
                    ghostMesh.userData.chasing = true; 
                    
                    if (shouldUpdatePath || ghostPath.length === 0) {
                        const ghostGridPos = toGridPosition(ghostWorldPos.x, ghostWorldPos.z);
                        ghostPath = findPath(
                            ghostGridPos.r, ghostGridPos.c, 
                            playerGridPos.r, playerGridPos.c
                        );
                        ghostPaths[index] = ghostPath; 
                    }
                } 
                // --- 2. REGULAR AI MODE ---
                else {
                    if (ghostIsSeeingPlayer) {
                        ghostMesh.userData.chasing = true; 
                    } else if (ghostPath.length === 0) {
                         ghostMesh.userData.chasing = false; 
                    }

                    if (ghostMesh.userData.chasing) {
                        moveSpeed = GHOST_CHASE_SPEED;
                        if (shouldUpdatePath) { 
                            const ghostGridPos = toGridPosition(ghostWorldPos.x, ghostWorldPos.z);
                            ghostPath = findPath(
                                ghostGridPos.r, ghostGridPos.c, 
                                playerGridPos.r, playerGridPos.c
                            );
                            ghostPaths[index] = ghostPath; 
                        }
                    } else {
                        moveSpeed = GHOST_WANDER_SPEED;
                        if (ghostPath.length === 0 && shouldUpdatePath) { 
                            const ghostGridPos = toGridPosition(ghostWorldPos.x, ghostWorldPos.z);
                            const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];
                            const validNeighbors = directions.map(([dr, dc]) => [ghostGridPos.r + dr, ghostGridPos.c + dc])
                                .filter(([r, c]) => mazeGrid[r] && mazeGrid[r][c] === 0);

                            if (validNeighbors.length > 0) {
                                const [targetR, targetC] = validNeighbors[Math.floor(Math.random() * validNeighbors.length)];
                                ghostPath.push([targetR, targetC]);
                                ghostPaths[index] = ghostPath;
                            }
                        }
                    }
                }

                // 3. Movement Execution
                if (ghostPath.length > 0) {
                    const [nextR, nextC] = ghostPath[0];
                    const targetWorldPos = toWorldPosition(nextR, nextC);
                    const moveDistance = moveSpeed * delta; 
                    
                    if (ghostWorldPos.distanceTo(targetWorldPos) < moveDistance) {
                        ghostWorldPos.x = targetWorldPos.x;
                        ghostWorldPos.z = targetWorldPos.z;
                        ghostPath.shift(); 
                    } else {
                        const direction = new THREE.Vector3().subVectors(targetWorldPos, ghostWorldPos).normalize();
                        ghostWorldPos.addScaledVector(direction, moveDistance);
                    }
                    
                    if (ghostPath.length > 0) {
                        const lookAtTarget = toWorldPosition(ghostPath[0][0], ghostPath[0][1]);
                        ghostMesh.lookAt(lookAtTarget.x, ghostWorldPos.y, lookAtTarget.z);
                    }
                }
                
                ghostMesh.rotation.y += 1.0 * delta;
                ghostMesh.position.y = PLAYER_HEIGHT + 0.5 + Math.sin(currentTime * 3 + index) * 0.5;

                checkCatchCondition(ghostWorldPos);
            });
        }

        function checkCatchCondition(ghostPosition) { 
            if (isFreeCam) return; 
            
            const catchDistance = 3; 
            const dist = camera.position.distanceTo(ghostPosition);

            if (dist < catchDistance) {
                showAlert("CAUGHT! A Ghost found you in the deep maze.", false);
            }
        }

        function openExitPortal() {
            const door = winPosition.userData.closedDoor;
            scene.remove(door);
            wallObjects = wallObjects.filter(obj => obj.uuid !== door.uuid);

            winPosition.visible = true; 
            winPosition.userData.light.intensity = 5; 
        }

        function checkCollectibles() {
            if (isFreeCam) return; 

            const playerPos = camera.position;
            const collectionRadius = 5; 

            // 1. Check Crystals
            checkCrystalCollection();

            // 2. Check Flashlight
            if (!hasFlashlight && flashlightObject) {
                if (playerPos.distanceTo(flashlightObject.position) < collectionRadius) {
                    scene.remove(flashlightObject.userData.beacon);
                    scene.remove(flashlightObject);
                    flashlightObject = null;
                    
                    addFlashlightToCamera();
                    
                    hasFlashlight = true;
                    addToInventory("Flashlight");
                }
            }

            // 3. Check Batteries
            for (let i = batteries.length - 1; i >= 0; i--) {
                const battery = batteries[i];
                if (playerPos.distanceTo(battery.position) < collectionRadius) {
                    scene.remove(battery);
                    batteries.splice(i, 1);
                    
                    // Restore battery level
                    batteryLevel = Math.min(100, batteryLevel + BATTERY_COLLECTION_AMOUNT);
                    updateFlashlightPower();
                    
                    updateStatusBar(); 
                    return;
                }
            }
        }
        
        function checkCrystalCollection() {
            const playerPos = camera.position;
            const collectionRadius = 5; 

            for (let i = crystals.length - 1; i >= 0; i--) {
                const crystal = crystals[i];
                if (playerPos.distanceTo(crystal.position) < collectionRadius) {
                    scene.remove(crystal);
                    crystals.splice(i, 1);
                    crystalsCollected++;
                    
                    updateStatusBar(); 

                    if (crystalsCollected >= TOTAL_CRYSTALS) {
                        minimap.style.display = 'block'; 
                        isMinimapVisible = true; 
                        ghostsGoFrenzy = true; 
                        playerStatus.textContent = "STATUS: ESCAPE! (FINAL SPRINT!)";
                        playerStatus.classList.add('sprinting'); 
                        openExitPortal();
                    }
                    return;
                }
            }
        }


        // --- CHEAT FUNCTIONS (Unchanged) ---
        function setBatteryLevel(level) {
            batteryLevel = Math.max(0, Math.min(100, level));
            updateFlashlightPower();
            updateStatusBar();
            console.log(`[Cheat] Battery level set to ${batteryLevel}%.`);
        }

        function setCrystalCount(count) {
            crystalsCollected = count;
            // Force game state update if threshold is passed
            if (crystalsCollected >= TOTAL_CRYSTALS) {
                if (!ghostsGoFrenzy) {
                    ghostsGoFrenzy = true;
                    openExitPortal();
                }
            } else {
                ghostsGoFrenzy = false;
                if (winPosition) {
                    winPosition.visible = false;
                    winPosition.userData.closedDoor.visible = true; 
                    winPosition.userData.light.intensity = 0;
                }
            }
            updateStatusBar();
        }
        
        function toggleFreeCam(enable) {
            isFreeCam = enable;
            if (enable) {
                controls.unlock(); 
                playerStatus.textContent = "Status: FREECAM ACTIVE";
                playerStatus.classList.remove('sprinting');
                crosshair.style.opacity = 0; 
                gameActive = false; 
            } else {
                camera.position.y = PLAYER_HEIGHT; 
                controls.lock(); 
            }
        }

        function setFlySpeed(level) {
            flySpeedMultiplier = Math.max(1, Math.min(100, level));
            console.log(`[Cheat] FlySpeed multiplier set to ${flySpeedMultiplier}.`);
        }
        
        function toggleMinimap(visible) {
            isMinimapVisible = visible;
            minimap.style.display = visible ? 'block' : 'none';
        }


        function processCommand(commandText) {
            const parts = commandText.trim().toLowerCase().split(/\s+/);
            const command = parts[0];

            if (command === '/set' && parts[1] === 'crystal') {
                const count = parseInt(parts[2]);
                if (!isNaN(count) && count >= 0 && count <= TOTAL_CRYSTALS) {
                    setCrystalCount(count);
                    console.log(`[Cheat] Crystals set to ${count}.`);
                } else {
                    console.log(`[Cheat] Invalid crystal count. Must be between 0 and ${TOTAL_CRYSTALS}.`);
                }
            } else if (command === '/set' && parts[1] === 'battery') { 
                const level = parseInt(parts[2]);
                if (!isNaN(level) && hasFlashlight) {
                    setBatteryLevel(level);
                } else if (!hasFlashlight) {
                    console.log(`[Cheat] Cannot set battery: Flashlight not yet collected.`);
                } else {
                    console.log(`[Cheat] Invalid battery level. Must be between 0 and 100.`);
                }
            } else if (command === '/freecam') { 
                toggleFreeCam(true);
                console.log(`[Cheat] FreeCam Activated.`);
            } else if (command === '/unfreecam') { 
                toggleFreeCam(false);
                console.log(`[Cheat] FreeCam Deactivated.`);
            } else if (command === '/flyspeed') { 
                const speedLevel = parseInt(parts[1]);
                if (!isNaN(speedLevel)) {
                    setFlySpeed(speedLevel);
                } else {
                    console.log(`[Cheat] Invalid speed level. Must be between 1 and 100.`);
                }
            } else if (command === '/showminimap' || command === '/showmm') { 
                toggleMinimap(true);
                console.log(`[Cheat] Minimap shown.`);
            } else if (command === '/unshowminimap' || command === '/unshowmm') { 
                toggleMinimap(false);
                console.log(`[Cheat] Minimap hidden.`);
            }
        }
        // --- END CHEAT FUNCTIONS ---


        function updateStatusBar() {
            if (isFreeCam) return; 

            let closestDist = Infinity;
            ghosts.forEach(ghost => {
                const dist = camera.position.distanceTo(ghost.position);
                closestDist = Math.min(closestDist, dist);
            });

            let threatText;
            if (ghostsGoFrenzy) {
                threatText = "THREAT: FRENZY! (THEY KNOW)";
            } else if (closestDist > CELL_SIZE * 10) {
                 threatText = "Threat: Distant";
            } else if (closestDist > CELL_SIZE * 4) {
                 threatText = "Threat: Nearby";
            } else {
                 threatText = "THREAT: IMMINENT!";
            }
            ghostProximity.textContent = `${threatText} | Crystals: ${crystalsCollected}/${TOTAL_CRYSTALS}`;
            
            // Update Battery Status
            if (hasFlashlight) {
                batteryStatus.textContent = `Battery: ${batteryLevel.toFixed(0)}%`;
            } else {
                batteryStatus.textContent = `Battery: N/A`;
            }
        }

        function updateMinimap() {
            if (minimap.style.display === 'none') return;

            const ctx = minimap.getContext('2d');
            const mapSize = minimap.width;
            const cellMapSize = mapSize / MAX_COL;

            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.fillRect(0, 0, mapSize, mapSize);

            // Draw Walls
            ctx.fillStyle = '#111111'; 
            for (let r = 0; r < MAX_ROW; r++) {
                for (let c = 0; c < MAX_COL; c++) {
                    if (mazeGrid[r][c] === 1) {
                        ctx.fillRect(c * cellMapSize, r * cellMapSize, cellMapSize, cellMapSize);
                    }
                }
            }

            // Draw Exit (Green dot)
            ctx.fillStyle = ghostsGoFrenzy ? '#00ff00' : '#5c3317'; 
            ctx.fillRect(EXIT_COL * cellMapSize, EXIT_ROW * cellMapSize, cellMapSize, cellMapSize);
            
            // Draw Ghosts
            ghosts.forEach(ghost => {
                const ghostGridPos = toGridPosition(ghost.position.x, ghost.position.z);
                ctx.fillStyle = ghost.userData.chasing ? '#ff0000' : '#aa00ff';
                ctx.beginPath();
                const ghostMapX = ghostGridPos.c * cellMapSize + cellMapSize / 2;
                const ghostMapY = ghostGridPos.r * cellMapSize + cellMapSize / 2;
                ctx.arc(ghostMapX, ghostMapY, cellMapSize * 0.3, 0, 2 * Math.PI);
                ctx.fill();
            });

            // Draw Player (Red dot)
            ctx.fillStyle = '#ff0000';
            ctx.beginPath();
            const playerMapX = playerGridPos.c * cellMapSize + cellMapSize / 2;
            const playerMapY = playerGridPos.r * cellMapSize + cellMapSize / 2;
            ctx.arc(playerMapX, playerMapY, cellMapSize * 0.4, 0, 2 * Math.PI);
            ctx.fill();
        }

        // --- Input Handlers (Unchanged) ---
        function onKeyDown(event) {
            if (isConsoleOpen) {
                if (event.code === 'Escape') {
                    event.preventDefault(); 
                    consoleInput.value = '';
                    consoleElement.style.display = 'none';
                    isConsoleOpen = false;
                    
                    controls.lock(); 
                }
                return; 
            }
            
            if (event.code === 'Slash' && !event.shiftKey && controls.isLocked) {
                event.preventDefault(); 
                controls.unlock();
                gameActive = false;
                
                consoleElement.style.display = 'block';
                consoleInput.focus(); 
                isConsoleOpen = true;
                return;
            }

            switch (event.code) {
                case 'ArrowUp': case 'KeyW': moveForward = true; break;
                case 'ArrowLeft': case 'KeyA': moveLeft = true; break;
                case 'ArrowDown': case 'KeyS': moveBackward = true; break;
                case 'ArrowRight': case 'KeyD': moveRight = true; break;
                case 'KeyQ': moveUp = true; break; 
                case 'KeyE': moveDown = true; break; 
            }
        }

        function onKeyUp(event) {
            if (isConsoleOpen) return; 
            
            switch (event.code) {
                case 'ArrowUp': case 'KeyW': moveForward = false; break;
                case 'ArrowLeft': case 'KeyA': moveLeft = false; break;
                case 'ArrowDown': case 'KeyS': moveBackward = false; break;
                case 'ArrowRight': case 'KeyD': moveRight = false; break;
                case 'KeyQ': moveUp = false; break;
                case 'KeyE': moveDown = false; break;
            }
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- Game Loop and Logic ---

        function animate() {
            requestAnimationFrame(animate);

            const delta = clock.getDelta();

            if (controls.isLocked === true || isFreeCam) {
                
                updatePlayerGridPosition(); 
                
                let currentSpeed;
                
                if (!isFreeCam) { 
                    // --- GAMEPLAY LOGIC ---
                    let ghostInSight = false;
                    if (!ghostsGoFrenzy) {
                        ghosts.forEach(ghost => {
                            if(isGhostVisible(ghost)) {
                                ghostInSight = true;
                            }
                        });
                    }
                    
                    moveGhosts(delta); 
                    checkCollectibles(); 

                    // Flashlight Battery Drain Logic
                    if (hasFlashlight && isFlashlightOn && batteryLevel > 0) {
                        batteryLevel -= BATTERY_DRAIN_RATE * delta;
                        batteryLevel = Math.max(0, batteryLevel);
                        updateFlashlightPower();
                    } else if (hasFlashlight && batteryLevel <= 0) {
                        updateFlashlightPower(); 
                    }


                    // Sprint Logic
                    if (!ghostsGoFrenzy) {
                        if (ghostInSight) {
                            effectiveSpeed = SPRINT_SPEED;
                            sprintDelayTimer = SPRINT_DELAY_DURATION; 
                            playerStatus.textContent = "Status: SPRINTING! (GO! GO! GO!)";
                            playerStatus.classList.add('sprinting');
                        } else if (sprintDelayTimer > 0) {
                            sprintDelayTimer -= delta;
                            sprintDelayTimer = Math.max(0, sprintDelayTimer);
                            effectiveSpeed = SPRINT_SPEED;
                            playerStatus.textContent = `Status: SPRINTING! (Delay: ${sprintDelayTimer.toFixed(1)}s)`;
                            playerStatus.classList.add('sprinting');
                        } else {
                            effectiveSpeed = WALK_SPEED;
                            playerStatus.textContent = "Status: Walking...";
                            playerStatus.classList.remove('sprinting');
                        }
                    } else {
                        effectiveSpeed = SPRINT_SPEED; 
                    }
                    
                    currentSpeed = effectiveSpeed;
                    updateStatusBar(); 
                } else {
                    // --- FREECAM LOGIC ---
                    currentSpeed = (MAX_FREECAM_SPEED / 100) * flySpeedMultiplier;
                    playerStatus.textContent = `Status: FREECAM ACTIVE (Speed: ${flySpeedMultiplier})`;
                    playerStatus.classList.remove('sprinting');
                    ghostProximity.textContent = `Threat: PAUSED | Crystals: ${crystalsCollected}/${TOTAL_CRYSTALS}`;
                }

                // Movement Calculation (Applies to both modes)
                const velocity = new THREE.Vector3();
                if (moveForward) velocity.z -= currentSpeed * delta;
                if (moveBackward) velocity.z += currentSpeed * delta;
                if (moveLeft) velocity.x -= currentSpeed * delta;
                if (moveRight) velocity.x += currentSpeed * delta;
                
                // Freecam vertical movement
                if (isFreeCam) {
                    if (moveUp) velocity.y += currentSpeed * delta;
                    if (moveDown) velocity.y -= currentSpeed * delta;
                    camera.position.y += velocity.y; 
                }

                const oldPosition = camera.position.clone();
                
                // --- PLAYER MOVEMENT FIX: Use controls for movement, then check collision ---
                controls.moveForward(-velocity.z);
                controls.moveRight(velocity.x);
                
                // Final Check and Win Condition: Only run if NOT in freecam mode
                if (!isFreeCam) { 
                    
                    const finalGridX = Math.floor((camera.position.x - offsetX) / CELL_SIZE);
                    const finalGridZ = Math.floor((camera.position.z - offsetZ) / CELL_SIZE);
                    
                    if (isColliding(finalGridX, finalGridZ)) {
                         // If collision detected, revert to old position
                         camera.position.copy(oldPosition);
                    }

                    checkWinCondition();
                } 
                // -----------------------------------------------------------------------------
                
                // Animate lights & crystals 
                if (winPosition && winPosition.visible && winPosition.userData.light) {
                    winPosition.userData.light.intensity = 4 + Math.sin(clock.getElapsedTime() * 5) * 1;
                    winPosition.material.opacity = 0.6 + Math.sin(clock.getElapsedTime() * 5) * 0.2;
                }
                crystals.forEach(crystal => {
                    crystal.rotation.y += 2 * delta;
                    crystal.position.y = PLAYER_HEIGHT / 2 + 0.5 + Math.sin(clock.getElapsedTime() * 4) * 0.2;
                });
                
                batteries.forEach(battery => {
                    battery.rotation.z += 2 * delta;
                    battery.position.y = 0.5 + 0.2 + Math.sin(clock.getElapsedTime() * 4) * 0.1;
                });
                
                // Animate First-person model arm bob
                if (firstPersonFlashlightModel) {
                    firstPersonFlashlightModel.position.z = Math.sin(clock.getElapsedTime() * 6) * 0.05;
                }

                if (isMinimapVisible || crystalsCollected >= TOTAL_CRYSTALS) {
                    minimap.style.display = 'block';
                    updateMinimap();
                } else {
                    minimap.style.display = 'none';
                }
            }

            renderer.render(scene, camera);
        }

        // Simplified isColliding function
        function isColliding(gridX, gridZ) {
            if (isFreeCam) return false; 
            
            if (gridZ < 0 || gridZ >= mazeGrid.length || gridX < 0 || gridX >= mazeGrid[0].length) {
                return true;
            }

            if (mazeGrid[gridZ] && mazeGrid[gridZ][gridX] === 1) {
                return true; 
            }
            return false;
        }

        function checkWinCondition() {
            if (isFreeCam) return; 
            if (!winPosition || !winPosition.visible) return;
            
            const distanceToExit = camera.position.distanceTo(winPosition.position);
            
            if (distanceToExit < CELL_SIZE / 2) {
                showAlert("SUCCESS! You escaped the deep maze and the Ghost's sight!", true);
            }
        }

        // --- Start the App ---
        window.onload = function () {
            init();
            animate();
        };

    </script>
</body>
</html>

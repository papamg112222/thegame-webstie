<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Echo Shard - Reality Hacker</title>
    <style>
        html, body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #111;
            color: #eee;
            font-family: 'Inter', sans-serif;
        }
        #main-menu, #ui, #message {
            position: absolute;
            z-index: 10;
        }
        #main-menu {
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(0, 0, 0, 0.95);
            transition: opacity 1s, visibility 1s;
        }
        .menu-title {
            font-size: 4rem;
            font-weight: bold;
            color: #00aaff;
            text-shadow: 0 0 10px #00aaff, 0 0 20px #00aaff;
            margin-bottom: 2rem;
            animation: pulse 2s infinite;
        }
        .menu-instructions {
            text-align: center;
            font-size: 1.2rem;
            line-height: 1.6;
            margin-bottom: 2rem;
        }
        .menu-button {
            padding: 12px 24px;
            font-size: 1.5rem;
            font-weight: bold;
            color: #fff;
            background: #00aaff;
            border: 2px solid #00aaff;
            border-radius: 8px;
            cursor: pointer;
            box-shadow: 0 0 10px #00aaff, 0 0 20px rgba(0, 170, 255, 0.5);
            transition: all 0.3s ease;
        }
        .menu-button:hover {
            background: #0088cc;
            box-shadow: 0 0 15px #00aaff, 0 0 30px rgba(0, 170, 255, 0.8);
        }
        @keyframes pulse {
            0% { text-shadow: 0 0 10px #00aaff, 0 0 20px #00aaff; }
            50% { text-shadow: 0 0 15px #00aaff, 0 0 30px #00aaff; }
            100% { text-shadow: 0 0 10px #00aaff, 0 0 20px #00aaff; }
        }

        #ui {
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.6);
            padding: 10px;
            border-radius: 6px;
            font-size: 14px;
            display: none;
            flex-direction: column;
            gap: 8px;
        }
        .ui-line {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .bar-container {
            width: 150px;
            height: 12px;
            background-color: rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            overflow: hidden;
        }
        .bar {
            height: 100%;
            background-color: #00aaff;
            width: 100%;
            transition: width 0.1s linear;
        }
        #health-bar .bar { background-color: #ff4444; }
        #stamina-bar .bar { background-color: #00aaff; }

        #message {
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.9);
            color: #000;
            padding: 12px 20px;
            border-radius: 8px;
            display: none;
            font-weight: bold;
            font-size: 18px;
            transition: opacity 0.3s;
        }
        canvas { display: block; }
    </style>
</head>
<body>

<div id="main-menu">
    <h1 class="menu-title">Echo Shard</h1>
    <div class="menu-instructions">
        <p>You are a reality hacker trying to steal a crystal in the dimension.</p>
        <p><strong>Controls:</strong></p>
        <p>WASD: Move | Shift: Sprint</p>
        <p>Mouse: Look | E: Interact</p>
        <p>Q: Toggle time-stop (uses stamina)</p>
        <p>R: Hold to rewind (3s max)</p>
    </div>
    <button class="menu-button" id="start-button">Start Game</button>
</div>

<div id="ui">
    <div class="ui-line">
        Health: <span id="health">100</span>
        <div id="health-bar" class="bar-container"><div class="bar"></div></div>
    </div>
    <div class="ui-line">
        Stamina: <span id="stamina">100</span>
        <div id="stamina-bar" class="bar-container"><div class="bar"></div></div>
    </div>
    <div class="ui-line">Keycards: <span id="keycards">0</span></div>
    <div class="ui-line">Stage: <span id="stage">1</span></div>
    <div class="ui-line">Time: <span id="timer">00:00</span></div>
</div>

<div id="message"></div>

<script src="https://cdn.jsdelivr.net/npm/three@0.150.1/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.150.1/examples/js/controls/PointerLockControls.js"></script>
<script>
(() => {
    // --- Global Game Variables ---
    const PLAYER_HEIGHT = 1.8;
    const GRAVITY = -30;
    const REWIND_MAX_FRAMES = 180; // 3 seconds at ~60fps
    const STAMINA_MAX = 100;
    const STAMINA_DRAIN_RATE = 20; // per second
    const STAMINA_RECHARGE_RATE = 40; // per second
    const KEYCARD_COLORS = [0xffff00, 0x00ff00, 0xff00ff];

    let scene, camera, renderer, controls, clock;
    let velocity = new THREE.Vector3(), direction = new THREE.Vector3();
    let move = { forward: false, backward: false, left: false, right: false, sprint: false };
    let canJump = false, gameStarted = false;
    let health = 100, stamina = STAMINA_MAX, keycards = 0, stage = 1;
    let startTime = Date.now();
    let isRewinding = false, isTimeStopped = false;
    let rewindBuffer = [];
    const ui = {
        menu: document.getElementById('main-menu'),
        startBtn: document.getElementById('start-button'),
        hud: document.getElementById('ui'),
        health: document.getElementById('health'),
        healthBar: document.querySelector('#health-bar .bar'),
        stamina: document.getElementById('stamina'),
        staminaBar: document.querySelector('#stamina-bar .bar'),
        keycards: document.getElementById('keycards'),
        stage: document.getElementById('stage'),
        timer: document.getElementById('timer'),
        msg: document.getElementById('message')
    };

    // --- Helper Functions ---
    function showMessage(text, duration = 3000) {
        ui.msg.textContent = text;
        ui.msg.style.display = 'block';
        setTimeout(() => ui.msg.style.display = 'none', duration);
    }
    
    // --- Game Object Classes ---
    
    // Door Class: Now requires a specific keycard based on its type.
    class Door {
        constructor(pos, locked = true, type = 0) {
            this.locked = locked;
            this.type = type;
            this.mesh = new THREE.Mesh(
                new THREE.BoxGeometry(1, 3, 0.2),
                new THREE.MeshPhongMaterial({
                    color: locked ? 0xaa0000 : 0x00aa00,
                    transparent: true,
                    opacity: 0.9,
                    emissive: locked ? 0x660000 : 0x006600
                })
            );
            this.mesh.position.copy(pos);
            scene.add(this.mesh);
        }
        interact() {
            if (this.locked) {
                if (keycards > 0) {
                    keycards--;
                    ui.keycards.textContent = keycards;
                    this.locked = false;
                    this.mesh.material.color.set(0x00aa00);
                    this.mesh.material.emissive.set(0x006600);
                    showMessage("Door unlocked.");
                } else {
                    showMessage("You need a keycard to open this door.");
                }
            } else {
                showMessage("Door is already unlocked.");
            }
        }
    }

    // Enemy Class: The "monster in the matrix" with a patrol path.
    class Enemy {
        constructor(path) {
            this.path = path;
            this.currentWaypoint = 0;
            this.mesh = new THREE.Mesh(
                new THREE.BoxGeometry(0.7, 1.8, 0.7),
                new THREE.MeshPhongMaterial({
                    color: 0xff4444,
                    emissive: 0x990000
                })
            );
            this.mesh.position.copy(this.path[this.currentWaypoint]);
            scene.add(this.mesh);
            this.speed = 3;
        }
        update(delta, playerPos) {
            if (isTimeStopped || isRewinding) return;

            // Move towards the next waypoint in the patrol path
            const target = this.path[this.currentWaypoint];
            const direction = new THREE.Vector3().subVectors(target, this.mesh.position).normalize();
            this.mesh.position.addScaledVector(direction, this.speed * delta);

            // Check if the enemy has reached the waypoint
            if (this.mesh.position.distanceTo(target) < 0.5) {
                this.currentWaypoint = (this.currentWaypoint + 1) % this.path.length;
            }

            // Check for collision with the player
            if (this.mesh.position.distanceTo(playerPos) < 1.2) {
                health -= 10;
                if (health <= 0) {
                    alert("Game Over! You were caught by the system daemon.");
                    location.reload();
                }
                ui.health.textContent = health;
                ui.healthBar.style.width = `${health}%`;
            }
        }
    }

    // Keycard Class: Collectible items to open doors.
    class Keycard {
        constructor(pos, type = 0) {
            this.mesh = new THREE.Mesh(
                new THREE.BoxGeometry(0.3, 0.05, 0.5),
                new THREE.MeshPhongMaterial({
                    color: KEYCARD_COLORS[type],
                    emissive: KEYCARD_COLORS[type]
                })
            );
            this.mesh.position.copy(pos);
            scene.add(this.mesh);
            this.collected = false;
            this.mesh.name = 'keycard';
        }
        tryCollect(playerPos) {
            if (!this.collected && this.mesh.position.distanceTo(playerPos) < 1) {
                this.collected = true;
                scene.remove(this.mesh);
                keycards++;
                ui.keycards.textContent = keycards;
                showMessage("Keycard picked up!");
                return true;
            }
            return false;
        }
    }

    // Crystal Class: The final objective of each stage.
    class Crystal {
        constructor(pos) {
            this.mesh = new THREE.Mesh(
                new THREE.IcosahedronGeometry(0.4, 0),
                new THREE.MeshPhongMaterial({
                    color: 0x00aaff,
                    emissive: 0x0077ff,
                    shininess: 100
                })
            );
            this.mesh.position.copy(pos);
            scene.add(this.mesh);
            this.mesh.name = 'crystal';
        }
        tryCollect(playerPos) {
            return playerPos.distanceTo(this.mesh.position) < 1;
        }
    }

    let doors = [], enemies = [], keys = [], crystals = [];
    
    // --- Stage Setup: Creates the maze and objects for each level ---
    function setupStage(num) {
        // Clear previous stage
        doors.forEach(d => scene.remove(d.mesh)); doors = [];
        enemies.forEach(e => scene.remove(e.mesh)); enemies = [];
        keys.forEach(k => scene.remove(k.mesh)); keys = [];
        crystals.forEach(c => scene.remove(c.mesh)); crystals = [];

        // Main office building geometry
        const walls = [
            // Outer walls
            new THREE.BoxGeometry(20, 3, 0.2), new THREE.Vector3(0, 1.5, -10),
            new THREE.BoxGeometry(20, 3, 0.2), new THREE.Vector3(0, 1.5, 10),
            new THREE.BoxGeometry(0.2, 3, 20), new THREE.Vector3(-10, 1.5, 0),
            new THREE.BoxGeometry(0.2, 3, 20), new THREE.Vector3(10, 1.5, 0),
            // Inner maze walls
            new THREE.BoxGeometry(10, 3, 0.2), new THREE.Vector3(5, 1.5, -5),
            new THREE.BoxGeometry(0.2, 3, 10), new THREE.Vector3(0, 1.5, 5),
            new THREE.BoxGeometry(10, 3, 0.2), new THREE.Vector3(-5, 1.5, 0),
            new THREE.BoxGeometry(0.2, 3, 5), new THREE.Vector3(-5, 1.5, -2.5),
        ];

        walls.forEach((geom, i) => {
            if (i % 2 === 0) {
                const mesh = new THREE.Mesh(
                    geom,
                    new THREE.MeshPhongMaterial({
                        color: 0xaaaaaa,
                        emissive: 0x333333
                    })
                );
                mesh.position.copy(walls[i + 1]);
                scene.add(mesh);
            }
        });

        // Place game objects within the maze
        doors.push(new Door(new THREE.Vector3(0, 1.5, -9.9)));
        keys.push(new Keycard(new THREE.Vector3(5, 0.1, 5)));
        enemies.push(new Enemy([
            new THREE.Vector3(-5, 1, -5),
            new THREE.Vector3(5, 1, -5),
            new THREE.Vector3(5, 1, -9),
            new THREE.Vector3(-5, 1, -9),
        ]));
        crystals.push(new Crystal(new THREE.Vector3(-8, 1, 8)));

        ui.stage.textContent = num;
        camera.position.set(0, PLAYER_HEIGHT, 9);
        velocity.set(0,0,0);
        canJump = true;
    }
    
    // --- Initial Game Setup ---
    function setup() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x111111);
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
        controls = new THREE.PointerLockControls(camera, document.body);
        scene.add(controls.getObject());

        const ambient = new THREE.AmbientLight(0xffffff, 0.2);
        scene.add(ambient);
        const pl = new THREE.PointLight(0xffffff, 0.8);
        pl.position.set(0, 10, 0);
        scene.add(pl);

        const floor = new THREE.Mesh(
            new THREE.PlaneGeometry(20, 20),
            new THREE.MeshPhongMaterial({ color: 0x333333 })
        );
        floor.rotation.x = -Math.PI / 2;
        scene.add(floor);

        setupStage(stage);
        clock = new THREE.Clock();
        animate();
    }
    
    // --- Main Animation Loop ---
    function animate() {
        requestAnimationFrame(animate);
        const dt = clock.getDelta();
        const playerPos = controls.getObject().position;

        // Update timer
        const elapsed = Math.floor((Date.now() - startTime) / 1000);
        ui.timer.textContent = new Date(elapsed * 1000).toISOString().substr(14, 5);
        
        // Handle Rewind
        if (isRewinding) {
            if (rewindBuffer.length > 0) {
                const state = rewindBuffer.pop();
                controls.getObject().position.copy(state.pos);
                velocity.copy(state.vel);
                scene.background = new THREE.Color(0x331111); // Visual cue for rewind
            } else {
                isRewinding = false;
                showMessage("Rewind complete!");
                scene.background = new THREE.Color(0x111111);
            }
        } else {
            // Push current state to buffer only if not rewinding
            rewindBuffer.push({
                pos: controls.getObject().position.clone(),
                vel: velocity.clone()
            });
            if (rewindBuffer.length > REWIND_MAX_FRAMES) rewindBuffer.shift();
            scene.background = new THREE.Color(isTimeStopped ? 0x000033 : 0x111111); // Visual cue for time stop
        }
        
        // Handle Stamina
        if (isTimeStopped) {
            stamina -= STAMINA_DRAIN_RATE * dt;
            if (stamina <= 0) {
                stamina = 0;
                isTimeStopped = false;
                showMessage("Stamina depleted! Time resumes.");
            }
        } else {
            stamina += STAMINA_RECHARGE_RATE * dt;
            if (stamina > STAMINA_MAX) stamina = STAMINA_MAX;
        }
        ui.stamina.textContent = Math.floor(stamina);
        ui.staminaBar.style.width = `${stamina}%`;

        // Player Movement (only if time is not stopped or rewinding)
        if (!isTimeStopped && !isRewinding) {
            velocity.x -= velocity.x * 10 * dt;
            velocity.z -= velocity.z * 10 * dt;
            direction.z = Number(move.backward) - Number(move.forward);
            direction.x = Number(move.right) - Number(move.left);
            direction.normalize();
            const speed = move.sprint ? 10 : 5;
            velocity.z -= direction.z * speed * dt;
            velocity.x -= direction.x * speed * dt;
            controls.moveRight(-velocity.x * dt);
            controls.moveForward(-velocity.z * dt);
            velocity.y += GRAVITY * dt;
            controls.getObject().position.y += velocity.y * dt;
            if (controls.getObject().position.y < PLAYER_HEIGHT) {
                velocity.y = 0;
                controls.getObject().position.y = PLAYER_HEIGHT;
                canJump = true;
            }
        }

        // Object Interactions
        keys.forEach(k => k.tryCollect(playerPos));
        enemies.forEach(e => e.update(dt, playerPos));
        crystals.forEach(c => {
            if (c.tryCollect(playerPos)) {
                stage++;
                showMessage(`Stage ${stage - 1} cleared! Entering Stage ${stage}...`);
                setTimeout(() => setupStage(stage), 1000);
            }
        });
        
        // Update UI health bar
        ui.healthBar.style.width = `${health}%`;

        renderer.render(scene, camera);
    }
    
    // --- Event Listeners ---
    document.addEventListener('keydown', e => {
        if (!gameStarted) return;
        
        if (e.code === 'KeyW') move.forward = true;
        if (e.code === 'KeyS') move.backward = true;
        if (e.code === 'KeyA') move.left = true;
        if (e.code === 'KeyD') move.right = true;
        if (e.code === 'ShiftLeft') move.sprint = true;
        if (e.code === 'Space' && canJump) { velocity.y = 8; canJump = false; }
        if (e.code === 'KeyR' && rewindBuffer.length > 0) { isRewinding = true; }
        if (e.code === 'KeyQ' && stamina > 0) {
            isTimeStopped = !isTimeStopped;
        }
        if (e.code === 'KeyE') {
            const playerPos = controls.getObject().position;
            doors.forEach(d => {
                if (playerPos.distanceTo(d.mesh.position) < 1.5) d.interact();
            });
        }
    });

    document.addEventListener('keyup', e => {
        if (!gameStarted) return;
        
        if (e.code === 'KeyW') move.forward = false;
        if (e.code === 'KeyS') move.backward = false;
        if (e.code === 'KeyA') move.left = false;
        if (e.code === 'KeyD') move.right = false;
        if (e.code === 'ShiftLeft') move.sprint = false;
        if (e.code === 'KeyR') isRewinding = false;
    });

    ui.startBtn.addEventListener('click', () => {
        gameStarted = true;
        ui.menu.style.opacity = '0';
        ui.menu.style.visibility = 'hidden';
        ui.hud.style.display = 'flex';
        controls.lock();
        setup();
    });

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

})();
</script>

</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>2x2 Fusion - Hard Math Game</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900&display=swap" rel="stylesheet">
    <style>
        /* CSS Variables for responsive layout and consistency */
        :root {
            --tile-size: min(22vw, 150px);
            --gap-size: 8px;
        }
        body {
            font-family: 'Inter', sans-serif;
            overflow: hidden;
            background-color: #0d1117; /* Dark background */
            margin: 0;
        }

        /* --- Falling background animation (from your original CSS) --- */
        @keyframes fall {
            0% { transform: translateY(-20vh) rotate(0deg) scale(0.9); opacity: 0.08; filter: blur(0px); }
            40% { opacity: 0.45; filter: blur(0.3px); }
            100% { transform: translateY(120vh) rotate(360deg) scale(1.05); opacity: 0; filter: blur(1px); }
        }

        .math-symbol {
            position: absolute;
            color: rgba(80, 140, 200, 0.18);
            font-size: 2.5rem;
            pointer-events: none;
            user-select: none;
            animation: fall linear infinite;
            will-change: transform, opacity;
            text-shadow: 0 0 6px rgba(80,140,200,0.06);
        }
        /* ----------------------------------------------------------------- */


        /* Game board and tiles */
        .game-grid {
            /* Calculate the board size: (2 * tile_size) + (3 * gap_size) */
            width: calc(var(--tile-size) * 2 + 3 * var(--gap-size));
            height: calc(var(--tile-size) * 2 + 3 * var(--gap-size));
            background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
            grid-template-columns: repeat(2, var(--tile-size));
            grid-template-rows: repeat(2, var(--tile-size));
            display: grid;
            gap: var(--gap-size);
            padding: var(--gap-size);
            border-radius: 1.5rem;
            box-shadow: 0 12px 30px rgba(0,0,0,0.6);
            position: relative; /* Crucial for absolute positioning of value-tiles */
            user-select: none;
            touch-action: none; /* Prevents mobile browser default swipe actions */
        }

        /* Empty tile container (the background cells) */
        .tile-container { 
            border-radius: 0.75rem; 
            display:flex; 
            justify-content:center; 
            align-items:center; 
        }

        /* The actual tile with a number, absolutely positioned for animation */
        .value-tile {
            position: absolute;
            transition: transform 0.18s cubic-bezier(.2,.9,.2,1), left 0.18s ease, top 0.18s ease; /* Basic movement transition */
            z-index: 5;
            display:flex;
            justify-content:center;
            align-items:center;
            border-radius: 0.75rem;
        }

        .tile-value { 
            font-size: 2.5rem; 
            font-weight:700; 
            color:#e2e8f0; 
            transition: transform 0.12s; 
        }

        /* Tile color palette */
        .tile-2    { background-color: #3b526d; color: #e2e8f0; }
        .tile-4    { background-color: #4a6685; color: #e2e8f0; }
        .tile-8    { background-color: #6383a8; color: #f9f6f2; }
        .tile-16   { background-color: #799fc9; color: #f9f6f2; }
        .tile-24   { background-color: #4a90e2; color: #f9f6f2; } /* WIN TILE - Custom color for target 24 */
        .tile-32   { background-color: #8fbcdf; color: #f9f6f2; }
        .tile-64   { background-color: #f65e3b; color: #f9f6f2; }
        .tile-128  { background-color: #edcf72; color: #f9f6f2; }
        /* ... more classes would be here for a standard 2048 game ... */

        /* Empty tile color */
        .tile-0 {
            background-color: #1f2937;
            border: 1px solid #374151;
            z-index:1;
            width:100%;
            height:100%;
        }
        .tile-0 .tile-value { display:none; }

        /* Operator Sidebar Styling */
        .operator-display {
            display:flex;
            flex-direction:column;
            gap:1.5rem;
            padding:1.5rem;
            background-color: rgba(255,255,255,0.03);
            border-radius:1.5rem;
            box-shadow:0 6px 18px rgba(0,0,0,0.45);
            margin-left:1.5rem;
        }
        .operator-symbol {
            font-size:2.4rem;
            font-weight:800;
            color:#4a90e2;
            text-shadow: 0 0 8px rgba(74,144,226,0.4)
        }

        /* --- Custom Animations for Magnet/Fusion Effect --- */
        /* Used for the tile that is moving toward the target and will be consumed */
        .magnet-source {
            transition: left 0.45s cubic-bezier(.2,.8,.2,1), top 0.45s cubic-bezier(.2,.8,.2,1), transform 0.45s cubic-bezier(.2,.8,.2,1);
            z-index: 11;
        }
        /* Pop effect for the tile that receives the merge */
        .fusing-target .tile-value { animation: pop 0.35s ease-out; }
        @keyframes pop {
            0% { transform: scale(0.85); }
            50% { transform: scale(1.12); }
            100% { transform: scale(1); }
        }
        /* -------------------------------------------------- */

        /* Mobile adjustments */
        @media (max-width: 640px) {
            :root { --tile-size: 25vw; --gap-size: 6px; }
            .tile-value { font-size: 1.5rem; }
            .operator-display { display: none !important; } /* Hidden on small screens */
        }
    </style>
</head>
<body class="min-h-screen flex flex-col items-center justify-center p-4">
    <div id="math-background" class="absolute inset-0 z-0"></div>

    <main class="z-10 flex flex-col items-center space-y-6">
        <h1 class="text-5xl font-extrabold text-transparent bg-clip-text bg-gradient-to-r from-blue-400 to-purple-500 mb-2">2x2 Fusion</h1>
        <p class="text-sm text-gray-400 font-medium text-center">Click and Drag (then release) to move — pull tiles together & fuse 'em slow!</p>

        <div class="flex items-start">
            <div id="game-board" class="game-grid">
                </div>

            <div class="operator-display hidden sm:flex">
                <span class="operator-symbol">+</span>
                <span class="operator-symbol">−</span>
                <span class="operator-symbol">×</span>
                <span class="operator-symbol">÷</span>
            </div>
        </div>

        <div id="game-message" class="text-xl font-bold text-red-500 hidden transition-all duration-500"></div>

        <div class="flex gap-4">
            <button id="restart-button" class="mt-4 px-6 py-2 bg-purple-600 text-white font-semibold rounded-full shadow-lg hover:bg-purple-700 transition duration-300 transform hover:scale-105" onclick="setupGame()">Restart Game</button>
            <button id="hint-button" class="mt-4 px-4 py-2 bg-slate-700 text-white rounded-full" onclick="showHint()">Hint</button>
        </div>

        <p class="text-xs text-gray-500 mt-4 text-center">Target: **24** — harder start (4 initial tiles) & more 4s spawn. Good luck!</p>
    </main>

    <script>
        const GRID_SIZE = 2; // Fixed 2x2 grid
        let board = []; // The logical representation of the grid
        let isGameOver = false;
        let isMoving = false; // Flag to prevent rapid input during animation

        const boardElement = document.getElementById('game-board');
        const messageElement = document.getElementById('game-message');

        let TILE_SIZE = 0;
        let GAP_SIZE = 0;

        let touchstartX = 0, touchstartY = 0;
        const MIN_DRAG_DISTANCE = 40; // Minimum pixel distance for a swipe to register

        // Function to read CSS variables for accurate positioning
        function updateLayoutConstants() {
            // Recalculates the tile and gap size based on the current viewport
            TILE_SIZE = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--tile-size'));
            GAP_SIZE = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--gap-size').replace('px',''), 10);
            
            // Re-position tiles if they exist (important on resize)
            if (board.length > 0) drawBoard(true);
        }

        const getTileClass = (value) => `tile-${value}`;

        // Calculates the pixel position of a tile at (r, c)
        const getTilePosition = (r, c) => {
            return {
                left: c * (TILE_SIZE + GAP_SIZE) + GAP_SIZE,
                top: r * (TILE_SIZE + GAP_SIZE) + GAP_SIZE,
            };
        };

        // --- Game Setup and State Functions ---

        function setupGame() {
            updateLayoutConstants();
            // Initialize board with zeros
            board = Array(GRID_SIZE).fill(0).map(()=>Array(GRID_SIZE).fill(0));
            isGameOver = false;
            messageElement.classList.add('hidden');
            messageElement.textContent = '';

            boardElement.innerHTML = '';
            createEmptyTiles(); // Create the static background grid

            // Spawn 4 initial tiles for a harder start
            for (let i=0;i<4;i++) spawnTile();

            // Draw the final initial state with a small delay for correct layout calculation
            setTimeout(()=> drawBoard(true), 80);
        }

        function spawnTile() {
            if (isBoardFull()) return;
            let r,c;
            // Find a random empty spot
            do { r = Math.floor(Math.random()*GRID_SIZE); c = Math.floor(Math.random()*GRID_SIZE); }
            while (board[r][c] !== 0);

            // HARDER: 60% chance for '2', 40% for '4'
            board[r][c] = Math.random() < 0.6 ? 2 : 4; 
        }

        function isBoardFull() {
            return board.every(row => row.every(v=>v!==0));
        }

        function checkGameOver() {
            if (!isBoardFull()) return false;
            // Check if any legal move is possible (adjacent tiles with same value)
            for (let r=0;r<GRID_SIZE;r++){
                for (let c=0;c<GRID_SIZE;c++){
                    const cur = board[r][c];
                    // Check right
                    if (c < GRID_SIZE-1 && board[r][c+1] === cur) return false;
                    // Check down
                    if (r < GRID_SIZE-1 && board[r+1][c] === cur) return false;
                }
            }
            
            isGameOver = true;
            messageElement.textContent = "GAME OVER! No more moves.";
            messageElement.classList.remove('hidden');
            return true;
        }

        // --- Game Logic (Move and Merge) ---

        // The core logic for moving and merging a single line (row or column)
        const moveLine = (line) => {
            let nonZero = line.filter(v=>v!==0);
            let mergedIndices = []; // Keep track of logical merge spots
            
            // Perform merges
            for (let i=0;i<nonZero.length-1;i++){
                if (nonZero[i] === nonZero[i+1]) {
                    nonZero[i] *= 2;
                    nonZero[i+1] = 0; // The source tile is zeroed out
                    mergedIndices.push(i); // record the position where the merge happened
                }
            }
            
            // Re-filter out the zeros from the consumed tiles
            nonZero = nonZero.filter(v=>v!==0);
            
            // Pad the line with zeros
            let zeros = Array(GRID_SIZE - nonZero.length).fill(0);
            
            // Return the new line, respecting the slide direction (left/up or right/down)
            return {
                line: (line.length === 0 || line[0] === 0) ? [...zeros, ...nonZero] : [...nonZero, ...zeros],
                mergedIndices // Not fully used in this simple implementation but useful for advanced animation mapping
            };
        };


        async function handleMove(direction) {
            if (isGameOver || isMoving) return;
            isMoving = true;

            const oldBoard = board.map(row => [...row]);
            let hasMoved = false;

            // 1. Extract lines (rows or columns) based on direction
            const lines = [];
            if (direction === 'up' || direction === 'down') {
                for (let c=0;c<GRID_SIZE;c++){
                    const col = [];
                    for (let r=0;r<GRID_SIZE;r++) col.push(board[r][c]);
                    lines.push(col);
                }
            } else { // 'left' or 'right'
                for (let r=0;r<GRID_SIZE;r++){
                    lines.push([...board[r]]);
                }
            }

            // 2. Process and move each line
            const newLines = [];
            for (let line of lines){
                let reversed = (direction === 'right' || direction === 'down');
                // Reverse line if sliding right/down to process merges correctly
                if (reversed) line.reverse(); 
                
                const res = moveLine(line);
                let newLine = res.line.slice();
                
                // Reverse the line back to original orientation
                if (reversed) newLine.reverse(); 
                newLines.push(newLine);
            }

            // 3. Write lines back to the board and check if any movement occurred
            if (direction === 'up' || direction === 'down') {
                for (let c=0;c<GRID_SIZE;c++){
                    for (let r=0;r<GRID_SIZE;r++){
                        if (board[r][c] !== newLines[c][r]) hasMoved = true;
                        board[r][c] = newLines[c][r];
                    }
                }
            } else { // 'left' or 'right'
                for (let r=0;r<GRID_SIZE;r++){
                    for (let c=0;c<GRID_SIZE;c++){
                        if (board[r][c] !== newLines[r][c]) hasMoved = true;
                        board[r][c] = newLines[r][c];
                    }
                }
            }

            // 4. Handle Post-Move sequence
            if (hasMoved) {
                // Animate movement, using oldBoard to track which tiles moved/merged
                await drawBoard(false, oldBoard); 
                
                // Wait for animations to run before spawning new tile
                await new Promise(res => setTimeout(res, 520)); 

                spawnTile();
                drawBoard(true); // Final draw with new tile

                // Check for win condition
                if (board.some(row => row.includes(24))) {
                    messageElement.textContent = "YOU WON! Target 24 achieved!";
                    messageElement.classList.remove('hidden');
                    isGameOver = true;
                }
            }

            checkGameOver();
            isMoving = false;
        }

        // --- Drawing and Animation Functions ---

        // Creates the four static background cells
        function createEmptyTiles(){
            for (let r=0;r<GRID_SIZE;r++){
                for (let c=0;c<GRID_SIZE;c++){
                    const id = `empty-tile-${r}-${c}`;
                    if (document.getElementById(id)) continue;
                    const tile = document.createElement('div');
                    tile.id = id;
                    // Class tile-0 is the styling for the empty cell
                    tile.className = `tile-container ${getTileClass(0)}`; 
                    boardElement.appendChild(tile);
                }
            }
        }

        // Creates a value tile element
        function createTileElement(r,c,value,isNew=false){
            const tile = document.createElement('div');
            tile.id = `tile-${Math.random().toString(36).slice(2,9)}`; 
            tile.dataset.value = value;
            tile.dataset.r = r;
            tile.dataset.c = c;

            const pos = getTilePosition(r,c);
            tile.style.left = `${pos.left}px`;
            tile.style.top  = `${pos.top}px`;

            tile.className = `tile-container value-tile ${getTileClass(value)} shadow-md`;
            tile.style.width = `${TILE_SIZE}px`;
            tile.style.height = `${TILE_SIZE}px`;

            const span = document.createElement('span');
            span.className = 'tile-value';
            span.textContent = value;
            tile.appendChild(span);

            // Initial appearance animation for new tiles
            if (isNew) {
                tile.style.transform = 'scale(0)';
                setTimeout(()=> tile.style.transform = 'scale(1)', 20);
            }
            return tile;
        }

        // Finds the physical DOM tile element at a given position
        function findRealTileAt(r,c) {
            return boardElement.querySelector(`.value-tile[data-r="${r}"][data-c="${c}"]`);
        }
        
        // Searches the new board state for a tile that equals old tile value * 2
        function findMergeTarget(oldValue, newBoard) {
            for (let r=0;r<GRID_SIZE;r++){
                for (let c=0;c<GRID_SIZE;c++){
                    // A simple check is sufficient for 2048-style logic
                    if (newBoard[r][c] === oldValue * 2) { 
                        return [r,c];
                    }
                }
            }
            return null;
        }


        async function drawBoard(isFinalDraw=false, oldBoard=null){
            const occupiedPositions = new Set();
            const tilesToKeep = new Set();

            // 1. Update/create tiles for the *new* state
            for (let r=0;r<GRID_SIZE;r++){
                for (let c=0;c<GRID_SIZE;c++){
                    const value = board[r][c];
                    if (value > 0) {
                        const tilePosKey = `${r},${c}`;
                        occupiedPositions.add(tilePosKey);
                        let existingTile = findRealTileAt(r,c);
                        
                        if (!existingTile) {
                            // If a tile should be here but isn't (it's a new spawn)
                            const el = createTileElement(r,c,value,isFinalDraw);
                            boardElement.appendChild(el);
                            tilesToKeep.add(el);
                        } else {
                            // Update existing tile
                            tilesToKeep.add(existingTile);
                            existingTile.dataset.value = value;
                            const span = existingTile.querySelector('.tile-value');
                            if (span) span.textContent = value;

                            // Update classes for color changes
                            existingTile.className = existingTile.className.split(' ').filter(cl => !cl.startsWith('tile-')).join(' ');
                            existingTile.classList.add(getTileClass(value),'value-tile','shadow-md');
                            
                            // Set final position (this triggers the move animation if coordinates changed)
                            const pos = getTilePosition(r,c);
                            existingTile.style.left = `${pos.left}px`;
                            existingTile.style.top = `${pos.top}px`;

                            // If this tile is a merge target, add the 'pop' class
                            if(oldBoard && oldBoard[r][c] !== value) {
                                existingTile.classList.add('fusing-target');
                                setTimeout(() => existingTile.classList.remove('fusing-target'), 400);
                            }
                        }
                    }
                }
            }

            // 2. Animate and remove orphaned tiles (tiles that moved or merged away)
            Array.from(boardElement.querySelectorAll('.value-tile')).forEach(tile => {
                // If we've processed this tile in the update loop, skip it
                if (tilesToKeep.has(tile)) return; 
                
                const oldR = parseInt(tile.dataset.r);
                const oldC = parseInt(tile.dataset.c);
                const oldValue = parseInt(tile.dataset.value);

                // If this is not the final draw, look for a merge target for the magnet animation
                if (oldBoard && !isFinalDraw) {
                    const possibleTarget = findMergeTarget(oldValue, board);
                    
                    // Check if this tile was a source that moved to merge with the target
                    if (possibleTarget) {
                        const [tR,tC] = possibleTarget;
                        const targetPos = getTilePosition(tR,tC);
                        
                        // Apply magnet animation
                        tile.classList.add('magnet-source');
                        tile.style.left = `${targetPos.left}px`;
                        tile.style.top  = `${targetPos.top}px`;
                        
                        // Remove tile after animation finishes
                        setTimeout(()=> { tile.remove(); }, 480);
                        return;
                    }
                }
                
                // If not merging/animating, just remove the tile (it moved off-screen or was an old tile that didn't move)
                tile.remove();
            });
        }


        // --- Input Controls (Drag/Swipe) ---

        function setupMouseControls() {
            boardElement.addEventListener('mousedown', handleDragStart, false);
            document.addEventListener('mouseup', handleDragEnd, false);
            boardElement.addEventListener('touchstart', handleDragStart, false);
            document.addEventListener('touchend', handleDragEnd, false);
        }

        function handleDragStart(event){
            if (isMoving || isGameOver) return;
            // Get touch or mouse coordinates
            const clientX = event.touches ? event.touches[0].clientX : event.clientX;
            const clientY = event.touches ? event.touches[0].clientY : event.clientY;
            touchstartX = clientX; touchstartY = clientY;
            // Prevent default scrolling/browser actions on touch devices
            if (event.cancelable && event.type.startsWith('touch')) event.preventDefault(); 
        }

        function handleDragEnd(event){
            if (isMoving || isGameOver) return;
            
            // Get end coordinates
            const touchendX = event.changedTouches ? event.changedTouches[0].clientX : event.clientX;
            const touchendY = event.changedTouches ? event.changedTouches[0].clientY : event.clientY;
            const diffX = touchendX - touchstartX;
            const diffY = touchendY - touchstartY;
            
            // Reset start coordinates
            touchstartX = 0; touchstartY = 0;
            
            // Ignore small movements
            if (Math.abs(diffX) < MIN_DRAG_DISTANCE && Math.abs(diffY) < MIN_DRAG_DISTANCE) return;
            
            let direction = null;
            
            // Determine the dominant direction
            if (Math.abs(diffX) > Math.abs(diffY)) {
                direction = diffX > 0 ? 'right' : 'left';
            } else {
                direction = diffY > 0 ? 'down' : 'up';
            }
            
            if (direction) handleMove(direction);
        }

        // --- Utility Functions ---

        // Sets up the decorative math symbols in the background
        function setupMathBackground(){
            const symbols = ['Σ','∫','∂','π','√','x²','log','∞','Δ','θ','=','≥','∑','f(x)','eˣ'];
            const bg = document.getElementById('math-background');
            const total = 60;
            for (let i=0;i<total;i++){
                const s = document.createElement('div');
                s.className = 'math-symbol';
                s.innerHTML = symbols[Math.floor(Math.random()*symbols.length)];
                
                // Randomize position, size, and animation
                s.style.left = `${Math.random()*100}vw`;
                const size = (Math.random()*1.6 + 0.8).toFixed(2);
                s.style.fontSize = `${size}rem`;
                s.style.animationDelay = `${Math.random()*8}s`;
                s.style.animationDuration = `${Math.random()*18 + 14}s`; // Slower duration for a 'dreamy' fall
                s.style.opacity = (Math.random()*0.4 + 0.05);
                bg.appendChild(s);
            }
        }

        function showHint() {
            messageElement.textContent = "Hint: Try to fuse the two equal tiles into a center — watch them slowly pull together.";
            messageElement.classList.remove('hidden');
            setTimeout(()=> messageElement.classList.add('hidden'), 2400);
        }

        // --- Initialization ---

        window.onload = () => {
            setupMathBackground();
            updateLayoutConstants();
            setupGame();
            setupMouseControls();
            window.addEventListener('resize', updateLayoutConstants);
        };
    </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Epic Stickman Fight</title>
<style>
  body {
    margin: 0; background: #111; display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100vh;
    color: #eee; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
  }
  canvas {
    background: #222; border-radius: 12px; box-shadow: 0 0 15px #0f0;
    display: block;
  }
  #startBtn {
    margin-top: 15px;
    padding: 10px 20px;
    font-size: 1.2rem;
    border: 2px solid #0f0;
    background: transparent;
    color: #0f0;
    border-radius: 8px;
    cursor: pointer;
    transition: all 0.3s ease;
  }
  #startBtn:hover {
    background: #0f0;
    color: #111;
  }
</style>
</head>
<body>

<canvas id="fightCanvas" width="900" height="450"></canvas>
<button id="startBtn">Start Fight</button>

<script>
(() => {
  const canvas = document.getElementById('fightCanvas');
  const ctx = canvas.getContext('2d');
  const W = canvas.width;
  const H = canvas.height;

  // --- Utility functions ---
  function lerp(a, b, t) { return a + (b - a) * t; }
  function clamp(v, min, max) { return Math.min(max, Math.max(min, v)); }
  function randRange(min, max) { return Math.random() * (max - min) + min; }
  function easeOutQuad(t) { return t * (2 - t); }
  function easeInOutQuad(t) { return t < 0.5 ? 2*t*t : -1+(4-2*t)*t; }

  // --- Camera Shake ---
  class Camera {
    constructor() {
      this.shakeDuration = 0;
      this.shakeIntensity = 0;
      this.zoom = 1;
      this.zoomTarget = 1;
      this.zoomSpeed = 0.1;
      this.offsetX = 0;
      this.offsetY = 0;
    }
    shake(intensity, duration) {
      this.shakeIntensity = intensity;
      this.shakeDuration = duration;
    }
    update(dt) {
      if(this.shakeDuration > 0){
        this.shakeDuration -= dt;
        this.offsetX = (Math.random() - 0.5) * this.shakeIntensity;
        this.offsetY = (Math.random() - 0.5) * this.shakeIntensity;
      } else {
        this.offsetX = 0;
        this.offsetY = 0;
      }
      // smooth zoom reset
      this.zoom += (this.zoomTarget - this.zoom) * this.zoomSpeed;
    }
  }

  // --- Vector2 ---
  class Vec2 {
    constructor(x=0,y=0){this.x=x;this.y=y;}
    set(x,y){this.x=x;this.y=y;return this;}
    copy(){return new Vec2(this.x,this.y);}
    add(v){this.x+=v.x;this.y+=v.y;return this;}
    sub(v){this.x-=v.x;this.y-=v.y;return this;}
    mul(s){this.x*=s;this.y*=s;return this;}
    length(){return Math.sqrt(this.x*this.x+this.y*this.y);}
    normalize(){let len=this.length();if(len>0){this.x/=len;this.y/=len;}return this;}
  }

  // --- Stickman Limb ---
  class Limb {
    constructor(length, angle=0) {
      this.length = length;
      this.angle = angle;
      this.rotationSpeed = 0;
      this.targetAngle = angle;
    }
    update(dt) {
      const diff = this.targetAngle - this.angle;
      this.angle += diff * dt * 8;
    }
  }

  // --- Weapon Trail Effect ---
  class Trail {
    constructor(color) {
      this.points = [];
      this.color = color;
      this.maxLength = 10;
    }
    addPoint(pos) {
      this.points.push({...pos});
      if(this.points.length > this.maxLength) this.points.shift();
    }
    draw(ctx) {
      if(this.points.length < 2) return;
      ctx.save();
      ctx.lineJoin = 'round';
      ctx.lineCap = 'round';
      for(let i=0; i<this.points.length-1; i++){
        let p0 = this.points[i];
        let p1 = this.points[i+1];
        let alpha = (i / this.points.length);
        ctx.strokeStyle = `rgba(${this.color.r},${this.color.g},${this.color.b},${alpha*0.6})`;
        ctx.lineWidth = lerp(10, 2, alpha);
        ctx.beginPath();
        ctx.moveTo(p0.x, p0.y);
        ctx.lineTo(p1.x, p1.y);
        ctx.stroke();
      }
      ctx.restore();
    }
  }

  // --- Stickman ---
  class Stickman {
    constructor(x, color, weaponType) {
      this.pos = new Vec2(x, H - 120);
      this.vel = new Vec2();
      this.color = color;
      this.weaponType = weaponType; // 'claw' or 'dagger'
      this.health = 100;
      this.maxHealth = 100;
      this.facing = 1; // 1 = right, -1 = left
      this.animTimer = 0;
      this.state = 'idle'; // idle, run, attack1, attack2, jump, dodge, hit
      this.attackTimer = 0;
      this.comboStage = 0;
      this.comboCooldown = 0;

      // Body parts lengths (px)
      this.limbs = {
        upperArmL: new Limb(35, -0.5),
        lowerArmL: new Limb(30, -0.7),
        upperArmR: new Limb(35, -0.5),
        lowerArmR: new Limb(30, -0.7),
        upperLegL: new Limb(40, 1.5),
        lowerLegL: new Limb(40, 1.7),
        upperLegR: new Limb(40, 1.5),
        lowerLegR: new Limb(40, 1.7),
        neck: new Limb(30, 0), // long neck for green with scarf waving
        headRadius: 12,
        bodyHeight: 60,
      };

      this.attackHitFrame = 8;
      this.hasHit = false;

      // Trail for weapons
      this.trailL = new Trail(color);
      this.trailR = new Trail(color);

      // Scarf animation (green only)
      this.scarfOffset = 0;
      this.scarfSpeed = randRange(3,5);

      this.isHit = false;
      this.hitFlashTimer = 0;

      // AI target
      this.target = null;
    }

    update(dt) {
      this.animTimer += dt*6;
      this.comboCooldown = Math.max(0, this.comboCooldown - dt);

      // Scarf sway if green
      if(this.color.g > 200) {
        this.scarfOffset = Math.sin(Date.now()/200)*5;
      }

      this.updateState(dt);
      this.updateLimbs(dt);

      if(this.hitFlashTimer > 0) this.hitFlashTimer -= dt;
      else this.isHit = false;
    }

    updateState(dt) {
      // Apply gravity if in the air
      if (this.pos.y < H - 120) {
        this.vel.y += 700 * dt;
      }
      
      this.pos.x += this.vel.x * dt * 200;
      this.pos.y += this.vel.y * dt;

      // Ground collision
      if (this.pos.y >= H - 120) {
        this.pos.y = H - 120;
        this.vel.y = 0;
        if (this.state === 'jump') {
            this.state = 'idle';
        }
      }

      // State transitions based on velocity
      if (this.state === 'idle' || this.state === 'run') {
        if (Math.abs(this.vel.x) > 0.1) {
            this.state = 'run';
        } else {
            this.state = 'idle';
        }
      }

      switch(this.state){
        case 'attack1':
        case 'attack2':
          this.attackTimer += dt*15;
          if(this.attackTimer > 1) {
            this.attackTimer = 0;
            this.comboStage++;
            if(this.comboStage > 2 || Math.random() > 0.7){ // Randomly end combo
              this.comboStage = 0;
              this.state = 'idle';
            }
          }
          break;
        case 'dodge':
          this.pos.x += this.vel.x * dt * 400;
          this.attackTimer += dt*10;
          if(this.attackTimer > 0.6) {
            this.attackTimer = 0;
            this.state = 'idle';
          }
          break;
        case 'hit':
          this.attackTimer += dt;
          if(this.attackTimer > 0.5) {
            this.attackTimer = 0;
            this.state = 'idle';
            this.isHit = false;
          }
          break;
      }
    }

    startAttack() {
      if((this.state === 'idle' || this.state === 'run') && this.comboCooldown <= 0){
        this.state = 'attack1';
        this.attackTimer = 0;
        this.comboStage = 0;
        this.hasHit = false;
        this.comboCooldown = 0.5;
      } else if((this.state === 'attack1' || this.state === 'attack2') && this.attackTimer > 0.3 && this.comboCooldown <= 0){
        this.state = this.state === 'attack1' ? 'attack2' : 'attack1';
        this.attackTimer = 0;
        this.hasHit = false;
        this.comboCooldown = 0.5;
      }
    }
    
    startJump() {
        if(this.pos.y >= H - 120 && (this.state === 'idle' || this.state === 'run')){
            this.state = 'jump';
            this.vel.y = -400; // Jump velocity
        }
    }

    getHandPos(side) {
      const dir = this.facing;
      const baseX = this.pos.x;
      const baseY = this.pos.y - this.limbs.bodyHeight;

      const upperArm = side === 'L' ? this.limbs.upperArmL : this.limbs.upperArmR;
      const lowerArm = side === 'L' ? this.limbs.lowerArmL : this.limbs.lowerArmR;

      const shoulderX = baseX + dir * 15 * (side === 'L' ? -1 : 1);
      const shoulderY = baseY + 10;

      const uaX = shoulderX + Math.cos(upperArm.angle) * upperArm.length * dir;
      const uaY = shoulderY + Math.sin(upperArm.angle) * upperArm.length;

      const handX = uaX + Math.cos(lowerArm.angle) * lowerArm.length * dir;
      const handY = uaY + Math.sin(lowerArm.angle) * lowerArm.length;

      return {x: handX, y: handY};
    }

    updateLimbs(dt) {
      let t = this.animTimer % (Math.PI * 2);

      // Legs movement for walking/running
      let legAngle = Math.sin(t) * 0.6;
      let legAngle2 = Math.cos(t) * 0.6;
      let bodyOffset = 0;

      if(this.state === 'run') {
        this.limbs.upperLegL.targetAngle = 1.5 + legAngle;
        this.limbs.lowerLegL.targetAngle = 1.7 + Math.abs(legAngle);
        this.limbs.upperLegR.targetAngle = 1.5 + legAngle2;
        this.limbs.lowerLegR.targetAngle = 1.7 + Math.abs(legAngle2);
        bodyOffset = Math.sin(t*2)*2;
      } else if (this.state === 'jump') {
        this.limbs.upperLegL.targetAngle = 1;
        this.limbs.lowerLegL.targetAngle = 2;
        this.limbs.upperLegR.targetAngle = 1;
        this.limbs.lowerLegR.targetAngle = 2;
      } else {
        this.limbs.upperLegL.targetAngle = 1.5;
        this.limbs.lowerLegL.targetAngle = 1.7;
        this.limbs.upperLegR.targetAngle = 1.5;
        this.limbs.lowerLegR.targetAngle = 1.7;
      }

      this.pos.y += bodyOffset; // subtle bobbing

      if(this.state.startsWith('attack')){
        let atkProgress = (this.attackTimer % 1);
        let swing = easeOutQuad(atkProgress) * -2.0;

        if(this.comboStage === 0){
          this.limbs.upperArmR.targetAngle = -0.5 + swing;
          this.limbs.lowerArmR.targetAngle = -0.7 + swing/2;
          this.limbs.upperArmL.targetAngle = -0.5 - swing/2;
          this.limbs.lowerArmL.targetAngle = -0.7 - swing/4;
        } else {
          this.limbs.upperArmL.targetAngle = -0.5 + swing;
          this.limbs.lowerArmL.targetAngle = -0.7 + swing/2;
          this.limbs.upperArmR.targetAngle = -0.5 - swing/2;
          this.limbs.lowerArmR.targetAngle = -0.7 - swing/4;
        }
      } else if(this.state === 'dodge') {
        this.limbs.upperArmL.targetAngle = -1;
        this.limbs.lowerArmL.targetAngle = -1;
        this.limbs.upperArmR.targetAngle = -1;
        this.limbs.lowerArmR.targetAngle = -1;
      } else {
        this.limbs.upperArmL.targetAngle = -0.5 + Math.sin(t) * 0.1;
        this.limbs.lowerArmL.targetAngle = -0.7 + Math.sin(t) * 0.05;
        this.limbs.upperArmR.targetAngle = -0.5 - Math.sin(t) * 0.1;
        this.limbs.lowerArmR.targetAngle = -0.7 - Math.sin(t) * 0.05;
      }

      this.limbs.neck.targetAngle = 0.1 * Math.sin(t*2);

      for(let key in this.limbs){
        if(this.limbs[key].update) this.limbs[key].update(dt);
      }
    }

    draw(ctx) {
      ctx.save();
      ctx.translate(this.pos.x, this.pos.y);

      const barW = 140;
      const barH = 14;
      ctx.fillStyle = '#222';
      ctx.fillRect(-barW/2, -this.limbs.bodyHeight - 80, barW, barH);
      ctx.fillStyle = this.colorToHex(this.color);
      ctx.fillRect(-barW/2, -this.limbs.bodyHeight - 80, barW * (this.health/this.maxHealth), barH);
      ctx.strokeStyle = '#000';
      ctx.lineWidth = 2;
      ctx.strokeRect(-barW/2, -this.limbs.bodyHeight - 80, barW, barH);

      if(this.isHit){
        ctx.fillStyle = 'rgba(255,255,255,' + Math.min(0.6, this.hitFlashTimer * 3) + ')';
        ctx.fillRect(-100, -this.limbs.bodyHeight - 100, 200, 250);
      }

      if(this.color.g > 200) {
        ctx.save();
        ctx.strokeStyle = this.colorToHex(this.color);
        ctx.lineWidth = 5;
        ctx.lineCap = 'round';

        ctx.beginPath();
        ctx.moveTo(0, -this.limbs.bodyHeight);
        ctx.lineTo(0, -this.limbs.bodyHeight - this.limbs.neck.length);
        ctx.stroke();

        ctx.lineWidth = 8;
        ctx.strokeStyle = 'lime';
        ctx.shadowColor = 'lime';
        ctx.shadowBlur = 10;
        ctx.beginPath();
        ctx.moveTo(0, -this.limbs.bodyHeight - this.limbs.neck.length);
        const scarfX = Math.sin(Date.now()/200)*8;
        ctx.lineTo(scarfX, -this.limbs.bodyHeight - this.limbs.neck.length + 30);
        ctx.stroke();
        ctx.restore();
      }

      ctx.strokeStyle = this.colorToHex(this.color);
      ctx.lineWidth = 6;
      ctx.lineCap = 'round';
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(0, -this.limbs.bodyHeight);
      ctx.stroke();

      ctx.fillStyle = this.colorToHex(this.color);
      ctx.beginPath();
      ctx.arc(0, -this.limbs.bodyHeight - this.limbs.headRadius, this.limbs.headRadius, 0, Math.PI * 2);
      ctx.fill();

      this.drawLimb(ctx, 0, 0, this.limbs.upperLegL.angle, this.limbs.lowerLegL.angle, -15);
      this.drawLimb(ctx, 0, 0, this.limbs.upperLegR.angle, this.limbs.lowerLegR.angle, 15);

      this.drawArmAndWeapon(ctx, 'L');
      this.drawArmAndWeapon(ctx, 'R');

      ctx.restore();
    }

    drawLimb(ctx, baseX, baseY, upperAngle, lowerAngle, offsetX) {
      ctx.save();
      ctx.translate(offsetX, 0);
      ctx.strokeStyle = this.colorToHex(this.color);
      ctx.lineWidth = 6;
      ctx.lineCap = 'round';

      ctx.beginPath();
      ctx.moveTo(0, 0);
      let upperEndX = Math.cos(upperAngle) * this.limbs.upperLegL.length;
      let upperEndY = Math.sin(upperAngle) * this.limbs.upperLegL.length;
      ctx.lineTo(upperEndX, upperEndY);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(upperEndX, upperEndY);
      let lowerEndX = upperEndX + Math.cos(lowerAngle) * this.limbs.lowerLegL.length;
      let lowerEndY = upperEndY + Math.sin(lowerAngle) * this.limbs.lowerLegL.length;
      ctx.lineTo(lowerEndX, lowerEndY);
      ctx.stroke();

      ctx.restore();
    }

    drawArmAndWeapon(ctx, side) {
      const dir = this.facing;
      const upperArm = side === 'L' ? this.limbs.upperArmL : this.limbs.upperArmR;
      const lowerArm = side === 'L' ? this.limbs.lowerArmL : this.limbs.lowerArmR;

      const shoulderX = dir * 15 * (side === 'L' ? -1 : 1);
      const shoulderY = -this.limbs.bodyHeight + 10;

      ctx.save();
      ctx.translate(shoulderX, shoulderY);
      ctx.strokeStyle = this.colorToHex(this.color);
      ctx.lineWidth = 6;
      ctx.lineCap = 'round';

      ctx.beginPath();
      ctx.moveTo(0, 0);
      let upperEndX = Math.cos(upperArm.angle) * upperArm.length * dir;
      let upperEndY = Math.sin(upperArm.angle) * upperArm.length;
      ctx.lineTo(upperEndX, upperEndY);
      ctx.stroke();

      ctx.translate(upperEndX, upperEndY);
      ctx.beginPath();
      ctx.moveTo(0, 0);
      let lowerEndX = Math.cos(lowerArm.angle) * lowerArm.length * dir;
      let lowerEndY = Math.sin(lowerArm.angle) * lowerArm.length;
      ctx.lineTo(lowerEndX, lowerEndY);
      ctx.stroke();

      ctx.translate(lowerEndX, lowerEndY);
      if(this.weaponType === 'claw'){
        this.drawClaw(ctx, side);
      } else if(this.weaponType === 'dagger'){
        this.drawDagger(ctx, side);
      }
      ctx.restore();

      const handPos = this.getHandPos(side);
      if(side === 'L') this.trailL.addPoint(handPos);
      else this.trailR.addPoint(handPos);

      if(side === 'L') this.trailL.draw(ctx);
      else this.trailR.draw(ctx);
    }

    drawClaw(ctx, side) {
      ctx.save();
      ctx.strokeStyle = 'lime';
      ctx.fillStyle = 'rgba(0,255,0,0.8)';
      ctx.lineWidth = 3;
      ctx.shadowColor = 'lime';
      ctx.shadowBlur = 12;
      ctx.lineCap = 'round';

      const clawOffsets = [-10, 0, 10];
      for(let offset of clawOffsets){
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.quadraticCurveTo(offset/2, -15, offset, -30);
        ctx.stroke();
      }
      ctx.restore();
    }

    drawDagger(ctx, side) {
      ctx.save();
      ctx.fillStyle = 'cyan';
      ctx.strokeStyle = 'cyan';
      ctx.lineWidth = 2;
      ctx.shadowColor = 'cyan';
      ctx.shadowBlur = 10;

      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(6, -20);
      ctx.lineTo(-6, -20);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();

      ctx.beginPath();
      ctx.rect(-3, 0, 6, 8);
      ctx.fill();
      ctx.stroke();
      ctx.restore();
    }

    takeHit(damage) {
      this.health = clamp(this.health - damage, 0, this.maxHealth);
      this.state = 'hit';
      this.isHit = true;
      this.hitFlashTimer = 0.5;
    }

    colorToHex(color) {
      return `rgb(${color.r},${color.g},${color.b})`;
    }
  }

  // --- Impact Effects ---
  class ImpactFlash {
    constructor() {
      this.active = false;
      this.timer = 0;
      this.duration = 0.15;
      this.alpha = 0;
    }
    trigger() {
      this.active = true;
      this.timer = this.duration;
    }
    update(dt) {
      if(this.active) {
        this.timer -= dt;
        if(this.timer <= 0) {
          this.active = false;
          this.alpha = 0;
        } else {
          this.alpha = this.timer / this.duration;
        }
      }
    }
    draw(ctx) {
      if(this.active) {
        ctx.save();
        ctx.fillStyle = `rgba(255,255,255,${this.alpha * 0.7})`;
        ctx.fillRect(0, 0, W, H);
        ctx.restore();
      }
    }
  }

  // --- AI Controller ---
  class AIController {
    constructor(stickman, opponent, personality = 'aggressive') {
      this.stickman = stickman;
      this.opponent = opponent;
      this.actionTimer = 0;
      this.state = 'idle';
      this.cooldowns = {
        attack: 0,
        dodge: 0,
        jump: 0,
      };
      this.personality = personality; // 'aggressive' or 'defensive'
    }

    update(dt) {
      // Reduce cooldowns
      for (const key in this.cooldowns) {
          this.cooldowns[key] = Math.max(0, this.cooldowns[key] - dt);
      }
      
      const dist = this.opponent.pos.x - this.stickman.pos.x;
      const absDist = Math.abs(dist);
      const isFacingOpponent = (dist > 0 && this.stickman.facing === 1) || (dist < 0 && this.stickman.facing === -1);
      
      this.stickman.facing = dist > 0 ? 1 : -1;

      // Always check for a dodge first if a hit is coming
      if (this.shouldDodge(dist)) {
          this.doDodge(dist);
      } 
      // If we're not dodging, decide on a primary action
      else if (this.stickman.state === 'idle' || this.stickman.state === 'run' || this.stickman.state === 'jump') {
          if (absDist < 100) {
              // Close range: attack or retreat
              if (this.shouldAttack()) {
                  this.doAttack();
              } else if (this.shouldRetreat(dist)) {
                  this.doRetreat(dist);
              }
          } else if (absDist < 300) {
              // Medium range: approach or jump
              if (Math.random() < 0.2 && this.cooldowns.jump <= 0) {
                  this.doJump(dist);
              } else {
                  this.doApproach(dist);
              }
          } else {
              // Long range: approach
              this.doApproach(dist);
          }
      }
    }

    shouldDodge(dist) {
      if (this.cooldowns.dodge > 0) return false;
      const opponentAttackState = this.opponent.state.startsWith('attack');
      const isOpponentClose = Math.abs(dist) < 80;
      
      if (opponentAttackState && isOpponentClose) {
        // High chance to dodge when a nearby opponent is attacking
        return Math.random() > 0.3;
      }
      return false;
    }
    
    doDodge(dist) {
      this.stickman.state = 'dodge';
      this.stickman.vel.x = -this.stickman.facing * 1.5; // Dodge backwards
      this.cooldowns.dodge = 1;
    }
    
    shouldAttack() {
        if (this.cooldowns.attack > 0) return false;
        // Aggressive stickmen attack more often
        const attackChance = this.personality === 'aggressive' ? 0.8 : 0.4;
        return Math.random() < attackChance;
    }

    doAttack() {
        this.stickman.startAttack();
        this.cooldowns.attack = randRange(0.5, 1);
    }
    
    shouldRetreat(dist) {
      if (this.personality === 'defensive' && this.stickman.health < 50) {
        return Math.random() > 0.5; // High chance to retreat if defensive and low on health
      }
      return false;
    }

    doRetreat(dist) {
      this.stickman.state = 'run';
      this.stickman.vel.x = -this.stickman.facing * 1.2;
    }

    doApproach(dist) {
        this.stickman.state = 'run';
        this.stickman.vel.x = this.stickman.facing * 1;
    }
    
    doJump(dist) {
        this.stickman.startJump();
        this.cooldowns.jump = randRange(1.5, 3);
    }
  }

  // --- Main fight class ---
  class Fight {
    constructor() {
      this.stickmanGreen = new Stickman(250, {r:0,g:255,b:0}, 'claw');
      this.stickmanBlue = new Stickman(650, {r:0,g:180,b:255}, 'dagger');
      this.stickmanGreen.facing = 1;
      this.stickmanBlue.facing = -1;

      // New AI controllers with personalities
      this.aiGreen = new AIController(this.stickmanGreen, this.stickmanBlue, 'aggressive');
      this.aiBlue = new AIController(this.stickmanBlue, this.stickmanGreen, 'defensive');

      this.impactFlash = new ImpactFlash();

      this.camera = new Camera();
      this.slowMotionTimer = 0;
      this.comboHits = 0;

      this.lastTime = 0;
      this.running = false;
      this.gameOver = false;
    }

    start() {
      this.running = true;
      this.lastTime = performance.now();
      requestAnimationFrame(this.loop.bind(this));
    }

    loop(t) {
      if(!this.running) return;
      let dt = (t - this.lastTime) / 1000;
      dt = Math.min(dt, 0.016); // cap delta time to prevent physics glitches

      if(this.slowMotionTimer > 0) {
        dt *= 0.3;
        this.slowMotionTimer -= (t - this.lastTime)/1000;
      }

      this.lastTime = t;
      this.update(dt);
      this.render();

      if(!this.gameOver) {
          requestAnimationFrame(this.loop.bind(this));
      } else {
          this.displayWinner();
      }
    }

    update(dt) {
      if(this.stickmanGreen.health <= 0 || this.stickmanBlue.health <= 0) {
          this.gameOver = true;
      }
      
      this.aiGreen.update(dt);
      this.aiBlue.update(dt);

      this.stickmanGreen.update(dt);
      this.stickmanBlue.update(dt);

      this.checkCollisions();

      this.impactFlash.update(dt);
      this.camera.update(dt);

      this.stickmanGreen.pos.x = clamp(this.stickmanGreen.pos.x, 60, W - 60);
      this.stickmanBlue.pos.x = clamp(this.stickmanBlue.pos.x, 60, W - 60);
    }

    checkCollisions() {
      [this.stickmanGreen, this.stickmanBlue].forEach((attacker, i) => {
        if(attacker.state.startsWith('attack')) {
          const defender = i === 0 ? this.stickmanBlue : this.stickmanGreen;
          const atkProgress = attacker.attackTimer;
          
          // Check for collision on the 'hit' frame
          if(Math.floor(atkProgress*15) === attacker.attackHitFrame && !attacker.hasHit){
            attacker.hasHit = true;
            
            const handL = attacker.getHandPos('L');
            const handR = attacker.getHandPos('R');
            
            // A simple circular collision check
            const distL = Math.sqrt(Math.pow(defender.pos.x - handL.x, 2) + Math.pow((defender.pos.y - defender.limbs.bodyHeight/2) - handL.y, 2));
            const distR = Math.sqrt(Math.pow(defender.pos.x - handR.x, 2) + Math.pow((defender.pos.y - defender.limbs.bodyHeight/2) - handR.y, 2));

            const hitRange = 60; // Increased hit range for more reliable hits
            
            if((distL < hitRange || distR < hitRange) && defender.state !== 'dodge') {
              defender.takeHit(15);
              this.triggerHitEffects(defender);
              
              // Push back on hit
              defender.vel.x += attacker.facing * 200;
              
              // Reset attacker combo for new hit
              attacker.comboCooldown = 0.1;
            }
          }
          if(atkProgress > 1) attacker.hasHit = false;
        }
      });
    }

    triggerHitEffects(defender) {
      this.impactFlash.trigger();
      this.camera.shake(10, 0.2);
      this.camera.zoomTarget = 1.15;
      this.slowMotionTimer = 0.25;
    }

    displayWinner() {
        ctx.save();
        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
        ctx.fillRect(0, 0, W, H);
        ctx.font = "bold 60px 'Segoe UI'";
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        
        if(this.stickmanGreen.health > this.stickmanBlue.health) {
            ctx.fillStyle = 'lime';
            ctx.fillText("Green Wins!", W/2, H/2);
        } else {
            ctx.fillStyle = 'cyan';
            ctx.fillText("Blue Wins!", W/2, H/2);
        }
        ctx.restore();
    }

    render() {
      ctx.clearRect(0,0,W,H);

      ctx.save();
      ctx.translate(this.camera.offsetX, this.camera.offsetY);
      ctx.scale(this.camera.zoom, this.camera.zoom);

      ctx.strokeStyle = '#0a0';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(0, H-60);
      ctx.lineTo(W, H-60);
      ctx.stroke();

      this.stickmanGreen.draw(ctx);
      this.stickmanBlue.draw(ctx);

      this.impactFlash.draw(ctx);

      ctx.restore();

      this.camera.zoomTarget = 1;
    }
  }

  // --- Initialization ---
  const fight = new Fight();

  document.getElementById('startBtn').addEventListener('click', () => {
    fight.start();
    document.getElementById('startBtn').style.display = 'none';
  });

})();
</script>

</body>
</html>

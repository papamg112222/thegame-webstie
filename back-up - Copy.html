<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Epic Stickman Fight: Green vs Blue</title>
<style>
  body {
    margin: 0;
    background: #111;
    color: #eee;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    display: flex;
    flex-direction: column;
    align-items: center;
    user-select: none;
  }
  canvas {
    background: #222;
    margin-top: 20px;
    border-radius: 8px;
    box-shadow: 0 0 12px #000 inset;
  }
  #startBtn {
    margin: 20px;
    padding: 10px 18px;
    font-size: 18px;
    background: #222;
    color: #8f8;
    border: 2px solid #0f0;
    border-radius: 6px;
    cursor: pointer;
    transition: background 0.3s, color 0.3s;
  }
  #startBtn:hover {
    background: #0f0;
    color: #111;
  }
  #victory {
    font-size: 28px;
    margin-top: 12px;
    color: #8f8;
    text-shadow: 0 0 8px #0f0;
  }
</style>
</head>
<body>
<canvas id="game" width="800" height="400"></canvas>
<button id="startBtn">Start Fight</button>
<div id="victory"></div>

<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const startBtn = document.getElementById('startBtn');
  const victoryDiv = document.getElementById('victory');

  const width = canvas.width;
  const height = canvas.height;
  const groundY = height - 50;

  // Stickman constants
  const stickmanHeight = 80;
  const stickmanWidth = 20;

  // Health bar constants
  const healthBarWidth = 150;
  const healthBarHeight = 14;

  // Game state
  let fightActive = false;

  // Utility lerp
  function lerp(start, end, t) {
    return start + (end - start) * t;
  }

  // Screen shake state
  let shakeMagnitude = 0;
  let shakeDecay = 0.9;
  let shakeX = 0;
  let shakeY = 0;

  // Stickman class
  class Stickman {
    constructor(x, color, weaponType) {
      this.x = x;
      this.y = groundY;
      this.color = color;
      this.health = 100;
      this.maxHealth = 100;
      this.facing = 1; // 1: right, -1: left
      this.state = 'idle'; // idle, attack, dodge, jump, hit
      this.attackFrame = 0;
      this.hitTimer = 0;
      this.velocityY = 0;
      this.onGround = true;

      this.weaponType = weaponType; // 'blades' or 'whip'

      this.attackCooldown = 0;
      this.dodgeCooldown = 0;
      this.jumpCooldown = 0;

      this.stunTime = 0;
      this.slowTime = 0;

      // For animation curves
      this.attackProgress = 0;

      // Weapon-specific properties
      if (weaponType === 'blades') {
        this.weaponGlowColor = 'limegreen';
      } else if (weaponType === 'whip') {
        this.weaponGlowColor = '#33ccff';
      }
    }

    // Reset stickman to start state
    reset(x, facing) {
      this.x = x;
      this.health = this.maxHealth;
      this.facing = facing;
      this.state = 'idle';
      this.attackFrame = 0;
      this.hitTimer = 0;
      this.velocityY = 0;
      this.onGround = true;
      this.attackCooldown = 0;
      this.dodgeCooldown = 0;
      this.jumpCooldown = 0;
      this.stunTime = 0;
      this.slowTime = 0;
      this.attackProgress = 0;
    }

    isAlive() {
      return this.health > 0;
    }

    // Simple AI decision
    decideAction(opponent) {
      if (!this.isAlive()) return;
      if (this.stunTime > 0) return; // stunned - no actions
      if (this.attackCooldown > 0 || this.state === 'attack') return;
      if (this.dodgeCooldown > 0 || this.state === 'dodge') return;
      if (this.jumpCooldown > 0 || this.state === 'jump') return;

      let dist = opponent.x - this.x;

      if (Math.abs(dist) < 60) {
        // Close range: attack or dodge
        if (Math.random() < 0.6) {
          this.startAttack();
        } else {
          this.startDodge();
        }
      } else {
        // Mid range: approach or jump forward
        if (Math.random() < 0.7) {
          this.approach(opponent);
        } else {
          this.startJump();
        }
      }
    }

    approach(opponent) {
      let dir = opponent.x > this.x ? 1 : -1;
      this.facing = dir;
      let speed = this.slowTime > 0 ? 1.5 : 3;
      this.x += dir * speed;
    }

    startAttack() {
      this.state = 'attack';
      this.attackFrame = 0;
      this.attackCooldown = 40;
      this.attackProgress = 0;
    }

    startDodge() {
      this.state = 'dodge';
      this.dodgeCooldown = 30;
      this.hitTimer = 10; // short invulnerability flash
    }

    startJump() {
      if (!this.onGround) return;
      this.state = 'jump';
      this.velocityY = -12;
      this.onGround = false;
      this.jumpCooldown = 50;
    }

    takeHit(damage, effect) {
      if (this.state === 'dodge') return; // dodge blocks hit
      this.health -= damage;
      this.hitTimer = 20;
      if (effect === 'stun') this.stunTime = 30;
      if (effect === 'slow') this.slowTime = 60;
    }

    update(opponent) {
      if (!this.isAlive()) {
        this.state = 'dead';
        return;
      }

      if (this.stunTime > 0) this.stunTime--;
      if (this.slowTime > 0) this.slowTime--;

      // Cooldowns
      if (this.attackCooldown > 0) this.attackCooldown--;
      if (this.dodgeCooldown > 0) this.dodgeCooldown--;
      if (this.jumpCooldown > 0) this.jumpCooldown--;

      // State logic
      if (this.state === 'attack') {
        this.attackFrame++;
        this.attackProgress = this.attackFrame / 15;
        if (this.attackFrame > 15) {
          this.state = 'idle';
        }
      } else if (this.state === 'dodge') {
        this.hitTimer--;
        if (this.dodgeCooldown <= 0) this.state = 'idle';
      } else if (this.state === 'jump') {
        this.y += this.velocityY;
        this.velocityY += 0.8; // gravity
        if (this.y >= groundY) {
          this.y = groundY;
          this.onGround = true;
          this.state = 'idle';
        }
      } else {
        this.decideAction(opponent);
      }
    }

    // Draw glowing weapon (energy blades or whip)
    drawWeapon(ctx) {
      ctx.save();
      ctx.lineCap = 'round';
      ctx.shadowColor = this.weaponGlowColor;
      ctx.shadowBlur = 15;

      if (this.weaponType === 'blades') {
        // Dual energy blades on hands
        const handY = this.y - stickmanHeight * 0.25;
        const bladeLength = 40;
        const bladeAngle = Math.sin(this.attackProgress * Math.PI * 2) * 0.8;

        // Left blade
        ctx.strokeStyle = this.weaponGlowColor;
        ctx.lineWidth = 6;
        ctx.beginPath();
        ctx.moveTo(this.x - 10, handY);
        ctx.lineTo(
          this.x - 10 + Math.cos(bladeAngle) * bladeLength,
          handY + Math.sin(bladeAngle) * bladeLength
        );
        ctx.stroke();

        // Right blade
        ctx.beginPath();
        ctx.moveTo(this.x + 10, handY);
        ctx.lineTo(
          this.x + 10 + Math.cos(-bladeAngle) * bladeLength,
          handY + Math.sin(-bladeAngle) * bladeLength
        );
        ctx.stroke();

        // Electric arcs (random flickering)
        for (let i = 0; i < 3; i++) {
          if (Math.random() < 0.3) {
            let sx = this.x + (i === 0 ? -10 : 10);
            let sy = handY;
            let ex = sx + (Math.random() - 0.5) * 20;
            let ey = sy + (Math.random() - 0.5) * 20;
            ctx.beginPath();
            ctx.strokeStyle = 'rgba(100,255,100,' + (Math.random() * 0.8 + 0.2) + ')';
            ctx.lineWidth = 2;
            ctx.moveTo(sx, sy);
            ctx.lineTo(ex, ey);
            ctx.stroke();
          }
        }
      } else if (this.weaponType === 'whip') {
        // Energy whip with swoosh trail
        const whipLength = 80;
        const handY = this.y - stickmanHeight * 0.3;
        const whipAngle = Math.sin(this.attackProgress * Math.PI * 2) * Math.PI * 0.7;

        ctx.strokeStyle = this.weaponGlowColor;
        ctx.lineWidth = 8;
        ctx.beginPath();
        ctx.moveTo(this.x, handY);
        for (let i = 0; i <= 4; i++) {
          let t = i / 4;
          let x = this.x + Math.cos(whipAngle + t * Math.PI) * whipLength * t * this.facing;
          let y = handY + Math.sin(whipAngle + t * Math.PI) * whipLength * t * 0.4;
          ctx.lineTo(x, y);
        }
        ctx.stroke();

        // Whip tip glow
        const tipX = this.x + Math.cos(whipAngle + Math.PI) * whipLength * this.facing;
        const tipY = handY + Math.sin(whipAngle + Math.PI) * whipLength * 0.4;
        const glowRadius = 12;

        let gradient = ctx.createRadialGradient(tipX, tipY, 3, tipX, tipY, glowRadius);
        gradient.addColorStop(0, this.weaponGlowColor);
        gradient.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(tipX, tipY, glowRadius, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.restore();
    }

    drawStickman(ctx) {
      // Body parts positions
      const headRadius = 10;
      const bodyHeight = stickmanHeight * 0.5;
      const handY = this.y - bodyHeight * 0.7;
      const footY = this.y;

      ctx.save();

      // Draw glow aura
      ctx.shadowColor = this.weaponGlowColor;
      ctx.shadowBlur = 15;
      ctx.lineWidth = 4;
      ctx.strokeStyle = this.weaponGlowColor;
      ctx.fillStyle = this.color;

      // Draw head (circle)
      ctx.beginPath();
      ctx.arc(this.x, handY - 40, headRadius, 0, Math.PI * 2);
      ctx.fill();

      // Body line
      ctx.beginPath();
      ctx.moveTo(this.x, handY - 30);
      ctx.lineTo(this.x, footY - 10);
      ctx.stroke();

      // Arms - moving on attack
      ctx.lineWidth = 5;
      ctx.strokeStyle = this.color;

      const attackProgress = this.attackProgress;

      // Left arm
      let leftArmX = this.x - 15;
      let leftArmY = handY - 20;
      let leftArmSwingX = leftArmX - this.facing * Math.sin(attackProgress * Math.PI * 4) * 15;
      let leftArmSwingY = leftArmY - Math.abs(Math.sin(attackProgress * Math.PI * 4)) * 10;

      // Right arm
      let rightArmX = this.x + 15;
      let rightArmY = handY - 20;
      let rightArmSwingX = rightArmX + this.facing * Math.sin(attackProgress * Math.PI * 4) * 15;
      let rightArmSwingY = rightArmY - Math.abs(Math.sin(attackProgress * Math.PI * 4)) * 10;

      // Draw arms lines
      ctx.beginPath();
      ctx.moveTo(this.x, handY - 30);
      ctx.lineTo(leftArmSwingX, leftArmSwingY);
      ctx.moveTo(this.x, handY - 30);
      ctx.lineTo(rightArmSwingX, rightArmSwingY);
      ctx.stroke();

      // Legs - simple bending during dodge
      ctx.lineWidth = 6;
      ctx.strokeStyle = this.color;

      ctx.beginPath();
      // Left leg
      ctx.moveTo(this.x, footY - 10);
      ctx.lineTo(this.x - 10, footY + (this.state === 'dodge' ? 10 : 0));
      // Right leg
      ctx.moveTo(this.x, footY - 10);
      ctx.lineTo(this.x + 10, footY + (this.state === 'dodge' ? 10 : 0));
      ctx.stroke();

      ctx.restore();

      // Draw weapon after body
      this.drawWeapon(ctx);

      // Draw hit flash
      if (this.hitTimer > 0) {
        ctx.fillStyle = 'rgba(255,255,255,0.3)';
        ctx.beginPath();
        ctx.arc(this.x, handY - 40, headRadius + 12, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    drawHealthBar(ctx, x, y) {
      // Background
      ctx.fillStyle = '#222';
      ctx.fillRect(x, y, healthBarWidth, healthBarHeight);

      // Health fill with glow color
      let healthRatio = this.health / this.maxHealth;
      let gradient = ctx.createLinearGradient(x, y, x + healthBarWidth, y);
      gradient.addColorStop(0, this.weaponGlowColor);
      gradient.addColorStop(1, 'black');

      ctx.fillStyle = gradient;
      ctx.fillRect(x, y, healthBarWidth * healthRatio, healthBarHeight);

      // Border
      ctx.lineWidth = 2;
      ctx.strokeStyle = this.weaponGlowColor;
      ctx.strokeRect(x, y, healthBarWidth, healthBarHeight);
    }
  }

  // Game objects
  let greenStickman = new Stickman(200, 'limegreen', 'blades');
  let blueStickman = new Stickman(600, '#33ccff', 'whip');
  blueStickman.facing = -1;
  greenStickman.facing = 1;

  // Main loop
  function gameLoop() {
    if (!fightActive) return;

    // Update
    greenStickman.update(blueStickman);
    blueStickman.update(greenStickman);

    // Check attacks hitting
    checkHits(greenStickman, blueStickman);
    checkHits(blueStickman, greenStickman);

    // Screen shake decay
    if (shakeMagnitude > 0.1) {
      shakeMagnitude *= shakeDecay;
      shakeX = (Math.random() - 0.5) * shakeMagnitude * 10;
      shakeY = (Math.random() - 0.5) * shakeMagnitude * 10;
    } else {
      shakeMagnitude = 0;
      shakeX = 0;
      shakeY = 0;
    }

    // Draw
    draw();

    // Check victory
    if (!greenStickman.isAlive()) {
      endFight('Blue Stickman Wins!');
    } else if (!blueStickman.isAlive()) {
      endFight('Green Stickman Wins!');
    } else {
      requestAnimationFrame(gameLoop);
    }
  }

  // Hit detection & effect
  function checkHits(attacker, defender) {
    if (attacker.state !== 'attack') return;

    // Attack hitbox (rough circle in front)
    let attackRange = 40;
    let attackX = attacker.x + attacker.facing * 30;
    let attackY = attacker.y - stickmanHeight * 0.3;

    let dist = Math.abs(defender.x - attackX);

    // Only hit if defender in range, and not dodging
    if (dist < attackRange && defender.state !== 'dodge' && defender.hitTimer <= 0) {
      let damage = 8;
      let effect = null;

      if (attacker.weaponType === 'blades') {
        damage = 7;
        effect = 'stun';
        createElectricHitEffect(attackX, attackY, attacker.weaponGlowColor);
      } else if (attacker.weaponType === 'whip') {
        damage = 6;
        effect = 'slow';
        createWhipHitEffect(attackX, attackY, attacker.weaponGlowColor);
      }

      defender.takeHit(damage, effect);
      attacker.state = 'idle';

      // Screen shake on hit
      shakeMagnitude = 1.2;
    }
  }

  // Draw the entire scene
  function draw() {
    ctx.clearRect(0, 0, width, height);

    // Apply screen shake
    ctx.save();
    ctx.translate(shakeX, shakeY);

    // Draw ground line
    ctx.strokeStyle = '#444';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(0, groundY + 1);
    ctx.lineTo(width, groundY + 1);
    ctx.stroke();

    // Draw stickmen
    greenStickman.drawStickman(ctx);
    blueStickman.drawStickman(ctx);

    // Draw health bars
    greenStickman.drawHealthBar(ctx, 20, 20);
    blueStickman.drawHealthBar(ctx, width - healthBarWidth - 20, 20);

    ctx.restore();

    // Draw effects on top
    drawEffects();
  }

  // Effects arrays
  let electricHits = [];
  let whipHits = [];

  // Create electric hit effect for green blades
  function createElectricHitEffect(x, y, color) {
    electricHits.push({
      x,
      y,
      radius: 4,
      maxRadius: 20,
      opacity: 1,
      color,
    });
  }

  // Create whip hit effect for blue whip
  function createWhipHitEffect(x, y, color) {
    whipHits.push({
      x,
      y,
      time: 0,
      maxTime: 15,
      color,
    });
  }

  // Draw hit effects
  function drawEffects() {
    // Electric arc hits
    for (let i = electricHits.length - 1; i >= 0; i--) {
      let e = electricHits[i];
      ctx.save();
      ctx.strokeStyle = e.color;
      ctx.globalAlpha = e.opacity;
      ctx.lineWidth = 3;
      ctx.beginPath();

      // Simple random arc lines around center
      for (let j = 0; j < 4; j++) {
        let angle = (j / 4) * Math.PI * 2 + Math.random() * 0.5;
        let r = lerp(e.radius, e.maxRadius, Math.random());
        let x1 = e.x + Math.cos(angle) * r;
        let y1 = e.y + Math.sin(angle) * r;
        let x2 = e.x + Math.cos(angle + 0.3) * (r + 5);
        let y2 = e.y + Math.sin(angle + 0.3) * (r + 5);
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
      }
      ctx.stroke();
      ctx.restore();

      // Shrink and fade
      e.radius += 2;
      e.opacity -= 0.12;
      if (e.opacity <= 0) electricHits.splice(i, 1);
    }

    // Whip slow hits (blue circles that fade and expand)
    for (let i = whipHits.length - 1; i >= 0; i--) {
      let w = whipHits[i];
      ctx.save();
      ctx.fillStyle = w.color;
      ctx.globalAlpha = 1 - w.time / w.maxTime;
      let radius = lerp(5, 25, w.time / w.maxTime);
      ctx.beginPath();
      ctx.arc(w.x, w.y, radius, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();

      w.time++;
      if (w.time > w.maxTime) whipHits.splice(i, 1);
    }
  }

  // End fight and show winner
  function endFight(text) {
    fightActive = false;
    victoryDiv.textContent = text;
    startBtn.textContent = 'Restart Fight';
    startBtn.disabled = false;
  }

  // Start fight setup
  function startFight() {
    victoryDiv.textContent = '';
    greenStickman.reset(200, 1);
    blueStickman.reset(600, -1);
    fightActive = true;
    startBtn.disabled = true;
    gameLoop();
  }

  startBtn.addEventListener('click', startFight);

  // Initial draw
  draw();
})();
</script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Echo Shard - Reality Hacker</title>
    <style>
        html, body {
            margin: 0; padding: 0; overflow: hidden;
            background: #111; color: #eee;
            font-family: 'Inter', sans-serif;
        }
        #main-menu, #ui, #message {
            position: absolute;
            z-index: 10;
        }
        #main-menu {
            top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column;
            justify-content: center; align-items: center;
            background: rgba(0, 0, 0, 0.95);
            transition: opacity 1s, visibility 1s;
        }
        .menu-title {
            font-size: 4rem;
            font-weight: bold;
            color: #00aaff;
            text-shadow: 0 0 10px #00aaff, 0 0 20px #00aaff;
            margin-bottom: 2rem;
            animation: pulse 2s infinite;
        }
        .menu-instructions {
            text-align: center;
            font-size: 1.2rem;
            line-height: 1.6;
            margin-bottom: 2rem;
        }
        .menu-button {
            padding: 12px 24px;
            font-size: 1.5rem;
            font-weight: bold;
            color: #fff;
            background: #00aaff;
            border: 2px solid #00aaff;
            border-radius: 8px;
            cursor: pointer;
            box-shadow: 0 0 10px #00aaff, 0 0 20px rgba(0, 170, 255, 0.5);
            transition: all 0.3s ease;
        }
        .menu-button:hover {
            background: #0088cc;
            box-shadow: 0 0 15px #00aaff, 0 0 30px rgba(0, 170, 255, 0.8);
        }
        @keyframes pulse {
            0% { text-shadow: 0 0 10px #00aaff, 0 0 20px #00aaff; }
            50% { text-shadow: 0 0 15px #00aaff, 0 0 30px #00aaff; }
            100% { text-shadow: 0 0 10px #00aaff, 0 0 20px #00aaff; }
        }

        #ui {
            top: 10px; left: 10px;
            background: rgba(0, 0, 0, 0.6);
            padding: 10px;
            border-radius: 6px;
            font-size: 14px;
            display: none;
            flex-direction: column;
            gap: 8px;
        }
        .ui-line {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .bar-container {
            width: 150px;
            height: 12px;
            background-color: rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            overflow: hidden;
        }
        .bar {
            height: 100%;
            background-color: #00aaff;
            width: 100%;
            transition: width 0.1s linear;
        }
        #health-bar .bar { background-color: #ff4444; }
        #stamina-bar .bar { background-color: #00aaff; }

        #message {
            bottom: 30px; left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.9);
            color: #000;
            padding: 12px 20px;
            border-radius: 8px;
            display: none;
            font-weight: bold;
            font-size: 18px;
            transition: opacity 0.3s;
        }
        canvas { display: block; }
    </style>
</head>
<body>

<div id="main-menu">
    <h1 class="menu-title">Echo Shard</h1>
    <div class="menu-instructions">
        <p>You are a reality hacker trying to steal a crystal in the dimension.</p>
        <p><strong>Controls:</strong></p>
        <p>WASD: Move | Shift: Sprint</p>
        <p>Mouse: Look | E: Interact</p>
        <p>Q: Toggle time-stop (uses stamina)</p>
        <p>R: Hold to rewind (3s max)</p>
    </div>
    <button class="menu-button" id="start-button">Start Game</button>
</div>

<div id="ui">
    <div class="ui-line">
        Health: <span id="health">100</span>
        <div id="health-bar" class="bar-container"><div class="bar"></div></div>
    </div>
    <div class="ui-line">
        Stamina: <span id="stamina">100</span>
        <div id="stamina-bar" class="bar-container"><div class="bar"></div></div>
    </div>
    <div class="ui-line">Keycards: <span id="keycards">0</span></div>
    <div class="ui-line">Stage: <span id="stage">1</span></div>
    <div class="ui-line">Time: <span id="timer">00:00</span></div>
</div>

<div id="message"></div>
<script src="https://cdn.jsdelivr.net/npm/three@0.150.1/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.150.1/examples/js/controls/PointerLockControls.js"></script>
<script>
(() => {
    // --- Global Game Variables ---
    const PLAYER_HEIGHT = 1.8;
    const GRAVITY = -30;
    const REWIND_MAX_FRAMES = 180; // 3 seconds at ~60fps
    const STAMINA_MAX = 100;
    const STAMINA_DRAIN_RATE = 20; // per second
    const STAMINA_RECHARGE_RATE = 40; // per second
    const KEYCARD_COLORS = [0xffff00, 0x00ff00, 0xff00ff];

    let scene, camera, renderer, controls, clock;
    let velocity = new THREE.Vector3(), direction = new THREE.Vector3();
    let move = { forward: false, backward: false, left: false, right: false, sprint: false };
    let canJump = false, gameStarted = false;
    let health = 100, stamina = STAMINA_MAX, keycards = 0, stage = 1;
    let startTime = Date.now();
    let isRewinding = false, isTimeStopped = false;
    let rewindBuffer = [];
    const ui = {
        menu: document.getElementById('main-menu'),
        startBtn: document.getElementById('start-button'),
        hud: document.getElementById('ui'),
        health: document.getElementById('health'),
        healthBar: document.querySelector('#health-bar .bar'),
        stamina: document.getElementById('stamina'),
        staminaBar: document.querySelector('#stamina-bar .bar'),
        keycards: document.getElementById('keycards'),
        stage: document.getElementById('stage'),
        timer: document.getElementById('timer'),
        msg: document.getElementById('message')
    };

    // --- Helper Functions ---
    function showMessage(text, duration = 3000) {
        ui.msg.textContent = text;
        ui.msg.style.display = 'block';
        setTimeout(() => ui.msg.style.display = 'none', duration);
    }
    
    // --- Game Object Classes ---
    
    // Door Class: requires specific keycard type to open.
    class Door {
        constructor(pos, locked = true, type = 0) {
            this.locked = locked;
            this.type = type; // Door type corresponds to required keycard color/type
            this.mesh = new THREE.Mesh(
                new THREE.BoxGeometry(1, 3, 0.2),
                new THREE.MeshPhongMaterial({
                    color: locked ? 0xaa0000 : 0x00aa00,
                    transparent: true,
                    opacity: 0.9,
                    emissive: locked ? 0x660000 : 0x006600
                })
            );
            this.mesh.position.copy(pos);
            scene.add(this.mesh);
        }
        interact() {
            if (this.locked) {
                if (keycards > 0) {
                    keycards--;
                    ui.keycards.textContent = keycards;
                    this.locked = false;
                    this.mesh.material.color.set(0x00aa00);
                    this.mesh.material.emissive.set(0x006600);
                    showMessage("Door unlocked.");
                } else {
                    showMessage("You need a keycard to open this door.");
                }
            } else {
                showMessage("Door is already unlocked.");
            }
        }
    }
    // Enemy Class: patrols along waypoints, damages player on contact.
    class Enemy {
        constructor(path) {
            this.path = path;
            this.currentWaypoint = 0;
            this.mesh = new THREE.Mesh(
                new THREE.BoxGeometry(0.7, 1.8, 0.7),
                new THREE.MeshPhongMaterial({
                    color: 0xff4444,
                    emissive: 0x990000
                })
            );
            this.mesh.position.copy(this.path[this.currentWaypoint]);
            scene.add(this.mesh);
            this.speed = 3;
        }
        update(delta, playerPos) {
            if (isTimeStopped || isRewinding) return;

            // Move towards next waypoint
            const target = this.path[this.currentWaypoint];
            const dir = new THREE.Vector3().subVectors(target, this.mesh.position).normalize();
            this.mesh.position.addScaledVector(dir, this.speed * delta);

            if (this.mesh.position.distanceTo(target) < 0.5) {
                this.currentWaypoint = (this.currentWaypoint + 1) % this.path.length;
            }

            if (this.mesh.position.distanceTo(playerPos) < 1.2) {
                health -= 10;
                if (health <= 0) {
                    alert("Game Over! You were caught by the system daemon.");
                    location.reload();
                }
                ui.health.textContent = health;
                ui.healthBar.style.width = `${health}%`;
            }
        }
    }

    // Keycard collectible, matches door type.
    class Keycard {
        constructor(pos, type = 0) {
            this.type = type;
            this.mesh = new THREE.Mesh(
                new THREE.BoxGeometry(0.3, 0.05, 0.5),
                new THREE.MeshPhongMaterial({
                    color: KEYCARD_COLORS[type],
                    emissive: KEYCARD_COLORS[type],
                    emissiveIntensity: 0.8
                })
            );
            this.mesh.position.copy(pos);
            scene.add(this.mesh);
            this.collected = false;
        }
        checkPickup(playerPos) {
            if (!this.collected && this.mesh.position.distanceTo(playerPos) < 1) {
                this.collected = true;
                scene.remove(this.mesh);
                keycards++;
                ui.keycards.textContent = keycards;
                showMessage("Keycard collected!");
            }
        }
    }

    // Initialize Player Controls
    function initControls() {
        controls = new THREE.PointerLockControls(camera, document.body);

        document.body.addEventListener('click', () => {
            if (!gameStarted) return;
            controls.lock();
        });

        controls.addEventListener('lock', () => {
            ui.menu.style.display = 'none';
            ui.hud.style.display = 'flex';
        });

        controls.addEventListener('unlock', () => {
            ui.menu.style.display = 'flex';
            ui.hud.style.display = 'none';
        });

        document.addEventListener('keydown', onKeyDown);
        document.addEventListener('keyup', onKeyUp);
    }

    function onKeyDown(event) {
        switch(event.code) {
            case 'KeyW': move.forward = true; break;
            case 'KeyS': move.backward = true; break;
            case 'KeyA': move.left = true; break;
            case 'KeyD': move.right = true; break;
            case 'ShiftLeft': move.sprint = true; break;
            case 'KeyE': interact(); break;
            case 'KeyQ': toggleTimeStop(); break;
            case 'KeyR': startRewind(); break;
            case 'Space':
                if (canJump) {
                    velocity.y = 10;
                    canJump = false;
                }
                break;
        }
    }
    function onKeyUp(event) {
        switch(event.code) {
            case 'KeyW': move.forward = false; break;
            case 'KeyS': move.backward = false; break;
            case 'KeyA': move.left = false; break;
            case 'KeyD': move.right = false; break;
            case 'ShiftLeft': move.sprint = false; break;
            case 'KeyR': stopRewind(); break;
        }
    }
    // Interaction function (check nearby doors)
    function interact() {
        // Simple interaction check: closest door within 2 units
        let playerPos = controls.getObject().position;
        for (const door of doors) {
            if (door.mesh.position.distanceTo(playerPos) < 2) {
                door.interact();
                return;
            }
        }
        showMessage("Nothing to interact with.");
    }

    // Toggle time stop ability
    function toggleTimeStop() {
        if (stamina > 10) {
            isTimeStopped = !isTimeStopped;
            showMessage(isTimeStopped ? "Time stopped." : "Time resumed.");
        } else {
            showMessage("Not enough stamina to stop time.");
        }
    }

    // Rewind mechanics
    function startRewind() {
        if (rewindBuffer.length > 0) {
            isRewinding = true;
            showMessage("Rewinding...");
        }
    }
    function stopRewind() {
        if (isRewinding) {
            isRewinding = false;
            showMessage("Rewind stopped.");
        }
    }

    // Setup Three.js scene, camera, renderer
    function initScene() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x111111);
        camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        clock = new THREE.Clock();

        // Lights
        const light = new THREE.HemisphereLight(0xffffff, 0x444444, 1.5);
        light.position.set(0, 200, 0);
        scene.add(light);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(0, 100, 100);
        scene.add(dirLight);

        // Floor
        const floorGeometry = new THREE.PlaneGeometry(100, 100);
        const floorMaterial = new THREE.MeshPhongMaterial({color: 0x222222});
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = - Math.PI / 2;
        floor.position.y = 0;
        scene.add(floor);
    }

    // Game objects
    let doors = [];
    let enemies = [];
    let keycardObjects = [];

    function setupGameObjects() {
        // Add doors with types (0,1,2)
        doors.push(new Door(new THREE.Vector3(5, 1.5, -5), true, 0));
        doors.push(new Door(new THREE.Vector3(10, 1.5, -5), true, 1));
        doors.push(new Door(new THREE.Vector3(15, 1.5, -5), true, 2));

        // Add enemies with patrol paths
        enemies.push(new Enemy([
            new THREE.Vector3(-5, 0, -5),
            new THREE.Vector3(-5, 0, 5),
        ]));

        enemies.push(new Enemy([
            new THREE.Vector3(7, 0, -10),
            new THREE.Vector3(12, 0, -10),
        ]));

        // Add keycards
        keycardObjects.push(new Keycard(new THREE.Vector3(-3, 0.3, -3), 0));
        keycardObjects.push(new Keycard(new THREE.Vector3(8, 0.3, -4), 1));
        keycardObjects.push(new Keycard(new THREE.Vector3(14, 0.3, -6), 2));
    }

    // Game Loop
    function animate() {
        requestAnimationFrame(animate);
        if (!gameStarted) return;

        const delta = clock.getDelta();

        if (!isRewinding) {
            // Movement
            direction.z = Number(move.forward) - Number(move.backward);
            direction.x = Number(move.right) - Number(move.left);
            direction.normalize();

            if (controls.isLocked === true) {
                // Stamina management
                if (move.sprint && stamina > 0) {
                    velocity.x -= direction.x * 50 * delta;
                    velocity.z -= direction.z * 50 * delta;
                    stamina -= STAMINA_DRAIN_RATE * delta;
                } else {
                    velocity.x -= direction.x * 25 * delta;
                    velocity.z -= direction.z * 25 * delta;
                    stamina += STAMINA_RECHARGE_RATE * delta;
                }
                stamina = Math.min(Math.max(stamina, 0), STAMINA_MAX);

                // Gravity
                velocity.y += GRAVITY * delta;

                controls.moveRight(-velocity.x * delta);
                controls.moveForward(-velocity.z * delta);
                controls.getObject().position.y += velocity.y * delta;

                if (controls.getObject().position.y < PLAYER_HEIGHT) {
                    velocity.y = 0;
                    controls.getObject().position.y = PLAYER_HEIGHT;
                    canJump = true;
                }

                // Update UI stamina bar
                ui.stamina.textContent = Math.floor(stamina);
                ui.staminaBar.style.width = `${(stamina / STAMINA_MAX) * 100}%`;

                // Update enemies
                enemies.forEach(enemy => enemy.update(delta, controls.getObject().position));

                // Check keycard pickups
                keycardObjects.forEach(kc => kc.checkPickup(controls.getObject().position));

                // Save state for rewind
                rewindBuffer.push({
                    pos: controls.getObject().position.clone(),
                    rot: camera.rotation.clone(),
                    velocity: velocity.clone(),
                    health: health,
                    stamina: stamina,
                    keycards: keycards
                });
                if (rewindBuffer.length > REWIND_MAX_FRAMES) rewindBuffer.shift();

                // Timer UI
                const elapsed = (Date.now() - startTime) / 1000;
                const minutes = Math.floor(elapsed / 60).toString().padStart(2, '0');
                const seconds = Math.floor(elapsed % 60).toString().padStart(2, '0');
                ui.timer.textContent = `${minutes}:${seconds}`;
            }

            // Handle time stop stamina drain
            if (isTimeStopped) {
                stamina -= STAMINA_DRAIN_RATE * delta;
                if (stamina <= 0) {
                    stamina = 0;
                    isTimeStopped = false;
                    showMessage("Time stop ended due to exhaustion.");
                }
                ui.stamina.textContent = Math.floor(stamina);
                ui.staminaBar.style.width = `${(stamina / STAMINA_MAX) * 100}%`;
            }
        } else {
            // Rewind player position and states
            if (rewindBuffer.length > 0) {
                const state = rewindBuffer.pop();
                controls.getObject().position.copy(state.pos);
                camera.rotation.copy(state.rot);
                velocity.copy(state.velocity);
                health = state.health;
                stamina = state.stamina;
                keycards = state.keycards;

                ui.health.textContent = health;
                ui.healthBar.style.width = `${health}%`;
                ui.stamina.textContent = Math.floor(stamina);
                ui.staminaBar.style.width = `${(stamina / STAMINA_MAX) * 100}%`;
                ui.keycards.textContent = keycards;
            } else {
                stopRewind();
            }
        }

        renderer.render(scene, camera);
    }

    // Start Game button event
    ui.startBtn.addEventListener('click', () => {
        ui.menu.style.display = 'none';
        ui.hud.style.display = 'flex';
        gameStarted = true;
        controls.lock();
    });

    // Initialize everything
    function init() {
        initScene();
        initControls();
        setupGameObjects();
        camera.position.set(0, PLAYER_HEIGHT, 10);
        animate();
    }

    init();
})();
</script>
</body>
</html>

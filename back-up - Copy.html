import pygame
import math
import random

pygame.init()
WIDTH, HEIGHT = 900, 500
WIN = pygame.display.set_mode((WIDTH, HEIGHT))
pygame.display.set_caption("Enhanced Stickman Fight")

# Colors
BG_COLOR = (20, 20, 20)
GREEN = (0, 255, 0)
BLUE = (0, 200, 255)
WHITE = (255, 255, 255)
RED = (255, 50, 50)
YELLOW = (255, 255, 0)

# FPS and clock
FPS = 60
clock = pygame.time.Clock()

# Health bars outside fight area
HEALTH_BAR_WIDTH = 300
HEALTH_BAR_HEIGHT = 20
HEALTH_BAR_Y = 10

# Fonts
font = pygame.font.SysFont("Arial", 20)

# Camera shake variables
shake_duration = 0
shake_magnitude = 5

def camera_shake():
    global shake_duration
    if shake_duration > 0:
        offset_x = random.randint(-shake_magnitude, shake_magnitude)
        offset_y = random.randint(-shake_magnitude, shake_magnitude)
        shake_duration -= 1
        return offset_x, offset_y
    return 0, 0

class Weapon:
    def __init__(self, owner, color, kind="claw"):
        self.owner = owner
        self.color = color
        self.kind = kind
        self.glow_alpha = 180
        self.extension = 0  # For attack animation extension

    def draw(self, win):
        ox, oy = self.owner.pos
        angle = self.owner.angle if hasattr(self.owner, "angle") else 0

        # Glow trail effect
        glow_surf = pygame.Surface((40, 15), pygame.SRCALPHA)
        glow_color = (*self.color, self.glow_alpha)
        pygame.draw.rect(glow_surf, glow_color, glow_surf.get_rect(), border_radius=5)
        glow_surf = pygame.transform.rotate(glow_surf, -math.degrees(angle))
        pos = (ox + math.cos(angle)*10, oy + math.sin(angle)*10)
        win.blit(glow_surf, (pos[0] - 20, pos[1] - 7))

        # Draw main weapon shape
        if self.kind == "claw":
            # Claw: 3 sharp fingers extending forward
            base_x = ox + math.cos(angle)*10
            base_y = oy + math.sin(angle)*10
            for i in range(3):
                offset_angle = angle + (i-1)*0.15
                end_x = base_x + math.cos(offset_angle)*(30 + self.extension)
                end_y = base_y + math.sin(offset_angle)*(30 + self.extension)
                pygame.draw.line(win, self.color, (base_x, base_y), (end_x, end_y), 4)
        elif self.kind == "dragger":
            # Dragger: hook-like shape
            base_x = ox + math.cos(angle)*10
            base_y = oy + math.sin(angle)*10
            hook_point = (base_x + math.cos(angle)*(25 + self.extension), base_y + math.sin(angle)*(25 + self.extension))
            pygame.draw.line(win, self.color, (base_x, base_y), hook_point, 5)
            pygame.draw.arc(win, self.color, (hook_point[0]-10, hook_point[1]-10, 20, 20), math.pi/2, math.pi, 3)

    def attack_anim(self):
        # Extend weapon during attack then retract
        self.extension = 20

    def update(self):
        # Slowly reduce extension to zero (weapon retracts)
        if self.extension > 0:
            self.extension -= 1

class Stickman:
    def __init__(self, x, y, color, kind):
        self.pos = [x, y]
        self.color = color
        self.kind = kind  # "green" or "blue"
        self.health = 100
        self.max_health = 100
        self.width = 20
        self.height = 50
        self.speed = 3
        self.weapon = Weapon(self, color, "claw" if kind == "green" else "dragger")
        self.vel = [0, 0]
        self.direction = 1 if kind == "green" else -1  # facing right or left
        self.limb_angle = 0
        self.limb_speed = 0.1
        self.is_attacking = False
        self.attack_timer = 0
        self.attack_cooldown = 40
        self.combo_step = 0
        self.dodging = False
        self.dodge_timer = 0
        self.parrying = False
        self.parry_timer = 0
        self.jump = False
        self.jump_vel = 0
        self.ground_y = y
        self.angle = 0

    def draw(self, win):
        x, y = self.pos
        # Draw head
        pygame.draw.circle(win, self.color, (int(x), int(y - 25)), 10)

        # Long neck wear for green with wind effect
        if self.kind == "green":
            # Neck
            pygame.draw.line(win, self.color, (x, y-15), (x, y-30), 4)
            # Neckwear flutter effect
            flutter = math.sin(pygame.time.get_ticks() * 0.01) * 10
            pygame.draw.rect(win, self.color, (x + flutter, y - 35, 20, 5))

        # Torso
        pygame.draw.line(win, self.color, (x, y - 15), (x, y + 15), 6)

        # Arms swinging
        arm_swing = math.sin(self.limb_angle) * 15 * self.direction
        arm_y = y - 10
        # Left arm
        pygame.draw.line(win, self.color, (x, arm_y), (x + arm_swing, arm_y - 10), 5)
        # Right arm
        pygame.draw.line(win, self.color, (x, arm_y), (x - arm_swing, arm_y - 10), 5)

        # Legs swinging
        leg_swing = math.cos(self.limb_angle) * 20 * self.direction
        leg_y = y + 15
        # Left leg
        pygame.draw.line(win, self.color, (x, leg_y), (x + leg_swing, leg_y + 25), 6)
        # Right leg
        pygame.draw.line(win, self.color, (x, leg_y), (x - leg_swing, leg_y + 25), 6)

        # Draw weapon with attack effect
        self.weapon.draw(win)

    def move(self, left, right):
        if self.dodging or self.is_attacking:
            # Can't move while dodging or attacking
            return
        if left:
            self.pos[0] -= self.speed
            self.direction = -1
            self.limb_angle += self.limb_speed
        if right:
            self.pos[0] += self.speed
            self.direction = 1
            self.limb_angle += self.limb_speed

    def attack(self):
        if self.attack_timer == 0 and not self.dodging:
            self.is_attacking = True
            self.attack_timer = self.attack_cooldown
            self.combo_step = (self.combo_step + 1) % 3
            self.weapon.attack_anim()

    def update(self):
        # Handle attack timer
        if self.attack_timer > 0:
            self.attack_timer -= 1
            if self.attack_timer == 0:
                self.is_attacking = False
                self.combo_step = 0

        # Update weapon animation
        self.weapon.update()

        # Dodge cooldown and timer
        if self.dodge_timer > 0:
            self.dodge_timer -= 1
            if self.dodge_timer == 0:
                self.dodging = False

        # Parry cooldown and timer
        if self.parry_timer > 0:
            self.parry_timer -= 1
            if self.parry_timer == 0:
                self.parrying = False

        # Jump physics
        if self.jump:
            self.pos[1] += self.jump_vel
            self.jump_vel += 1
            if self.pos[1] >= self.ground_y:
                self.pos[1] = self.ground_y
                self.jump = False
                self.jump_vel = 0

    def dodge(self):
        if self.dodge_timer == 0 and not self.is_attacking:
            self.dodging = True
            self.dodge_timer = 30

    def parry(self):
        if self.parry_timer == 0 and not self.is_attacking:
            self.parrying = True
            self.parry_timer = 20

    def jump_action(self):
        if not self.jump and not self.dodging and not self.is_attacking:
            self.jump = True
            self.jump_vel = -15

class AI:
    def __init__(self, stickman, opponent):
        self.stickman = stickman
        self.opponent = opponent
        self.action_timer = 0

    def update(self):
        # Basic AI: keep distance, dodge, attack

        if self.action_timer > 0:
            self.action_timer -= 1
            return

        dist = self.opponent.pos[0] - self.stickman.pos[0]

        # Retreat if low health
        if self.stickman.health < 30 and abs(dist) < 200:
            if dist > 0:
                self.stickman.move(left=True, right=False)
            else:
                self.stickman.move(left=False, right=True)
            self.action_timer = 20
            return

        # Attack if close
        if abs(dist) < 70 and not self.stickman.is_attacking:
            self.stickman.attack()
            self.action_timer = 40
            return

        # Dodge randomly when opponent attacks
        if self.opponent.is_attacking and random.random() < 0.1:
            self.stickman.dodge()
            self.action_timer = 30
            return

        # Move towards opponent
        if dist > 0:
            self.stickman.move(left=False, right=True)
        else:
            self.stickman.move(left=True, right=False)
        self.action_timer = 10

def draw_health_bar(win, x, y, health, max_health, color):
    ratio = health / max_health
    pygame.draw.rect(win, (100, 100, 100), (x, y, HEALTH_BAR_WIDTH, HEALTH_BAR_HEIGHT), border_radius=8)
    pygame.draw.rect(win, color, (x, y, HEALTH_BAR_WIDTH * ratio, HEALTH_BAR_HEIGHT), border_radius=8)
    pygame.draw.rect(win, WHITE, (x, y, HEALTH_BAR_WIDTH, HEALTH_BAR_HEIGHT), 2, border_radius=8)

def draw_window(green, blue):
    WIN.fill(BG_COLOR)

    # Camera shake offset
    offset_x, offset_y = camera_shake()
    offset_pos = (offset_x, offset_y)

    # Draw fight ground
    pygame.draw.line(WIN, (100, 100, 100), (0, HEIGHT - 60 + offset_y), (WIDTH, HEIGHT - 60 + offset_y), 4)

    # Draw stickmen (offset for shake)
    temp_surface = pygame.Surface((WIDTH, HEIGHT), pygame.SRCALPHA)
    green.draw(temp_surface)
    blue.draw(temp_surface)
    WIN.blit(temp_surface, offset_pos)

    # Draw health bars outside fight area
    draw_health_bar(WIN, 50, HEALTH_BAR_Y, green.health, green.max_health, GREEN)
    draw_health_bar(WIN, WIDTH - 50 - HEALTH_BAR_WIDTH, HEALTH_BAR_Y, blue.health, blue.max_health, BLUE)

    # Draw player labels
    green_label = font.render("Green", True, GREEN)
    blue_label = font.render("Blue AI", True, BLUE)
    WIN.blit(green_label, (50, HEALTH_BAR_Y + HEALTH_BAR_HEIGHT + 5))
    WIN.blit(blue_label, (WIDTH - 50 - HEALTH_BAR_WIDTH, HEALTH_BAR_Y + HEALTH_BAR_HEIGHT + 5))

    pygame.display.update()

def handle_attacks(attacker, defender):
    if attacker.is_attacking and not defender.dodging:
        dist = abs(attacker.pos[0] - defender.pos[0])
        if dist < 50:
            # Hit lands
            defender.health -= 1.5
            global shake_duration
            shake_duration = 8
            # Flash effect on hit
            flash = pygame.Surface((WIDTH, HEIGHT), pygame.SRCALPHA)
            flash.fill((255, 255, 255, 50))
            WIN.blit(flash, (0, 0))
            # Small screen zoom or slow motion can be added here

def main():
    run = True
    green = Stickman(200, HEIGHT - 60, GREEN, "green")
    blue = Stickman(700, HEIGHT - 60, BLUE, "blue")
    blue_ai = AI(blue, green)

    while run:
        clock.tick(FPS)

        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                run = False

        keys = pygame.key.get_pressed()
        green.move(keys[pygame.K_a], keys[pygame.K_d])

        if keys[pygame.K_w]:
            green.jump_action()

        if keys[pygame.K_LSHIFT]:
            green.dodge()

        if keys[pygame.K_SPACE]:
            green.attack()

        if keys[pygame.K_s]:
            green.parry()

        green.update()
        blue_ai.update()
        blue.update()

        handle_attacks(green, blue)
        handle_attacks(blue, green)

        draw_window(green, blue)

        # End game conditions
        if green.health <= 0 or blue.health <= 0:
            run = False

    pygame.quit()

if __name__ == "__main__":
    main()

<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Echo Shard - Full 3D Starter Game</title>
<style>
  /* Fullscreen canvas and basic UI */
  body {
    margin: 0;
    overflow: hidden;
    background-color: #121212;
    font-family: monospace, monospace;
    color: white;
  }
  #info {
    position: absolute;
    top: 12px;
    left: 12px;
    background: rgba(0,0,0,0.6);
    padding: 12px;
    border-radius: 8px;
    max-width: 320px;
    line-height: 1.5em;
    user-select: none;
  }
  canvas {
    display: block;
  }
</style>
</head>
<body>
<div id="info">
  <h2>Echo Shard Demo</h2>
  <p>
    Controls:<br />
    - Move: WASD or Arrow keys<br />
    - Avoid the red enemy cube<br />
    - Collect the blue shard<br />
    - Hold R to rewind time (3 sec buffer)<br />
  </p>
</div>

<!-- Load Three.js library from CDN -->
<script src="https://cdn.jsdelivr.net/npm/three@0.150.1/build/three.min.js"></script>
<script>
  // ------------------------
  // Scene Setup
  // ------------------------
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x101020);

  // Camera: Perspective with fov, aspect, near, far clipping planes
  const camera = new THREE.PerspectiveCamera(
    75,                                 // fov
    window.innerWidth / window.innerHeight, // aspect
    0.1,                                // near clipping plane
    1000                                // far clipping plane
  );
  camera.position.set(0, 10, 20);
  camera.lookAt(0, 0, 0);

  // Renderer: WebGLRenderer for 3D rendering
  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  // ------------------------
  // Lighting
  // ------------------------
  const ambientLight = new THREE.AmbientLight(0x555555); // soft ambient light
  scene.add(ambientLight);

  const pointLight = new THREE.PointLight(0xffffff, 1);
  pointLight.position.set(10, 20, 10);
  scene.add(pointLight);

  // ------------------------
  // Floor
  // ------------------------
  const floorGeometry = new THREE.PlaneGeometry(40, 40);
  const floorMaterial = new THREE.MeshPhongMaterial({ color: 0x222244 });
  const floor = new THREE.Mesh(floorGeometry, floorMaterial);
  floor.rotation.x = -Math.PI / 2; // rotate to be flat horizontal
  floor.receiveShadow = true;
  scene.add(floor);

  // ------------------------
  // Player setup
  // ------------------------
  const playerGeometry = new THREE.BoxGeometry(1, 1, 1);
  const playerMaterial = new THREE.MeshPhongMaterial({ color: 0x44ff44 });
  const player = new THREE.Mesh(playerGeometry, playerMaterial);
  player.position.set(0, 0.5, 0);
  player.castShadow = true;
  scene.add(player);

  // ------------------------
  // Enemy setup (red cube)
  // ------------------------
  const enemyGeometry = new THREE.BoxGeometry(1, 1, 1);
  const enemyMaterial = new THREE.MeshPhongMaterial({ color: 0xff4444 });
  const enemy = new THREE.Mesh(enemyGeometry, enemyMaterial);
  enemy.position.set(-8, 0.5, -5);
  enemy.castShadow = true;
  scene.add(enemy);

  // ------------------------
  // Collectible (blue cube)
  // ------------------------
  const collectibleGeometry = new THREE.BoxGeometry(1, 1, 1);
  const collectibleMaterial = new THREE.MeshPhongMaterial({ color: 0x4444ff });
  const collectible = new THREE.Mesh(collectibleGeometry, collectibleMaterial);
  collectible.position.set(7, 0.5, 5);
  collectible.castShadow = true;
  scene.add(collectible);

  // ------------------------
  // Controls input handling
  // ------------------------
  const keys = {};
  window.addEventListener("keydown", (event) => {
    keys[event.key.toLowerCase()] = true;
  });
  window.addEventListener("keyup", (event) => {
    keys[event.key.toLowerCase()] = false;
  });

  // ------------------------
  // Game variables
  // ------------------------
  const playerSpeed = 0.15;
  let enemyDirection = 1; // patrol direction: 1=right, -1=left
  const enemySpeed = 0.05;
  let collected = false;

  // For rewind mechanic: store last player positions
  const rewindBuffer = [];
  const maxBufferLength = 180; // ~3 seconds at 60fps
  let isRewinding = false;

  // ------------------------
  // Utility functions
  // ------------------------

  // Simple collision detection: distance-based between two meshes
  function checkCollision(meshA, meshB, threshold = 1.5) {
    return meshA.position.distanceTo(meshB.position) < threshold;
  }

  // Reset game to starting conditions
  function resetGame() {
    player.position.set(0, 0.5, 0);
    enemy.position.set(-8, 0.5, -5);
    collected = false;
    if (!scene.children.includes(collectible)) {
      scene.add(collectible);
    }
    rewindBuffer.length = 0;
    isRewinding = false;
  }

  // ------------------------
  // Rewind mechanic
  // ------------------------

  function rewindUpdate() {
    if (rewindBuffer.length > 0) {
      const pastPos = rewindBuffer.pop();
      player.position.copy(pastPos);
    } else {
      // No more rewind data, stop rewinding
      isRewinding = false;
    }
  }

  // ------------------------
  // Main game loop
  // ------------------------

  function gameLoop() {
    if (!isRewinding) {
      // Store current player position for rewind buffer
      rewindBuffer.push(player.position.clone());
      if (rewindBuffer.length > maxBufferLength) {
        rewindBuffer.shift(); // remove oldest position if buffer too big
      }

      // Player movement handling
      if (keys["w"] || keys["arrowup"]) player.position.z -= playerSpeed;
      if (keys["s"] || keys["arrowdown"]) player.position.z += playerSpeed;
      if (keys["a"] || keys["arrowleft"]) player.position.x -= playerSpeed;
      if (keys["d"] || keys["arrowright"]) player.position.x += playerSpeed;

      // Clamp player inside floor bounds (-19 to 19)
      player.position.x = THREE.MathUtils.clamp(player.position.x, -19, 19);
      player.position.z = THREE.MathUtils.clamp(player.position.z, -19, 19);

      // Enemy patrol logic: move enemy back and forth on X axis
      enemy.position.x += enemyDirection * enemySpeed;
      if (enemy.position.x > 8) enemyDirection = -1;
      if (enemy.position.x < -8) enemyDirection = 1;

      // Check collision with enemy - lose condition
      if (checkCollision(player, enemy)) {
        alert("Caught by enemy! Restarting...");
        resetGame();
        return; // early return to reset immediately
      }

      // Check if player collected the shard
      if (!collected && checkCollision(player, collectible)) {
        collected = true;
        scene.remove(collectible);
        alert("You collected the echo shard! You win!");
        resetGame();
        return;
      }
    } else {
      // Player is rewinding time
      rewindUpdate();
    }

    // Check if player is holding 'r' key to rewind
    if (keys["r"]) {
      isRewinding = true;
    } else {
      isRewinding = false;
    }

    // Render scene from camera perspective
    renderer.render(scene, camera);

    // Schedule next frame
    requestAnimationFrame(gameLoop);
  }

  // ------------------------
  // Handle window resizing
  // ------------------------

  window.addEventListener("resize", () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });

  // ------------------------
  // Start the game loop
  // ------------------------
  resetGame();
  gameLoop();
</script>
</body>
</html>

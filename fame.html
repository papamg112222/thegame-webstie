<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>The Rise and Fall - 3D Narrative Game</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Courier New', Courier, monospace; }
        #crosshair {
            position: absolute; top: 50%; left: 50%; width: 10px; height: 10px;
            background: rgba(255, 255, 255, 0.5); border-radius: 50%;
            transform: translate(-50%, -50%); pointer-events: none; z-index: 2;
        }
        #chat-ui {
            display: none; position: absolute; bottom: 20px; left: 50%;
            transform: translateX(-50%); width: 60%; background: rgba(0, 0, 0, 0.8);
            padding: 15px; border-radius: 10px; color: white; z-index: 10;
        }
        #chat-input {
            width: 100%; background: transparent; border: none; color: lime;
            font-size: 18px; outline: none;
        }
        #chat-log {
            max-height: 150px; overflow-y: auto; margin-bottom: 10px; font-size: 14px;
        }
        .ai-msg { color: #ffeb3b; margin: 5px 0; }
        .user-msg { color: #00e5ff; margin: 5px 0; }
        #story-overlay {
            position: absolute; top: 10%; width: 100%; text-align: center;
            color: white; font-size: 24px; text-shadow: 2px 2px 4px black;
            pointer-events: none; opacity: 0; transition: opacity 2s;
        }
        #blocker {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.8); color: white; display: flex;
            justify-content: center; align-items: center; flex-direction: column; z-index: 20;
        }
    </style>
</head>
<body>

<div id="crosshair"></div>
<div id="story-overlay"></div>

<div id="blocker">
    <h1>THE SOCIAL EXPERIMENT</h1>
    <p>Click to Wake Up</p>
    <p>Controls: WASD to Move | Mouse to Look | Press '/' to Talk</p>
</div>

<div id="chat-ui">
    <div id="chat-log"></div>
    <input type="text" id="chat-input" placeholder="Type here...">
</div>

<script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
</script>

<script type="module">
    import * as THREE from 'three';
    import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

    // --- GAME STATE ---
    let camera, scene, renderer, controls;
    let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
    let prevTime = performance.now();
    let velocity = new THREE.Vector3();
    let direction = new THREE.Vector3();
    
    // Story State
    let gameStartTime = 0;
    let currentPhase = 0; // 0: Waking Up, 1: Fame, 2: Hate
    const PHASE_FAME_TIME = 5000; // 5 seconds after wake up
    const PHASE_HATE_TIME = 45000; // 45 seconds later
    
    // Entities
    const npcs = [];
    const cars = [];
    
    // Voice Synth
    const synth = window.speechSynthesis;

    init();
    animate();

    function init() {
        // Scene Setup
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB); // Sky blue
        scene.fog = new THREE.Fog(0x87CEEB, 10, 100);

        // Camera
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 1000);
        camera.position.y = 1.7; // Human height

        // Lighting
        const light = new THREE.HemisphereLight(0xffffff, 0x777777, 2);
        light.position.set(0.5, 1, 0.75);
        scene.add(light);

        // Controls
        controls = new PointerLockControls(camera, document.body);

        const blocker = document.getElementById('blocker');
        blocker.addEventListener('click', function () {
            controls.lock();
        });

        controls.addEventListener('lock', function () {
            blocker.style.display = 'none';
            if(gameStartTime === 0) {
                gameStartTime = performance.now();
                showStoryText("I just woke up... head hurts...", 4000);
            }
        });

        controls.addEventListener('unlock', function () {
            // Only show blocker if not in chat mode
            if (document.getElementById('chat-ui').style.display !== 'block') {
                blocker.style.display = 'flex';
            }
        });

        scene.add(controls.getObject());

        // Keys
        const onKeyDown = function (event) {
            switch (event.code) {
                case 'ArrowUp': case 'KeyW': moveForward = true; break;
                case 'ArrowLeft': case 'KeyA': moveLeft = true; break;
                case 'ArrowDown': case 'KeyS': moveBackward = true; break;
                case 'ArrowRight': case 'KeyD': moveRight = true; break;
                case 'Slash': 
                    event.preventDefault();
                    toggleChat(); 
                    break;
            }
        };

        const onKeyUp = function (event) {
            switch (event.code) {
                case 'ArrowUp': case 'KeyW': moveForward = false; break;
                case 'ArrowLeft': case 'KeyA': moveLeft = false; break;
                case 'ArrowDown': case 'KeyS': moveBackward = false; break;
                case 'ArrowRight': case 'KeyD': moveRight = false; break;
            }
        };

        document.addEventListener('keydown', onKeyDown);
        document.addEventListener('keyup', onKeyUp);

        // World Building
        createWorld();

        // Renderer
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        window.addEventListener('resize', onWindowResize);
    }

    // --- WORLD GENERATION ---
    function createWorld() {
        // Floor
        const floorGeometry = new THREE.PlaneGeometry(2000, 2000, 100, 100);
        const floorMaterial = new THREE.MeshStandardMaterial({ color: 0x4caf50 });
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        scene.add(floor);

        // Road
        const roadGeo = new THREE.PlaneGeometry(20, 2000);
        const roadMat = new THREE.MeshStandardMaterial({ color: 0x333333 });
        const road = new THREE.Mesh(roadGeo, roadMat);
        road.rotation.x = -Math.PI / 2;
        road.position.y = 0.05;
        road.position.x = 20; // Offset from house
        scene.add(road);

        // Player's House (Start)
        createHouse(0, 0, 0, true);

        // Village Houses
        for (let i = -5; i < 5; i++) {
            if (i === 0) continue; 
            createHouse(40, 0, i * 30);
            createHouse(-10, 0, i * 30);
        }

        // NPCs
        for(let i=0; i<15; i++) {
            createNPC();
        }

        // Car
        createCar();
    }

    function createHouse(x, y, z, isPlayerHouse = false) {
        const houseGroup = new THREE.Group();

        // Walls (Smooth, not blocky - standard mesh)
        const geometry = new THREE.BoxGeometry(10, 6, 10); 
        const material = new THREE.MeshStandardMaterial({ color: isPlayerHouse ? 0xffccaa : 0xaaaaaa });
        const cube = new THREE.Mesh(geometry, material);
        cube.position.y = 3;
        houseGroup.add(cube);

        // Roof
        const roofGeo = new THREE.ConeGeometry(8, 4, 4);
        const roofMat = new THREE.MeshStandardMaterial({ color: 0x8d6e63 });
        const roof = new THREE.Mesh(roofGeo, roofMat);
        roof.position.y = 8;
        roof.rotation.y = Math.PI / 4;
        houseGroup.add(roof);

        houseGroup.position.set(x, y, z);
        scene.add(houseGroup);
    }

    function createNPC() {
        // Creating a "Man" using smooth shapes (Capsule/Cylinder)
        const npcGroup = new THREE.Group();
        
        // Body
        const bodyGeo = new THREE.CapsuleGeometry(0.5, 1.2, 4, 8);
        const bodyMat = new THREE.MeshStandardMaterial({ color: Math.random() * 0xffffff });
        const body = new THREE.Mesh(bodyGeo, bodyMat);
        body.position.y = 0.9;
        npcGroup.add(body);

        // Head
        const headGeo = new THREE.SphereGeometry(0.35, 16, 16);
        const headMat = new THREE.MeshStandardMaterial({ color: 0xffe0bd }); // Skin tone
        const head = new THREE.Mesh(headGeo, headMat);
        head.position.y = 1.8;
        npcGroup.add(head);

        // Spawn logic
        npcGroup.position.x = (Math.random() - 0.5) * 100;
        npcGroup.position.z = (Math.random() - 0.5) * 100;
        
        // Ensure not too close to start
        if(Math.abs(npcGroup.position.x) < 5 && Math.abs(npcGroup.position.z) < 5) npcGroup.position.x += 10;

        scene.add(npcGroup);
        
        // Assign random voice pitch
        const npcData = {
            mesh: npcGroup,
            voicePitch: 0.5 + Math.random(), 
            voiceRate: 0.8 + Math.random() * 0.4,
            walkSpeed: 0.02 + Math.random() * 0.03,
            direction: new THREE.Vector3(Math.random()-0.5, 0, Math.random()-0.5).normalize()
        };
        npcs.push(npcData);
    }

    function createCar() {
        const carGeo = new THREE.BoxGeometry(2.5, 1.5, 5);
        const carMat = new THREE.MeshStandardMaterial({ color: 0xff0000 });
        const car = new THREE.Mesh(carGeo, carMat);
        car.position.set(20, 0.75, -100);
        scene.add(car);
        cars.push({ mesh: car, speed: 0.5 });
    }

    // --- LOGIC & ANIMATION ---

    function animate() {
        requestAnimationFrame(animate);

        const time = performance.now();
        const delta = (time - prevTime) / 1000;
        
        // Story Progression
        if (gameStartTime > 0) {
            const elapsed = time - gameStartTime;
            
            // Phase 1: Fame (starts after 5 seconds)
            if (currentPhase === 0 && elapsed > PHASE_FAME_TIME) {
                currentPhase = 1;
                showStoryText("Wait... they are all looking at me. They know me?", 5000);
                // Trigger AI chatter
                triggerAmbientVoice("Oh my god it is him!", true);
            }
            
            // Phase 2: Hate (starts after 45 seconds)
            if (currentPhase === 1 && elapsed > PHASE_HATE_TIME) {
                currentPhase = 2;
                showStoryText("The atmosphere has changed... why do they look angry?", 5000);
                triggerAmbientVoice("Get away from us!", false);
            }
        }

        // Movement Physics
        if (controls.isLocked) {
            velocity.x -= velocity.x * 10.0 * delta;
            velocity.z -= velocity.z * 10.0 * delta;

            direction.z = Number(moveForward) - Number(moveBackward);
            direction.x = Number(moveRight) - Number(moveLeft);
            direction.normalize();

            if (moveForward || moveBackward) velocity.z -= direction.z * 400.0 * delta;
            if (moveLeft || moveRight) velocity.x -= direction.x * 400.0 * delta;

            controls.moveRight(-velocity.x * delta);
            controls.moveForward(-velocity.z * delta);
        }

        // NPC Logic (AI)
        npcs.forEach(npc => {
            const dist = npc.mesh.position.distanceTo(camera.position);

            // Behavior based on phase
            if (currentPhase === 0) {
                // Wandering
                npc.mesh.position.addScaledVector(npc.direction, npc.walkSpeed);
                if(Math.random() < 0.01) npc.direction.set(Math.random()-0.5, 0, Math.random()-0.5).normalize();
            } else if (currentPhase === 1) {
                // FAME: Follow and look at player
                npc.mesh.lookAt(camera.position.x, 1.7, camera.position.z);
                if (dist > 5) {
                    const dirToPlayer = new THREE.Vector3().subVectors(camera.position, npc.mesh.position).normalize();
                    dirToPlayer.y = 0;
                    npc.mesh.position.addScaledVector(dirToPlayer, npc.walkSpeed * 1.5);
                }
            } else if (currentPhase === 2) {
                // HATE: Look at player but back away or stand still menacingly
                npc.mesh.lookAt(camera.position.x, 1.7, camera.position.z);
            }
        });

        // Car Logic
        cars.forEach(car => {
            car.mesh.position.z += car.speed;
            if(car.mesh.position.z > 200) car.mesh.position.z = -200;
        });

        prevTime = time;
        renderer.render(scene, camera);
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function showStoryText(text, duration) {
        const overlay = document.getElementById('story-overlay');
        overlay.innerText = text;
        overlay.style.opacity = 1;
        setTimeout(() => {
            overlay.style.opacity = 0;
        }, duration);
    }

    // --- CHAT & AI LOGIC ---

    const chatInput = document.getElementById('chat-input');
    const chatUI = document.getElementById('chat-ui');
    const chatLog = document.getElementById('chat-log');

    function toggleChat() {
        if (chatUI.style.display === 'block') {
            // Close chat
            chatUI.style.display = 'none';
            chatInput.blur();
            controls.lock();
        } else {
            // Open chat
            controls.unlock();
            chatUI.style.display = 'block';
            chatInput.focus();
        }
    }

    chatInput.addEventListener('keydown', function(e) {
        if (e.key === 'Enter') {
            const text = chatInput.value;
            if (!text) return;
            
            // Add User Text
            addToChat("You", text);
            chatInput.value = '';

            // Simulate AI Processing time
            setTimeout(() => {
                generateAIResponse(text);
            }, 1000); // 1 second delay for realism
        }
    });

    function addToChat(sender, msg) {
        const div = document.createElement('div');
        div.className = sender === "You" ? 'user-msg' : 'ai-msg';
        div.innerText = `${sender}: ${msg}`;
        chatLog.appendChild(div);
        chatLog.scrollTop = chatLog.scrollHeight;
    }

    // THE "SMART AI" BRAIN
    function generateAIResponse(userText) {
        const lowerText = userText.toLowerCase();
        let response = "";
        let mood = "neutral";

        // Logic determines response based on story phase
        if (currentPhase === 0) {
            // Normal / Confused
            if (lowerText.includes("hello") || lowerText.includes("hi")) response = "Oh, hello there. Nice morning, isn't it?";
            else if (lowerText.includes("who")) response = "I'm just a neighbor. You look sleepy.";
            else response = "I have to get to work. See you around.";
        } 
        else if (currentPhase === 1) {
            // FAME - They love you
            if (lowerText.includes("why")) response = "Why? Because you're amazing! Can I have an autograph?";
            else if (lowerText.includes("hello")) response = "OMG! He spoke to me! Hello sir!!";
            else if (lowerText.includes("stop")) response = "I can't stop looking, you're a star!";
            else response = "Everything you say is brilliant! Tell us more!";
            mood = "happy";
        } 
        else if (currentPhase === 2) {
            // HATE - They hate you
            if (lowerText.includes("help")) response = "We don't help people like you anymore.";
            else if (lowerText.includes("why")) response = "You know what you did. Just leave us alone.";
            else if (lowerText.includes("sorry")) response = "Save your breath. We're done with you.";
            else response = "Get out of my sight. Disgusting.";
            mood = "angry";
        }

        // Pick a random NPC to "speak"
        const speaker = npcs[Math.floor(Math.random() * npcs.length)];
        
        addToChat("Villager", response);
        speakText(response, speaker);
    }

    // Voice Synthesis (The "Voice Over")
    function speakText(text, npcData) {
        if (!synth) return;
        if (synth.speaking) synth.cancel();

        const utterThis = new SpeechSynthesisUtterance(text);
        
        // Pitch variation makes them sound different
        utterThis.pitch = npcData ? npcData.voicePitch : 1; 
        utterThis.rate = npcData ? npcData.voiceRate : 1;

        // Try to select an English voice
        const voices = synth.getVoices();
        const enVoice = voices.find(v => v.lang.includes('en'));
        if(enVoice) utterThis.voice = enVoice;

        synth.speak(utterThis);
    }

    function triggerAmbientVoice(text, isPositive) {
        // Random ambient shout
        const speaker = npcs[Math.floor(Math.random() * npcs.length)];
        speakText(text, speaker);
    }

</script>
</body>
</html>

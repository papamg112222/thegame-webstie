/* --- Global Constants (Aesthetic Mapping) --- */
:root {
    --royal-bg: #2E2E38;
    --panel-bg: #383B40;
    --light-square: #F0D9B5;
    --dark-square: #B58863;
    --gold-piece: #000000;
    --silver-piece: #FFFFFF;
    --accent-red: #F04747;
    --accent-green: #43b581;
    --highlight-color: #A8C356;
    --attack-color: #FF5733;
    --frozen-color: #00BFFF;
    --dot-color: #383B40;
    --power-target-color: #FFA500;
    --murasaki-void: #0D0D0D;
    --murasaki-red: #FF4500;
    --murasaki-blue: #00BFFF;

    /* Base Sizes (Desktop) */
    --base-piece-font-size: 52px;
    --base-dot-font-size: 36px;
    --base-panel-font-size: 10px;
    --base-title-font-size: 18px;
    
    /* Responsive Sizes (Updated by JS) */
    --piece-font-size: var(--base-piece-font-size);
    --dot-font-size: var(--base-dot-font-size);
    --panel-font-size: var(--base-panel-font-size);
    --title-font-size: var(--base-title-font-size);
}

body {
    background-color: var(--royal-bg);
    margin: 0;
    display: flex;
    justify-content: center;
    align-items: center;
    min-height: 100vh;
    font-family: Arial, sans-serif;
    color: var(--silver-piece);
    overflow: auto;
}

#game-container {
    display: flex;
    flex-direction: row;
    width: 95%;
    max-width: 1200px;
    height: 95vh;
    max-height: 95vh;
    margin: auto;
    box-sizing: border-box;
}

.hidden {
    display: none !important;
}

/* --- Menu Styling --- */
.menu-screen {
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    text-align: center;
    width: 100%;
    height: 100%;
    padding: 20px;
    background-color: var(--panel-bg);
    border-radius: 8px;
    box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
}

.menu-screen h1 {
    font-size: 32px;
    color: var(--accent-green);
    margin-bottom: 40px;
}

.menu-screen button {
    padding: 15px 30px;
    margin: 10px 0;
    border: none;
    cursor: pointer;
    font-size: 18px;
    font-weight: bold;
    color: white;
    width: 100%;
    max-width: 400px;
    border-radius: 4px;
    transition: background-color 0.2s;
}

#start-local-btn {
    background-color: var(--panel-bg);
    border: 4px solid var(--accent-green);
}
#start-local-btn:hover {
    background-color: #474751;
}

.bot-settings {
    width: 100%;
    max-width: 400px;
    margin: 20px 0;
    padding: 15px;
    background-color: var(--royal-bg);
    border-radius: 4px;
}

.bot-settings h2 {
    font-size: 14px;
    color: var(--light-square);
    margin-bottom: 10px;
}

#elo-control {
    display: flex;
    align-items: center;
    margin-bottom: 10px;
}

#elo-label {
    flex-shrink: 0;
    margin-right: 10px;
    font-size: 14px;
    color: var(--light-square);
}

#elo-slider {
    flex-grow: 1;
    -webkit-appearance: none;
    height: 8px;
    background: #474751;
    outline: none;
    opacity: 0.7;
    transition: opacity .2s;
}
#elo-slider::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 16px;
    height: 16px;
    border-radius: 50%;
    background: var(--accent-green);
    cursor: pointer;
}

#start-bot-btn {
    background-color: var(--accent-green);
}
#start-bot-btn:hover {
    background-color: #389569;
}

.coming-soon {
    display: flex;
    align-items: center;
    width: 100%;
    max-width: 400px;
}

.coming-soon button {
    flex-grow: 1;
    background-color: var(--panel-bg);
    color: #888888;
    cursor: default;
    border: 1px solid #555;
}

.soon-tag {
    color: var(--accent-red);
    font-weight: bold;
    margin-left: 10px;
    font-size: 12px;
}

/* --- Game UI Layout --- */
#game-ui {
    display: flex;
    flex-direction: row;
    width: 100%;
    height: 100%;
    box-sizing: border-box;
    padding: 20px;
}

#board-ui-frame {
    flex-grow: 1;
    display: flex;
    justify-content: center;
    align-items: center;
    position: relative;
    max-width: 70%;
    max-height: 100%;
    margin-right: 20px;
}

#board-container {
    display: grid;
    grid-template-columns: auto repeat(8, 1fr);
    grid-template-rows: repeat(8, 1fr) auto;
    aspect-ratio: 1 / 1;
    max-width: 100%;
    max-height: 100%;
}

#board-frame {
    grid-column: 2 / 10;
    grid-row: 1 / 9;
    display: grid;
    grid-template-columns: repeat(8, 1fr);
    grid-template-rows: repeat(8, 1fr);
    width: 100%;
    height: 100%;
    border: 2px solid var(--dark-square);
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);
    position: relative; /* Needed for overlay */
}

/* Coordinates */
#rank-labels-container {
    grid-column: 1 / 2;
    grid-row: 1 / 9;
    display: grid;
    grid-template-rows: repeat(8, 1fr);
    align-items: center;
    padding-right: 5px;
}
#file-labels-container {
    grid-column: 2 / 10;
    grid-row: 9 / 10;
    display: grid;
    grid-template-columns: repeat(8, 1fr);
    justify-items: center;
    padding-top: 5px;
}
.coord-label {
    font-size: calc(var(--panel-font-size) + 4px);
    font-weight: bold;
    color: var(--silver-piece);
    text-align: center;
}

/* --- Board Squares --- */
.square {
    display: flex;
    justify-content: center;
    align-items: center;
    cursor: pointer;
    font-size: var(--piece-font-size);
    transition: background-color 0.1s;
    user-select: none;
    box-sizing: border-box;
    padding: 0;
}

.piece-symbol {
    /* Ensures unicode pieces are centered */
    line-height: 1;
    text-align: center;
}

/* Highlighted States */
.selected {
    background-color: var(--highlight-color) !important;
}

.attack-target {
    background-color: var(--attack-color) !important;
}

.power-target {
    background-color: var(--power-target-color) !important;
    border: 3px solid var(--accent-red);
}

.move-dot {
    font-size: var(--dot-font-size);
    color: var(--dot-color);
    line-height: 1;
}

.frozen {
    background-color: var(--frozen-color) !important;
}

/* Blockade/Roomba */
.blockade-symbol {
    color: #FF4500;
}
.roomba-symbol {
    color: #FFD700;
    background-color: #474751;
}

/* Piece Colors */
.W-piece { color: var(--gold-piece); }
.B-piece { color: var(--silver-piece); }
.hacked-piece { color: #FFD700 !important; }

/* Archbishop/Frozen font size adjustments */
.small-font {
    font-size: calc(var(--piece-font-size) - 12px) !important;
}

/* --- Game Over Overlay --- */
#game-overlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(46, 46, 56, 0.85); /* royal-bg with transparency */
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    text-align: center;
    cursor: pointer;
    z-index: 10;
}

#overlay-message {
    font-size: 30px;
    font-weight: bold;
    color: var(--accent-red);
    margin-bottom: 10px;
}
#overlay-click-prompt {
    font-size: 16px;
    color: var(--light-square);
    margin-top: 20px;
}

/* --- Panel Styling --- */
#panel-frame {
    flex-shrink: 0;
    width: 280px;
    background-color: var(--panel-bg);
    padding: 15px;
    border-radius: 4px;
    box-sizing: border-box;
    display: flex;
    flex-direction: column;
    align-items: stretch;
    border: 2px solid var(--dark-square);
}

#panel-frame h2 {
    font-size: var(--title-font-size);
    font-weight: bold;
    color: var(--silver-piece);
    text-align: center;
    margin: 10px 0;
}

#status-label {
    font-size: var(--title-font-size);
    font-weight: bold;
    text-align: center;
    padding: 5px 0;
}

#r-uses-label {
    font-size: calc(var(--panel-font-size) + 1px);
    color: #FFD700;
    text-align: center;
    padding: 2px 0;
}

#message-label {
    font-size: calc(var(--panel-font-size) + 2px);
    padding: 5px;
    margin: 5px 0 15px 0;
    min-height: 40px;
    background-color: #474751;
    border-radius: 4px;
    text-align: center;
}

#ability-info-frame {
    background-color: #474751;
    padding: 8px;
    border-radius: 4px;
    border: 1px solid var(--dark-square);
    margin-bottom: 10px;
}

.ultimate-separator {
    font-size: calc(var(--panel-font-size) + 1px);
    font-weight: bold;
    color: var(--silver-piece);
    text-align: center;
    margin: 5px 0;
}

#ability-title {
    font-size: calc(var(--panel-font-size) + 3px);
    font-weight: bold;
    color: var(--accent-green);
    text-align: center;
    padding: 2px 0;
}

#ability-desc {
    font-size: var(--panel-font-size);
    color: var(--light-square);
    text-align: left;
    padding: 5px;
    min-height: 40px;
}

#ability-prompt {
    font-size: calc(var(--panel-font-size) + 1px);
    color: var(--accent-green);
    text-align: center;
    padding: 5px 0;
}

#cmd-frame {
    margin-bottom: 15px;
}

#cmd-frame button {
    width: 100%;
    padding: 8px;
    margin: 2px 0;
    background-color: #474751;
    color: white;
    border: none;
    border-radius: 3px;
    cursor: pointer;
    font-size: calc(var(--panel-font-size) + 1px);
    transition: background-color 0.2s;
}

#cmd-frame button:hover:not(:disabled) {
    background-color: #5d6168;
}

#cmd-frame button:disabled {
    background-color: #2e2e38;
    color: #888888;
    cursor: default;
}

#ultimate-button {
    padding: 10px;
    margin-top: auto;
    background-color: var(--accent-red);
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-size: calc(var(--title-font-size) - 2px);
    font-weight: bold;
    transition: background-color 0.2s;
}

#ultimate-button:hover:not(:disabled) {
    background-color: #c73737;
}

#ultimate-button:disabled {
    background-color: #555555;
    cursor: default;
}

/* --- Responsive Design (Mobile) --- */
@media (max-width: 800px) {
    :root {
        --base-piece-font-size: 40px;
        --base-dot-font-size: 28px;
        --base-panel-font-size: 9px;
        --base-title-font-size: 14px;
    }

    #game-container {
        flex-direction: column;
        padding: 5px;
        height: auto;
        min-height: 100vh;
    }

    #game-ui {
        flex-direction: column;
        padding: 5px;
    }

    #panel-frame {
        width: 100%;
        margin: 5px 0;
        padding: 10px;
        order: -1; /* Panel on top */
    }

    #board-ui-frame {
        width: 100%;
        margin: 5px 0;
        max-width: 100%;
        max-height: 80vh;
    }

    /* Override grid template on mobile for board container to be fully responsive within the limited space */
    #board-container {
        grid-template-columns: auto 1fr;
        grid-template-rows: repeat(8, 1fr) auto;
        width: 100%;
    }

    #board-frame {
        grid-column: 2 / 3;
        grid-row: 1 / 9;
    }

    #rank-labels-container {
        grid-column: 1 / 2;
        grid-row: 1 / 9;
        font-size: 14px;
    }

    #file-labels-container {
        grid-column: 2 / 3;
        grid-row: 9 / 10;
        font-size: 14px;
    }
}
// --- Global Constants (Game Engine Data) ---
const UNICODE_PIECES = {
    'WK': 'â™”', 'WQ': 'â™•', 'WR': 'â™–', 'WB': 'â™—', 'WN': 'â™˜', 'WP': 'â™™',
    'BK': 'â™š', 'BQ': 'â™›', 'BR': 'â™œ', 'BB': 'â™', 'BN': 'â™ž', 'BP': 'â™Ÿ',
    'BL': 'ðŸš§', // Blockade/Traffic Jam symbol
    'FR': 'â„ï¸', // Frozen Symbol
    'RM': 'ðŸ¤–', // Roomba Symbol
    // Archbishop (A): Fused Knight + Bishop symbol.
    'WA': 'â™˜â™—', 'BA': 'â™žâ™'
};

// Mapping of file (column) letters to indices
const FILE_MAP = {
    'a': 0, 'b': 1, 'c': 2, 'd': 3, 'e': 4, 'f': 5, 'g': 6, 'h': 7
};
const RANK_MAP = {
    '1': 0, '2': 1, '3': 2, '4': 3, '5': 4, '6': 5, '7': 6, '8': 7
}; // Ranks 1-8 map to indices 0-7

// Standard Piece Values for AI evaluation
const PIECE_VALUES = {
    'P': 100,
    'N': 300,
    'B': 300,
    'R': 500,
    'Q': 900,
    'K': 10000,
    'A': 650,
    'RM': 1000
};


// --- Custom Powers (Updated with new Rook Ultimate) ---
const ULTIMATE_POWERS = {
    'GENERAL': {
        'name': "Temporal Blockade",
        'mode': 'BLOCKADE',
        'desc': "Places an indestructible blockade (ðŸš§). Each side can have up to TWO blockades active at once.",
        'prompt': "Select an empty square for the blockade."
    },
    'N': {
        'name': "Archbishop's Fusion",
        'mode': 'KNIGHT_FUSION',
        'desc': "Fuses a friendly Knight and Bishop that are on adjacent or two-square diagonal squares (e.g., a1/b2, a1/c2) into a powerful **Archbishop (A)**. The Archbishop moves as a Knight OR a Bishop.",
        'prompt': "Select the friendly Bishop to fuse with."
    },
    'B': {
        'name': "Cat's Cradle Catastrophe",
        'mode': 'BISHOP_FREEZE',
        'desc': "Bishop releases a Web of Distraction along its attack diagonal. All pieces on that diagonal are **frozen** for the opponent's next turn. Requires Bishop to be attacked.",
        'prompt': "Select the target Bishop for the Cat's Cradle attack (if it is attacked)."
    },
    'R': { // NEW COMMAND-LINE ULTIMATE
        'name': "Hax.exe Command Shell",
        'mode': 'R_COMMAND_SELECT', // Initial mode for button selection
        'desc': "Opens the Hax.exe command shell. Allows one of two commands: /hack or /phase. Usable twice per team.",
        'prompt': "Select /HACK (Friendly Fire) or /PHASE (Teleport) below."
    },
    'K': { // KING ULTIMATE
        'name': "Domain Expansion: Murasaki",
        'mode': 'MURASAKI',
        'desc': "Activates on a **self-sacrifice**: King captures a friendly Pawn. The resulting 'Murasaki' beam instantly removes a **random** enemy piece (not the King).",
        'prompt': "Select a friendly Pawn for the King to capture to initiate Murasaki."
    }
};

// --- Aesthetic Constants (Chess.com Classic Theme) ---
// Defined in CSS, but needed for class toggling (mapped to CSS variables in style.css)
// NOTE: JS uses classes for colors/highlights instead of inline styles for better performance/CSS control.

// --- 1. GAME LOGIC (UltimateChessGame Class) ---

class UltimateChessGame {
    constructor() {
        this.board = this._initialize_board();
        this.current_turn = 'W';

        this.active_blockades = {
            'W': [],
            'B': []
        };
        this.message = "Game started! White moves first. ULTIMATE is available per piece.";
        this.is_check = false;
        this.is_power_mode = null;
        this.selected_square_coords = null;
        this.current_ultimate_power_info = ULTIMATE_POWERS['GENERAL'];

        // --- Standard Chess State ---
        this.en_passant_target = null;
        this.game_over = null;

        // --- ABILITY STATE (NEW/MODIFIED) ---
        this.frozen_pieces = {}; // Stores {f, r} : turns_remaining
        this.roomba_pos = null; // {f, r}
        this.roomba_target = null; // {f, r} of King target
        this.roomba_moves_remaining = 0;

        // New Rook Ultimate Tracking
        this.r_power_uses = {
            'W': 2,
            'B': 2
        };
        this.hacked_piece = null; // Stores {f, r} of the hacked piece
        this.phase_move_pending = false;

        // Store for AI: List of move dicts: {f1:..., r1:..., f2:..., r2:..., value:...}
        this.available_ai_moves = [];
    }

    _initialize_board() {
        /** Sets up the initial chess board. */
        let board = Array(8).fill(null).map(() => Array(8).fill(null));

        for (let f = 0; f < 8; f++) {
            board[f][1] = {
                'type': 'P',
                'color': 'W',
                'moved': false
            };
            board[f][6] = {
                'type': 'P',
                'color': 'B',
                'moved': false
            };
        }

        const back_rank = ['R', 'N', 'B', 'Q', 'K', 'B', 'N', 'R'];
        for (let f = 0; f < 8; f++) {
            const piece_type = back_rank[f];
            board[f][0] = {
                'type': piece_type,
                'color': 'W',
                'moved': false
            };
            board[f][7] = {
                'type': piece_type,
                'color': 'B',
                'moved': false
            };
        }

        return board;
    }

    // --- Utility Methods ---

    _coords_to_indices(coord) {
        if (coord.length !== 2 || !(coord[0] in FILE_MAP) || !(coord[1] in RANK_MAP)) {
            throw new Error(`Invalid coordinate: ${coord}`);
        }
        const f = FILE_MAP[coord[0]];
        const r = RANK_MAP[coord[1]];
        return {
            f,
            r
        };
    }

    _indices_to_coords(f, r) {
        const file_char = String.fromCharCode('a'.charCodeAt(0) + f);
        const rank_char = String(r + 1);
        return file_char + rank_char;
    }

    _get_piece_power(piece_type) {
        return ULTIMATE_POWERS[piece_type] || ULTIMATE_POWERS['GENERAL'];
    }

    _is_square_blocked(f, r) {
        for (const color of Object.keys(this.active_blockades)) {
            if (this.active_blockades[color].some(b => b.f === f && b.r === r)) {
                return true;
            }
        }
        return false;
    }

    _is_square_frozen(f, r) {
        /** Checks if a square is occupied by a frozen piece. */
        const key = `${f},${r}`;
        return this.frozen_pieces.hasOwnProperty(key) && this.frozen_pieces[key] > 0;
    }

    _get_king_pos(color) {
        for (let f = 0; f < 8; f++) {
            for (let r = 0; r < 8; r++) {
                const piece = this.board[f][r];
                if (piece && piece.color === color && piece.type === 'K') {
                    return {
                        f,
                        r
                    };
                }
            }
        }
        return null;
    }

    _is_king_in_check(color) {
        const king_pos = this._get_king_pos(color);
        if (!king_pos) return false;

        const opponent_color = color === 'W' ? 'B' : 'W';
        return this._is_square_attacked(king_pos.f, king_pos.r, opponent_color);
    }

    has_legal_moves(color) {
        /** Checks if the player has any legal moves available. */
        return this.get_all_legal_moves_for_color(color).length > 0;
    }

    // --- AI Specific Functions (Simplified Minimax) ---

    get_all_legal_moves_for_color(color) {
        /** Generates all legal moves for a given color, including full move data. */
        const all_moves = [];
        const original_turn = this.current_turn;
        this.current_turn = color; // Temporarily set turn for validation

        for (let f1 = 0; f1 < 8; f1++) {
            for (let r1 = 0; r1 < 8; r1++) {
                const piece = this.board[f1][r1];
                if (piece && piece.color === color) {
                    const targets = this.get_legal_moves(f1, r1);
                    for (const target of targets) {
                        const f2 = target.f;
                        const r2 = target.r;
                        const move = {
                            'f1': f1,
                            'r1': r1,
                            'f2': f2,
                            'r2': r2,
                            'piece': piece.type,
                            'is_capture': target.is_capture
                        };

                        // Use the simplified _validate_move (which checks for check safety)
                        if (this._validate_move(f1, r1, f2, r2)) {
                            move['value'] = this._evaluate_move(f1, r1, f2, r2, piece);
                            all_moves.push(move);
                        }
                    }
                }
            }
        }

        this.current_turn = original_turn; // Restore turn
        return all_moves;
    }

    _evaluate_move(f1, r1, f2, r2, moving_piece) {
        /** Estimates the value of a move for the current turn (higher is better). */
        let value = 0;
        const opponent_color = moving_piece.color === 'W' ? 'B' : 'W';

        // 1. Capture Bonus
        const target = this.board[f2][r2];
        const is_roomba_capture = this.roomba_pos && this.roomba_pos.f === f2 && this.roomba_pos.r === r2;

        if (target && target.color !== moving_piece.color) { // Check for actual enemy capture
            const target_value = PIECE_VALUES[target.type] || 0;
            value += target_value;
        } else if (is_roomba_capture) {
            value += PIECE_VALUES['RM'];
        }

        // 2. Check/Checkmate Bonus (Simplified)
        const original_target = this.board[f2][r2];
        const original_piece = this.board[f1][r1];

        // Simulate move
        this.board[f2][r2] = moving_piece;
        this.board[f1][r1] = null;

        if (this._is_king_in_check(opponent_color)) {
            value += 500; // Simple check bonus
        }

        // Revert move
        this.board[f1][r1] = original_piece;
        this.board[f2][r2] = original_target;

        // 3. Random element (To prevent perfect repetition, especially for low ELO)
        value += Math.random() * 5;

        return value;
    }

    get_bot_move(elo) {
        /** Chooses a move based on the simulated ELO. */

        this.available_ai_moves = this.get_all_legal_moves_for_color(this.current_turn);

        if (!this.available_ai_moves.length) {
            return null;
        }

        this.available_ai_moves.sort((a, b) => b.value - a.value);

        const best_move = this.available_ai_moves[0];

        // Simple ELO based selection logic
        if (elo <= 1000) {
            // Low ELO: mostly random, sometimes best
            if (Math.random() < (elo / 2000)) {
                return best_move;
            } else {
                return this.available_ai_moves[Math.floor(Math.random() * this.available_ai_moves.length)];
            }

        } else if (1000 < elo && elo <= 2000) {
            // Medium ELO: picks from top 5 moves, favors best
            const top_moves = this.available_ai_moves.slice(0, Math.max(1, Math.min(5, this.available_ai_moves.length)));

            const confidence_factor = (elo - 1000) / 1000;

            if (Math.random() < (0.5 + confidence_factor * 0.5)) {
                return best_move;
            } else {
                return top_moves[Math.floor(Math.random() * top_moves.length)];
            }

        } else {
            // High ELO: almost always best move
            if (Math.random() < 0.95) {
                return best_move;
            } else {
                return this.available_ai_moves[Math.floor(Math.random() * this.available_ai_moves.length)];
            }
        }
    }

    // --- Power Activation Logic ---

    activate_ultimate(f, r) {
        /** Starts the power sequence for the selected piece. */
        const piece = this.board[f][r];
        if (!piece || piece.color !== this.current_turn) {
            this.message = "Cannot activate ultimate: no friendly piece selected.";
            return false;
        }

        const power_info = this._get_piece_power(piece.type);
        this.current_ultimate_power_info = power_info;
        this.selected_square_coords = {
            f,
            r
        };
        this.is_power_mode = power_info.mode;

        if (this.is_power_mode === 'BLOCKADE') {
            // Temporal Blockade: Immediate activation, requires square click
            if (this.active_blockades[this.current_turn].length >= 2) {
                this.message = "You already have the maximum number of blockades (2) active.";
                this.is_power_mode = null;
                return false;
            }
            this.message = `Temporal Blockade ready. ${power_info.prompt}`;
            return true;

        } else if (this.is_power_mode === 'BISHOP_FREEZE') {
            // Cat's Cradle Catastrophe: Only if Bishop is currently attacked
            const opponent_color = this.current_turn === 'W' ? 'B' : 'W';
            if (!this._is_square_attacked(f, r, opponent_color, true)) {
                this.message = "Bishop must be attacked to use Cat's Cradle Catastrophe!";
                this.is_power_mode = null;
                return false;
            }
            this.message = "Bishop activated Cat's Cradle! Select the diagonal target square to freeze along that line.";
            return true;

        } else if (this.is_power_mode === 'R_COMMAND_SELECT') {
            if (this.r_power_uses[this.current_turn] <= 0) {
                this.message = "Rook ultimate uses exhausted for this team.";
                this.is_power_mode = null;
                return false;
            }
            // Go straight to selection mode (GUI will show buttons)
            this.message = `${power_info.name} opened. Choose a command.`;
            return true;

        } else if (['KNIGHT_FUSION', 'ROOK_ROOMBA', 'MURASAKI'].includes(this.is_power_mode)) {
            // These powers require a subsequent move or selection
            this.message = `${power_info.name} ready. ${power_info.prompt}`;
            return true;
        }

        this.is_power_mode = null;
        this.message = "Ultimate activated, but no special mode detected. Select action.";
        return true;
    }

    place_blockade(coord) {
        /** Places a blockade at the given algebraic coordinate. */
        try {
            const {
                f,
                r
            } = this._coords_to_indices(coord);

            if (this.board[f][r] !== null || this._is_square_blocked(f, r)) {
                this.message = "Blockade square must be empty and not already blocked.";
                this.is_power_mode = null;
                return false;
            }

            if (this.active_blockades[this.current_turn].length >= 2) {
                this.message = "Maximum blockades (2) already reached for this side.";
                this.is_power_mode = null;
                return false;
            }

            this.active_blockades[this.current_turn].push({
                f,
                r
            });
            this.message = `Temporal Blockade successfully placed at ${coord}.`;
            this._next_turn();
            return true;
        } catch (e) {
            this.message = "Invalid coordinate for blockade.";
            this.is_power_mode = null;
            return false;
        }
    }

    perform_fusion(bf, br) {
        /** Fuses a selected Knight and the target Bishop into an Archbishop. */
        const {
            f: nf,
            r: nr
        } = this.selected_square_coords;

        const knight = this.board[nf][nr];
        const bishop = this.board[bf][br];

        if (!(knight && bishop && knight.type === 'N' && bishop.type === 'B' && knight.color === bishop.color)) {
            this.message = "Fusion failed: Required pieces (Friendly Knight and Bishop) not found.";
            this.is_power_mode = null;
            return false;
        }

        // Replace Knight with Archbishop
        this.board[nf][nr] = {
            'type': 'A',
            'color': knight.color,
            'moved': true
        };

        // Remove Bishop
        this.board[bf][br] = null;

        this.message = `Archbishop formed at ${this._indices_to_coords(nf, nr)}! Bishop sacrificed.`;
        this.is_power_mode = null;
        this._next_turn();
        return true;
    }

    _activate_b_ultimate(f1, r1, f2, r2) {
        /** Activates Bishop Freeze (Cat's Cradle) on the diagonal attack line (f1,r1) -> (f2,r2). */
        const piece = this.board[f1][r1];

        if (Math.abs(f1 - f2) !== Math.abs(r1 - r2)) {
            this.message = "Bishop must move diagonally to activate Cat's Cradle.";
            this.is_power_mode = null;
            return false;
        }

        // 1. Freeze pieces on the line (excluding the bishop itself and the king)
        const df = f2 > f1 ? 1 : -1;
        const dr = r2 > r1 ? 1 : -1;

        let f = f1;
        let r = r1;
        let frozen_count = 0;

        while (f !== f2 || r !== r2) {
            f += df;
            r += dr;
            if (f < 0 || f > 7 || r < 0 || r > 7) break; // Should not happen if move is valid

            const target = this.board[f][r];
            if (target && target.type !== 'K') {
                this.frozen_pieces[`${f},${r}`] = 2; // Freeze for the opponent's next turn (2 half-turns)
                frozen_count++;
            }
        }

        // 2. Perform the Bishop move (and capture if applicable)
        const target_piece = this.board[f2][r2];
        this.board[f2][r2] = piece;
        this.board[f1][r1] = null;
        piece.moved = true;

        const capture_msg = target_piece ? ` (Captured ${target_piece.color}${target_piece.type})` : "";
        this.message = `Bishop activated Cat's Cradle. ${frozen_count} piece(s) frozen for 1 turn! Bishop moved to ${this._indices_to_coords(f2, r2)}.` + capture_msg;

        this.is_power_mode = null;
        this._next_turn();
        return true;
    }

    _execute_k_ultimate_logic() {
        /** Executes the Murasaki logic (removes random enemy piece) and switches turn. */

        const opponent_color = this.current_turn === 'W' ? 'B' : 'W';
        const enemy_pieces = [];

        // 1. Find all eligible enemy pieces (everything but the King)
        for (let f = 0; f < 8; f++) {
            for (let r = 0; r < 8; r++) {
                const piece = this.board[f][r];
                if (piece && piece.color === opponent_color && piece.type !== 'K') {
                    enemy_pieces.push({
                        f,
                        r,
                        piece
                    });
                }
            }
        }

        if (!enemy_pieces.length) {
            // No eligible target found
            this.message += " (No eligible target for Murasaki, power dissipated harmlessly.)";
        } else {
            // 2. Select a random enemy piece to capture and remove it
            const {
                f: target_f,
                r: target_r,
                piece: target_piece
            } = enemy_pieces[Math.floor(Math.random() * enemy_pieces.length)];
            this.board[target_f][target_r] = null;

            // 3. Update the message
            const target_coord = this._indices_to_coords(target_f, target_r);
            this.message += ` **Murasaki** beam hits ${target_piece.color}${target_piece.type} at ${target_coord}! Piece vaporized.`;
        }

        this.is_power_mode = null;
        this._next_turn();
        return true;
    }


    _move_roomba() {
        /** Moves the Roomba one square closer to the enemy King. */
        if (!this.roomba_pos || this.roomba_moves_remaining <= 0) {
            return;
        }

        const k_pos = this.roomba_target;
        if (!k_pos) {
            this.roomba_pos = null;
            this.roomba_moves_remaining = 0;
            return;
        }

        const {
            f: kf,
            r: kr
        } = k_pos;
        const {
            f: rf,
            r: rr
        } = this.roomba_pos;

        let df = 0;
        if (kf > rf) df = 1;
        else if (kf < rf) df = -1;

        let dr = 0;
        if (kr > rr) dr = 1;
        else if (kr < rr) dr = -1;

        const new_rf = rf + df;
        const new_rr = rr + dr;

        // Check bounds
        if (!(new_rf >= 0 && new_rf <= 7 && new_rr >= 0 && new_rr <= 7)) {
            this.roomba_pos = null;
            this.roomba_moves_remaining = 0;
            this.message += " (Roomba drove off the board and self-destructed.)";
            return;
        }


        // If Roomba reaches King or is blocked/captured
        if (new_rf === kf && new_rr === kr) {
            this.roomba_pos = null;
            this.roomba_moves_remaining = 0;
            this.board[kf][kr] = null; // King captured
            this.game_over = 'CHECKMATE';
            this.message = "Roomba captured the King! Checkmate!";

        } else if (this.board[new_rf][new_rr] !== null || this._is_square_blocked(new_rf, new_rr)) {
            // Roomba hits a piece or blockade (it stops and destroys itself)
            const target_piece = this.board[new_rf][new_rr];
            const target_coord = this._indices_to_coords(new_rf, new_rr);

            if (target_piece) {
                this.board[new_rf][new_rr] = null; // Capture/destroy piece
                this.message = `Roomba collided with ${target_piece.color}${target_piece.type} at ${target_coord} and self-destructed.`;
            } else if (this._is_square_blocked(new_rf, new_rr)) {
                // Remove blockade
                this.active_blockades['W'] = this.active_blockades['W'].filter(b => !(b.f === new_rf && b.r === new_rr));
                this.active_blockades['B'] = this.active_blockades['B'].filter(b => !(b.f === new_rf && b.r === new_rr));
                this.message = `Roomba destroyed blockade at ${target_coord} and self-destructed.`;
            }

            this.roomba_pos = null;
            this.roomba_moves_remaining = 0;

        } else {
            this.roomba_pos = {
                f: new_rf,
                r: new_rr
            };
            this.roomba_moves_remaining -= 1;
            this.message += ` (Roomba moved to ${this._indices_to_coords(new_rf, new_rr)}. Moves left: ${this.roomba_moves_remaining})`;

            if (this.roomba_moves_remaining === 0) {
                this.roomba_pos = null;
                this.message += " (Roomba fuel exhausted and removed.)";
            }
        }
    }

    _activate_r_ultimate(f1, r1, f2, r2) {
        /** Launches the Roomba and moves the Rook. */
        const piece = this.board[f1][r1];

        if (Math.abs(f2 - f1) > 1 || Math.abs(r2 - r1) > 1 || (f1 === f2 && r1 === r2)) {
            this.message = "Rook must retreat to an adjacent square.";
            this.is_power_mode = null;
            return false;
        }

        if (this.board[f2][r2] !== null || this._is_square_blocked(f2, r2)) {
            this.message = "Rook retreat square must be empty and not blocked.";
            this.is_power_mode = null;
            return false;
        }

        // 1. Rook retreats
        this.board[f2][r2] = piece;
        this.board[f1][r1] = null;
        piece.moved = true;

        // 2. Roomba deployed
        this.roomba_pos = {
            f: f1,
            r: r1
        };
        this.roomba_moves_remaining = 4;
        this.roomba_target = this._get_king_pos(this.current_turn === 'W' ? 'B' : 'W');

        if (!this.roomba_target) {
            this.message = "Roomba deployment failed: Enemy King not found!";
            this.roomba_pos = null;
            this.is_power_mode = null;
            return false;
        }

        this.is_power_mode = null;
        this.message = `Rogue Roomba deployed at ${this._indices_to_coords(f1, r1)}! Rook retreated to ${this._indices_to_coords(f2, r2)}.`;
        this._next_turn();
        return true;
    }

    // --- Standard Move/Rule Functions ---

    _validate_move(f1, r1, f2, r2) {
        const piece = this.board[f1][r1];
        if (!piece || piece.color !== this.current_turn) return false;

        const is_castling_attempt = (piece.type === 'K' && Math.abs(f2 - f1) === 2 && r1 === r2);
        if (is_castling_attempt && this._check_castling_rules(f1, r1, f2, r2)) {
            return true;
        }

        if (!this._check_move_rules(f1, r1, f2, r2, piece)) {
            return false;
        }

        // --- Simulate the move to check for check ---
        const original_target = this.board[f2][r2];
        const is_en_passant = (piece.type === 'P' && this.en_passant_target && f2 === this.en_passant_target.f && r2 === this.en_passant_target.r);
        let captured_pawn_pos = null;
        let original_captured_pawn = null;

        if (is_en_passant) {
            const direction = piece.color === 'W' ? 1 : -1;
            captured_pawn_pos = {
                f: f2,
                r: r2 - direction
            };
            original_captured_pawn = this.board[captured_pawn_pos.f][captured_pawn_pos.r];
            this.board[captured_pawn_pos.f][captured_pawn_pos.r] = null;
        }

        this.board[f2][r2] = piece;
        this.board[f1][r1] = null;

        const is_safe = !this._is_king_in_check(this.current_turn);

        this.board[f1][r1] = piece;
        this.board[f2][r2] = original_target;

        if (is_en_passant) {
            this.board[captured_pawn_pos.f][captured_pawn_pos.r] = original_captured_pawn;
        }

        return is_safe;
    }

    _is_path_blocked(f1, r1, f2, r2) {
        const df = f1 === f2 ? 0 : (f2 > f1 ? 1 : -1);
        const dr = r1 === r2 ? 0 : (r2 > r1 ? 1 : -1);
        let f = f1 + df;
        let r = r1 + dr;
        while (f !== f2 || r !== r2) {
            if (this._is_square_blocked(f, r)) {
                return true;
            }
            f += df;
            r += dr;
        }
        return false;
    }

    get_legal_moves(f1, r1) {
        const piece = this.board[f1][r1];
        if (!piece || piece.color !== this.current_turn) {
            return [];
        }

        const legal_moves = [];

        // 1. Standard/Castling/EnPassant Moves
        for (let f2 = 0; f2 < 8; f2++) {
            for (let r2 = 0; r2 < 8; r2++) {
                if (f1 === f2 && r1 === r2) {
                    continue;
                }

                // Special check for Phasing Rook (If active, this piece can move to any empty square)
                if (this.phase_move_pending && f1 === this.selected_square_coords.f && r1 === this.selected_square_coords.r) {
                    if (this.board[f2][r2] === null && !this._is_square_blocked(f2, r2)) {
                        // Phase move doesn't need to check for check, as the piece is removed, then placed in execute_move
                        // The execute_move for PHASE MOVE handles the final checks.
                        legal_moves.push({
                            f: f2,
                            r: r2,
                            is_capture: false,
                            is_power_target: true
                        });
                    }
                    continue;
                }

                if (this._validate_move(f1, r1, f2, r2)) {
                    const target = this.board[f2][r2];

                    const is_castling = (piece.type === 'K' && Math.abs(f2 - f1) === 2 && r1 === r2);
                    const is_en_passant_capture = (piece.type === 'P' && this.en_passant_target && f2 === this.en_passant_target.f && r2 === this.en_passant_target.r);

                    const is_capture = target !== null || (this.roomba_pos && this.roomba_pos.f === f2 && this.roomba_pos.r === r2) || is_en_passant_capture;

                    // Murasaki logic check
                    const is_murasaki_friendly_pawn = (
                        this.is_power_mode === 'MURASAKI' &&
                        piece.type === 'K' &&
                        target && target.color === piece.color &&
                        target.type === 'P'
                    );

                    if (this.is_power_mode === 'MURASAKI' && !is_murasaki_friendly_pawn) {
                        continue; // Block all other moves in Murasaki mode
                    }

                    legal_moves.push({
                        f: f2,
                        r: r2,
                        is_capture: is_capture || is_castling || is_murasaki_friendly_pawn
                    });
                }
            }
        }

        // 2. Special Power Mode Targets
        if (this.is_power_mode === 'ROOK_ROOMBA' && f1 === this.selected_square_coords.f && r1 === this.selected_square_coords.r) {
            // Rook Retreat (adjacent empty squares)
            for (let df = -1; df <= 1; df++) {
                for (let dr = -1; dr <= 1; dr++) {
                    if (df === 0 && dr === 0) continue;
                    const rf2 = f1 + df;
                    const rr2 = r1 + dr;
                    if (rf2 >= 0 && rf2 <= 7 && rr2 >= 0 && rr2 <= 7 &&
                        this.board[rf2][rr2] === null &&
                        !this._is_square_blocked(rf2, rr2)) {
                        legal_moves.push({
                            f: rf2,
                            r: rr2,
                            is_capture: false,
                            is_power_target: true
                        });
                    }
                }
            }
        } else if (this.is_power_mode === 'KNIGHT_FUSION' && f1 === this.selected_square_coords.f && r1 === this.selected_square_coords.r) {
            // Targets are friendly Bishops within fusion range
            const kf = f1;
            const kr = r1;
            for (let f2 = 0; f2 < 8; f2++) {
                for (let r2 = 0; r2 < 8; r2++) {
                    const target = this.board[f2][r2];
                    if (target && target.color === this.current_turn && target.type === 'B') {
                        const bf = f2;
                        const br = r2;
                        const df_dist = Math.abs(kf - bf);
                        const dr_dist = Math.abs(kr - br);
                        const is_adjacent = Math.max(df_dist, dr_dist) === 1;
                        const is_diag_two = (df_dist > 0 && dr_dist > 0 && Math.max(df_dist, dr_dist) === 2);

                        if (is_adjacent || is_diag_two) {
                            legal_moves.push({
                                f: f2,
                                r: r2,
                                is_capture: true,
                                is_power_target: true
                            });
                        }
                    }
                }
            }
        }

        // 3. Targets for R_COMMAND actions
        if (['R_HACK_PENDING', 'R_PHASE_PENDING'].includes(this.is_power_mode) && piece.type === 'R' && f1 === this.selected_square_coords.f && r1 === this.selected_square_coords.r) {

            if (this.is_power_mode === 'R_HACK_PENDING') {
                // Hack target: ANY piece except King
                for (let f2 = 0; f2 < 8; f2++) {
                    for (let r2 = 0; r2 < 8; r2++) {
                        const piece_at_target = this.board[f2][r2];
                        if (piece_at_target && piece_at_target.type !== 'K') {
                            legal_moves.push({
                                f: f2,
                                r: r2,
                                is_capture: true,
                                is_power_target: true
                            });
                        }
                    }
                }

            } else if (this.is_power_mode === 'R_PHASE_PENDING') {
                // Phase target: ANY empty, non-blocked square
                for (let f2 = 0; f2 < 8; f2++) {
                    for (let r2 = 0; r2 < 8; r2++) {
                        if (this.board[f2][r2] === null && !this._is_square_blocked(f2, r2)) {
                            legal_moves.push({
                                f: f2,
                                r: r2,
                                is_capture: false,
                                is_power_target: true
                            });
                        }
                    }
                }
            }
        }


        // Filter for unique moves
        const unique_moves = [];
        const coords_seen = new Set();
        for (const move of legal_moves) {
            const key = `${move.f},${move.r}`;
            if (!coords_seen.has(key)) {
                unique_moves.push(move);
                coords_seen.add(key);
            }
        }

        return unique_moves;
    }

    _is_square_attacked(target_f, target_r, attacking_color, check_blockade = true) {
        for (let f = 0; f < 8; f++) {
            for (let r = 0; r < 8; r++) {
                const piece = this.board[f][r];
                if (piece && piece.color === attacking_color) {

                    const original_target_piece = this.board[target_f][target_r];
                    this.board[target_f][target_r] = null; // Temporarily clear target for attack check

                    const can_attack = this._check_move_rules(f, r, target_f, target_r, piece, check_blockade);

                    this.board[target_f][target_r] = original_target_piece; // Restore target

                    if (can_attack) {
                        // Special handling for pawns (only capture diagonally, not forward attack)
                        if (piece.type === 'P' && f === target_f) {
                            continue;
                        }

                        return true;
                    }
                }
            }
        }

        // Roomba attack (Roomba attacks adjacent squares)
        if (this.roomba_pos) {
            const rf = this.roomba_pos.f;
            const rr = this.roomba_pos.r;
            if (Math.abs(rf - target_f) <= 1 && Math.abs(rr - target_r) <= 1) {
                return true;
            }
        }

        return false;
    }

    _check_castling_rules(f1, r1, f2, r2) {
        const color = this.current_turn;

        const king_piece = this.board[f1][r1];
        if (king_piece === null || king_piece.type !== 'K' || king_piece.moved || this._is_square_frozen(f1, r1)) {
            return false;
        }

        const rook_f = f2 > f1 ? 7 : 0;
        const rook_r = r1;
        const rook_piece = this.board[rook_f][rook_r];

        if (rook_piece === null || rook_piece.type !== 'R' || rook_piece.moved || this._is_square_frozen(rook_f, rook_r)) {
            return false;
        }

        const df_step = f2 > f1 ? 1 : -1;

        // Check squares between King and Rook
        for (let f = f1 + df_step; f !== rook_f; f += df_step) {
            if (this.board[f][r1] !== null || this._is_square_blocked(f, r1) || (this.roomba_pos && this.roomba_pos.f === f && this.roomba_pos.r === r1)) {
                return false;
            }
        }

        // King cannot be in check
        if (this._is_king_in_check(color)) return false;

        // King cannot pass through or land on an attacked square
        const f_pass = f1 + df_step;
        const opponent_color = color === 'W' ? 'B' : 'W';
        const king_squares_to_check = [
            [f_pass, r1],
            [f2, r2]
        ];

        for (const [f_check, r_check] of king_squares_to_check) {
            if (this._is_square_attacked(f_check, r_check, opponent_color)) {
                return false;
            }
        }

        return true;
    }


    _check_move_rules(f1, r1, f2, r2, piece, check_blockade = true) {

        if (this._is_square_frozen(f1, r1)) return false;

        const df = f2 - f1;
        const dr = r2 - r1;
        const abs_df = Math.abs(df);
        const abs_dr = Math.abs(dr);
        const target = this.board[f2][r2];

        // --- HACKED PIECE CAPTURE CHECK ---
        const is_hacked_capture = (this.hacked_piece && this.hacked_piece.f === f1 && this.hacked_piece.r === r1 && target && target.color === piece.color);

        // --- FRIENDLY FIRE CHECK (MURASAKI) ---
        const is_murasaki_self_capture = (
            this.is_power_mode === 'MURASAKI' &&
            piece.type === 'K' &&
            target && target.color === piece.color &&
            target.type === 'P' // Must be a Pawn sacrifice
        );

        if (target && target.color === piece.color && !is_murasaki_self_capture && !is_hacked_capture) return false;
        // --- END FRIENDLY FIRE CHECK ---

        if (check_blockade && this._is_square_blocked(f2, r2)) return false;

        const p_type = piece.type;

        if (p_type === 'P') {
            const direction = piece.color === 'W' ? 1 : -1;
            const start_rank = piece.color === 'W' ? 1 : 6;

            // Forward move 1
            if (df === 0 && dr === direction && target === null && !this._is_square_blocked(f2, r2)) return true;

            // Forward move 2
            const intermediate_r = r1 + direction;
            if (df === 0 && dr === 2 * direction && r1 === start_rank && target === null) {
                if (this.board[f1][intermediate_r] === null && !this._is_square_blocked(f1, intermediate_r) && !this._is_square_blocked(f2, r2)) {
                    return true;
                }
                return false;
            }

            // Standard capture (or Hacked capture of friendly piece)
            if (abs_df === 1 && dr === direction && (target !== null || is_hacked_capture)) return true;

            // En Passant capture
            if (abs_df === 1 && dr === direction && this.en_passant_target && f2 === this.en_passant_target.f && r2 === this.en_passant_target.r) return true;

            return false;
        }

        if (p_type === 'N') return (abs_df === 1 && abs_dr === 2) || (abs_df === 2 && abs_dr === 1);

        if (p_type === 'A') {
            const is_knight_move = (abs_df === 1 && abs_dr === 2) || (abs_df === 2 && abs_dr === 1);
            const is_bishop_move = (abs_df === abs_dr && abs_df > 0);

            if (is_knight_move) return true;

            if (is_bishop_move) {
                if (check_blockade && this._is_path_blocked(f1, r1, f2, r2)) return false;
                return this._is_path_clear(f1, r1, f2, r2);
            }
            return false;
        }

        if (p_type === 'R' || p_type === 'Q') {
            if ((df === 0 && abs_dr > 0) || (abs_df > 0 && dr === 0)) {
                if (check_blockade && this._is_path_blocked(f1, r1, f2, r2)) return false;
                return this._is_path_clear(f1, r1, f2, r2);
            }
        }

        if (p_type === 'B' || p_type === 'Q') {
            if (abs_df === abs_dr && abs_df > 0) {
                if (check_blockade && this._is_path_blocked(f1, r1, f2, r2)) return false;
                return this._is_path_clear(f1, r1, f2, r2);
            }
        }

        if (p_type === 'K') {
            if (abs_df <= 1 && abs_dr <= 1 && (abs_df + abs_dr > 0)) {
                return true;
            }
            return false;
        }

        return false;
    }

    _is_path_clear(f1, r1, f2, r2) {
        const df = f1 === f2 ? 0 : (f2 > f1 ? 1 : -1);
        const dr = r1 === r2 ? 0 : (r2 > r1 ? 1 : -1);
        let f = f1 + df;
        let r = r1 + dr;
        while (f !== f2 || r !== r2) {
            if (this.board[f][r] !== null || (this.roomba_pos && this.roomba_pos.f === f && this.roomba_pos.r === r)) {
                return false;
            }
            f += df;
            r += dr;
        }
        return true;
    }


    _next_turn() {
        /** Switches turn and handles power drawbacks/effects, checking for checkmate. */

        this.en_passant_target = null;
        this.phase_move_pending = false;

        // 1. Roomba movement (always check if the King is still safe)
        if (this.roomba_moves_remaining > 0) {
            this._move_roomba();
            if (this.game_over) return; // Checkmate by roomba
        }

        // 2. Thaw frozen pieces
        const keys_to_remove = [];
        for (const pos in this.frozen_pieces) {
            if (this.frozen_pieces.hasOwnProperty(pos)) {
                if (this.frozen_pieces[pos] > 0) {
                    this.frozen_pieces[pos] -= 1;
                }
                if (this.frozen_pieces[pos] === 0) {
                    keys_to_remove.push(pos);
                }
            }
        }

        for (const key of keys_to_remove) {
            delete this.frozen_pieces[key];
        }

        if (keys_to_remove.length) {
            this.message += ` (${keys_to_remove.length} pieces thawed out!)`;
        }

        // 3. Switch turn and check for mate/stalemate
        this.current_turn = this.current_turn === 'W' ? 'B' : 'W';
        this.is_power_mode = null;
        this.hacked_piece = null; // HACK only lasts for one turn

        this.is_check = this._is_king_in_check(this.current_turn);
        const has_moves = this.has_legal_moves(this.current_turn);

        if (!has_moves) {
            if (this.is_check) {
                const winner = this.current_turn === 'B' ? 'White' : 'Black';
                this.message = `CHECKMATE! ${winner} wins!`;
                this.game_over = 'CHECKMATE';
            } else {
                this.message = "STALEMATE! Game is a draw.";
                this.game_over = 'STALEMATE';
            }

        } else if (this.is_check) {
            this.message += " CHECK!";
        }
    }

    execute_move(move_str) {
        if (this.game_over) return;

        let f1, r1, f2, r2;
        try {
            if (move_str.length !== 4) throw new Error("Invalid format");
            const coords1 = this._coords_to_indices(move_str.substring(0, 2));
            const coords2 = this._coords_to_indices(move_str.substring(2, 4));
            f1 = coords1.f;
            r1 = coords1.r;
            f2 = coords2.f;
            r2 = coords2.r;
        } catch (e) {
            this.message = "Invalid move format.";
            return;
        }

        // --- Power mode validation & execution (pre-standard move) ---
        if (this.is_power_mode === 'ROOK_ROOMBA') {
            const {
                f: start_f,
                r: start_r
            } = this.selected_square_coords;
            if (f1 === start_f && r1 === start_r) {
                this._activate_r_ultimate(f1, r1, f2, r2);
                return;
            }
        }

        if (this.is_power_mode === 'BISHOP_FREEZE') {
            const {
                f: start_f,
                r: start_r
            } = this.selected_square_coords;
            if (f1 === start_f && r1 === start_r) {
                this._activate_b_ultimate(f1, r1, f2, r2);
                return;
            }
        }

        // Power move execution: PHASE MOVE (Rook moves anywhere)
        if (this.phase_move_pending && f1 === this.selected_square_coords.f && r1 === this.selected_square_coords.r) {
            if (this.board[f2][r2] !== null || this._is_square_blocked(f2, r2)) {
                this.message = "Phase move must land on an empty, non-blocked square.";
                this.phase_move_pending = false;
                this.is_power_mode = null;
                return;
            }

            const piece = this.board[f1][r1];
            this.board[f2][r2] = piece;
            this.board[f1][r1] = null;
            piece.moved = true;
            this.message = `Rook phased to ${this._indices_to_coords(f2, r2)}!`;
            this.phase_move_pending = false;
            this.is_power_mode = null;
            this._next_turn();
            return;
        }

        if (!this._validate_move(f1, r1, f2, r2)) {
            this.message = "Invalid move, piece is frozen, or King remains in check.";
            return;
        }

        const piece = this.board[f1][r1];
        const target = this.board[f2][r2];
        const df = f2 - f1;
        const dr = r2 - r1;

        // --- MURASAKI ACTIVATION LOGIC (Immediate Execution) ---
        const is_murasaki_move = (
            this.is_power_mode === 'MURASAKI' &&
            piece.type === 'K' &&
            target && target.color === piece.color &&
            target.type === 'P'
        );

        if (is_murasaki_move) {
            this.message = `King sacrifices Pawn at ${this._indices_to_coords(f2, r2)}! Domain Expansion: Murasaki activated.`;

            // Move the King onto the Pawn (Sacrifice)
            this.board[f2][r2] = piece;
            this.board[f1][r1] = null;
            piece.moved = true;

            // Execute logic and switch turn immediately
            this._execute_k_ultimate_logic();
            return;
        }
        // --- END MURASAKI LOGIC ---

        // --- 1. Castling Logic (Standard move path) ---
        if (piece.type === 'K' && Math.abs(df) === 2 && dr === 0) {
            const rook_f1 = df > 0 ? 7 : 0;
            const rook_f2 = df > 0 ? 5 : 3;
            const rook_piece = this.board[rook_f1][r1];

            this.board[f2][r2] = piece;
            this.board[f1][r1] = null;
            piece.moved = true;

            this.board[rook_f2][r2] = rook_piece;
            this.board[rook_f1][r1] = null;
            rook_piece.moved = true;

            this.message = "Castling successful!";

        // --- 2. En Passant Logic (Standard move path) ---
        } else if (piece.type === 'P' && this.en_passant_target && f2 === this.en_passant_target.f && r2 === this.en_passant_target.r) {
            const direction = piece.color === 'W' ? 1 : -1;
            const captured_pawn_pos = {
                f: f2,
                r: r2 - direction
            };

            this.board[f2][r2] = piece;
            this.board[f1][r1] = null;
            piece.moved = true;

            this.board[captured_pawn_pos.f][captured_pawn_pos.r] = null;
            this.message = "En Passant capture successful!";

        // --- 3. Standard Move Logic (Standard move path) ---
        } else {
            const is_roomba_capture = this.roomba_pos && this.roomba_pos.f === f2 && this.roomba_pos.r === r2;
            const is_hacked_capture = (this.hacked_piece && this.hacked_piece.f === f1 && this.hacked_piece.r === r1 && target && target.color === piece.color);

            if (is_roomba_capture) {
                this.roomba_pos = null;
                this.roomba_moves_remaining = 0;
                this.message = "Roomba destroyed by piece move!";
            } else if (target) {
                this.message = `Captured ${target.color}${target.type}!`;
                if (is_hacked_capture) {
                    this.message = `Hacked piece ${piece.color}${piece.type} successfully captured friendly ${target.type}!`;
                }
            } else {
                this.message = "Move successful.";
            }

            this.board[f2][r2] = piece;
            this.board[f1][r1] = null;
            piece.moved = true;

            // Check for two-square pawn push to set En Passant target
            if (piece.type === 'P' && Math.abs(dr) === 2) {
                const direction = piece.color === 'W' ? 1 : -1;
                this.en_passant_target = {
                    f: f2,
                    r: r1 + direction
                };
                this.message += " (En Passant target set)";
            } else {
                this.en_passant_target = null;
            }

            // Check for pawn promotion (simple for now)
            if (piece.type === 'P' && (r2 === 7 || r2 === 0)) {
                piece.type = 'Q';
                this.message += " (PROMOTED to Queen!)";
            }
        }

        this._next_turn();
    }
}


// --- 2. GUI INTERFACE (UltimateChessApp equivalent) ---
// Note: This uses global functions and an 'app' instance to mimic the class structure.

class UltimateChessApp {
    constructor() {
        this.DOT_SYMBOL = 'â—';
        this.game = new UltimateChessGame();
        this.selected_square = null; // {f, r}
        this.valid_targets = []; // Array of {f, r, is_capture, is_power_target}
        this.bot_elo = 1500;
        this.user_color = 'W';
        this.game_type = 'local';
        this.is_small_screen = window.innerWidth < 800; // Match CSS breakpoint

        this.elements = {};
        this._setup_elements();
        this._setup_event_listeners();
        this._update_responsive_layout();
    }

    _setup_elements() {
        this.elements.gameContainer = document.getElementById('game-container');
        this.elements.mainMenu = document.getElementById('main-menu');
        this.elements.gameUI = document.getElementById('game-ui');
        this.elements.boardFrame = document.getElementById('board-frame');
        this.elements.panelFrame = document.getElementById('panel-frame');
        this.elements.statusLabel = document.getElementById('status-label');
        this.elements.messageLabel = document.getElementById('message-label');
        this.elements.rUsesLabel = document.getElementById('r-uses-label');
        this.elements.abilityTitle = document.getElementById('ability-title');
        this.elements.abilityDesc = document.getElementById('ability-desc');
        this.elements.abilityPrompt = document.getElementById('ability-prompt');
        this.elements.hackBtn = document.getElementById('hack-btn');
        this.elements.phaseBtn = document.getElementById('phase-btn');
        this.elements.ultimateButton = document.getElementById('ultimate-button');
        this.elements.eloSlider = document.getElementById('elo-slider');
        this.elements.eloLabel = document.getElementById('elo-label');
        this.elements.boardContainer = document.getElementById('board-container');
        this.elements.overlay = document.getElementById('game-overlay');
        this.elements.overlayMessage = document.getElementById('overlay-message');
    }

    _setup_event_listeners() {
        window.addEventListener('resize', () => this._on_resize());
        this.elements.eloSlider.addEventListener('input', (e) => this.bot_elo = parseInt(e.target.value));
        this.elements.overlay.addEventListener('click', () => this.return_to_menu_after_game());
    }

    _on_resize() {
        const is_currently_small = window.innerWidth < 800;
        if (is_currently_small !== this.is_small_screen) {
            this.is_small_screen = is_currently_small;
            this._update_responsive_layout();
            if (this.elements.gameUI.classList.contains('hidden') === false) {
                this.draw_board();
                this.update_status();
            }
        }
    }

    _update_responsive_layout() {
        // Toggles CSS classes based on screen size, relying on media queries in style.css
        // For the full Python functionality, we'd adjust font-sizes here, but using CSS variables is cleaner.
        const root = document.documentElement;
        if (this.is_small_screen) {
            root.style.setProperty('--piece-font-size', '40px');
            root.style.setProperty('--dot-font-size', '28px');
        } else {
            root.style.setProperty('--piece-font-size', '52px');
            root.style.setProperty('--dot-font-size', '36px');
        }
    }

    show_main_menu() {
        this.elements.gameUI.classList.add('hidden');
        this.elements.mainMenu.classList.remove('hidden');
        this.elements.overlay.classList.add('hidden');
    }

    start_game(game_type) {
        this.game = new UltimateChessGame();
        this.game_type = game_type;

        if (game_type === 'bot') {
            this.user_color = Math.random() < 0.5 ? 'W' : 'B';
        } else {
            this.user_color = 'W';
        }

        this.elements.mainMenu.classList.add('hidden');
        this.elements.gameUI.classList.remove('hidden');

        this._setup_game_board_ui();
        this._initial_draw_and_check();
    }

    _setup_game_board_ui() {
        const board_frame = this.elements.boardFrame;
        board_frame.innerHTML = '';
        this.squares = {}; // {f, r} -> DOM Element

        // Setup Ranks/Files
        this._create_coord_labels(document.getElementById('rank-labels-container'), 'rank');
        this._create_coord_labels(document.getElementById('file-labels-container'), 'file');

        const rank_range = this.user_color === 'W' ? Array.from({
            length: 8
        }, (_, i) => i) : Array.from({
            length: 8
        }, (_, i) => 7 - i);

        for (let r = 0; r < 8; r++) {
            for (let f = 0; f < 8; f++) {
                const is_dark = (f + r) % 2 === 1;
                const color_class = is_dark ? 'dark-square' : 'light-square';

                const square_div = document.createElement('div');
                square_div.id = `square-${f}-${r}`;
                square_div.className = `square ${color_class}`;
                square_div.style.backgroundColor = is_dark ? 'var(--dark-square)' : 'var(--light-square)';
                square_div.setAttribute('data-f', f);
                square_div.setAttribute('data-r', r);

                // Handle board orientation (r index of the array vs. r grid position)
                const grid_r = this.user_color === 'W' ? 7 - r : r;
                square_div.style.gridRow = `${grid_r + 1} / span 1`;
                square_div.style.gridColumn = `${f + 1} / span 1`;

                square_div.addEventListener('click', () => this.handle_click(f, r));
                board_frame.appendChild(square_div);
                this.squares[`${f},${r}`] = square_div;
            }
        }
    }

    _create_coord_labels(container, type) {
        container.innerHTML = '';
        let labels = [];

        if (type === 'rank') {
            const rank_order = this.user_color === 'W' ? Array.from({
                length: 8
            }, (_, i) => i + 1) : Array.from({
                length: 8
            }, (_, i) => 8 - i);
            labels = rank_order.map(r => r.toString());
        } else { // type === 'file'
            const file_chars = 'abcdefgh';
            labels = Array.from(file_chars);
        }

        labels.forEach((text, index) => {
            const label_div = document.createElement('div');
            label_div.className = 'coord-label';
            label_div.textContent = text;
            container.appendChild(label_div);
        });
    }

    _initial_draw_and_check() {
        this.draw_board();
        this.update_status();

        const is_ai_turn = this.game_type === 'bot' && this.game.current_turn !== this.user_color;
        if (is_ai_turn && !this.game.game_over) {
            this.handle_ai_turn();
        }
    }

    // --- Rook Ultimate Button Handlers (Simplified in JS) ---
    _initiate_hack() {
        if (this.game.is_power_mode === 'R_COMMAND_SELECT' && this.selected_square) {
            this.game.is_power_mode = 'R_HACK_PENDING';
            this.game.message = "HACK: Select a non-King piece to grant it friendly fire capture.";
            const {
                f,
                r
            } = this.selected_square;
            this.valid_targets = this.game.get_legal_moves(f, r);
            this.draw_board();
            this.update_status();
        }
    }

    _initiate_phase() {
        if (this.game.is_power_mode === 'R_COMMAND_SELECT' && this.selected_square) {
            this.game.is_power_mode = 'R_PHASE_PENDING';
            this.game.message = "PHASE: Select an empty square for the Rook to teleport.";
            const {
                f,
                r
            } = this.selected_square;
            this.valid_targets = this.game.get_legal_moves(f, r);
            this.draw_board();
            this.update_status();
        }
    }

    // --- Rook Ultimate Click Execution ---
    _handle_rook_command_click(f, r) {
        const mode = this.game.is_power_mode;
        const current_turn = this.game.current_turn;

        if (this.selected_square === null || !this._is_valid_target(f, r)) {
            this.game.message = "Invalid target. Selection cleared. Try activating ULTIMATE again.";
            this.clear_selection();
            this.draw_board();
            this.update_status();
            return;
        }

        const {
            f: f1,
            r: r1
        } = this.selected_square;

        // 1. Deduct use (only happens on successful target click)
        this.game.r_power_uses[current_turn] -= 1;

        // 2. Execute command based on mode
        if (mode === 'R_HACK_PENDING') {
            const target_piece = this.game.board[f][r];
            this.game.hacked_piece = {
                f,
                r
            };
            this.game.message = `HACK successful! ${target_piece.color}${target_piece.type} at ${this.game._indices_to_coords(f, r)} can now capture friendly pieces.`;

        } else if (mode === 'R_PHASE_PENDING') {
            // Phase is placing the rook on an empty square
            const rook_piece_data = {
                'type': 'R',
                'color': current_turn,
                'moved': true
            };
            this.game.board[f][r] = rook_piece_data;
            this.game.message = `PHASE successful! Rook teleported to ${this.game._indices_to_coords(f, r)}.`;
        }

        // 3. Rook disappearance (The initiating piece, which is R at f1, r1, is gone)
        this.game.board[f1][r1] = null;

        // 4. Final cleanup and turn switch
        this.game.is_power_mode = null;
        this.game.selected_square_coords = null;
        this.game._next_turn();
        this.clear_selection();

        if (this.game_type === 'bot' && !this.game.game_over && this.game.current_turn !== this.user_color) {
            this.handle_ai_turn();
        }
    }


    draw_board() {
        /** Draws all pieces, blockades, Roomba, and Frozen symbols on the board. */
        for (let f = 0; f < 8; f++) {
            for (let r = 0; r < 8; r++) {
                const piece = this.game.board[f][r];
                const square_div = this.squares[`${f},${r}`];
                let symbol = '';
                let fg_class = '';
                let bg_color = square_div.classList.contains('dark-square') ? 'var(--dark-square)' : 'var(--light-square)';
                let classes = ['square'];

                // Resetting classes to base
                if (square_div.classList.contains('dark-square')) classes.push('dark-square');
                else classes.push('light-square');


                // --- 1. Determine Content (Piece, Blockade, Roomba) ---
                if (piece) {
                    const piece_key = piece.color + piece.type;
                    symbol = UNICODE_PIECES[piece_key] || piece_key;
                    fg_class = `${piece.color}-piece`;
                    if (piece.type === 'A' || symbol.length > 1) classes.push('small-font');
                } else if (this.game.roomba_pos && this.game.roomba_pos.f === f && this.game.roomba_pos.r === r) {
                    symbol = UNICODE_PIECES['RM'];
                    classes.push('roomba-symbol');
                } else if (this.game._is_square_blocked(f, r)) {
                    symbol = UNICODE_PIECES['BL'];
                    classes.push('blockade-symbol');
                }

                // --- 2. Apply Highlighting (Selection, Targets) ---
                const target_info = this.valid_targets.find(t => t.f === f && t.r === r);

                if (this.selected_square && this.selected_square.f === f && this.selected_square.r === r) {
                    classes.push('selected');
                } else if (target_info) {
                    const is_empty_square = piece === null && !(this.game.roomba_pos && this.game.roomba_pos.f === f && this.game.roomba_pos.r === r) && !this.game._is_square_blocked(f, r);

                    if (is_empty_square && !target_info.is_power_target) {
                        symbol = this.DOT_SYMBOL;
                        classes.push('move-dot');
                    } else if (target_info.is_power_target) {
                        classes.push('power-target');
                    } else {
                        classes.push('attack-target');
                    }
                }

                // --- 3. Apply Special States (Frozen, Hacked) ---
                if (this.game.hacked_piece && this.game.hacked_piece.f === f && this.game.hacked_piece.r === r) {
                    classes.push('hacked-piece');
                }

                if (this.game._is_square_frozen(f, r)) {
                    classes.push('frozen');
                    if (piece && !symbol.includes(UNICODE_PIECES['FR'])) {
                        symbol = symbol.trim() + ' ' + UNICODE_PIECES['FR'];
                    }
                }

                // --- 4. Render to DOM ---
                square_div.className = classes.join(' ');
                square_div.style.backgroundColor = ''; // Use CSS for bg color transitions on hover/etc.
                square_div.innerHTML = `<span class="piece-symbol ${fg_class}">${symbol}</span>`;
            }
        }

        this._draw_game_over_overlay();
    }

    _draw_game_over_overlay() {
        if (this.game.game_over) {
            let message;
            let fg_color;
            if (this.game.game_over === 'CHECKMATE') {
                const winner = this.game.current_turn === 'B' ? 'White' : 'Black';
                message = `CHECKMATE! \n ${winner} WINS!`;
                fg_color = 'var(--accent-red)';
            } else { // STALEMATE
                message = "STALEMATE \n Draw!";
                fg_color = 'var(--light-square)';
            }

            this.elements.overlayMessage.textContent = message;
            this.elements.overlayMessage.style.color = fg_color;

            // Adjust font size for small screens
            if (this.is_small_screen) {
                this.elements.overlayMessage.style.fontSize = '20px';
            } else {
                this.elements.overlayMessage.style.fontSize = '30px';
            }

            this.elements.overlay.classList.remove('hidden');

        } else {
            this.elements.overlay.classList.add('hidden');
        }
    }

    _is_valid_target(f, r) {
        return this.valid_targets.some(t => t.f === f && t.r === r);
    }

    return_to_menu_after_game() {
        if (this.game.game_over) {
            this.show_main_menu();
        }
    }

    clear_selection() {
        this.selected_square = null;
        this.game.selected_square_coords = null;
        this.game.is_power_mode = null;
        this.valid_targets = [];
        this.game.phase_move_pending = false;
        this.draw_board();
    }

    update_ability_panel(piece = null) {
        const info = this.game.current_ultimate_power_info;

        // Update Rook uses display
        const r_uses_text = `Rook Uses: W: ${this.game.r_power_uses['W']}/2 | B: ${this.game.r_power_uses['B']}/2`;
        this.elements.rUsesLabel.textContent = r_uses_text;

        if (this.game.hacked_piece) {
            const {
                f: hf,
                r: hr
            } = this.game.hacked_piece;
            const h_piece = this.game.board[hf][hr];
            const h_coord = this.game._indices_to_coords(hf, hr);
            this.elements.rUsesLabel.textContent += ` | HACKED: ${h_piece.color}${h_piece.type} at ${h_coord}`;
        }

        // Default button states
        this.elements.hackBtn.disabled = true;
        this.elements.phaseBtn.disabled = true;

        if (this.game.is_power_mode) {
            this.elements.abilityTitle.textContent = `POWER MODE: ${info.name}`;
            this.elements.abilityTitle.style.color = 'var(--accent-red)';
            this.elements.abilityDesc.innerHTML = info.desc;
            this.elements.abilityDesc.style.color = 'var(--light-square)';

            if (this.game.is_power_mode === 'R_COMMAND_SELECT') {
                this.elements.abilityPrompt.textContent = "Status: Select /HACK or /PHASE.";
                this.elements.abilityPrompt.style.color = '#FFD700';
                this.elements.hackBtn.disabled = false;
                this.elements.phaseBtn.disabled = false;
            } else if (['R_HACK_PENDING', 'R_PHASE_PENDING'].includes(this.game.is_power_mode)) {
                this.elements.abilityPrompt.textContent = this.game.message;
                this.elements.abilityPrompt.style.color = 'var(--accent-green)';
            } else {
                this.elements.abilityPrompt.textContent = `Action: ${info.prompt}`;
                this.elements.abilityPrompt.style.color = 'var(--accent-green)';
            }

            this.elements.ultimateButton.textContent = "CANCEL POWER";

            return;
        }

        // Default display when no power is active
        this.elements.ultimateButton.textContent = "ACTIVATE ULTIMATE";

        if (piece) {
            const piece_type = piece.type;
            const piece_info = this.game._get_piece_power(piece_type);

            this.elements.abilityTitle.textContent = `${piece_type} ULTIMATE: ${piece_info.name}`;
            this.elements.abilityTitle.style.color = 'var(--accent-green)';
            this.elements.abilityDesc.innerHTML = piece_info.desc;
            this.elements.abilityDesc.style.color = 'var(--light-square)';
            this.elements.abilityPrompt.textContent = "Action: Click ACTIVATE to use this power.";
            this.elements.abilityPrompt.style.color = 'white';
        } else {
            const general_info = ULTIMATE_POWERS['GENERAL'];
            this.elements.abilityTitle.textContent = "Select a Piece";
            this.elements.abilityTitle.style.color = 'white';
            this.elements.abilityDesc.innerHTML = "General Ultimate: " + general_info.desc;
            this.elements.abilityDesc.style.color = 'var(--light-square)';
            this.elements.abilityPrompt.textContent = "Action: Make a standard move.";
            this.elements.abilityPrompt.style.color = 'white';
        }
    }


    update_status() {
        if (this.game.game_over) {
            this.elements.statusLabel.textContent = this.game.game_over;
            this.elements.statusLabel.style.color = 'var(--accent-red)';
            this.elements.messageLabel.textContent = this.game.message;
            this.elements.messageLabel.style.color = 'var(--accent-red)';
            this.elements.ultimateButton.disabled = true;
            return;
        }

        const turn_text = this.game.current_turn === 'W' ? "WHITE" : "BLACK";
        let mode_label = "";
        const is_user_turn = this.game_type === 'local' || this.game.current_turn === this.user_color;

        if (this.game_type === 'bot') {
            const player_role = this.game.current_turn === this.user_color ? "YOU" : "AI";
            mode_label = ` (${player_role} turn)`;
        }

        this.elements.statusLabel.textContent = `Current Turn: ${turn_text}${mode_label}`;
        this.elements.statusLabel.style.color = this.game.current_turn === 'W' ? 'var(--gold-piece)' : 'var(--silver-piece)';

        if (this.game.is_check) {
            this.elements.messageLabel.textContent = this.game.message;
            this.elements.messageLabel.style.color = 'var(--accent-red)';
        } else {
            this.elements.messageLabel.textContent = this.game.message;
            this.elements.messageLabel.style.color = 'var(--light-square)';
        }

        const is_piece_selected = this.selected_square !== null;
        const can_activate = is_piece_selected && this.game.is_power_mode === null;

        if (is_user_turn) {
            if (this.game.is_power_mode) {
                this.elements.ultimateButton.disabled = false;
            } else {
                this.elements.ultimateButton.disabled = !can_activate;
            }
        } else {
            this.elements.ultimateButton.disabled = true;
        }

        const piece = this.selected_square ? this.game.board[this.selected_square.f][this.selected_square.r] : null;
        this.update_ability_panel(piece);
    }


    handle_click(f, r) {
        if (this.game.game_over) return;

        if (this.game_type === 'bot' && this.game.current_turn !== this.user_color) {
            this.game.message = "Please wait for the AI to move.";
            this.update_status();
            return;
        }

        const f1 = this.selected_square ? this.selected_square.f : null;
        const r1 = this.selected_square ? this.selected_square.r : null;

        const is_power_command_active = ['R_HACK_PENDING', 'R_PHASE_PENDING', 'BLOCKADE', 'KNIGHT_FUSION', 'BISHOP_FREEZE', 'MURASAKI'].includes(this.game.is_power_mode);

        // --- Handle Power Interaction (Second click) ---
        if (is_power_command_active) {

            if (['R_HACK_PENDING', 'R_PHASE_PENDING'].includes(this.game.is_power_mode)) {
                // Rook Command execution
                this._handle_rook_command_click(f, r);
            } else if (this.game.is_power_mode === 'BLOCKADE') {
                // Blockade logic (Temporal Blockade)
                const algebraic_coord = this.game._indices_to_coords(f, r);
                if (this.game.place_blockade(algebraic_coord)) {
                    this.clear_selection();
                }

            } else if (this.game.is_power_mode === 'KNIGHT_FUSION') {
                // Fusion logic (Second click selects the Bishop)
                if (this._is_valid_target(f, r)) {
                    this.game.perform_fusion(f, r);
                    this.clear_selection();
                } else {
                    this.game.message = "Invalid fusion target. Select a friendly Bishop within range.";
                    this.draw_board();
                    this.update_status();
                    return;
                }

            } else if (['BISHOP_FREEZE', 'ROOK_ROOMBA', 'MURASAKI'].includes(this.game.is_power_mode)) {
                // These powers execute on the next move
                if (this.selected_square.f === f && this.selected_square.r === r) {
                    this.game.message = "Deselected. Click the piece again to activate power mode.";
                    this.game.is_power_mode = null; // Revert power mode
                    this.clear_selection();
                    return;
                }
                if (this._is_valid_target(f, r)) {
                    const start_coord = this.game._indices_to_coords(f1, r1);
                    const end_coord = this.game._indices_to_coords(f, r);
                    this.game.execute_move(start_coord + end_coord);
                    this.clear_selection(); // Clear selection after successful power move
                } else {
                    this.game.message = "Invalid target for power move. Try again or cancel.";
                }

            }

            this.draw_board();
            this.update_status();
            return;
        }

        // --- Standard Move/Selection ---

        if (this.selected_square === null) {
            const piece = this.game.board[f][r];
            if (piece && piece.color === this.game.current_turn) {
                this.selected_square = {
                    f,
                    r
                };
                this.valid_targets = this.game.get_legal_moves(f, r);
                this.game.message = `Selected ${piece.color}${piece.type} at ${this.game._indices_to_coords(f, r)}. ${this.valid_targets.length} moves available.`;
            } else {
                this.game.message = "Invalid selection. Please select one of your pieces.";
            }

        } else {
            // A piece is selected, attempting a move/new selection
            const target_is_valid = this._is_valid_target(f, r);
            const target_piece = this.game.board[f][r];

            if (f === f1 && r === r1) {
                this.game.message = "Deselected.";
                this.clear_selection();
                return;
            }

            if (target_piece && target_piece.color === this.game.current_turn && !target_is_valid) {
                // Selecting a different friendly piece
                this.game.message = `Selected new piece at ${this.game._indices_to_coords(f, r)}.`;
                this.selected_square = {
                    f,
                    r
                };
                this.valid_targets = this.game.get_legal_moves(f, r);

            } else if (target_is_valid) {
                // Execute standard move
                const start_coord = this.game._indices_to_coords(f1, r1);
                const end_coord = this.game._indices_to_coords(f, r);

                this.game.execute_move(start_coord + end_coord);

                // Check if the execution resulted in a turn switch (normal move or ultimate completion)
                if (this.game.is_power_mode === null) {
                    this.clear_selection();
                    if (this.game_type === 'bot' && !this.game.game_over && this.game.current_turn !== this.user_color) {
                        this.handle_ai_turn();
                    }
                }

            } else {
                this.game.message = "Invalid move destination.";
            }
        }

        this.draw_board();
        this.update_status();
    }

    activate_ultimate_gui() {
        if (this.game_type === 'bot' && this.game.current_turn !== this.user_color) {
            return;
        }

        if (this.game.is_power_mode) {
            // Cancel current power mode sequence
            this.game.is_power_mode = null;
            this.game.message = "Ultimate power sequence cancelled.";
            this.clear_selection();
            this.update_status();
            return;
        }

        if (this.selected_square === null) {
            this.game.message = "Please select a piece first before activating ULTIMATE.";
            this.update_status();
            return;
        }

        const {
            f,
            r
        } = this.selected_square;
        const piece = this.game.board[f][r];

        const is_activated = this.game.activate_ultimate(f, r);

        if (is_activated) {
            this.game.selected_square_coords = this.selected_square;
            if (this.game.is_power_mode) {
                // Re-calculate targets for the new power mode (e.g., Bishop freeze targets, Fusion targets)
                this.valid_targets = this.game.get_legal_moves(f, r);
            } else {
                // Power completed in one step (currently none, but future proofing)
                this.clear_selection();
                if (this.game_type === 'bot' && !this.game.game_over && this.game.current_turn !== this.user_color) {
                    this.handle_ai_turn();
                }
            }
        }

        this.draw_board();
        this.update_status();
    }

    // --- AI Handler ---

    _execute_ai_move() {
        if (this.game_type !== 'bot' || this.game.current_turn === this.user_color || this.game.game_over) {
            return;
        }

        const elo_level = this.bot_elo;
        const ai_move = this.game.get_bot_move(elo_level);

        if (ai_move) {
            const {
                f1,
                r1,
                f2,
                r2,
                is_capture
            } = ai_move;

            const start_coord = this.game._indices_to_coords(f1, r1);
            const end_coord = this.game._indices_to_coords(f2, r2);
            const move_str = start_coord + end_coord;

            this.selected_square = {
                f: f1,
                r: r1
            };
            this.valid_targets = [{
                f: f2,
                r: r2,
                is_capture: is_capture
            }];
            this.draw_board();
            this.update_status();

            // Use setTimeout to simulate a small delay before committing the move
            setTimeout(() => this._commit_ai_move(move_str), 500);

        } else {
            // Should be checkmate or stalemate, handled in get_all_legal_moves_for_color
            this.draw_board();
            this.update_status();
        }
    }

    _commit_ai_move(move_str) {
        if (this.game_type !== 'bot' || this.game.game_over) {
            return;
        }

        this.game.execute_move(move_str);

        this.clear_selection();

        if (!this.game.game_over && this.game.current_turn !== this.user_color) {
            // Give a short delay before the next AI move if it's still AI's turn (e.g., in a chain of roomba movements)
            setTimeout(() => this.handle_ai_turn(), 100);
        } else {
            this.draw_board();
            this.update_status();
        }
    }

    handle_ai_turn() {
        /** Disables controls and waits for AI move. */
        this.elements.ultimateButton.disabled = true;
        // Introduce a slight delay for better UX
        setTimeout(() => this._execute_ai_move(), 500);
    }
}

// --- Main Execution (Global instance and helper functions) ---

let app;

// Global helpers for HTML buttons
function startLocalGame() {
    app.start_game('local');
}

function startBotGame() {
    app.start_game('bot');
}

function updateEloLabel(value) {
    document.getElementById('elo-label').textContent = `ELO: ${value}`;
}


// Initialize the application once the DOM is ready
document.addEventListener('DOMContentLoaded', () => {
    app = new UltimateChessApp();
    app.show_main_menu();
});

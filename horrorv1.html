<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ultimate Chess (Anime Edition)</title>
    <style>
        /* --- Aesthetic Constants (from Python) --- */
        :root {
            --royal-bg: #2E2E38;
            --panel-bg: #383B40;
            --light-square: #F0D9B5;
            --dark-square: #B58863;
            --gold-piece: #000000;
            --silver-piece: #FFFFFF;
            --accent-red: #F04747;
            --accent-green: #43b581;
            --highlight-color: #A8C356;
            --attack-color: #FF5733;
            --frozen-color: #00BFFF;
            --power-target-color: #FFA500;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 0;
            background-color: var(--royal-bg);
            color: var(--silver-piece);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }

        /* Main App Container */
        #app-container {
            display: flex;
            flex-direction: row;
            max-width: 1200px;
            width: 95%;
            padding: 20px;
            gap: 20px;
            flex-wrap: wrap; /* Responsive on smaller screens */
        }

        /* --- Chess Board Styles --- */
        #board-ui-container {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            min-width: 350px;
            order: 1; /* Desktop layout: Board on left */
        }

        #board-container {
            display: grid;
            grid-template-columns: auto repeat(8, 1fr) auto;
            grid-template-rows: repeat(8, 1fr) auto;
            gap: 0;
            border: 5px solid var(--dark-square);
        }

        .rank-label, .file-label {
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 14px;
            font-weight: bold;
            color: var(--light-square);
        }
        .rank-label { grid-column: 1; }
        .file-label { grid-row: 9; }

        .chess-square {
            width: 75px; /* Base size */
            height: 75px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            font-size: 52px;
            font-weight: bold;
            transition: background-color 0.1s;
            position: relative;
        }

        .piece {
            line-height: 1;
        }

        /* Dynamic Highlighting (JS will add these classes) */
        .selected { background-color: var(--highlight-color) !important; }
        .target-dot {
            font-size: 36px;
            color: var(--panel-bg);
            position: absolute;
            opacity: 0.8;
        }
        .capture-target { box-shadow: inset 0 0 0 5px var(--attack-color); }
        .power-target { background-color: var(--power-target-color) !important; }
        .frozen {
            background-color: var(--frozen-color) !important;
            box-shadow: inset 0 0 10px 2px rgba(0, 191, 255, 0.7);
        }
        .hacked-piece { color: #FFD700 !important; }
        .check-square { box-shadow: inset 0 0 0 5px var(--accent-red) !important; }

        /* Game Over Overlay */
        #game-over-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(46, 46, 56, 0.85); /* royal-bg with transparency */
            display: flex;
            justify-content: center;
            align-items: center;
            text-align: center;
            flex-direction: column;
            cursor: pointer;
            z-index: 10;
        }
        #game-over-overlay h2 { font-size: 32px; margin: 0; color: var(--accent-red); }
        #game-over-overlay p { font-size: 18px; color: var(--light-square); margin-top: 10px; }

        /* --- Panel Styles --- */
        #panel-frame {
            background-color: var(--panel-bg);
            padding: 20px;
            border-radius: 8px;
            width: 300px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            order: 2; /* Desktop layout: Panel on right */
        }

        #status-label {
            font-size: 18px;
            font-weight: bold;
            padding: 5px 0;
            text-align: center;
        }

        #message-label {
            min-height: 40px;
            padding: 10px 0;
            border-top: 1px solid #474751;
            margin-top: 10px;
            font-size: 14px;
        }

        #ability-info-frame {
            background-color: #474751;
            padding: 10px;
            margin-top: 15px;
            border-radius: 4px;
        }
        .ability-title { font-size: 16px; font-weight: bold; color: var(--accent-green); text-align: center; }
        .ability-desc { font-size: 12px; color: var(--light-square); margin-top: 5px; }
        .ability-prompt { font-size: 14px; font-weight: bold; color: var(--accent-green); margin-top: 10px; }
        #r-uses-label { font-size: 14px; color: gold; text-align: center; }

        .cmd-button {
            width: 100%;
            padding: 10px;
            margin-top: 5px;
            border: none;
            border-radius: 4px;
            background-color: #474751;
            color: white;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.2s;
        }
        .cmd-button:hover:not(:disabled) { background-color: #5d6168; }
        .cmd-button:disabled { cursor: not-allowed; opacity: 0.5; }

        #ultimate-button {
            width: 100%;
            padding: 15px;
            margin-top: 20px;
            border: none;
            border-radius: 4px;
            background-color: var(--accent-red);
            color: white;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        #ultimate-button:hover:not(:disabled) { background-color: #c93b3b; }
        #ultimate-button:disabled { cursor: not-allowed; opacity: 0.5; }

        /* --- Main Menu Styles --- */
        #main-menu {
            display: none;
            flex-direction: column;
            align-items: center;
            padding: 50px;
            background-color: var(--royal-bg);
            border-radius: 8px;
            text-align: center;
            width: 400px;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.4);
        }
        #main-menu h1 { font-size: 32px; color: var(--accent-green); margin-bottom: 40px; }
        .menu-button {
            width: 100%;
            padding: 15px;
            margin: 10px 0;
            font-size: 18px;
            font-weight: bold;
            border: 4px solid var(--panel-bg);
            border-radius: 4px;
            background-color: var(--panel-bg);
            color: white;
            cursor: pointer;
            transition: background-color 0.2s, border-color 0.2s;
        }
        .menu-button:hover { background-color: #474751; }
        #start-bot-btn { background-color: var(--accent-green); border-color: var(--accent-green); }
        #start-bot-btn:hover { background-color: #319e6d; border-color: #319e6d; }
        .elo-control { display: flex; align-items: center; margin: 10px 0; width: 100%; }
        .elo-control label { font-size: 14px; margin-right: 10px; color: var(--light-square); width: 60px; text-align: left; }
        .elo-control input[type="range"] { flex-grow: 1; }
        .coming-soon { color: #888888; font-style: italic; font-size: 12px; margin-top: -5px; }


        /* --- Responsive Adjustments --- */
        @media (max-width: 900px) {
            #app-container {
                flex-direction: column;
                align-items: center;
                gap: 10px;
            }
            #board-ui-container {
                order: 2; /* Mobile layout: Board below panel */
            }
            #panel-frame {
                order: 1; /* Mobile layout: Panel on top */
                width: 100%;
                max-width: 450px;
            }
            .chess-square {
                width: 45px; /* Smaller size for mobile */
                height: 45px;
                font-size: 40px;
            }
            .chess-square .piece { font-size: 40px; }
            .chess-square.frozen .piece { font-size: 30px; }
            .chess-square .target-dot { font-size: 28px; }
            #game-over-overlay h2 { font-size: 24px; }
            #game-over-overlay p { font-size: 16px; }
        }
        @media (max-width: 500px) {
            .chess-square {
                width: 35px;
                height: 35px;
                font-size: 30px;
            }
            .chess-square .piece { font-size: 30px; }
            .chess-square.frozen .piece { font-size: 22px; }
        }
    </style>
</head>
<body>

<div id="app-container">
    
    <div id="main-menu">
        <h1>ULTIMATE CHESS</h1>
        
        <button class="menu-button" onclick="app.startGame('local')">2 PLAYER (LOCAL)</button>

        <div style="width: 100%; margin: 20px 0;">
            <p style="font-size: 14px; font-weight: bold; color: white;">Play with Bot (ELOfied)</p>
            <div class="elo-control">
                <label id="elo-label">ELO: 1500</label>
                <input type="range" id="elo-slider" min="1" max="3000" value="1500" oninput="document.getElementById('elo-label').textContent = 'ELO: ' + this.value">
            </div>
            <button id="start-bot-btn" class="menu-button" onclick="app.startGame('bot')">START BOT GAME</button>
        </div>

        <button class="menu-button" disabled>PLAY WITH FRIEND (ONLINE)</button>
        <p class="coming-soon">[COMING SOON]</p>

    </div>

    <div id="board-ui-container" style="display: none;">
        <div id="board-container">
            </div>
    </div>
    
    <div id="panel-frame" style="display: none;">
        <h2 style="color: var(--silver-piece); text-align: center;">ULTIMATE CHESS</h2>
        
        <div id="status-label" style="color: var(--silver-piece);"></div>

        <div id="r-uses-label"></div>

        <div id="message-label" style="color: var(--light-square);"></div>

        <div id="ability-info-frame">
            <div style="font-size: 12px; font-weight: bold; color: white; text-align: center; padding-bottom: 5px;">--- ULTIMATE POWER ---</div>
            <div id="ability-title" class="ability-title"></div>
            <div id="ability-desc" class="ability-desc"></div>
            <div id="ability-prompt" class="ability-prompt"></div>

            <div id="cmd-frame" style="margin-top: 10px;">
                <button id="hack-btn" class="cmd-button" onclick="app._initiate_hack()" disabled>/HACK (Friendly Fire)</button>
                <button id="phase-btn" class="cmd-button" onclick="app._initiate_phase()" disabled>/PHASE (Teleport Rook)</button>
            </div>
        </div>

        <button id="ultimate-button" onclick="app.activateUltimateGUI()" disabled>ACTIVATE ULTIMATE</button>

        <button id="menu-button-game" class="cmd-button" style="margin-top: 15px; background-color: var(--accent-red);" onclick="app.showMainMenu()">QUIT TO MENU</button>
    </div>

</div>

<script>
// --- Global Constants (Game Engine Data) ---
const UNICODE_PIECES = {
    'WK': 'â™”', 'WQ': 'â™•', 'WR': 'â™–', 'WB': 'â™—', 'WN': 'â™˜', 'WP': 'â™™',
    'BK': 'â™š', 'BQ': 'â™›', 'BR': 'â™œ', 'BB': 'â™', 'BN': 'â™ž', 'BP': 'â™Ÿ',
    'BL': 'ðŸš§', // Blockade
    'FR': 'â„ï¸', // Frozen
    'RM': 'ðŸ¤–', // Roomba
    'WA': 'â™˜â™—', 'BA': 'â™žâ™', // Archbishop
    'DOT': 'â—'
};
const FILE_MAP = { 'a': 0, 'b': 1, 'c': 2, 'd': 3, 'e': 4, 'f': 5, 'g': 6, 'h': 7 };
const RANK_MAP = { '1': 0, '2': 1, '3': 2, '4': 3, '5': 4, '6': 5, '7': 6, '8': 7 };
const PIECE_VALUES = {'P': 100, 'N': 300, 'B': 300, 'R': 500, 'Q': 900, 'K': 10000, 'A': 650, 'RM': 1000};
const ULTIMATE_POWERS = {
    'GENERAL': {
        'name': "Temporal Blockade", 'mode': 'BLOCKADE',
        'desc': "Places an indestructible blockade (ðŸš§). Each side can have up to TWO active.",
        'prompt': "Select an empty square for the blockade."
    },
    'N': {
        'name': "Archbishop's Fusion", 'mode': 'KNIGHT_FUSION',
        'desc': "Fuses a friendly Knight and Bishop that are on adjacent or two-square diagonal squares (e.g., a1/b2, a1/c2) into a powerful **Archbishop (A)**. The Archbishop moves as a Knight OR a Bishop.",
        'prompt': "Select the friendly Bishop to fuse with."
    },
    'B': {
        'name': "Cat's Cradle Catastrophe", 'mode': 'BISHOP_FREEZE',
        'desc': "Bishop releases a Web of Distraction along its attack diagonal. All pieces on that diagonal are **frozen** for the opponent's next turn. Requires Bishop to be attacked.",
        'prompt': "Select the diagonal target square to freeze along that line."
    },
    'R': {
        'name': "Hax.exe Command Shell", 'mode': 'R_COMMAND_SELECT',
        'desc': "Opens the Hax.exe command shell. Allows one of two commands: /hack or /phase. Usable twice per team.",
        'prompt': "Select /HACK (Friendly Fire) or /PHASE (Teleport) below."
    },
    'K': {
        'name': "Domain Expansion: Murasaki", 'mode': 'MURASAKI',
        'desc': "Activates on a **self-sacrifice**: King captures a friendly Pawn. The resulting 'Murasaki' beam instantly removes a **random** enemy piece (not the King).",
        'prompt': "Select a friendly Pawn for the King to capture to initiate Murasaki."
    }
};

// --- Aesthetic Constants for JS ---
const COLORS = {
    LIGHT: '#F0D9B5', DARK: '#B58863', HIGHLIGHT: '#A8C356', ATTACK: '#FF5733',
    FROZEN: '#00BFFF', POWER_TARGET: '#FFA500', GOLD: '#000000', SILVER: '#FFFFFF',
    ACCENT_GREEN: '#43b581', ACCENT_RED: '#F04747'
};


// --- 1. GAME LOGIC (UltimateChessGame Class) ---
class UltimateChessGame {
    constructor() {
        this._initializeGame();
    }

    _initializeBoard() {
        let board = Array(8).fill(0).map(() => Array(8).fill(null));
        const backRank = ['R', 'N', 'B', 'Q', 'K', 'B', 'N', 'R'];
        for (let f = 0; f < 8; f++) {
            board[f][1] = { type: 'P', color: 'W', moved: false };
            board[f][6] = { type: 'P', color: 'B', moved: false };
            board[f][0] = { type: backRank[f], color: 'W', moved: false };
            board[f][7] = { type: backRank[f], color: 'B', moved: false };
        }
        return board;
    }

    _initializeGame() {
        this.board = this._initializeBoard();
        this.currentTurn = 'W';
        this.activeBlockades = { 'W': [], 'B': [] };
        this.message = "Game started! White moves first. ULTIMATE is available per piece.";
        this.isCheck = false;
        this.isPowerMode = null;
        this.selectedSquareCoords = null;
        this.enPassantTarget = null;
        this.gameOver = null;
        this.frozenPieces = {};
        this.roombaPos = null;
        this.roombaTarget = null;
        this.roombaMovesRemaining = 0;
        this.rPowerUses = { 'W': 2, 'B': 2 };
        this.hackedPiece = null;
        this.phaseMovePending = false;
        // Used by AI (but only for simple selection here)
        this.availableAiMoves = [];
        this.currentUltimatePowerInfo = ULTIMATE_POWERS['GENERAL'];
    }

    // --- Utility Methods ---
    _coordsToIndices(coord) {
        if (coord.length !== 2 || !(coord[0] in FILE_MAP) || !(coord[1] in RANK_MAP)) {
            throw new Error(`Invalid coordinate: ${coord}`);
        }
        return [FILE_MAP[coord[0]], RANK_MAP[coord[1]]];
    }

    _indicesToCoords(f, r) {
        const fileChar = String.fromCharCode(97 + f);
        const rankChar = String(r + 1);
        return fileChar + rankChar;
    }

    _getPiecePower(pieceType) {
        return ULTIMATE_POWERS[pieceType] || ULTIMATE_POWERS['GENERAL'];
    }

    _isSquareBlocked(f, r) {
        return this.activeBlockades['W'].some(b => b[0] === f && b[1] === r) ||
               this.activeBlockades['B'].some(b => b[0] === f && b[1] === r);
    }

    _isSquareFrozen(f, r) {
        return this.frozenPieces[`${f},${r}`] > 0;
    }

    _getKingPos(color) {
        for (let f = 0; f < 8; f++) {
            for (let r = 0; r < 8; r++) {
                const piece = this.board[f][r];
                if (piece && piece.color === color && piece.type === 'K') {
                    return [f, r];
                }
            }
        }
        return null;
    }
    
    // Simplified checks for brevity, assuming standard chess rules + powers.
    // Full logic needs to be ported from Python's _validate_move, _check_move_rules, etc.
    // For this demonstration, we'll only port the simplest parts of the core logic.
    // *** NOTE: THE BELOW MOVE VALIDATION IS A SIMPLIFIED STUB ***
    getLegalMoves(f1, r1) {
        const piece = this.board[f1][r1];
        if (!piece || piece.color !== this.currentTurn || this._isSquareFrozen(f1, r1)) return [];

        let legalMoves = [];
        for (let f2 = 0; f2 < 8; f2++) {
            for (let r2 = 0; r2 < 8; r2++) {
                if (f1 === f2 && r1 === r2) continue;

                // Simple check: is target empty or is it an enemy piece?
                const target = this.board[f2][r2];
                const isRoombaCapture = this.roombaPos && this.roombaPos[0] === f2 && this.roombaPos[1] === r2;
                const isCapture = (target && target.color !== piece.color) || isRoombaCapture;
                
                // Blocked square check
                if (this._isSquareBlocked(f2, r2)) continue;

                // Simplistic 'move' rule check (should be replaced by full _check_move_rules)
                const df = Math.abs(f2 - f1);
                const dr = Math.abs(r2 - r1);

                let isPseudoLegal = false;
                switch (piece.type) {
                    case 'P': isPseudoLegal = (df === 0 && dr === 1 && !target) || (df === 0 && dr === 2 && r1 === (piece.color === 'W' ? 1 : 6) && !target && !this.board[f1][r1 + (piece.color === 'W' ? 1 : -1)]) || (df === 1 && dr === 1 && (isCapture || (this.enPassantTarget && this.enPassantTarget[0] === f2 && this.enPassantTarget[1] === r2))); break;
                    case 'N': isPseudoLegal = (df === 1 && dr === 2) || (df === 2 && dr === 1); break;
                    case 'B': isPseudoLegal = df === dr && df > 0 && !this._isPathBlocked(f1, r1, f2, r2); break;
                    case 'R': isPseudoLegal = (df === 0 && dr > 0) || (dr === 0 && df > 0) && !this._isPathBlocked(f1, r1, f2, r2); break;
                    case 'Q': isPseudoLegal = (df === dr || df === 0 || dr === 0) && df > 0 && !this._isPathBlocked(f1, r1, f2, r2); break;
                    case 'K': isPseudoLegal = df <= 1 && dr <= 1; break;
                    case 'A': isPseudoLegal = ((df === 1 && dr === 2) || (df === 2 && dr === 1) || (df === dr && df > 0 && !this._isPathBlocked(f1, r1, f2, r2))); break;
                }
                
                // Simplified King check safety validation (must be replaced by full logic)
                if (isPseudoLegal) {
                     // In a real port, you would simulate the move and call _isKingInCheck()
                     // For this JS demo, we skip the deep check to keep the size manageable.
                     // The Python code's _validate_move is required here.
                     legalMoves.push({ coords: [f2, r2], isCapture: isCapture });
                }
            }
        }
        
        // Add power-specific targets here (Blockade, Fusion, Hack, Phase)
        // ... (This logic is contained within the app class for GUI purposes)

        return legalMoves;
    }

    // --- Standard Move Execution (Simplified for JS) ---
    executeMove(moveStr) {
        if (this.gameOver) return;

        try {
            const [f1, r1] = this._coordsToIndices(moveStr.substring(0, 2));
            const [f2, r2] = this._coordsToIndices(moveStr.substring(2, 4));
            const piece = this.board[f1][r1];
            const target = this.board[f2][r2];
            
            // Check if the move is legal (should use full Python logic here)
            // For the demo, we assume the GUI only allows legal moves.

            // 1. Move the piece
            this.board[f2][r2] = piece;
            this.board[f1][r1] = null;
            piece.moved = true;

            // 2. Handle Roomba capture
            if (this.roombaPos && this.roombaPos[0] === f2 && this.roombaPos[1] === r2) {
                this.roombaPos = null;
                this.roombaMovesRemaining = 0;
                this.message = "Roomba destroyed by piece move!";
            } else if (target) {
                this.message = `Captured ${target.color}${target.type}!`;
            } else {
                this.message = "Move successful.";
            }

            // 3. Pawn push/En Passant
            if (piece.type === 'P' && Math.abs(r2 - r1) === 2) {
                const direction = piece.color === 'W' ? 1 : -1;
                this.enPassantTarget = [f2, r1 + direction];
                this.message += " (En Passant target set)";
            } else {
                this.enPassantTarget = null;
            }

            // 4. Pawn promotion (simplified to Queen)
            if (piece.type === 'P' && (r2 === 7 || r2 === 0)) {
                piece.type = 'Q';
                this.message += " (PROMOTED to Queen!)";
            }
            
            // 5. Check for Hacked Piece capture (Friendly Fire)
            if (this.hackedPiece && this.hackedPiece[0] === f2 && this.hackedPiece[1] === r2) {
                this.hackedPiece = null;
                // If it was an enemy piece, it's already captured. If friendly, it's also captured.
            }
            
        } catch (e) {
            this.message = "An error occurred during move execution.";
            console.error(e);
        }

        this._nextTurn();
    }

    _isKingInCheck(color) {
        // Simplified stub: Full _is_square_attacked logic is too complex for this port.
        // Assume no check logic for this demo to avoid infinite size.
        return false; 
    }
    
    _isPathBlocked(f1, r1, f2, r2) {
        // Simplified path checking (only checks for pieces, not blockades)
        let df = f1 === f2 ? 0 : (f2 > f1 ? 1 : -1);
        let dr = r1 === r2 ? 0 : (r2 > r1 ? 1 : -1);
        let f = f1 + df, r = r1 + dr;
        while (f !== f2 || r !== r2) {
            if (this.board[f][r] || this._isSquareBlocked(f, r)) return true;
            f += df;
            r += dr;
        }
        return false;
    }

    // --- Power Activation Logic (Porting the core effects) ---

    // Note: Python's activate_ultimate() and related functions must be fully ported
    // The complexity prevents including them here, so we will stub them in the App class.
    
    // --- Roomba Logic (Ported from _move_roomba) ---
    _moveRoomba() {
        if (!this.roombaPos || this.roombaMovesRemaining <= 0) return;

        const [kf, kr] = this.roombaTarget;
        let [rf, rr] = this.roombaPos;

        let df = 0; if (kf > rf) df = 1; else if (kf < rf) df = -1;
        let dr = 0; if (kr > rr) dr = 1; else if (kr < rr) dr = -1;
        let [newRf, newRr] = [rf + df, rr + dr];

        if (!(0 <= newRf <= 7 && 0 <= newRr <= 7)) {
            this.roombaPos = null;
            this.roombaMovesRemaining = 0;
            this.message += " (Roomba drove off the board and self-destructed.)";
            return;
        }

        if (newRf === kf && newRr === kr) {
            this.roombaPos = null;
            this.roombaMovesRemaining = 0;
            this.board[kf][kr] = null;
            this.gameOver = 'CHECKMATE';
            this.message = "Roomba captured the King! Checkmate!";
        } else if (this.board[newRf][newRr] !== null || this._isSquareBlocked(newRf, newRr)) {
            const targetPiece = this.board[newRf][newRr];
            const targetCoord = this._indicesToCoords(newRf, newRr);

            if (targetPiece) {
                this.board[newRf][newRr] = null;
                this.message = `Roomba collided with ${targetPiece.color}${targetPiece.type} at ${targetCoord} and self-destructed.`;
            } else if (this._isSquareBlocked(newRf, newRr)) {
                // Remove blockade
                this.activeBlockades['W'] = this.activeBlockades['W'].filter(b => b[0] !== newRf || b[1] !== newRr);
                this.activeBlockades['B'] = this.activeBlockades['B'].filter(b => b[0] !== newRf || b[1] !== newRr);
                this.message = `Roomba destroyed blockade at ${targetCoord} and self-destructed.`;
            }
            
            this.roombaPos = null;
            this.roombaMovesRemaining = 0;
        } else {
            this.roombaPos = [newRf, newRr];
            this.roombaMovesRemaining -= 1;
            this.message += ` (Roomba moved to ${this._indicesToCoords(newRf, newRr)}. Moves left: ${this.roombaMovesRemaining})`;
            if (this.roombaMovesRemaining === 0) {
                this.roombaPos = null;
                this.message += " (Roomba fuel exhausted and removed.)";
            }
        }
    }


    // --- Next Turn (Ported) ---
    _nextTurn() {
        this.enPassantTarget = null;
        this.phaseMovePending = false;
        this.hackedPiece = null; // Hacked effect lasts for one opponent turn cycle, so reset here.

        // 1. Roomba movement
        if (this.roombaMovesRemaining > 0) {
            this._moveRoomba();
            if (this.gameOver) return;
        }

        // 2. Thaw frozen pieces
        let thawedCount = 0;
        const keysToUpdate = Object.keys(this.frozenPieces);
        for (const key of keysToUpdate) {
            this.frozenPieces[key] -= 1;
            if (this.frozenPieces[key] === 0) {
                delete this.frozenPieces[key];
                thawedCount++;
            }
        }
        if (thawedCount > 0) {
            this.message += ` (${thawedCount} pieces thawed out!)`;
        }

        // 3. Switch turn and check for mate/stalemate
        this.currentTurn = this.currentTurn === 'W' ? 'B' : 'W';
        this.isPowerMode = null;
        this.selectedSquareCoords = null;
        
        // Simplified check (requires full check logic for real game)
        this.isCheck = this._isKingInCheck(this.currentTurn);
        if (this.isCheck) this.message += " CHECK!";
        
        // This is where a proper 'hasLegalMoves' check would go.
    }
}


// --- 2. GUI INTERFACE (UltimateChessApp Class) ---
class UltimateChessApp {
    constructor() {
        this.game = new UltimateChessGame();
        this.selectedSquare = null; // [f, r]
        this.validTargets = []; // [{coords: [f, r], isCapture: bool, isPowerTarget: bool}]
        this.botElo = 1500;
        this.userColor = 'W';
        this.gameType = 'local';

        // DOM elements
        this.appContainer = document.getElementById('app-container');
        this.menu = document.getElementById('main-menu');
        this.boardUi = document.getElementById('board-ui-container');
        this.boardContainer = document.getElementById('board-container');
        this.panel = document.getElementById('panel-frame');

        this.statusLabel = document.getElementById('status-label');
        this.messageLabel = document.getElementById('message-label');
        this.rUsesLabel = document.getElementById('r-uses-label');
        this.abilityTitle = document.getElementById('ability-title');
        this.abilityDesc = document.getElementById('ability-desc');
        this.abilityPrompt = document.getElementById('ability-prompt');
        this.ultimateButton = document.getElementById('ultimate-button');
        this.hackBtn = document.getElementById('hack-btn');
        this.phaseBtn = document.getElementById('phase-btn');
        this.eloSlider = document.getElementById('elo-slider');
        
        this.squares = {};
        this.showMainMenu();

        this.eloSlider.addEventListener('input', (e) => this.botElo = parseInt(e.target.value));
    }

    // --- Frame Switching ---
    showMainMenu() {
        if (document.getElementById('game-over-overlay')) {
            document.getElementById('game-over-overlay').remove();
        }
        this.menu.style.display = 'flex';
        this.boardUi.style.display = 'none';
        this.panel.style.display = 'none';
        this.game = new UltimateChessGame(); // Reset game state
    }

    startGame(gameType) {
        this.game = new UltimateChessGame();
        this.gameType = gameType;
        this.userColor = gameType === 'bot' ? (Math.random() < 0.5 ? 'W' : 'B') : 'W';
        this.botElo = parseInt(this.eloSlider.value);

        this.menu.style.display = 'none';
        this.boardUi.style.display = 'flex';
        this.panel.style.display = 'block';

        this._setupGameBoardUI();
        this.drawBoard();
        this.updateStatus();

        if (gameType === 'bot' && this.game.currentTurn !== this.userColor) {
            this.handleAITurn();
        }
    }

    // --- UI Setup ---
    _setupGameBoardUI() {
        this.boardContainer.innerHTML = '';
        this.squares = {};
        const rankRange = this.userColor === 'W' ? [...Array(8).keys()] : [...Array(8).keys()].reverse();

        for (let r = 0; r < 8; r++) {
            // Rank Labels
            const rankDisplay = rankRange[r] + 1;
            const rankLabel = document.createElement('div');
            rankLabel.className = 'rank-label';
            rankLabel.textContent = rankDisplay;
            rankLabel.style.gridRow = r + 1;
            rankLabel.style.gridColumn = 1;
            this.boardContainer.appendChild(rankLabel);

            // Squares
            for (let f = 0; f < 8; f++) {
                const color = (f + rankRange[r]) % 2 === 0 ? COLORS.LIGHT : COLORS.DARK;
                const square = document.createElement('div');
                square.className = 'chess-square';
                square.style.backgroundColor = color;
                square.style.gridRow = r + 1;
                square.style.gridColumn = f + 2;
                square.dataset.f = f;
                square.dataset.r = rankRange[r];
                square.addEventListener('click', () => this.handleClick(f, rankRange[r]));
                
                const pieceElement = document.createElement('span');
                pieceElement.className = 'piece';
                square.appendChild(pieceElement);

                this.squares[`${f},${rankRange[r]}`] = { element: square, color: color, pieceElement: pieceElement };
                this.boardContainer.appendChild(square);
            }
        }

        // File Labels
        const fileChars = 'abcdefgh';
        for (let f = 0; f < 8; f++) {
            const fileLabel = document.createElement('div');
            fileLabel.className = 'file-label';
            fileLabel.textContent = fileChars[f];
            fileLabel.style.gridRow = 9;
            fileLabel.style.gridColumn = f + 2;
            this.boardContainer.appendChild(fileLabel);
        }
    }

    // --- Drawing and Status Updates ---
    drawBoard() {
        for (let f = 0; f < 8; f++) {
            for (let r = 0; r < 8; r++) {
                const key = `${f},${r}`;
                const squareData = this.squares[key];
                const squareEl = squareData.element;
                const pieceEl = squareData.pieceElement;
                const piece = this.game.board[f][r];
                
                // Reset classes
                squareEl.className = 'chess-square';
                squareEl.style.backgroundColor = squareData.color;
                pieceEl.className = 'piece';

                let symbol = '';
                let fgColor = COLORS.SILVER;
                let bgColor = squareData.color;
                
                // 1. Piece/Roomba/Blockade
                if (piece) {
                    const pieceKey = piece.color + piece.type;
                    symbol = UNICODE_PIECES[pieceKey] || pieceKey;
                    fgColor = piece.color === 'W' ? COLORS.GOLD : COLORS.SILVER;
                    if (piece.type === 'A') pieceEl.style.fontSize = '80%'; // Shrink Archbishop
                } else if (this.game.roombaPos && this.game.roombaPos[0] === f && this.game.roombaPos[1] === r) {
                    symbol = UNICODE_PIECES['RM'];
                    fgColor = 'gold';
                    bgColor = '#474751';
                } else if (this.game._isSquareBlocked(f, r)) {
                    symbol = UNICODE_PIECES['BL'];
                    fgColor = COLORS.ACCENT_RED;
                }

                // 2. Highlighting
                const targetInfo = this.validTargets.find(t => t.coords[0] === f && t.coords[1] === r);
                
                if (this.selectedSquare && this.selectedSquare[0] === f && this.selectedSquare[1] === r) {
                    squareEl.classList.add('selected');
                } else if (targetInfo) {
                    if (targetInfo.isPowerTarget) {
                        squareEl.style.backgroundColor = COLORS.POWER_TARGET;
                    } else if (targetInfo.isCapture || (piece && piece.color !== this.game.currentTurn)) {
                        squareEl.classList.add('capture-target');
                    } else if (!piece && (!this.game.roombaPos || this.game.roombaPos[0] !== f || this.game.roombaPos[1] !== r)) {
                        // Empty square target dot
                        symbol = UNICODE_PIECES.DOT;
                        fgColor = COLORS.PANEL_BG;
                        pieceEl.classList.add('target-dot');
                    }
                }
                
                // 3. Status Overlays
                if (this.game.hackedPiece && this.game.hackedPiece[0] === f && this.game.hackedPiece[1] === r) {
                    pieceEl.classList.add('hacked-piece');
                }
                if (this.game._isSquareFrozen(f, r)) {
                    squareEl.classList.add('frozen');
                    if (piece && !symbol.includes(UNICODE_PIECES.FR)) {
                        symbol += ' ' + UNICODE_PIECES.FR;
                    }
                }
                
                pieceEl.textContent = symbol.trim();
                pieceEl.style.color = fgColor;
                squareEl.style.backgroundColor = squareEl.classList.contains('selected') ? COLORS.HIGHLIGHT : (squareEl.classList.contains('capture-target') ? COLORS.ATTACK : squareData.color);

                // Add check square highlight (If King is in check, its square gets a red border)
                const kingPos = this.game._getKingPos(this.game.currentTurn);
                if (this.game.isCheck && kingPos && kingPos[0] === f && kingPos[1] === r) {
                    squareEl.classList.add('check-square');
                }
            }
        }
        this._drawGameOverOverlay();
    }

    updateStatus() {
        if (this.game.gameOver) {
            this.statusLabel.textContent = this.game.gameOver;
            this.statusLabel.style.color = COLORS.ACCENT_RED;
            this.messageLabel.textContent = this.game.message;
            this.messageLabel.style.color = COLORS.ACCENT_RED;
            this.ultimateButton.disabled = true;
            this.updateAbilityPanel(null); // Clear panel
            return;
        }

        const turnText = this.game.currentTurn === 'W' ? "WHITE" : "BLACK";
        let modeLabel = "";
        const isUserTurn = this.gameType === 'local' || this.game.currentTurn === this.userColor;

        if (this.gameType === 'bot') {
            const playerRole = this.game.currentTurn === this.userColor ? "YOU" : "AI";
            modeLabel = ` (${playerRole} turn)`;
        }
        
        this.statusLabel.textContent = `Current Turn: ${turnText}${modeLabel}`;
        this.statusLabel.style.color = this.game.currentTurn === 'W' ? COLORS.GOLD : COLORS.SILVER;
        
        this.messageLabel.textContent = this.game.message;
        this.messageLabel.style.color = this.game.isCheck ? COLORS.ACCENT_RED : COLORS.LIGHT;

        const isPieceSelected = this.selectedSquare !== null;
        const canActivate = isPieceSelected && this.game.isPowerMode === null;
        
        if (isUserTurn) {
            if (this.game.isPowerMode) {
                this.ultimateButton.textContent = "CANCEL POWER";
                this.ultimateButton.disabled = false;
            } else {
                this.ultimateButton.textContent = "ACTIVATE ULTIMATE";
                this.ultimateButton.disabled = !canActivate;
            }
        } else {
            this.ultimateButton.textContent = "AI's Turn...";
            this.ultimateButton.disabled = true;
        }
        
        const piece = isPieceSelected ? this.game.board[this.selectedSquare[0]][this.selectedSquare[1]] : null;
        this.updateAbilityPanel(piece);
    }

    updateAbilityPanel(piece = null) {
        let info = this.game.currentUltimatePowerInfo;
        
        // R Uses Display
        let rUsesText = `Rook Uses: W: ${this.game.rPowerUses['W']}/2 | B: ${this.game.rPowerUses['B']}/2`;
        if (this.game.hackedPiece) {
            const [hf, hr] = this.game.hackedPiece;
            const hPiece = this.game.board[hf][hr];
            const hCoord = this.game._indicesToCoords(hf, hr);
            rUsesText += ` | HACKED: ${hPiece.color}${hPiece.type} at ${hCoord}`;
        }
        this.rUsesLabel.textContent = rUsesText;
        
        // Power Mode Display
        if (this.game.isPowerMode) {
            this.abilityTitle.textContent = `POWER MODE: ${info.name}`;
            this.abilityTitle.style.color = COLORS.ACCENT_RED;
            this.abilityDesc.textContent = info.desc;
            this.abilityPrompt.textContent = this.game.isPowerMode === 'R_COMMAND_SELECT' ? "Status: Select /HACK or /PHASE." : `Action: ${info.prompt}`;
            
            this.hackBtn.disabled = this.game.isPowerMode !== 'R_COMMAND_SELECT';
            this.phaseBtn.disabled = this.game.isPowerMode !== 'R_COMMAND_SELECT';
            
            return;
        }
        
        // Default Display (No Power Active)
        this.hackBtn.disabled = true;
        this.phaseBtn.disabled = true;

        if (piece) {
            const pieceType = piece.type;
            info = this.game._getPiecePower(pieceType);
            this.abilityTitle.textContent = `${pieceType} ULTIMATE: ${info.name}`;
            this.abilityTitle.style.color = COLORS.ACCENT_GREEN;
            this.abilityDesc.textContent = info.desc;
            this.abilityPrompt.textContent = "Action: Click ACTIVATE to use this power.";
        } else {
            info = ULTIMATE_POWERS['GENERAL'];
            this.abilityTitle.textContent = "Select a Piece";
            this.abilityTitle.style.color = 'white';
            this.abilityDesc.textContent = "General Ultimate: " + info.desc;
            this.abilityPrompt.textContent = "Action: Make a standard move.";
        }
    }
    
    _drawGameOverOverlay() {
        let overlay = document.getElementById('game-over-overlay');
        if (this.game.gameOver && !overlay) {
            overlay = document.createElement('div');
            overlay.id = 'game-over-overlay';
            overlay.addEventListener('click', () => this.showMainMenu());
            this.boardContainer.style.position = 'relative'; // Ensure board is positioned
            this.boardContainer.appendChild(overlay);
        } else if (!this.game.gameOver && overlay) {
            overlay.remove();
            return;
        }

        if (this.game.gameOver) {
            const winner = this.game.currentTurn === 'B' ? 'White' : 'Black';
            const fullMessage = this.game.gameOver === 'CHECKMATE' 
                ? `<h2>CHECKMATE!</h2><p style="color:${COLORS.ACCENT_RED};">${winner} WINS!</p><p>(Click to return to Menu)</p>`
                : `<h2>STALEMATE</h2><p style="color:${COLORS.LIGHT};">Draw!</p><p>(Click to return to Menu)</p>`;
            overlay.innerHTML = fullMessage;
        }
    }

    clearSelection() {
        this.selectedSquare = null;
        this.game.selectedSquareCoords = null;
        this.game.isPowerMode = null;
        this.validTargets = [];
        this.game.phaseMovePending = false;
        this.drawBoard();
        this.updateStatus();
    }

    _isValidTarget(f, r) {
        return this.validTargets.some(t => t.coords[0] === f && t.coords[1] === r);
    }
    
    // --- Event Handlers (Click and Ultimate) ---

    handleClick(f, r) {
        if (this.game.gameOver || (this.gameType === 'bot' && this.game.currentTurn !== this.userColor)) return;

        const f1 = this.selectedSquare ? this.selectedSquare[0] : null;
        const r1 = this.selectedSquare ? this.selectedSquare[1] : null;
        const targetPiece = this.game.board[f][r];
        const isSelectedSquare = this.selectedSquare && f === f1 && r === r1;
        
        const isPowerCommandActive = this.game.isPowerMode in ULTIMATE_POWERS; // Check if in any power mode

        if (isPowerCommandActive) {
            // ** POWER MODE INTERACTION **
            if (this.game.isPowerMode === 'BLOCKADE') {
                if (!this.game.board[f][r] && !this.game._isSquareBlocked(f, r)) {
                    this.game.activeBlockades[this.game.currentTurn].push([f, r]);
                    this.game.message = `Temporal Blockade placed at ${this.game._indicesToCoords(f, r)}.`;
                    this.clearSelection();
                    this.game._nextTurn();
                } else {
                    this.game.message = "Blockade square must be empty and not already blocked.";
                }
            } else if (this.game.isPowerMode === 'KNIGHT_FUSION') {
                if (this._isValidTarget(f, r)) {
                    this._performFusion(f, r); // Handles next turn and cleanup
                } else {
                    this.game.message = "Invalid fusion target. Select a friendly Bishop within range.";
                }
            } else if (this.game.isPowerMode === 'R_HACK_PENDING' || this.game.isPowerMode === 'R_PHASE_PENDING') {
                this._handleRookCommandClick(f, r);
            } else if (this.game.isPowerMode === 'MURASAKI' || this.game.isPowerMode === 'BISHOP_FREEZE' || this.game.isPowerMode === 'ROOK_ROOMBA') {
                if (this._isValidTarget(f, r)) {
                    this._executePowerMove(f, r);
                } else {
                    this.game.message = "Invalid target for ultimate power.";
                }
            }
            // All power paths should clear selection and handle next turn on completion.
            
        } else {
            // ** STANDARD MOVE/SELECTION **
            if (isSelectedSquare) {
                this.clearSelection();
            } else if (targetPiece && targetPiece.color === this.game.currentTurn) {
                // Select new friendly piece
                this.selectedSquare = [f, r];
                this.validTargets = this.game.getLegalMoves(f, r);
                this.game.message = `Selected ${targetPiece.color}${targetPiece.type} at ${this.game._indicesToCoords(f, r)}. ${this.validTargets.length} moves available.`;
            } else if (this.selectedSquare && this._isValidTarget(f, r)) {
                // Execute standard move
                const startCoord = this.game._indicesToCoords(f1, r1);
                const endCoord = this.game._indicesToCoords(f, r);
                this.game.executeMove(startCoord + endCoord);
                this.clearSelection();
                if (this.gameType === 'bot' && !this.game.gameOver && this.game.currentTurn !== this.userColor) {
                    this.handleAITurn();
                }
            } else {
                this.game.message = "Invalid selection or move destination.";
            }
        }

        this.drawBoard();
        this.updateStatus();
    }
    
    // --- ULTIMATE Power Implementation STUBS (Ported from Python) ---

    activateUltimateGUI() {
        if (this.game.isPowerMode) {
            this.clearSelection();
            this.game.message = "Ultimate power sequence cancelled.";
            return;
        }

        if (!this.selectedSquare) {
            this.game.message = "Please select a piece first.";
            this.updateStatus();
            return;
        }

        const [f, r] = this.selectedSquare;
        const piece = this.game.board[f][r];
        const powerInfo = this.game._getPiecePower(piece.type);

        // STUB: Full validation from Python is needed here.
        if (piece.type === 'B') {
             // Bishop Freeze requires being attacked (stubbed to always work for demo)
        } else if (piece.type === 'R' && this.game.rPowerUses[this.game.currentTurn] <= 0) {
            this.game.message = "Rook ultimate uses exhausted for this team.";
            this.updateStatus();
            return;
        }

        this.game.isPowerMode = powerInfo.mode;
        this.game.currentUltimatePowerInfo = powerInfo;
        this.game.selectedSquareCoords = this.selectedSquare;
        this.validTargets = this.game.getLegalMoves(f, r); // Recalculate targets for power mode
        this.game.message = `${powerInfo.name} ready. ${powerInfo.prompt}`;

        this.drawBoard();
        this.updateStatus();
    }
    
    _performFusion(bf, br) {
        const [nf, nr] = this.game.selectedSquareCoords;
        const knight = this.game.board[nf][nr];
        
        // 1. Replace Knight with Archbishop
        this.game.board[nf][nr] = { type: 'A', color: knight.color, moved: true };
        // 2. Remove Bishop
        this.game.board[bf][br] = null;

        this.game.message = `Archbishop formed at ${this.game._indicesToCoords(nf, nr)}!`;
        this.clearSelection();
        this.game._nextTurn();
    }
    
    _executePowerMove(f2, r2) {
        const [f1, r1] = this.game.selectedSquareCoords;
        const piece = this.game.board[f1][r1];
        const targetCoord = this.game._indicesToCoords(f2, r2);
        
        if (this.game.isPowerMode === 'MURASAKI') {
             // King self-sacrifices on Pawn
            const opponentColor = this.game.currentTurn === 'W' ? 'B' : 'W';
            const enemyPieces = [];
            for (let f = 0; f < 8; f++) {
                for (let r = 0; r < 8; r++) {
                    const p = this.game.board[f][r];
                    if (p && p.color === opponentColor && p.type !== 'K') {
                        enemyPieces.push([f, r, p]);
                    }
                }
            }
            if (enemyPieces.length > 0) {
                const [targetF, targetR, targetPiece] = enemyPieces[Math.floor(Math.random() * enemyPieces.length)];
                this.game.board[targetF][targetR] = null;
                this.game.message = `King sacrifices Pawn! Murasaki vaporized ${targetPiece.color}${targetPiece.type} at ${this.game._indicesToCoords(targetF, targetR)}.`;
            } else {
                this.game.message = "King sacrifices Pawn, but no eligible enemy target found.";
            }

            // King moves onto the pawn
            this.game.board[f2][r2] = piece;
            this.game.board[f1][r1] = null;
            piece.moved = true;
            
        } else if (this.game.isPowerMode === 'BISHOP_FREEZE') {
            // Bishop Freeze: Move piece and apply frozen status
            const df = f2 > f1 ? 1 : -1;
            const dr = r2 > r1 ? 1 : -1;
            let f = f1 + df, r = r1 + dr;
            while (f !== f2 || r !== r2) {
                const target = this.game.board[f][r];
                if (target && target.type !== 'K') {
                    this.game.frozenPieces[`${f},${r}`] = 2;
                }
                f += df; r += dr;
            }
            
            // Perform the Bishop move (assuming legal move check passes)
            this.game.board[f2][r2] = piece;
            this.game.board[f1][r1] = null;
            piece.moved = true;
            this.game.message = `Bishop activated Cat's Cradle. Diagonal frozen! Bishop moved to ${targetCoord}.`;

        } else if (this.game.isPowerMode === 'ROOK_ROOMBA') {
            // Rook Roomba: Rook retreats one square, Roomba deploys on former spot.
            const enemyKingPos = this.game._getKingPos(this.game.currentTurn === 'W' ? 'B' : 'W');
            if (enemyKingPos) {
                 // 1. Rook retreats to f2, r2 (must be valid target from get_legal_moves)
                this.game.board[f2][r2] = piece;
                this.game.board[f1][r1] = null;
                piece.moved = true;

                // 2. Roomba deployed on f1, r1
                this.game.roombaPos = [f1, r1];
                this.game.roombaMovesRemaining = 4;
                this.game.roombaTarget = enemyKingPos;
                this.game.message = `Rogue Roomba deployed at ${this.game._indicesToCoords(f1, r1)}! Rook retreated to ${targetCoord}.`;
            } else {
                this.game.message = "Roomba deployment failed: Enemy King not found!";
            }
        }
        
        this.clearSelection();
        this.game._nextTurn();
        if (this.gameType === 'bot' && !this.game.gameOver && this.game.currentTurn !== this.userColor) {
            this.handleAITurn();
        }
    }
    
    // Rook Command Handlers
    _initiateHack() {
        if (this.game.isPowerMode === 'R_COMMAND_SELECT' && this.selectedSquare) {
            this.game.isPowerMode = 'R_HACK_PENDING';
            this.game.message = "HACK: Select a non-King piece to grant it friendly fire capture.";
            this.validTargets = this.game.getLegalMoves(this.selectedSquare[0], this.selectedSquare[1]);
            this.drawBoard();
            this.updateStatus();
        }
    }

    _initiatePhase() {
        if (this.game.isPowerMode === 'R_COMMAND_SELECT' && this.selectedSquare) {
            this.game.isPowerMode = 'R_PHASE_PENDING';
            this.game.message = "PHASE: Select an empty square for the Rook to teleport.";
            this.validTargets = this.game.getLegalMoves(this.selectedSquare[0], this.selectedSquare[1]);
            this.drawBoard();
            this.updateStatus();
        }
    }
    
    _handleRookCommandClick(f, r) {
        if (!this.selectedSquare || !this._isValidTarget(f, r)) {
            this.game.message = "Invalid target. Selection cleared. Try activating ULTIMATE again.";
            this.clearSelection();
            return;
        }

        const [f1, r1] = this.selectedSquare;
        const currentTurn = this.game.currentTurn;
        
        // 1. Deduct use
        this.game.rPowerUses[currentTurn] -= 1;

        // 2. Execute command
        if (this.game.isPowerMode === 'R_HACK_PENDING') {
            const targetPiece = this.game.board[f][r];
            this.game.hackedPiece = [f, r];
            this.game.message = `HACK successful! ${targetPiece.color}${targetPiece.type} at ${this.game._indicesToCoords(f, r)} can now capture friendly pieces.`;
        } else if (this.game.isPowerMode === 'R_PHASE_PENDING') {
            // Teleport Rook
            const rookPieceData = this.game.board[f1][r1];
            this.game.board[f][r] = rookPieceData;
            rookPieceData.moved = true;
            this.game.message = `PHASE successful! Rook teleported to ${this.game._indicesToCoords(f, r)}.`;
        }
        
        // 3. Rook disappearance (The initiating piece, which is R at f1, r1, is gone)
        this.game.board[f1][r1] = null;

        // 4. Final cleanup and turn switch
        this.clearSelection();
        this.game._nextTurn();
        
        if (this.gameType === 'bot' && !this.game.gameOver && this.game.currentTurn !== this.userColor) {
            this.handleAITurn();
        }
    }


    // --- AI Handler (Simplified) ---
    getBotMove() {
        this.game.availableAiMoves = this.game.getLegalMoves(this.game.currentTurn); // Simplified version
        if (this.game.availableAiMoves.length === 0) return null;

        // Simple Random Move (No ELO complexity ported)
        const move = this.game.availableAiMoves[Math.floor(Math.random() * this.game.availableAiMoves.length)];
        return {
            f1: this.selectedSquare[0], r1: this.selectedSquare[1],
            f2: move.coords[0], r2: move.coords[1],
            isCapture: move.isCapture // Placeholder
        };
    }

    handleAITurn() {
        if (this.game.gameOver || this.game.currentTurn === this.userColor) return;
        
        this.ultimateButton.disabled = true; // Visually disable

        // Simulating selection (select a random piece that has moves)
        let f1, r1, piece;
        const allPieces = [];
        for (let f = 0; f < 8; f++) {
            for (let r = 0; r < 8; r++) {
                const p = this.game.board[f][r];
                if (p && p.color === this.game.currentTurn) {
                    allPieces.push([f, r, p]);
                }
            }
        }
        
        // Find a piece with legal moves
        let selected = null;
        let moves = [];
        for (const [f, r, p] of allPieces) {
            const legalMoves = this.game.getLegalMoves(f, r);
            if (legalMoves.length > 0) {
                selected = [f, r];
                moves = legalMoves;
                piece = p;
                break;
            }
        }
        
        if (!selected) {
            this.game.message = this.game.isCheck ? "CHECKMATE!" : "STALEMATE!";
            this.game.gameOver = this.game.isCheck ? 'CHECKMATE' : 'STALEMATE';
            this.drawBoard();
            this.updateStatus();
            return;
        }

        f1 = selected[0]; r1 = selected[1];
        this.selectedSquare = selected;
        this.validTargets = moves;

        // Simulate a delay for AI thinking
        setTimeout(() => {
            // Simple random move logic (for this JS port)
            const move = moves[Math.floor(Math.random() * moves.length)];
            const f2 = move.coords[0];
            const r2 = move.coords[1];

            const startCoord = this.game._indicesToCoords(f1, r1);
            const endCoord = this.game._indicesToCoords(f2, r2);
            
            // Visual feedback of selected move
            this.selectedSquare = [f1, r1];
            this.validTargets = moves.filter(m => m.coords[0] === f2 && m.coords[1] === r2);
            this.drawBoard();
            this.updateStatus();

            // Commit move after a short visual delay
            setTimeout(() => {
                this.game.executeMove(startCoord + endCoord);
                this.clearSelection();
                
                if (!this.game.gameOver && this.game.currentTurn !== this.userColor) {
                    this.handleAITurn();
                } else {
                    this.drawBoard();
                    this.updateStatus();
                }
            }, 500); // Short commit delay

        }, 1000); // AI 'thinking' delay
    }

}

// --- 3. MAIN EXECUTION ---
let app;
document.addEventListener('DOMContentLoaded', () => {
    app = new UltimateChessApp();
});
</script>
</body>
</html>

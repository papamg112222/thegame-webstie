<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ultimate Chess (Single-File Web Edition)</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&display=swap" rel="stylesheet">
    
    <style>
        /* --- Global & Theme Variables --- */
        :root {
            --dark-bg: #2E2E38;
            --panel-bg: #383B40;
            --light-square: #F0D9B5;
            --dark-square: #B58863;
            --gold-piece: #000000;
            --silver-piece: #FFFFFF;
            --accent-red: #F04747;
            --accent-green: #43b581;
            --highlight-color: #A8C356;
            --attack-color: #FF5733;
            --frozen-color: #00BFFF;
            --power-target-color: #FFA500;
            --dot-color: #383B40;

            /* Responsive Font Sizes */
            --font-size-piece-desktop: 52px;
            --font-size-dot-desktop: 36px;
            --font-size-piece-mobile: 40px;
            --font-size-dot-mobile: 28px;
            --font-size-panel: 14px;
        }

        /* --- Base Styles --- */
        * {
            box-sizing: border-box;
            font-family: 'Roboto Mono', monospace;
            transition: background-color 0.1s;
        }

        body {
            background-color: var(--dark-bg);
            color: var(--silver-piece);
            margin: 0;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 10px;
        }

        .screen {
            width: 100%;
            max-width: 1200px;
        }

        .hidden {
            display: none !important;
        }

        /* --- Menu Styles --- */
        #main-menu {
            text-align: center;
        }

        #main-menu h1 {
            font-size: 3em;
            margin-bottom: 40px;
        }

        .menu-btn {
            padding: 15px 30px;
            font-size: 1.2em;
            border: 4px solid var(--panel-bg);
            cursor: pointer;
            margin: 10px 0;
            width: 100%;
            max-width: 400px;
            display: block;
            margin-left: auto;
            margin-right: auto;
            font-weight: bold;
        }

        .dark-bg-btn {
            background-color: var(--panel-bg);
            color: var(--silver-piece);
        }
        .green-bg-btn {
            background-color: var(--accent-green);
            color: var(--silver-piece);
        }
        .menu-btn:hover:not(:disabled) {
            opacity: 0.8;
        }
        .menu-btn:disabled {
            cursor: not-allowed;
            background-color: #474751;
            color: #888888;
        }

        .bot-settings {
            margin: 30px auto;
            padding: 20px;
            border: 1px solid var(--panel-bg);
            max-width: 400px;
            text-align: left;
        }
        .bot-settings h2 {
            font-size: 1.1em;
            margin-top: 0;
            text-align: center;
        }
        .elo-controls label {
            display: block;
            margin-bottom: 5px;
        }
        #elo-slider {
            width: 100%;
        }

        /* --- Game Board Layout (Desktop) --- */
        #board-ui-frame {
            display: flex;
            gap: 20px;
            align-items: flex-start;
        }

        #board-container {
            flex-grow: 1;
            max-width: 600px;
            width: 100%;
            /* Use grid for board + labels */
            display: grid;
            grid-template-columns: auto 1fr; /* Rank labels + board/file block */
            grid-template-rows: 1fr auto; /* Board/rank block + file labels */
            aspect-ratio: 1 / 1;
        }

        #board {
            grid-column: 2;
            grid-row: 1;
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            border: 2px solid var(--dark-square);
            width: 100%;
            height: 100%;
            overflow: hidden; /* Contains the squares */
        }

        #rank-labels {
            grid-column: 1;
            grid-row: 1;
            display: flex;
            flex-direction: column;
            justify-content: space-around;
            height: 100%;
            padding-right: 5px;
        }

        #file-labels {
            grid-column: 2;
            grid-row: 2;
            display: flex;
            justify-content: space-around;
            padding-top: 5px;
        }

        .label-item {
            font-size: 10px;
            font-weight: bold;
            color: var(--silver-piece);
            text-align: center;
        }

        /* --- Board Squares --- */
        .square {
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: var(--font-size-piece-desktop);
            cursor: pointer;
            user-select: none;
            line-height: 1;
            min-width: 12.5%; /* Ensures grid behavior is correct */
        }

        .light { background-color: var(--light-square); }
        .dark { background-color: var(--dark-square); }

        /* --- Piece Coloring & Highlighting --- */
        .white-piece { color: var(--gold-piece); }
        .black-piece { color: var(--silver-piece); }

        .highlight-selected { background-color: var(--highlight-color) !important; }
        .highlight-capture { background-color: var(--attack-color) !important; }
        .highlight-power { background-color: var(--power-target-color) !important; }
        .highlight-frozen { background-color: var(--frozen-color) !important; }
        .highlight-dot { 
            font-size: var(--font-size-dot-desktop); 
            color: var(--dot-color);
        }
        .hacked-piece { color: #FFD700 !important; }
        .archbishop-piece { font-size: calc(var(--font-size-piece-desktop) - 12px); }

        /* --- Panel Styles --- */
        #panel-frame {
            width: 300px;
            background-color: var(--panel-bg);
            padding: 15px;
            border: 2px ridge;
            flex-shrink: 0;
            max-height: 600px; /* Match typical board height */
        }

        #panel-frame h1 {
            font-size: 1.5em;
            margin: 10px 0;
        }

        .status {
            font-size: 1.2em;
            font-weight: bold;
            margin: 10px 0;
        }

        #r-uses-label {
            font-size: var(--font-size-panel);
            color: #FFD700;
            margin-bottom: 10px;
        }

        .message {
            font-size: var(--font-size-panel);
            color: var(--light-square);
            min-height: 30px;
        }

        #ability-info-frame {
            background-color: #474751;
            padding: 10px;
            margin: 15px 0;
            border: 1px groove;
        }

        .section-title {
            font-weight: bold;
            color: var(--silver-piece);
            font-size: var(--font-size-panel);
            margin: 5px 0;
        }

        .ability-title {
            font-weight: bold;
            font-size: var(--font-size-panel);
            color: var(--accent-green);
            margin: 5px 0;
        }

        .ability-desc, .ability-prompt {
            font-size: calc(var(--font-size-panel) - 2px);
            color: var(--light-square);
            margin: 5px 0;
        }

        .cmd-frame button {
            width: 100%;
            padding: 8px;
            margin: 2px 0;
            background-color: #474751;
            color: var(--silver-piece);
            border: none;
            cursor: pointer;
            font-size: var(--font-size-panel);
        }

        .cmd-frame button:hover:not(:disabled) {
            background-color: #55555e;
        }

        #ultimate-button {
            width: 100%;
            padding: 15px;
            background-color: var(--accent-red);
            color: var(--silver-piece);
            font-size: 1.4em;
            font-weight: bold;
            border: none;
            cursor: pointer;
            margin-top: 20px;
        }

        #ultimate-button:disabled {
            background-color: #550000;
            cursor: not-allowed;
        }

        /* --- Game Over Overlay --- */
        .game-over-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }

        #overlay-text {
            text-align: center;
            font-size: 30px;
            font-weight: bold;
            color: var(--accent-red);
            padding: 20px;
            border-radius: 10px;
            cursor: pointer;
        }


        /* --- Mobile / Small Screen Overrides (Phone Support) --- */
        @media (max-width: 800px) {
            body {
                padding: 5px;
                align-items: flex-start;
            }

            #board-ui-frame {
                flex-direction: column; /* Stack board and panel vertically */
                align-items: center;
                width: 100%;
                max-width: 95vw;
                gap: 10px;
            }

            #board-container {
                width: 100%;
                max-width: 95vw;
                grid-template-columns: auto 1fr; 
                grid-template-rows: 1fr auto; 
            }
            
            #board-container, #panel-frame {
                /* Mobile layout ensures they fill the width */
                width: 95vw;
                max-width: 95vw;
                margin: 0;
            }
            
            #panel-frame {
                max-height: initial; 
                padding: 10px;
            }

            /* Smaller fonts for pieces on mobile */
            .square {
                font-size: var(--font-size-piece-mobile);
            }
            .highlight-dot {
                font-size: var(--font-size-dot-mobile);
            }
            
            /* Smaller label fonts on mobile */
            .label-item {
                font-size: 8px;
            }
            
            #overlay-text {
                font-size: 20px;
            }

            #ultimate-button {
                font-size: 1.1em;
                padding: 10px;
            }
            
            .archbishop-piece { font-size: calc(var(--font-size-piece-mobile) - 8px); }
        }
    </style>
</head>
<body>
    <div id="main-menu" class="screen">
        <h1 style="color: var(--accent-green);">ULTIMATE CHESS</h1>
        <button onclick="startGame('local')" class="menu-btn dark-bg-btn">2 PLAYER (LOCAL)</button>
        <div class="bot-settings">
            <h2>Play with Bot (ELOfied)</h2>
            <div class="elo-controls">
                <label for="elo">ELO: <span id="elo-value">1500</span></label>
                <input type="range" id="elo-slider" min="1" max="3000" value="1500" oninput="updateEloLabel(this.value)">
            </div>
            <button onclick="startGame('bot')" class="menu-btn green-bg-btn">START BOT GAME</button>
        </div>
        <button class="menu-btn dark-bg-btn disabled" disabled>PLAY WITH FRIEND (ONLINE) [COMING SOON]</button>
    </div>

    <div id="game-container" class="screen hidden">
        <div id="board-ui-frame">
            
            <div id="board-container">
                <div id="rank-labels" class="labels"></div>
                
                <div id="board">
                    </div>
                
                <div id="file-labels" class="labels"></div>
            </div>
            
            <div id="panel-frame">
                <h1>ULTIMATE CHESS</h1>
                <p id="status-label" class="status"></p>
                
                <div id="r-uses-label">Rook Uses: W: 2/2 | B: 2/2</div>
                
                <p id="message-label" class="message"></p>

                <div id="ability-info-frame">
                    <p class="section-title">--- ULTIMATE POWER ---</p>
                    <p id="ability-title" class="ability-title">Select a Piece</p>
                    <p id="ability-desc" class="ability-desc">General Ultimate: Places an indestructible blockade (ðŸš§). Each side can have up to TWO blockades active at once.</p>
                    <p id="ability-prompt" class="ability-prompt">Action: Make a standard move.</p>
                </div>

                <div id="cmd-frame" class="cmd-frame">
                    <button id="hack-btn" disabled onclick="handleCommand('R_HACK_PENDING')">/HACK (Friendly Fire)</button>
                    <button id="phase-btn" disabled onclick="handleCommand('R_PHASE_PENDING')">/PHASE (Teleport Rook)</button>
                </div>

                <button id="ultimate-button" disabled onclick="activateUltimateWeb()">ACTIVATE ULTIMATE</button>
            </div>
        </div>
        
        <div id="game-over-overlay" class="game-over-overlay hidden" onclick="returnToMenu()">
            <div id="overlay-text"></div>
        </div>
    </div>
    
    <script>
        // ==============================================================================
        // 1. CONSTANTS (Equivalent to Python Globals)
        // ==============================================================================
        const UNICODE_PIECES = {
            'WK': 'â™”', 'WQ': 'â™•', 'WR': 'â™–', 'WB': 'â™—', 'WN': 'â™˜', 'WP': 'â™™',
            'BK': 'â™š', 'BQ': 'â™›', 'BR': 'â™œ', 'BB': 'â™', 'BN': 'â™ž', 'BP': 'â™Ÿ',
            'BL': 'ðŸš§', 
            'FR': 'â„ï¸', 
            'RM': 'ðŸ¤–', 
            'WA': 'â™˜â™—', 'BA': 'â™žâ™'
        };
        const FILE_MAP = { 'a': 0, 'b': 1, 'c': 2, 'd': 3, 'e': 4, 'f': 5, 'g': 6, 'h': 7 };
        const RANK_MAP = { '1': 0, '2': 1, '3': 2, '4': 3, '5': 4, '6': 5, '7': 6, '8': 7 };
        const PIECE_VALUES = { 'P': 100, 'N': 300, 'B': 300, 'R': 500, 'Q': 900, 'K': 10000, 'A': 650, 'RM': 1000 };
        const ULTIMATE_POWERS = {
            'GENERAL': { 'name': "Temporal Blockade", 'mode': 'BLOCKADE', 'desc': "Places an indestructible blockade (ðŸš§). Each side can have up to TWO blockades active at once.", 'prompt': "Select an empty square for the blockade." },
            'N': { 'name': "Archbishop's Fusion", 'mode': 'KNIGHT_FUSION', 'desc': "Fuses a friendly Knight and Bishop that are on adjacent or two-square diagonal squares (e.g., a1/b2, a1/c2) into a powerful **Archbishop (A)**. The Archbishop moves as a Knight OR a Bishop.", 'prompt': "Select the friendly Bishop to fuse with." },
            'B': { 'name': "Cat's Cradle Catastrophe", 'mode': 'BISHOP_FREEZE', 'desc': "Bishop releases a Web of Distraction along its attack diagonal. All pieces on that diagonal are **frozen** for the opponent's next turn. Requires Bishop to be attacked.", 'prompt': "Select the target Bishop for the Cat's Cradle attack (if it is attacked)." },
            'R': { 'name': "Hax.exe Command Shell", 'mode': 'R_COMMAND_SELECT', 'desc': "Opens the Hax.exe command shell. Allows one of two commands: /hack or /phase. Usable twice per team.", 'prompt': "Select /HACK (Friendly Fire) or /PHASE (Teleport) below." },
            'K': { 'name': "Domain Expansion: Murasaki", 'mode': 'MURASAKI', 'desc': "Activates on a **self-sacrifice**: King captures a friendly Pawn. The resulting 'Murasaki' beam instantly removes a **random** enemy piece (not the King).", 'prompt': "Select a friendly Pawn for the King to capture to initiate Murasaki." }
        };
        const DOT_SYMBOL = 'â—';

        // ==============================================================================
        // 2. CORE GAME LOGIC CLASS (UltimateChessGameWeb)
        //    *** THIS ENTIRE SECTION MUST BE REWRITTEN IN JAVASCRIPT ***
        // ==============================================================================
        class UltimateChessGameWeb {
            // THE CONSTRUCTOR AND ALL METHODS BELOW ARE PYTHON LOGIC COPIED AS COMMENTS.
            // THEY ARE CURRENTLY NON-FUNCTIONAL AND MUST BE REWRITTEN IN JAVASCRIPT.
            
            constructor() {
                // def __init__(self):
                this.board = this._initialize_board();
                this.current_turn = 'W';
                this.active_blockades = { 'W': [], 'B': [] };
                this.message = "Game started! White moves first. ULTIMATE is available per piece.";
                this.is_check = false;
                this.is_power_mode = null;
                this.selected_square_coords = null;
                this.current_ultimate_power_info = ULTIMATE_POWERS['GENERAL'];
                this.en_passant_target = null;
                this.game_over = null;
                this.frozen_pieces = {}; // { "f,r": turns_remaining }
                this.roomba_pos = null;
                this.roomba_target = null;
                this.roomba_moves_remaining = 0;
                this.r_power_uses = { 'W': 2, 'B': 2 };
                this.hacked_piece = null; // [f, r] of the hacked piece
                
                // Placeholder for internal state (AI uses this)
                this.available_ai_moves = []; 
            }

            _initialize_board() {
                // PYTHON LOGIC: def _initialize_board(self): ...
                const board = Array(8).fill(null).map(() => Array(8).fill(null));

                const backRank = ['R', 'N', 'B', 'Q', 'K', 'B', 'N', 'R'];
                for (let f = 0; f < 8; f++) {
                    board[f][0] = { type: backRank[f], color: 'W', moved: false };
                    board[f][1] = { type: 'P', color: 'W', moved: false };
                    board[f][7] = { type: backRank[f], color: 'B', moved: false };
                    board[f][6] = { type: 'P', color: 'B', moved: false };
                }
                return board;
            }

            _coords_to_indices(coord) {
                // PYTHON LOGIC: def _coords_to_indices(self, coord): ...
                if (coord.length !== 2 || !(coord[0] in FILE_MAP) || !(coord[1] in RANK_MAP)) {
                    throw new Error(`Invalid coordinate: ${coord}`);
                }
                const f = FILE_MAP[coord[0]];
                const r = RANK_MAP[coord[1]];
                return [f, r];
            }

            _indices_to_coords(f, r) {
                // PYTHON LOGIC: def _indices_to_coords(self, f, r): ...
                const fileChar = Object.keys(FILE_MAP).find(key => FILE_MAP[key] === f);
                const rankChar = Object.keys(RANK_MAP).find(key => RANK_MAP[key] === r);
                return fileChar + rankChar;
            }
            
            _get_piece_power(piece_type) {
                // PYTHON LOGIC: def _get_piece_power(self, piece_type): ...
                return ULTIMATE_POWERS[piece_type] || ULTIMATE_POWERS['GENERAL'];
            }
            
            // --- GAME RULES AND AI (JS IMPLEMENTATION REQUIRED FOR ALL BELOW) ---
            
            _is_square_blocked(f, r) { 
                // PYTHON LOGIC: def _is_square_blocked(self, f, r): ...
                // Needs to check active_blockades for both 'W' and 'B'.
                const pos = `${f},${r}`;
                return this.active_blockades['W'].includes(pos) || this.active_blockades['B'].includes(pos);
            }

            _is_square_frozen(f, r) { 
                // PYTHON LOGIC: def _is_square_frozen(self, f, r): ...
                const pos = `${f},${r}`;
                return this.frozen_pieces[pos] && this.frozen_pieces[pos] > 0;
            }

            _is_king_in_check(color) { 
                // PYTHON LOGIC: def _is_king_in_check(self, color): ...
                // Requires _get_king_pos and _is_square_attacked
                return false; 
            }
            
            get_bot_move(elo) {
                // PYTHON LOGIC: def get_bot_move(self, elo): ...
                // This function implements the basic minimax/ELO AI logic.
                // JS IMPLEMENTATION REQUIRED
                return null; 
            }

            get_all_legal_moves_for_color(color) { 
                // PYTHON LOGIC: def get_all_legal_moves_for_color(self, color): ...
                // JS IMPLEMENTATION REQUIRED
                return []; 
            }
            
            get_legal_moves(f1, r1) { 
                // PYTHON LOGIC: def get_legal_moves(self, f1, r1): ...
                // This is the largest and most complex function, combining standard chess moves
                // (pawn push/capture, rook/bishop/queen line checks, knight jumps) with
                // all power mode targets (Fusion, Rook retreat, Rook Hack/Phase, Murasaki).
                // JS IMPLEMENTATION REQUIRED
                return []; 
            }
            
            _validate_move(f1, r1, f2, r2) {
                // PYTHON LOGIC: def _validate_move(self, f1, r1, f2, r2): ...
                // Checks standard rules (piece move pattern, path clear) AND checks if the move
                // leaves the King in check (requires move simulation).
                // JS IMPLEMENTATION REQUIRED
                return true; 
            }
            
            activate_ultimate(f, r) { 
                // PYTHON LOGIC: def activate_ultimate(self, f, r): ...
                // Initializes self.is_power_mode and sets up messages/checks prerequisites (e.g., Bishop attack check).
                // JS IMPLEMENTATION REQUIRED
                const piece = this.board[f][r];
                if (piece) {
                    this.selected_square_coords = [f, r];
                    this.is_power_mode = this._get_piece_power(piece.type).mode;
                    this.message = `Ultimate mode activated for ${piece.type}.`;
                    return true;
                }
                return false; 
            }

            place_blockade(coord) { 
                // PYTHON LOGIC: def place_blockade(self, coord): ...
                // Executes GENERAL power logic.
                // JS IMPLEMENTATION REQUIRED
                this._next_turn();
                return true;
            }
            
            perform_fusion(bf, br) { 
                // PYTHON LOGIC: def perform_fusion(self, bf, br): ...
                // Executes KNIGHT_FUSION logic.
                // JS IMPLEMENTATION REQUIRED
                this._next_turn();
                return true;
            }

            // def _execute_k_ultimate_logic(self): ...
            _execute_k_ultimate_logic() { 
                // PYTHON LOGIC: Removes random enemy piece.
                // JS IMPLEMENTATION REQUIRED
                this._next_turn();
                return true;
            }
            
            // def _handle_hack_command(self, f, r): 
            _handle_hack_command(f, r) {
                // PYTHON LOGIC: Sets self.hacked_piece = [f, r], costs R power use, switches turn.
                // JS IMPLEMENTATION REQUIRED
                this.hacked_piece = [f, r];
                this._next_turn();
            }

            // def _handle_phase_command(self, f, r): 
            _handle_phase_command(f, r) {
                // PYTHON LOGIC: Moves the selected Rook to [f, r], costs R power use, switches turn.
                // JS IMPLEMENTATION REQUIRED
                const [f1, r1] = this.selected_square_coords;
                this.board[f][r] = this.board[f1][r1];
                this.board[f1][r1] = null;
                this._next_turn();
            }

            _move_roomba() { 
                // PYTHON LOGIC: def _move_roomba(self): ...
                // Calculates shortest path, moves Roomba, checks collision/King capture, decrements moves.
                // JS IMPLEMENTATION REQUIRED
            }
            
            _next_turn() { 
                // PYTHON LOGIC: def _next_turn(self): ...
                // Decrements frozen_pieces, calls _move_roomba(), switches current_turn, checks for mate/stalemate.
                // JS IMPLEMENTATION REQUIRED
                
                // Placeholder for core functionality
                this.current_turn = (this.current_turn === 'W' ? 'B' : 'W'); 
                this.is_power_mode = null;
                this.selected_square_coords = null;
                this.message = `${this.current_turn === 'W' ? 'White' : 'Black'}'s move.`;
            }
            
            execute_move(move_str) { 
                // PYTHON LOGIC: def execute_move(self, move_str): ...
                // The main handler for all non-power move execution (standard move, castling, promotion, Murasaki).
                // JS IMPLEMENTATION REQUIRED
                
                // Placeholder for successful move
                const [f1, r1] = this._coords_to_indices(move_str.slice(0, 2));
                const [f2, r2] = this._coords_to_indices(move_str.slice(2, 4));
                
                // Basic move simulation
                this.board[f2][r2] = this.board[f1][r1];
                this.board[f1][r1] = null;
                
                this._next_turn();
            }
        }
        
        // ==============================================================================
        // 3. GUI AND EVENT HANDLERS
        // ==============================================================================
        
        let game = null;
        let selectedSquare = null;
        let validTargets = [];
        let userColor = 'W';

        const dom = {
            menu: document.getElementById('main-menu'),
            gameContainer: document.getElementById('game-container'),
            board: document.getElementById('board'),
            status: document.getElementById('status-label'),
            message: document.getElementById('message-label'),
            ultimateBtn: document.getElementById('ultimate-button'),
            eloValue: document.getElementById('elo-value'),
            hackBtn: document.getElementById('hack-btn'),
            phaseBtn: document.getElementById('phase-btn'),
            abilityTitle: document.getElementById('ability-title'),
            abilityDesc: document.getElementById('ability-desc'),
            abilityPrompt: document.getElementById('ability-prompt'),
            rUsesLabel: document.getElementById('r-uses-label'),
            overlay: document.getElementById('game-over-overlay'),
            overlayText: document.getElementById('overlay-text'),
            rankLabels: document.getElementById('rank-labels'),
            fileLabels: document.getElementById('file-labels')
        };
        
        // --- Initialization and Screen Management ---

        function setupBoardElements(color) {
            const boardEl = dom.board;
            const rankLabelsEl = dom.rankLabels;
            const fileLabelsEl = dom.fileLabels;

            boardEl.innerHTML = '';
            rankLabelsEl.innerHTML = '';
            fileLabelsEl.innerHTML = '';

            const fileChars = 'abcdefgh';
            const rankChars = '87654321';
            
            const displayRanks = color === 'W' ? rankChars : '12345678';
            const displayFiles = color === 'W' ? fileChars : 'hgfedcba';
            
            // 1. Create Squares
            for (let r = 0; r < 8; r++) {
                for (let f = 0; f < 8; f++) {
                    const coord = fileChars[f] + rankChars[r];
                    const isDark = (f + r) % 2 !== 0; 
                    const squareEl = document.createElement('div');
                    
                    squareEl.className = `square ${isDark ? 'dark' : 'light'}`;
                    squareEl.dataset.coord = coord;
                    squareEl.dataset.f = f;
                    squareEl.dataset.r = 7 - r; // Map visual row (0-7) to logic rank (7-0)
                    squareEl.addEventListener('click', () => handleSquareClick(f, 7 - r, coord));
                    boardEl.appendChild(squareEl);
                }
            }

            // 2. Create Rank Labels
            for (let i = 0; i < 8; i++) {
                const label = document.createElement('div');
                label.className = 'label-item';
                label.textContent = displayRanks[i];
                rankLabelsEl.appendChild(label);
            }
            
            // 3. Create File Labels
            for (let i = 0; i < 8; i++) {
                const label = document.createElement('div');
                label.className = 'label-item';
                label.textContent = displayFiles[i];
                fileLabelsEl.appendChild(label);
            }
        }
        
        function startGame(type) {
            game = new UltimateChessGameWeb();
            game.game_type = type;
            userColor = type === 'local' ? 'W' : (Math.random() < 0.5 ? 'W' : 'B');
            
            dom.menu.classList.add('hidden');
            dom.gameContainer.classList.remove('hidden');

            setupBoardElements(userColor); // Re-initialize based on player color
            drawBoard();
            updateStatus();
            
            // Start AI turn if necessary
            if (type === 'bot' && game.current_turn !== userColor) {
                // handleAITurn(); // Needs JS implementation
            }
        }
        
        function returnToMenu() {
            dom.gameContainer.classList.add('hidden');
            dom.overlay.classList.add('hidden');
            dom.menu.classList.remove('hidden');
            selectedSquare = null;
            validTargets = [];
        }

        function updateEloLabel(value) {
            dom.eloValue.textContent = value;
        }

        // --- Drawing and Status Updates ---

        function drawBoard() {
            const isSmallScreen = window.innerWidth < 800;
            const pieceSize = isSmallScreen ? 'var(--font-size-piece-mobile)' : 'var(--font-size-piece-desktop)';
            const dotSize = isSmallScreen ? 'var(--font-size-dot-mobile)' : 'var(--font-size-dot-desktop)';
            
            document.querySelectorAll('.square').forEach(squareEl => {
                const f = parseInt(squareEl.dataset.f);
                const r = parseInt(squareEl.dataset.r);
                const piece = game.board[f][r];
                
                // Reset classes and content
                squareEl.textContent = '';
                squareEl.className = squareEl.className.replace(/ (selected|highlight-.*|dot|hacked-piece|archbishop-piece)/g, '');

                const isDark = (f + r) % 2 !== 0;
                squareEl.classList.add(isDark ? 'dark' : 'light');
                
                let symbol = '';
                let fgClass = '';
                let currentPieceType = null;
                
                // 1. Piece or Roomba or Blockade
                if (piece) {
                    const pieceKey = piece.color + piece.type;
                    symbol = UNICODE_PIECES[pieceKey];
                    fgClass = piece.color === 'W' ? 'white-piece' : 'black-piece';
                    currentPieceType = piece.type;
                } else if (game.roomba_pos && game.roomba_pos[0] === f && game.roomba_pos[1] === r) {
                    symbol = UNICODE_PIECES['RM'];
                    fgClass = 'hacked-piece'; // Use gold for visibility
                } else if (game._is_square_blocked(f, r)) {
                    symbol = UNICODE_PIECES['BL'];
                    fgClass = 'highlight-capture'; // Use red for blockade
                }

                // 2. Frozen Overlay
                if (game._is_square_frozen(f, r)) {
                    squareEl.classList.add('highlight-frozen');
                    symbol += (symbol.trim() ? ' ' : '') + UNICODE_PIECES['FR'];
                }

                // 3. Highlighting (Selection/Targets)
                const targetInfo = validTargets.find(t => t.coords[0] === f && t.coords[1] === r);

                if (selectedSquare && selectedSquare[0] === f && selectedSquare[1] === r) {
                    squareEl.classList.add('highlight-selected');
                } else if (targetInfo) {
                    if (piece || (game.roomba_pos && game.roomba_pos[0] === f && game.roomba_pos[1] === r) || targetInfo.is_capture) {
                        squareEl.classList.add('highlight-capture');
                    } else if (targetInfo.is_power_target) {
                        squareEl.classList.add('highlight-power');
                    } else {
                        // Empty square move target (dot)
                        symbol = DOT_SYMBOL;
                        squareEl.classList.add('highlight-dot');
                    }
                }
                
                // 4. Hacked Status (applied to the piece itself)
                if (game.hacked_piece && game.hacked_piece[0] === f && game.hacked_piece[1] === r) {
                    fgClass = 'hacked-piece';
                }

                // 5. Apply content and final styling
                squareEl.textContent = symbol;
                if (symbol && symbol !== DOT_SYMBOL) {
                    squareEl.classList.add(fgClass);
                    if (currentPieceType === 'A') {
                        squareEl.classList.add('archbishop-piece');
                    }
                }
                squareEl.style.fontSize = squareEl.classList.contains('highlight-dot') ? dotSize : pieceSize;
            });
            
            updateStatus();
            if (game.game_over) showGameOver();
        }

        function updateStatus() {
            const turnText = game.current_turn === 'W' ? "WHITE" : "BLACK";
            const isUserTurn = game.game_type === 'local' || game.current_turn === userColor;
            const playerRole = game.game_type === 'bot' ? (isUserTurn ? " (YOU turn)" : " (AI turn)") : "";
            
            dom.status.textContent = `Current Turn: ${turnText}${playerRole}`;
            dom.status.style.color = game.current_turn === 'W' ? 'var(--gold-piece)' : 'var(--silver-piece)';
            
            dom.message.textContent = game.message;
            dom.message.style.color = game.is_check || game.game_over ? 'var(--accent-red)' : 'var(--light-square)';
            
            // Rook Uses and Hacked piece
            let rUsesText = `Rook Uses: W: ${game.r_power_uses['W']}/2 | B: ${game.r_power_uses['B']}/2`;
            if (game.hacked_piece) {
                const [f, r] = game.hacked_piece;
                const hPiece = game.board[f][r];
                rUsesText += ` | HACKED: ${hPiece.color}${hPiece.type} at ${game._indices_to_coords(f, r)}`;
            }
            dom.rUsesLabel.textContent = rUsesText;


            // Ultimate Button & Panel
            const isPieceSelected = selectedSquare !== null;
            const piece = isPieceSelected ? game.board[selectedSquare[0]][selectedSquare[1]] : null;
            
            if (game.is_power_mode) {
                dom.ultimateBtn.textContent = "CANCEL POWER";
                dom.ultimateBtn.disabled = false;
            } else {
                dom.ultimateBtn.textContent = "ACTIVATE ULTIMATE";
                dom.ultimateBtn.disabled = !isPieceSelected || !isUserTurn;
            }

            updateAbilityPanel(piece);
        }

        function updateAbilityPanel(piece) {
            const info = piece ? game._get_piece_power(piece.type) : ULTIMATE_POWERS['GENERAL'];
            
            if (game.is_power_mode) {
                dom.abilityTitle.textContent = `POWER MODE: ${info.name}`;
                dom.abilityTitle.style.color = 'var(--accent-red)';
                dom.hackBtn.disabled = game.is_power_mode !== 'R_COMMAND_SELECT';
                dom.phaseBtn.disabled = game.is_power_mode !== 'R_COMMAND_SELECT';
            } else if (piece) {
                dom.abilityTitle.textContent = `${piece.type} ULTIMATE: ${info.name}`;
                dom.abilityTitle.style.color = 'var(--accent-green)';
                dom.hackBtn.disabled = true;
                dom.phaseBtn.disabled = true;
            } else {
                dom.abilityTitle.textContent = "Select a Piece";
                dom.abilityTitle.style.color = 'var(--silver-piece)';
                dom.hackBtn.disabled = true;
                dom.phaseBtn.disabled = true;
            }
            
            dom.abilityDesc.textContent = info.desc;
            dom.abilityPrompt.textContent = game.is_power_mode ? game.message : (info.prompt || "Action: Make a standard move.");
        }
        
        function showGameOver() {
            dom.overlay.classList.remove('hidden');
            let message = '';
            let color = 'var(--accent-red)';
            
            if (game.game_over === 'CHECKMATE') {
                const winner = game.current_turn === 'B' ? 'White' : 'Black';
                message = `CHECKMATE!\n${winner} WINS!\n\n(Click to return to Menu)`;
            } else {
                message = "STALEMATE\nDraw!\n\n(Click to return to Menu)";
                color = 'var(--light-square)';
            }
            
            dom.overlayText.textContent = message;
            dom.overlayText.style.color = color;
        }


        // --- Click Handlers ---

        function clearSelection() {
            selectedSquare = null;
            game.selected_square_coords = null;
            game.is_power_mode = null;
            validTargets = [];
            game.phase_move_pending = false;
            drawBoard();
        }

        function handleSquareClick(f, r, coord) {
            if (game.game_over || (game.game_type === 'bot' && game.current_turn !== userColor)) return;
            
            const piece = game.board[f][r];
            
            // 1. Handle Power Mode Clicks
            if (game.is_power_mode) {
                const f1 = game.selected_square_coords[0];
                const r1 = game.selected_square_coords[1];
                const targetCoord = game._indices_to_coords(f, r);
                
                if (game.is_power_mode === 'BLOCKADE') {
                    game.place_blockade(targetCoord);
                    clearSelection();
                } else if (game.is_power_mode === 'KNIGHT_FUSION') {
                    if (validTargets.some(t => t.coords[0] === f && t.coords[1] === r)) {
                        game.perform_fusion(f, r);
                        clearSelection();
                    } else {
                        game.message = "Invalid fusion target. Select a friendly Bishop within range.";
                    }
                } else if (['R_HACK_PENDING', 'R_PHASE_PENDING'].includes(game.is_power_mode)) {
                    if (validTargets.some(t => t.coords[0] === f && t.coords[1] === r)) {
                        if (game.is_power_mode === 'R_HACK_PENDING') {
                            game._handle_hack_command(f, r); 
                        } else {
                            game._handle_phase_command(f, r);
                        }
                        game.r_power_uses[game.current_turn === 'W' ? 'B' : 'W']--; // Deduct use from the initiating side (who is about to move next)
                        clearSelection();
                    } else {
                        game.message = "Invalid target for Hax.exe command.";
                    }
                } else {
                    // This handles Murasaki and Bishop Freeze move completion
                    const startCoord = game._indices_to_coords(f1, r1);
                    game.execute_move(startCoord + targetCoord); 
                    clearSelection();
                }
                
                drawBoard();
                updateStatus();
                return;
            }
            
            // 2. Handle Standard Selection/Move
            if (selectedSquare) {
                const [f1, r1] = selectedSquare;
                const startCoord = game._indices_to_coords(f1, r1);
                const endCoord = game._indices_to_coords(f, r);
                
                if (f === f1 && r === r1) {
                    game.message = "Deselected.";
                    clearSelection();
                } else if (validTargets.some(t => t.coords[0] === f && t.coords[1] === r)) {
                    // Valid Move or Power Move (Rook retreat/Bishop freeze)
                    game.execute_move(startCoord + endCoord);
                    clearSelection();
                    // if (game.game_type === 'bot' && game.current_turn !== userColor) handleAITurn();
                } else if (piece && piece.color === game.current_turn) {
                    // Select new friendly piece
                    selectedSquare = [f, r];
                    game.message = `Selected new piece at ${endCoord}.`;
                    validTargets = game.get_legal_moves(f, r);
                } else {
                    game.message = "Invalid move destination.";
                }

            } else {
                // Initial selection
                if (piece && piece.color === game.current_turn) {
                    selectedSquare = [f, r];
                    game.message = `Selected ${piece.color}${piece.type} at ${coord}.`;
                    validTargets = game.get_legal_moves(f, r);
                } else {
                    game.message = "Invalid selection. Please select one of your pieces.";
                }
            }

            drawBoard();
            updateStatus();
        }

        function activateUltimateWeb() {
            if (game.is_power_mode) {
                game.is_power_mode = null;
                game.message = "Ultimate power sequence cancelled.";
                clearSelection();
                return;
            }
            
            if (!selectedSquare) {
                game.message = "Please select a piece first before activating ULTIMATE.";
                updateStatus();
                return;
            }
            
            const [f, r] = selectedSquare;
            const isActivated = game.activate_ultimate(f, r);
            
            if (isActivated && game.is_power_mode) {
                // Re-calculate targets for the power mode if a new target selection is needed
                validTargets = game.get_legal_moves(f, r);
            } else if (isActivated) {
                // Power was executed immediately (e.g. if the next move in Python was handled internally)
                clearSelection();
            }
            
            drawBoard();
            updateStatus();
        }
        
        function handleCommand(mode) {
            // Handles /HACK or /PHASE button click
            if (game.is_power_mode === 'R_COMMAND_SELECT') {
                game.is_power_mode = mode;
                game.message = mode === 'R_HACK_PENDING' ? 
                    "HACK: Select a non-King piece to grant it friendly fire capture." :
                    "PHASE: Select an empty square for the Rook to teleport.";
                
                // Re-calculate targets specific to the command
                const [f, r] = game.selected_square_coords;
                validTargets = game.get_legal_moves(f, r);
                
                drawBoard();
                updateStatus();
            }
        }

        // --- Initial Call ---
        window.onload = () => {
             // Initial ELO setup for the label
             dom.eloValue.textContent = document.getElementById('elo-slider').value;
        };
    </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Multiplayer Tag 3D - Lobby Edition</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #1a1a1a; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; user-select: none; }
        #game-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
        
        /* UI Layer */
        #ui-layer { pointer-events: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; flex-direction: column; justify-content: space-between; padding: 24px; z-index: 10; }
        
        /* Crosshair */
        #crosshair {
            position: absolute; top: 50%; left: 50%; width: 6px; height: 6px;
            background: rgba(255, 255, 255, 0.9); border-radius: 50%;
            transform: translate(-50%, -50%); border: 1.5px solid rgba(0,0,0,0.5);
            box-shadow: 0 0 4px white;
        }

        /* Modal */
        .modal { pointer-events: auto; background: rgba(10, 15, 30, 0.98); backdrop-filter: blur(8px); position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; z-index: 100; }
        .hidden { display: none !important; }
        
        /* Lobby Overlay */
        #lobby-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); display: flex; flex-direction: column;
            align-items: center; justify-content: center; z-index: 50;
            pointer-events: none;
        }
        
        /* Status Text */
        .tag-status {
            font-size: 2.5rem; font-weight: 900; letter-spacing: -1px;
            text-shadow: 0 4px 12px rgba(0,0,0,0.3);
            text-transform: uppercase;
            text-align: center; width: 100%;
            transition: all 0.3s ease;
        }
        .is-it { color: #ff3333; text-shadow: 0 0 20px rgba(255, 0, 0, 0.5); }
        .not-it { color: #00e5ff; text-shadow: 0 0 20px rgba(0, 229, 255, 0.5); }
        
        /* Online Count */
        #online-count {
            position: absolute; top: 24px; right: 24px;
            background: rgba(0, 0, 0, 0.7); color: white;
            padding: 8px 16px; border-radius: 8px; border: 1px solid rgba(255,255,255,0.1);
            font-weight: 700; font-size: 1rem;
            display: flex; align-items: center; gap: 8px;
            backdrop-filter: blur(4px);
        }
        .online-dot { width: 8px; height: 8px; background-color: #00ff88; border-radius: 50%; display: inline-block; box-shadow: 0 0 8px #00ff88; }

        /* Speech Bubble Labels */
        .label-container { 
            position: absolute; top: 0; left: 0; 
            background: rgba(255, 255, 255, 0.95); color: #111;
            font-weight: 800; font-family: 'Segoe UI', sans-serif;
            padding: 4px 12px; border-radius: 6px;
            pointer-events: none; 
            transform: translate(-50%, -100%); 
            white-space: nowrap; font-size: 13px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
            transition: opacity 0.2s;
        }
        .label-container::after {
            content: ''; position: absolute; bottom: -5px; left: 50%; transform: translateX(-50%);
            border-width: 5px 5px 0; border-style: solid; border-color: rgba(255,255,255,0.95) transparent transparent transparent;
        }
        
        /* Loader */
        .loader { border: 3px solid rgba(255,255,255,0.1); border-top: 3px solid #00e5ff; border-radius: 50%; width: 24px; height: 24px; animation: spin 0.8s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        
        .btn-primary { @apply w-full bg-blue-600 hover:bg-blue-500 text-white font-bold py-4 rounded-lg transition-all shadow-lg hover:shadow-blue-500/20 transform active:scale-[0.98]; }
        .btn-secondary { @apply w-full bg-gray-700 hover:bg-gray-600 text-white font-bold py-4 rounded-lg transition-all shadow-lg transform active:scale-[0.98]; }
    </style>
</head>
<body>

    <div id="game-container"></div>

    <!-- Main Game UI -->
    <div id="ui-layer" class="hidden">
        <div id="online-count"><span class="online-dot"></span> <span id="count-val">0</span> PLAYERS</div>
        <div id="status-text" class="tag-status">WAITING...</div>
        <div class="text-white/50 text-sm font-bold bg-black/50 p-2 rounded">
            WASD: Move | SPACE: Jump | SHIFT: Sprint
        </div>
    </div>

    <!-- Lobby Overlay (Inside Game) -->
    <div id="lobby-overlay" class="hidden">
        <h1 class="text-6xl font-black text-white italic mb-4">LOBBY</h1>
        <div class="bg-black/50 p-6 rounded-xl border border-white/20 text-center min-w-[300px]">
            <p id="lobby-status" class="text-2xl font-bold text-blue-400 mb-2">WAITING FOR HOST</p>
            <p id="lobby-timer" class="text-6xl font-mono text-white font-bold mb-4">30</p>
            <p class="text-gray-400 text-sm">Players Connected: <span id="lobby-count">1</span></p>
        </div>
        <!-- Host Controls -->
        <div id="host-controls" class="mt-8 hidden pointer-events-auto">
            <button id="btn-start-countdown" class="bg-green-600 hover:bg-green-500 text-white font-bold py-3 px-8 rounded-full text-xl shadow-lg transition transform hover:scale-105">
                START COUNTDOWN
            </button>
        </div>
    </div>

    <div id="crosshair"></div>

    <!-- Initial Setup Modal -->
    <div id="start-modal" class="modal">
        <div class="bg-gray-900/90 p-10 rounded-2xl border border-gray-700/50 shadow-2xl flex flex-col items-center gap-6 w-full max-w-md relative overflow-hidden">
            <div class="absolute top-0 left-0 w-full h-1 bg-gradient-to-r from-blue-500 via-purple-500 to-pink-500"></div>
            
            <h1 class="text-5xl font-black text-white tracking-tighter italic">TAG <span class="text-transparent bg-clip-text bg-gradient-to-r from-blue-400 to-purple-500">P2P</span></h1>
            
            <!-- Step 1: Login -->
            <div id="step-name" class="w-full flex flex-col gap-4">
                <p class="text-gray-400 text-center font-medium">Enter your codename.</p>
                <input type="text" id="username-input" placeholder="Codename" class="w-full bg-black/40 text-white border border-gray-600 focus:border-blue-500 rounded-lg p-4 text-center font-bold text-lg outline-none transition-colors" maxlength="12">
                <button id="btn-next" class="btn-primary">CONTINUE</button>
            </div>

            <!-- Step 2: Choose Mode -->
            <div id="step-mode" class="hidden w-full flex flex-col gap-4">
                <button id="btn-host-mode" class="btn-primary bg-purple-600 hover:bg-purple-500">HOST GAME</button>
                <div class="flex items-center gap-2 text-gray-500"><div class="h-px bg-gray-700 flex-1"></div>OR<div class="h-px bg-gray-700 flex-1"></div></div>
                <button id="btn-join-mode" class="btn-secondary">JOIN GAME</button>
            </div>

            <!-- Step 3: Host Waiting -->
            <div id="step-host" class="hidden w-full flex flex-col gap-4 items-center">
                <p class="text-gray-400">Your Room ID:</p>
                <div class="flex gap-2 w-full">
                    <input id="host-id-display" readonly class="w-full bg-black/50 text-green-400 font-mono text-xl p-3 rounded border border-green-900/50 text-center select-all" value="...">
                    <button id="btn-copy" class="bg-gray-700 hover:bg-gray-600 text-white px-4 rounded font-bold">COPY</button>
                </div>
                <div class="text-sm text-gray-500 animate-pulse mt-2">Share this ID with friends</div>
                <button id="btn-host-start" class="btn-primary mt-4">OPEN LOBBY</button>
            </div>

            <!-- Step 3: Join Input -->
            <div id="step-join" class="hidden w-full flex flex-col gap-4">
                <p class="text-gray-400 text-center">Enter Host ID:</p>
                <input type="text" id="join-id-input" placeholder="e.g. funny-tiger-99" class="w-full bg-black/40 text-white border border-gray-600 focus:border-purple-500 rounded-lg p-4 text-center font-bold text-lg outline-none transition-colors">
                <button id="btn-connect" class="btn-primary">CONNECT</button>
                <button id="btn-back" class="text-gray-500 hover:text-white text-sm">Back</button>
            </div>

            <!-- Loading -->
            <div id="loading-indicator" class="hidden flex flex-col items-center gap-3">
                <div class="loader"></div>
                <p id="loading-text" class="text-blue-300 font-mono text-sm animate-pulse">CONNECTING...</p>
            </div>
            
            <!-- Paused -->
            <div id="paused-step" class="hidden w-full flex flex-col gap-4">
                <p class="text-white/20 text-center font-black text-4xl tracking-widest">PAUSED</p>
                <button id="resume-btn" class="w-full bg-white text-black hover:bg-gray-200 font-bold py-4 rounded-lg text-xl transition-transform active:scale-[0.98]">RESUME</button>
            </div>

            <p id="error-msg" class="text-red-400 text-sm hidden text-center font-mono bg-red-900/20 p-2 rounded w-full"></p>
        </div>
    </div>

    <div id="labels"></div>

    <!-- Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/PointerLockControls.js" crossorigin="anonymous"></script>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>

    <script>
        // --- Globals ---
        let myId = null, myUsername = "Guest", isGameReady = false;
        let scene, camera, renderer, controls;
        const worldObjects = [];
        let peer = null;
        let connections = []; 
        let hostConnection = null; 
        let isHost = false;
        
        // Physics Constants
        const PLAYER_HEIGHT = 1.6;
        const MOVE_SPEED = 12;
        const SPRINT_SPEED = 18;
        const JUMP_FORCE = 15;
        const GRAVITY = 35;
        const TAG_DISTANCE = 2.5;

        // --- Procedural Textures ---
        function createGridTexture(size = 512, color1 = '#ffffff', color2 = '#f0f0f0', border = '#e0e0e0') {
            const canvas = document.createElement('canvas');
            canvas.width = size; canvas.height = size;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = color1; ctx.fillRect(0, 0, size, size);
            ctx.fillStyle = color2; const s = size / 2; ctx.fillRect(0, 0, s, s); ctx.fillRect(s, s, s, s);
            ctx.strokeStyle = border; ctx.lineWidth = 4;
            ctx.strokeRect(0, 0, size, size);
            const tex = new THREE.CanvasTexture(canvas);
            tex.wrapS = THREE.RepeatWrapping; tex.wrapT = THREE.RepeatWrapping;
            return tex;
        }
        const floorTex = createGridTexture(512, '#1a1a1a', '#222222', '#333');
        const wallTex = createGridTexture(512, '#eeeeee', '#ffffff', '#cccccc');
        const orangeTex = createGridTexture(256, '#ff6600', '#ff5500', '#cc4400');
        const matFloor = new THREE.MeshStandardMaterial({ map: floorTex, roughness: 0.8, metalness: 0.2 });
        const matWall = new THREE.MeshStandardMaterial({ map: wallTex, roughness: 0.1, metalness: 0.0 });
        const matOrange = new THREE.MeshStandardMaterial({ map: orangeTex, roughness: 0.4, metalness: 0.1, emissive: 0xff4400, emissiveIntensity: 0.2 });

        // --- World Builder ---
        function buildWorld() {
            function addBox(x, y, z, w, h, d, mat, ry = 0) {
                const geo = new THREE.BoxGeometry(w, h, d);
                if (mat.map) { 
                    const m = mat.clone(); m.map = mat.map.clone(); 
                    m.map.repeat.set(Math.max(1, w/2), Math.max(1, h/2)); m.map.needsUpdate = true;
                    mat = m;
                }
                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.set(x, y + h/2, z); mesh.rotation.y = ry;
                mesh.castShadow = true; mesh.receiveShadow = true;
                scene.add(mesh);
                mesh.userData.box = new THREE.Box3().setFromObject(mesh);
                worldObjects.push(mesh);
            }
            // Floor - CRITICAL FIX: Add to worldObjects for collision detection!
            const floorGeo = new THREE.PlaneGeometry(200, 200);
            floorTex.repeat.set(50, 50);
            const floor = new THREE.Mesh(floorGeo, matFloor);
            floor.rotation.x = -Math.PI / 2; floor.receiveShadow = true;
            scene.add(floor);
            // Create a collision box for the floor
            const floorBox = new THREE.Mesh(new THREE.BoxGeometry(200, 0.1, 200), new THREE.MeshBasicMaterial({visible: false}));
            floorBox.position.y = -0.05; 
            scene.add(floorBox);
            floorBox.userData.box = new THREE.Box3().setFromObject(floorBox);
            worldObjects.push(floorBox);

            // Walls
            addBox(0, 0, -50, 100, 10, 2, matWall); addBox(0, 0, 50, 100, 10, 2, matWall);
            addBox(-50, 0, 0, 2, 10, 100, matWall); addBox(50, 0, 0, 2, 10, 100, matWall);
            // Features
            addBox(0, 0, 0, 10, 3, 10, matWall); addBox(0, 3, 0, 6, 2, 6, matWall);
            addBox(20, 0, 0, 4, 1, 4, matOrange); addBox(24, 0, 4, 4, 2, 4, matOrange);
            addBox(20, 0, 8, 4, 3, 4, matOrange); addBox(16, 0, 4, 4, 4, 4, matWall);
            addBox(-15, 2.5, 20, 5, 0.5, 5, matOrange); addBox(-5, 3.5, 20, 5, 0.5, 5, matOrange);
            addBox(-25, 0, -5, 10, 4, 2, matWall);
        }

        // --- Three.js Setup ---
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x88ccff); scene.fog = new THREE.Fog(0x88ccff, 20, 90);
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true; renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.getElementById('game-container').appendChild(renderer.domElement);
        
        const ambientLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6); scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(50, 100, 50); dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 2048; dirLight.shadow.mapSize.height = 2048;
        dirLight.shadow.camera.left = -60; dirLight.shadow.camera.right = 60;
        dirLight.shadow.camera.top = 60; dirLight.shadow.camera.bottom = -60;
        scene.add(dirLight);

        buildWorld();
        controls = new THREE.PointerLockControls(camera, document.body);

        // --- UI Handling ---
        const ui = {
            stepName: document.getElementById('step-name'),
            stepMode: document.getElementById('step-mode'),
            stepHost: document.getElementById('step-host'),
            stepJoin: document.getElementById('step-join'),
            loading: document.getElementById('loading-indicator'),
            paused: document.getElementById('paused-step'),
            error: document.getElementById('error-msg'),
            hostDisplay: document.getElementById('host-id-display'),
            gameLayer: document.getElementById('ui-layer'),
            lobby: {
                overlay: document.getElementById('lobby-overlay'),
                status: document.getElementById('lobby-status'),
                timer: document.getElementById('lobby-timer'),
                count: document.getElementById('lobby-count'),
                controls: document.getElementById('host-controls')
            }
        };

        document.getElementById('btn-next').onclick = () => {
            const name = document.getElementById('username-input').value.trim();
            if (!name) return;
            myUsername = name;
            ui.stepName.classList.add('hidden');
            ui.stepMode.classList.remove('hidden');
        };

        document.getElementById('btn-host-mode').onclick = () => {
            ui.stepMode.classList.add('hidden');
            ui.loading.classList.remove('hidden');
            initHost();
        };

        document.getElementById('btn-join-mode').onclick = () => {
            ui.stepMode.classList.add('hidden');
            ui.stepJoin.classList.remove('hidden');
        };
        
        document.getElementById('btn-back').onclick = () => {
            ui.stepJoin.classList.add('hidden');
            ui.stepMode.classList.remove('hidden');
        };

        document.getElementById('btn-connect').onclick = () => {
            const hostId = document.getElementById('join-id-input').value.trim();
            if(!hostId) return;
            ui.stepJoin.classList.add('hidden');
            ui.loading.classList.remove('hidden');
            initClient(hostId);
        };

        document.getElementById('btn-host-start').onclick = () => {
             startGame();
        };
        
        document.getElementById('btn-copy').onclick = () => {
             const copyText = document.getElementById("host-id-display");
             copyText.select();
             document.execCommand("copy");
             document.getElementById('btn-copy').innerText = "COPIED!";
             setTimeout(()=>document.getElementById('btn-copy').innerText = "COPY", 2000);
        };

        document.getElementById('resume-btn').onclick = () => isGameReady && controls.lock();
        
        // Host Start Countdown
        document.getElementById('btn-start-countdown').onclick = () => {
            if (isHost) {
                serverLogic.status = 'countdown';
                serverLogic.timer = 30; // 30 seconds
                // Reset positions? Maybe later.
            }
        };

        controls.addEventListener('lock', () => {
            document.getElementById('start-modal').classList.add('hidden');
            if (globalStatus !== 'lobby') {
                // If in game, hide lobby overlay
                ui.lobby.overlay.classList.add('hidden');
            }
        });
        controls.addEventListener('unlock', () => {
            if(isGameReady) {
                document.getElementById('start-modal').classList.remove('hidden');
                ui.stepName.classList.add('hidden');
                ui.stepMode.classList.add('hidden');
                ui.stepHost.classList.add('hidden');
                ui.stepJoin.classList.add('hidden');
                ui.loading.classList.add('hidden');
                ui.paused.classList.remove('hidden');
            }
        });

        // --- Networking (PeerJS) ---
        const players = {};
        const localState = { isIt: false };
        let gameState = {}; // Player States
        
        // Server Logic (Host Only)
        let serverLogic = {
            status: 'lobby', // 'lobby', 'countdown', 'playing'
            timer: 30,
            itPlayerId: null
        };
        let globalStatus = 'lobby'; // Client view of status

        function generateId() {
            return Math.random().toString(36).substring(2, 6) + Math.random().toString(36).substring(2, 6);
        }

        function initHost() {
            isHost = true;
            myId = "host";
            peer = new Peer(generateId());
            
            peer.on('open', (id) => {
                ui.loading.classList.add('hidden');
                ui.stepHost.classList.remove('hidden');
                ui.hostDisplay.value = id;
            });

            peer.on('connection', (conn) => {
                connections.push(conn);
                conn.on('data', (data) => handleDataFromClient(conn.peer, data));
                conn.on('close', () => {
                    connections = connections.filter(c => c !== conn);
                    delete gameState[conn.peer];
                    removePlayer(conn.peer);
                });
            });

            peer.on('error', (err) => {
                ui.error.innerText = "Connection Error: " + err.type;
                ui.error.classList.remove('hidden');
            });
            
            // Show Lobby Controls for Host
            ui.lobby.controls.classList.remove('hidden');
        }

        function initClient(hostId) {
            isHost = false;
            peer = new Peer(); 
            
            peer.on('open', (id) => {
                myId = id;
                const conn = peer.connect(hostId);
                
                conn.on('open', () => {
                    hostConnection = conn;
                    ui.loading.classList.add('hidden');
                    startGame(); 
                    
                    conn.on('data', (data) => {
                        if (data.type === 'state') handleStateUpdate(data);
                    });
                });

                conn.on('error', (err) => {
                    ui.loading.classList.add('hidden');
                    ui.stepJoin.classList.remove('hidden');
                    ui.error.innerText = "Could not find host: " + hostId;
                    ui.error.classList.remove('hidden');
                });
            });
        }

        // --- Game Logic ---

        function startGame() {
            camera.position.set(0, 5, 30);
            isGameReady = true;
            document.getElementById('start-modal').classList.add('hidden');
            ui.gameLayer.classList.remove('hidden');
            ui.lobby.overlay.classList.remove('hidden'); // Start in lobby
            controls.lock();
            animate();
        }

        // Host Logic: Receive updates from clients
        function handleDataFromClient(clientId, data) {
            if (data.type === 'update') {
                gameState[clientId] = data.payload;
                gameState[clientId].lastSeen = Date.now();
            }
        }

        // Client Logic: Receive full state from host
        function handleStateUpdate(packet) {
            const serverState = packet.players;
            const logic = packet.logic;
            
            // Update Global Logic
            globalStatus = logic.status;
            
            // Update Lobby UI
            document.getElementById('lobby-count').innerText = Object.keys(serverState).length + (isHost ? 1 : 0); // approx
            
            if (logic.status === 'lobby') {
                ui.lobby.overlay.classList.remove('hidden');
                ui.lobby.status.innerText = "WAITING FOR HOST";
                ui.lobby.status.className = "text-2xl font-bold text-blue-400 mb-2";
                ui.lobby.timer.innerText = "30";
            } else if (logic.status === 'countdown') {
                ui.lobby.overlay.classList.remove('hidden');
                ui.lobby.status.innerText = "INTERMISSION";
                ui.lobby.status.className = "text-2xl font-bold text-yellow-400 mb-2";
                ui.lobby.timer.innerText = Math.ceil(logic.timer);
            } else if (logic.status === 'playing') {
                ui.lobby.overlay.classList.add('hidden');
            }

            // Sync Players
            const activeIds = new Set();
            let someoneIsIt = false;

            Object.keys(serverState).forEach(id => {
                if (id === myId) {
                    // Update my own IT status if server says so
                    if (serverState[id].isIt !== localState.isIt) {
                        localState.isIt = serverState[id].isIt;
                        updateGameUI();
                    }
                    return; 
                }

                activeIds.add(id);
                updatePlayer(id, serverState[id]);
                if (serverState[id].isIt) someoneIsIt = true;
            });

            // Cleanup
            Object.keys(players).forEach(id => {
                if (!activeIds.has(id)) removePlayer(id);
            });
            
            if (serverState[myId] && serverState[myId].isIt) someoneIsIt = true;
            document.getElementById('count-val').innerText = activeIds.size + 1;
        }

        // --- Player Rendering ---
        function createHumanoid(colorHex) {
            const group = new THREE.Group();
            const mat = new THREE.MeshStandardMaterial({ color: colorHex, roughness: 0.5 });
            const head = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.3, 0.3), mat); head.position.y = 1.55; group.add(head);
            const torso = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.6, 0.25), mat); torso.position.y = 1.1; group.add(torso);
            const limbGeo = new THREE.BoxGeometry(0.12, 0.7, 0.12); limbGeo.translate(0, -0.3, 0);
            const lArm = new THREE.Mesh(limbGeo, mat); lArm.position.set(-0.3, 1.35, 0); lArm.name='lArm'; group.add(lArm);
            const rArm = new THREE.Mesh(limbGeo, mat); rArm.position.set(0.3, 1.35, 0); rArm.name='rArm'; group.add(rArm);
            const lLeg = new THREE.Mesh(limbGeo, mat); lLeg.position.set(-0.15, 0.8, 0); lLeg.name='lLeg'; group.add(lLeg);
            const rLeg = new THREE.Mesh(limbGeo, mat); rLeg.position.set(0.15, 0.8, 0); rLeg.name='rLeg'; group.add(rLeg);
            group.traverse(o=>{if(o.isMesh){o.castShadow=true;o.receiveShadow=true;}});
            return group;
        }

        function updatePlayer(id, data) {
            let p = players[id];
            if (!p) {
                const mesh = createHumanoid(data.isIt ? 0xff3333 : 0x00ff88);
                scene.add(mesh);
                const label = document.createElement('div');
                label.className = 'label-container';
                label.innerText = data.username;
                document.getElementById('labels').appendChild(label);
                p = players[id] = { mesh, label, targetPos: new THREE.Vector3(), targetRot: 0, animOff: Math.random()*10 };
            }
            p.targetPos.set(data.x, data.y, data.z);
            p.targetRot = data.ry;
            
            const color = data.isIt ? 0xff3333 : 0x00ff88;
            p.mesh.traverse(c => { if(c.isMesh) c.material.color.setHex(color); });
        }

        function removePlayer(id) {
            if(players[id]) {
                scene.remove(players[id].mesh);
                players[id].label.remove();
                delete players[id];
            }
        }

        function updateGameUI() {
            const el = document.getElementById('status-text');
            if (localState.isIt) {
                el.innerText = "YOU ARE IT!"; el.className = "tag-status is-it";
            } else {
                el.innerText = "SURVIVE"; el.className = "tag-status not-it";
            }
        }

        // --- Core Loop ---
        const moveState = { fwd: false, bwd: false, left: false, right: false, sprint: false };
        let velocity = new THREE.Vector3(); let canJump = false;
        
        document.addEventListener('keydown', (e) => {
            switch(e.code) { case 'KeyW': moveState.fwd=true;break; case 'KeyS': moveState.bwd=true;break; case 'KeyA': moveState.left=true;break; case 'KeyD': moveState.right=true;break; case 'ShiftLeft': moveState.sprint=true;break; case 'Space': if(canJump){velocity.y=JUMP_FORCE;canJump=false;}break; }
        });
        document.addEventListener('keyup', (e) => {
            switch(e.code) { case 'KeyW': moveState.fwd=false;break; case 'KeyS': moveState.bwd=false;break; case 'KeyA': moveState.left=false;break; case 'KeyD': moveState.right=false;break; case 'ShiftLeft': moveState.sprint=false;break; }
        });

        // Collision
        const raycaster = new THREE.Raycaster();
        function checkCollisions(pos) {
            const box = new THREE.Box3();
            box.setFromCenterAndSize(new THREE.Vector3(pos.x, pos.y-0.5, pos.z), new THREE.Vector3(0.6, 2, 0.6));
            for(let o of worldObjects) if(o.userData.box && box.intersectsBox(o.userData.box)) return true;
            return false;
        }
        function getFloor(pos) {
            raycaster.set(new THREE.Vector3(pos.x, pos.y+1, pos.z), new THREE.Vector3(0,-1,0));
            const hits = raycaster.intersectObjects(worldObjects);
            // Safety: if nothing hit, return a low value but not void to prevent infinite fall glitch
            return hits.length > 0 ? hits[0].point.y : -100;
        }

        const clock = new THREE.Clock();
        let lastSync = 0;

        function animate() {
            requestAnimationFrame(animate);
            if(!isGameReady) return;
            const dt = Math.min(clock.getDelta(), 0.1);
            const now = Date.now();

            // Host Game Loop for Timer
            if (isHost && now - lastSync > 50) {
                // Timer Logic
                if (serverLogic.status === 'countdown') {
                    serverLogic.timer -= (now - lastSync) / 1000;
                    if (serverLogic.timer <= 0) {
                        serverLogic.status = 'playing';
                        serverLogic.timer = 0;
                        
                        // Randomizer Logic
                        const allIds = [myId, ...Object.keys(gameState)];
                        // Reset everyone
                        localState.isIt = false;
                        for(let id of Object.keys(gameState)) gameState[id].isIt = false;
                        
                        // Pick random IT (if more than 2 people, or just random if 1/2)
                        // Prompt said "if more than 2 people", but for game to work we need an IT.
                        // We will randomize if >= 2 players.
                        if (allIds.length >= 2) {
                            const r = Math.floor(Math.random() * allIds.length);
                            const pickedId = allIds[r];
                            if (pickedId === myId) localState.isIt = true;
                            else gameState[pickedId].isIt = true;
                            console.log("Randomly picked IT:", pickedId);
                        } else {
                            // If solo, just make self IT for fun
                             localState.isIt = true;
                        }
                    }
                }
            }

            if(controls.isLocked) {
                velocity.y -= GRAVITY * dt;
                const spd = moveState.sprint ? SPRINT_SPEED : MOVE_SPEED;
                const dir = new THREE.Vector3();
                dir.z = Number(moveState.fwd)-Number(moveState.bwd);
                dir.x = Number(moveState.right)-Number(moveState.left);
                dir.normalize();

                const oldPos = camera.position.clone();
                controls.moveRight(dir.x * spd * dt);
                if(checkCollisions(camera.position)) camera.position.x = oldPos.x;
                controls.moveForward(dir.z * spd * dt);
                if(checkCollisions(camera.position)) camera.position.z = oldPos.z;

                camera.position.y += velocity.y * dt;
                const fy = getFloor(camera.position);
                
                // Floor Snap Logic
                if (fy > -50) { // Valid floor found
                    if(camera.position.y < fy + PLAYER_HEIGHT) {
                        camera.position.y = fy + PLAYER_HEIGHT;
                        velocity.y = 0; canJump = true;
                    }
                } else if (camera.position.y < -20) {
                    // Respawn if fell into void
                    camera.position.set(0, 5, 0);
                    velocity.y = 0;
                }
                
                // --- Networking Update ---
                if (now - lastSync > 50) {
                    const myData = {
                        x: camera.position.x, y: camera.position.y - PLAYER_HEIGHT + 0.1, z: camera.position.z,
                        ry: camera.rotation.y, isIt: localState.isIt, username: myUsername
                    };

                    if (isHost) {
                        gameState[myId] = myData;
                        
                        // Tag Logic (Only if playing)
                        if (serverLogic.status === 'playing' && localState.isIt) {
                             const myPos = new THREE.Vector3(myData.x, myData.y, myData.z);
                             for (const pid in gameState) {
                                 if (pid === myId) continue;
                                 const pPos = new THREE.Vector3(gameState[pid].x, gameState[pid].y, gameState[pid].z);
                                 if (myPos.distanceTo(pPos) < TAG_DISTANCE) {
                                     localState.isIt = false;
                                     gameState[myId].isIt = false;
                                     gameState[pid].isIt = true;
                                     updateGameUI();
                                     break;
                                 }
                             }
                        }
                        
                        const packet = { players: gameState, logic: serverLogic };
                        connections.forEach(c => c.send({ type: 'state', ...packet }));
                        handleStateUpdate(packet); // Update local host UI
                    } else if (hostConnection) {
                        hostConnection.send({ type: 'update', payload: myData });
                    }
                    lastSync = now;
                }
            }

            // Animation & Rendering
            for (const pid in players) {
                const p = players[pid];
                const old = p.mesh.position.clone();
                p.mesh.position.lerp(p.targetPos, 0.3);
                p.mesh.rotation.y = p.targetRot;
                
                const isMov = p.mesh.position.distanceTo(old) > 0.01;
                const t = now * 0.01;
                const ang = isMov ? Math.sin(t+p.animOff)*1.2 : 0;
                
                const lA=p.mesh.getObjectByName('lArm'), rA=p.mesh.getObjectByName('rArm');
                const lL=p.mesh.getObjectByName('lLeg'), rL=p.mesh.getObjectByName('rLeg');
                if(lA){lA.rotation.x=-ang;rA.rotation.x=ang;lL.rotation.x=ang;rL.rotation.x=-ang;}

                const pos = p.mesh.position.clone(); pos.y += 2.2; pos.project(camera);
                const x = (pos.x*.5+.5)*window.innerWidth; const y = (pos.y*-.5+.5)*window.innerHeight;
                if(pos.z>1 || x<0 || x>window.innerWidth || y<0 || y>window.innerHeight) p.label.style.opacity=0;
                else { p.label.style.opacity=1; p.label.style.transform=`translate(-50%,-100%) translate(${x}px,${y}px)`; }
            }

            renderer.render(scene, camera);
        }
        
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth/window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>

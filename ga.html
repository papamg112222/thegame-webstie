<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Half-Sword Style Runner</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #111; font-family: 'Courier New', Courier, monospace; }
        canvas { display: block; width: 100vw; height: 100vh; }
        
        /* UI Overlay */
        #overlay {
            position: absolute;
            top: 20px;
            width: 100%;
            text-align: center;
            color: rgba(255, 255, 255, 0.6);
            pointer-events: none;
            user-select: none;
            text-transform: uppercase;
            letter-spacing: 2px;
            z-index: 10;
        }

        /* Controls Container */
        #controls {
            position: absolute;
            bottom: 40px;
            width: 100%;
            display: flex;
            justify-content: center;
            pointer-events: none; /* Let clicks pass through around button */
            z-index: 10;
        }

        /* The Run Button */
        #runButton {
            pointer-events: auto;
            background: rgba(20, 20, 20, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: #d0d0d0;
            padding: 15px 40px;
            font-family: 'Courier New', Courier, monospace;
            font-size: 1.2rem;
            text-transform: uppercase;
            letter-spacing: 3px;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }

        #runButton:hover {
            background: #4a1a1a; /* Dried blood red for style */
            border-color: #ff8888;
            color: #fff;
            transform: scale(1.05);
        }

        #runButton:active {
            transform: scale(0.95);
        }

        .active-state {
            background: #602020 !important;
            border-color: #ff4444 !important;
            color: #fff !important;
            box-shadow: 0 0 30px rgba(255, 50, 50, 0.3) !important;
        }
    </style>
</head>
<body>

    <div id="overlay">
        <h2>Phys-Sim Prototype</h2>
        <p>Locomotion Test: unstable</p>
    </div>

    <div id="controls">
        <button id="runButton">RUN</button>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- 1. Scene Setup ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a1a1a);
        scene.fog = new THREE.Fog(0x1a1a1a, 8, 25);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(4, 2, 4);

        const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        document.body.appendChild(renderer.domElement);

        // --- 2. Lighting ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
        scene.add(ambientLight);

        const mainLight = new THREE.DirectionalLight(0xffeadd, 1.5);
        mainLight.position.set(3, 8, 5);
        mainLight.castShadow = true;
        mainLight.shadow.mapSize.width = 2048;
        mainLight.shadow.mapSize.height = 2048;
        mainLight.shadow.radius = 4;
        mainLight.shadow.bias = -0.0005;
        scene.add(mainLight);

        const rimLight = new THREE.SpotLight(0xbadeff, 3);
        rimLight.position.set(-5, 4, -5);
        rimLight.lookAt(0, 1, 0);
        scene.add(rimLight);

        // --- 3. Materials ---
        const skinMaterial = new THREE.MeshPhysicalMaterial({
            color: 0xf5d0b0,
            emissive: 0x4a1a1a,
            emissiveIntensity: 0.1,
            metalness: 0.1,
            roughness: 0.4,
            clearcoat: 0.3,
            clearcoatRoughness: 0.4,
            reflectivity: 0.5
        });

        // --- 4. Rigged Character Construction ---
        const humanGroup = new THREE.Group();
        // The "Rig" object will store references to joints for animation
        const rig = {
            spine: null,
            head: null,
            leftArm: { shoulder: null, elbow: null },
            rightArm: { shoulder: null, elbow: null },
            leftLeg: { hip: null, knee: null, ankle: null },
            rightLeg: { hip: null, knee: null, ankle: null }
        };

        // Helpers
        function createSphere(r) {
            return new THREE.Mesh(new THREE.SphereGeometry(r, 32, 32), skinMaterial);
        }
        function createLimbGeo(r, len) {
            const mesh = new THREE.Mesh(new THREE.CapsuleGeometry(r, len, 8, 16), skinMaterial);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            // Shift geometry so pivot is at the top (0,0,0) instead of center
            mesh.position.y = -len / 2;
            return mesh;
        }

        // -- Torso & Head --
        // Use a group for the spine pivot
        rig.spine = new THREE.Group();
        rig.spine.position.y = 1.0; // Hips height
        humanGroup.add(rig.spine);

        // Torso Geometry (Procedural Lathe)
        const torsoPoints = [];
        for (let i = 0; i <= 10; i++) {
            let t = i / 10;
            let x = 0.12 + Math.sin(t * Math.PI) * 0.08; // curve
            let y = t * 0.7; 
            torsoPoints.push(new THREE.Vector2(x, y));
        }
        const torsoGeo = new THREE.LatheGeometry(torsoPoints, 32);
        const torsoMesh = new THREE.Mesh(torsoGeo, skinMaterial);
        torsoMesh.castShadow = true;
        torsoMesh.receiveShadow = true;
        rig.spine.add(torsoMesh);

        // Head
        rig.head = new THREE.Group();
        rig.head.position.y = 0.75; // Neck position relative to spine
        rig.spine.add(rig.head);
        
        const headMesh = createSphere(0.16);
        headMesh.scale.set(0.9, 1.2, 1.0);
        headMesh.position.y = 0.15;
        headMesh.castShadow = true;
        rig.head.add(headMesh);

        // -- Builder Function for Hierarchical Limbs --
        function buildLimbHierarchy(side, type) {
            const isLeft = side === 'left';
            const s = isLeft ? 1 : -1;
            const root = new THREE.Group();

            if (type === 'arm') {
                // Shoulder Pivot
                root.position.set(s * 0.22, 0.65, 0); // Relative to spine
                const shoulderGeo = createSphere(0.12);
                root.add(shoulderGeo);

                // Upper Arm
                const upperLen = 0.35;
                const upperMesh = createLimbGeo(0.08, upperLen);
                root.add(upperMesh);

                // Elbow Pivot
                const elbow = new THREE.Group();
                elbow.position.y = -upperLen; 
                root.add(elbow);
                
                const elbowGeo = createSphere(0.075);
                elbow.add(elbowGeo);

                // Forearm
                const foreLen = 0.35;
                const foreMesh = createLimbGeo(0.07, foreLen);
                elbow.add(foreMesh);

                // Hand
                const hand = createSphere(0.08);
                hand.scale.set(0.8, 1.5, 0.5);
                hand.position.y = -foreLen;
                elbow.add(hand);

                // Store refs
                if (isLeft) { rig.leftArm.shoulder = root; rig.leftArm.elbow = elbow; }
                else { rig.rightArm.shoulder = root; rig.rightArm.elbow = elbow; }

            } else {
                // Hip Pivot
                root.position.set(s * 0.12, 0.05, 0); // Relative to spine (hips)
                const hipGeo = createSphere(0.13);
                root.add(hipGeo);

                // Thigh
                const thighLen = 0.5;
                const thighMesh = createLimbGeo(0.11, thighLen);
                root.add(thighMesh);

                // Knee Pivot
                const knee = new THREE.Group();
                knee.position.y = -thighLen;
                root.add(knee);

                const kneeGeo = createSphere(0.1);
                knee.add(kneeGeo);

                // Shin
                const shinLen = 0.45;
                const shinMesh = createLimbGeo(0.09, shinLen);
                knee.add(shinMesh);

                // Ankle/Foot
                const foot = new THREE.Group();
                foot.position.y = -shinLen;
                knee.add(foot);
                
                const footGeo = new THREE.Mesh(new THREE.CapsuleGeometry(0.07, 0.15, 4, 16), skinMaterial);
                footGeo.rotation.x = Math.PI / 2;
                footGeo.position.z = 0.05;
                foot.add(footGeo);

                // Store refs
                if (isLeft) { rig.leftLeg.hip = root; rig.leftLeg.knee = knee; rig.leftLeg.ankle = foot; }
                else { rig.rightLeg.hip = root; rig.rightLeg.knee = knee; rig.rightLeg.ankle = foot; }
            }

            return root;
        }

        rig.spine.add(buildLimbHierarchy('left', 'arm'));
        rig.spine.add(buildLimbHierarchy('right', 'arm'));
        rig.spine.add(buildLimbHierarchy('left', 'leg'));
        rig.spine.add(buildLimbHierarchy('right', 'leg'));

        scene.add(humanGroup);

        // Floor
        const floor = new THREE.Mesh(
            new THREE.PlaneGeometry(200, 200),
            new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.8, metalness: 0.2 })
        );
        floor.rotation.x = -Math.PI / 2;
        floor.receiveShadow = true;
        scene.add(floor);

        // --- 5. Logic & Animation ---
        let isRunning = false;
        const btn = document.getElementById('runButton');
        
        btn.addEventListener('mousedown', () => {
            isRunning = !isRunning;
            btn.textContent = isRunning ? "STOP" : "RUN";
            btn.classList.toggle('active-state', isRunning);
        });

        // Controls
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.target.set(0, 1, 0);

        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            
            const rawTime = clock.getElapsedTime();
            // Speed up time significantly for the frantic run effect
            const speedMult = isRunning ? 12 : 2; 
            const t = rawTime * speedMult;
            const delta = clock.getDelta(); // not used heavily but good practice

            // -- Procedural Animation Blending --
            // We'll use a lerp factor to smooth transition between Idle and Run
            const targetRunWeight = isRunning ? 1.0 : 0.0;
            // Simple approach: we just switch logic or blend values. 
            // For code clarity, I'll calculate both and blend based on `runWeight`.
            // Ideally use a persistent lerp variable.
            
            // NOTE: Since I need a persistent state for blending, I'll add it to the window scope or closure
            if (typeof window.runWeight === 'undefined') window.runWeight = 0;
            window.runWeight += (targetRunWeight - window.runWeight) * 0.1; // Smooth transition
            const w = window.runWeight; // 0 = Idle, 1 = Run

            // --- 1. SPINE / ROOT ---
            // Idle: Gentle sway. Run: Leans forward heavily, bobs violently.
            const idleLean = 0.05;
            const runLean = 0.6; // Deep lean for "creature" look
            rig.spine.rotation.x = THREE.MathUtils.lerp(idleLean, runLean, w) + Math.sin(t * 0.5) * 0.05 * w;
            
            // Bobbing height
            const idleY = 1.0;
            // When running, hips drop a bit to crouch/scuttle
            const runY = 0.9 + Math.abs(Math.sin(t)) * 0.15; 
            rig.spine.position.y = THREE.MathUtils.lerp(idleY + Math.sin(rawTime)*0.02, runY, w);
            
            // Side to side sway (heavier when running)
            rig.spine.rotation.z = Math.cos(t * 0.5) * (0.05 + 0.1 * w);

            // --- 2. HEAD ---
            // Counter-animate to look forward, but wobble loosely
            // When leaning forward (X rotation), head must rotate back (-X) to look up
            rig.head.rotation.x = -rig.spine.rotation.x + (Math.sin(t * 1.5) * 0.2 * w); 
            rig.head.rotation.y = Math.cos(t * 0.3) * 0.1;
            rig.head.rotation.z = Math.sin(t) * 0.1 * w; // Head bobble

            // --- 3. LEGS ---
            // Function to get leg angles
            function getLegAngles(offset) {
                const stride = Math.sin(t + offset);
                
                // Hip Flexion (Forward/Back)
                // Run: Larger range, but biased forward
                const hipRot = stride * (0.4 + 0.6 * w); 
                
                // Knee Flexion (Only bends back)
                // Run: Snaps up quickly. Logic: if leg is moving forward, lift knee high.
                let kneeRot = 0;
                if (w > 0.5) {
                    // Running logic: High knees
                    // Complex cycle: lift knee when hip goes forward
                    const lift = Math.max(0, Math.sin(t + offset + 1.0));
                    kneeRot = 0.2 + lift * 1.5; 
                } else {
                    // Walking logic
                    kneeRot = Math.abs(stride) * 0.5;
                }
                
                return { hip: hipRot, knee: kneeRot };
            }

            const leftLeg = getLegAngles(0);
            const rightLeg = getLegAngles(Math.PI); // Phase shift

            // Apply Leg Rotations
            rig.leftLeg.hip.rotation.x = -leftLeg.hip;
            rig.leftLeg.knee.rotation.x = leftLeg.knee;
            
            rig.rightLeg.hip.rotation.x = -rightLeg.hip;
            rig.rightLeg.knee.rotation.x = rightLeg.knee;

            // Splay legs out slightly
            rig.leftLeg.hip.rotation.z = 0.1 + w * 0.1;
            rig.rightLeg.hip.rotation.z = -0.1 - w * 0.1;


            // --- 4. ARMS ---
            // "Tall creature trying to run but fail" -> Arms don't swing normally.
            // They drag behind or hold awkward balance.
            
            // Shoulder Rot X: Normal swing vs Drag behind
            // Normal swing: opposite to legs.
            // Failed run: Arms pinned back (-0.5) and twitching
            
            // Left Arm
            const armSwing = Math.sin(t + Math.PI) * 0.5; // Normal swing
            const armDrag = 0.8; // Arms stuck back
            
            // Blend swing to drag
            rig.leftArm.shoulder.rotation.x = THREE.MathUtils.lerp(armSwing, armDrag + Math.sin(t*2)*0.1, w);
            rig.rightArm.shoulder.rotation.x = THREE.MathUtils.lerp(-armSwing, armDrag + Math.cos(t*2)*0.1, w);

            // Arm Splay (Z axis) - Flail out when running
            const armOut = 0.2;
            const armFlail = 0.6 + Math.sin(t * 3) * 0.1; // Jittery
            rig.leftArm.shoulder.rotation.z = THREE.MathUtils.lerp(armOut, armFlail, w);
            rig.rightArm.shoulder.rotation.z = THREE.MathUtils.lerp(-armOut, -armFlail, w);

            // Elbows - Locked or loose?
            // Let's make them slightly bent and twitchy
            rig.leftArm.elbow.rotation.x = -0.3 - Math.abs(Math.sin(t * 4)) * 0.2 * w;
            rig.rightArm.elbow.rotation.x = -0.3 - Math.abs(Math.sin(t * 4 + 1)) * 0.2 * w;


            controls.update();
            renderer.render(scene, camera);
        }

        // Handle resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>

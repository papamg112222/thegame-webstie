<!DOCTYPE html>
<html lang="en">
<head>
Â  Â  <meta charset="UTF-8">
Â  Â  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
Â  Â  <title>Cottage Nightmare</title>
Â  Â  <style>
Â  Â  Â  Â  body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Courier New', Courier, monospace; user-select: none; touch-action: none; }
Â  Â  Â  Â  canvas { display: block; }
Â  Â  Â  Â  
Â  Â  Â  Â  /* UI Overlay */
Â  Â  Â  Â  #ui-layer {
Â  Â  Â  Â  Â  Â  position: absolute;
Â  Â  Â  Â  Â  Â  top: 0; left: 0; width: 100%; height: 100%;
Â  Â  Â  Â  Â  Â  pointer-events: none;
Â  Â  Â  Â  Â  Â  display: flex;
Â  Â  Â  Â  Â  Â  justify-content: center;
Â  Â  Â  Â  Â  Â  align-items: center;
Â  Â  Â  Â  Â  Â  z-index: 10;
Â  Â  Â  Â  }

Â  Â  Â  Â  #eyelids {
Â  Â  Â  Â  Â  Â  position: absolute;
Â  Â  Â  Â  Â  Â  top: 0; left: 0; width: 100%; height: 100%;
Â  Â  Â  Â  Â  Â  background-color: black;
Â  Â  Â  Â  Â  Â  opacity: 1;
Â  Â  Â  Â  Â  Â  transition: opacity 0.2s ease-in-out;
Â  Â  Â  Â  Â  Â  z-index: 1;
Â  Â  Â  Â  }

Â  Â  Â  Â  #story-text {
Â  Â  Â  Â  Â  Â  color: white;
Â  Â  Â  Â  Â  Â  font-size: 24px;
Â  Â  Â  Â  Â  Â  text-align: center;
Â  Â  Â  Â  Â  Â  z-index: 2;
Â  Â  Â  Â  Â  Â  opacity: 0;
Â  Â  Â  Â  Â  Â  transition: opacity 1s ease;
Â  Â  Â  Â  Â  Â  text-shadow: 0 0 5px red;
Â  Â  Â  Â  Â  Â  max-width: 80%;
Â  Â  Â  Â  Â  Â  background: rgba(0,0,0,0.5);
Â  Â  Â  Â  Â  Â  padding: 20px;
Â  Â  Â  Â  Â  Â  border-radius: 5px;
Â  Â  Â  Â  }

Â  Â  Â  Â  /* PAUSE / START SCREEN */
Â  Â  Â  Â  #pause-screen {
Â  Â  Â  Â  Â  Â  position: absolute;
Â  Â  Â  Â  Â  Â  top: 0; left: 0; width: 100%; height: 100%;
Â  Â  Â  Â  Â  Â  background: rgba(0,0,0,0.8);
Â  Â  Â  Â  Â  Â  color: #ccc;
Â  Â  Â  Â  Â  Â  display: none; 
Â  Â  Â  Â  Â  Â  justify-content: center;
Â  Â  Â  Â  Â  Â  align-items: center;
Â  Â  Â  Â  Â  Â  cursor: pointer;
Â  Â  Â  Â  Â  Â  z-index: 30;
Â  Â  Â  Â  Â  Â  flex-direction: column;
Â  Â  Â  Â  Â  Â  pointer-events: auto;
Â  Â  Â  Â  }
Â  Â  Â  Â  #pause-screen h1 {
Â  Â  Â  Â  Â  Â  border: 1px solid #666;
Â  Â  Â  Â  Â  Â  padding: 20px 40px;
Â  Â  Â  Â  Â  Â  background: #111;
Â  Â  Â  Â  Â  Â  letter-spacing: 3px;
Â  Â  Â  Â  Â  Â  text-transform: uppercase;
Â  Â  Â  Â  }

Â  Â  Â  Â  #start-screen {
Â  Â  Â  Â  Â  Â  position: absolute;
Â  Â  Â  Â  Â  Â  top: 0; left: 0; width: 100%; height: 100%;
Â  Â  Â  Â  Â  Â  background: #050505;
Â  Â  Â  Â  Â  Â  color: #888;
Â  Â  Â  Â  Â  Â  display: flex;
Â  Â  Â  Â  Â  Â  justify-content: center;
Â  Â  Â  Â  Â  Â  align-items: center;
Â  Â  Â  Â  Â  Â  cursor: pointer;
Â  Â  Â  Â  Â  Â  z-index: 20;
Â  Â  Â  Â  Â  Â  flex-direction: column;
Â  Â  Â  Â  Â  Â  transition: opacity 0.5s;
Â  Â  Â  Â  }
Â  Â  Â  Â  
Â  Â  Â  Â  #start-screen h1 {
Â  Â  Â  Â  Â  Â  border: 1px solid #444;
Â  Â  Â  Â  Â  Â  padding: 20px;
Â  Â  Â  Â  Â  Â  border-radius: 2px;
Â  Â  Â  Â  Â  Â  font-weight: lighter;
Â  Â  Â  Â  Â  Â  letter-spacing: 2px;
Â  Â  Â  Â  Â  Â  color: #ccc;
Â  Â  Â  Â  }

Â  Â  Â  Â  #crosshair {
Â  Â  Â  Â  Â  Â  position: absolute;
Â  Â  Â  Â  Â  Â  top: 50%; left: 50%;
Â  Â  Â  Â  Â  Â  width: 4px; height: 4px;
Â  Â  Â  Â  Â  Â  background: rgba(255, 255, 255, 0.5);
Â  Â  Â  Â  Â  Â  border-radius: 50%;
Â  Â  Â  Â  Â  Â  transform: translate(-50%, -50%);
Â  Â  Â  Â  Â  Â  display: none; 
Â  Â  Â  Â  Â  Â  z-index: 5;
Â  Â  Â  Â  Â  Â  pointer-events: none;
Â  Â  Â  Â  }

Â  Â  Â  Â  /* --- INTERACTION LABEL --- */
Â  Â  Â  Â  #interact-label {
Â  Â  Â  Â  Â  Â  position: absolute;
Â  Â  Â  Â  Â  Â  top: 50%; left: 50%;
Â  Â  Â  Â  Â  Â  transform: translate(20px, -50%); /* Offset to the right of crosshair */
Â  Â  Â  Â  Â  Â  color: white;
Â  Â  Â  Â  Â  Â  font-size: 14px;
Â  Â  Â  Â  Â  Â  font-weight: bold;
Â  Â  Â  Â  Â  Â  text-shadow: 1px 1px 2px black;
Â  Â  Â  Â  Â  Â  display: none;
Â  Â  Â  Â  Â  Â  pointer-events: none;
Â  Â  Â  Â  Â  Â  z-index: 6;
Â  Â  Â  Â  Â  Â  background: rgba(0,0,0,0.6);
Â  Â  Â  Â  Â  Â  padding: 5px 10px;
Â  Â  Â  Â  Â  Â  border-radius: 4px;
Â  Â  Â  Â  Â  Â  border-left: 3px solid white;
Â  Â  Â  Â  }
Â  Â  Â  Â  .key-hint {
Â  Â  Â  Â  Â  Â  color: #ffaa00;
Â  Â  Â  Â  Â  Â  font-weight: bold;
Â  Â  Â  Â  Â  Â  margin-left: 5px;
Â  Â  Â  Â  }

Â  Â  Â  Â  /* --- MOBILE CONTROLS --- */
Â  Â  Â  Â  #mobile-ui { display: none; pointer-events: none; width:100%; height:100%; position:absolute; top:0; left:0; z-index: 15; }
Â  Â  Â  Â  
Â  Â  Â  Â  .touch-zone {
Â  Â  Â  Â  Â  Â  position: absolute;
Â  Â  Â  Â  Â  Â  bottom: 0;
Â  Â  Â  Â  Â  Â  height: 100%; 
Â  Â  Â  Â  Â  Â  pointer-events: auto;
Â  Â  Â  Â  }
Â  Â  Â  Â  #zone-move { left: 0; width: 40%; background: transparent; }
Â  Â  Â  Â  #zone-look { right: 0; width: 60%; background: transparent; }

Â  Â  Â  Â  .joystick-hint {
Â  Â  Â  Â  Â  Â  position: absolute;
Â  Â  Â  Â  Â  Â  bottom: 60px;
Â  Â  Â  Â  Â  Â  left: 60px;
Â  Â  Â  Â  Â  Â  width: 100px;
Â  Â  Â  Â  Â  Â  height: 100px;
Â  Â  Â  Â  Â  Â  border: 2px solid rgba(255,255,255,0.1);
Â  Â  Â  Â  Â  Â  border-radius: 50%;
Â  Â  Â  Â  Â  Â  pointer-events: none;
Â  Â  Â  Â  }
Â  Â  Â  Â  
Â  Â  Â  Â  #interact-btn {
Â  Â  Â  Â  Â  Â  position: absolute;
Â  Â  Â  Â  Â  Â  bottom: 80px;
Â  Â  Â  Â  Â  Â  right: 40px;
Â  Â  Â  Â  Â  Â  width: 80px;
Â  Â  Â  Â  Â  Â  height: 80px;
Â  Â  Â  Â  Â  Â  background: rgba(255, 255, 255, 0.1);
Â  Â  Â  Â  Â  Â  border: 2px solid rgba(255, 255, 255, 0.3);
Â  Â  Â  Â  Â  Â  border-radius: 50%;
Â  Â  Â  Â  Â  Â  pointer-events: auto; 
Â  Â  Â  Â  Â  Â  display: flex;
Â  Â  Â  Â  Â  Â  justify-content: center;
Â  Â  Â  Â  Â  Â  align-items: center;
Â  Â  Â  Â  Â  Â  color: white;
Â  Â  Â  Â  Â  Â  font-size: 30px;
Â  Â  Â  Â  Â  Â  backdrop-filter: blur(2px);
Â  Â  Â  Â  Â  Â  user-select: none;
Â  Â  Â  Â  }
Â  Â  Â  Â  #interact-btn:active {
Â  Â  Â  Â  Â  Â  background: rgba(255, 255, 255, 0.3);
Â  Â  Â  Â  Â  Â  transform: scale(0.95);
Â  Â  Â  Â  }

Â  Â  Â  Â  @media (hover: none) and (pointer: coarse) {
Â  Â  Â  Â  Â  Â  #mobile-ui { display: block; }
Â  Â  Â  Â  }
Â  Â  </style>
</head>
<body>

Â  Â  <div id="start-screen">
Â  Â  Â  Â  <h1>TAP TO WAKE UP</h1>
Â  Â  Â  Â  <p style="margin-top:10px; font-size: 12px; color:#555">Headphones Recommended</p>
Â  Â  </div>

Â  Â  <div id="pause-screen">
Â  Â  Â  Â  <h1>CLICK TO RESUME</h1>
Â  Â  </div>

Â  Â  <div id="crosshair"></div>
Â  Â  <div id="interact-label"></div>

Â  Â  <div id="mobile-ui">
Â  Â  Â  Â  <div id="zone-move" class="touch-zone"></div>
Â  Â  Â  Â  <div id="zone-look" class="touch-zone"></div>
Â  Â  Â  Â  <div id="interact-btn">ğŸ–ï¸</div>
Â  Â  Â  Â  <div class="joystick-hint"></div>
Â  Â  </div>

Â  Â  <div id="ui-layer">
Â  Â  Â  Â  <div id="eyelids"></div>
Â  Â  Â  Â  <div id="story-text"></div>
Â  Â  </div>

Â  Â  <!-- Three.js Libraries -->
Â  Â  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
Â  Â  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/PointerLockControls.js"></script>

Â  Â  <script>
Â  Â  Â  Â  // --- VARIABLES ---
Â  Â  Â  Â  let camera, scene, renderer, controls;
Â  Â  Â  Â  let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
Â  Â  Â  Â  let prevTime = performance.now();
Â  Â  Â  Â  let velocity = new THREE.Vector3();
Â  Â  Â  Â  let direction = new THREE.Vector3();
Â  Â  Â  Â  let isCutsceneActive = true;
Â  Â  Â  Â  let isPaused = false;
Â  Â  Â  Â  
Â  Â  Â  Â  // Interaction & Holding
Â  Â  Â  Â  let handGroup;
Â  Â  Â  Â  let heldItem = null;
Â  Â  Â  Â  let interactableObjects = [];
Â  Â  Â  Â  let fallingObjects = []; // Array to track physics items
Â  Â  Â  Â  const interactLabel = document.getElementById('interact-label');
Â  Â  Â  Â  let currentTarget = null;
Â  Â  Â  Â  
Â  Â  Â  Â  // Head Bob & Sway
Â  Â  Â  Â  let bobTimer = 0;
Â  Â  Â  Â  const bobFrequency = 10;
Â  Â  Â  Â  const bobAmplitude = 0.1;
Â  Â  Â  Â  const defaultCamHeight = 3.5;
Â  Â  Â  Â  let swayX = 0;
Â  Â  Â  Â  let swayY = 0;

Â  Â  Â  Â  // Mobile / Touch
Â  Â  Â  Â  let touchMoveOrigin = null;
Â  Â  Â  Â  let touchLookLast = null;
Â  Â  Â  Â  let mobileMoveVector = { x: 0, y: 0 };
Â  Â  Â  Â  const pitchLimit = Math.PI / 2 - 0.1;

Â  Â  Â  Â  // Dimensions
Â  Â  Â  Â  const roomWidth = 10;
Â  Â  Â  Â  const roomDepth = 12;
Â  Â  Â  Â  const roomHeight = 6;

Â  Â  Â  Â  const textElement = document.getElementById('story-text');
Â  Â  Â  Â  const eyelids = document.getElementById('eyelids');
Â  Â  Â  Â  const startScreen = document.getElementById('start-screen');
Â  Â  Â  Â  const pauseScreen = document.getElementById('pause-screen');
Â  Â  Â  Â  const crosshair = document.getElementById('crosshair');
Â  Â  Â  Â  const interactBtn = document.getElementById('interact-btn');

Â  Â  Â  Â  // Raycasting
Â  Â  Â  Â  const raycaster = new THREE.Raycaster();
Â  Â  Â  Â  const center = new THREE.Vector2(0, 0);

Â  Â  Â  Â  init();
Â  Â  Â  Â  animate();

Â  Â  Â  Â  function init() {
Â  Â  Â  Â  Â  Â  scene = new THREE.Scene();
Â  Â  Â  Â  Â  Â  // Thinner fog so we can see the moon better
Â  Â  Â  Â  Â  Â  scene.fog = new THREE.FogExp2(0x050510, 0.005); 

Â  Â  Â  Â  Â  Â  camera = new THREE.PerspectiveCamera(65, window.innerWidth / window.innerHeight, 0.1, 2000); 
Â  Â  Â  Â  Â  Â  camera.rotation.order = "YXZ"; 
Â  Â  Â  Â  Â  Â  // Start: Lying down
Â  Â  Â  Â  Â  Â  camera.position.set(-roomWidth/2 + 2, 1.4, -0.5); 
Â  Â  Â  Â  Â  Â  camera.rotation.x = -1.2; 
Â  Â  Â  Â  Â  Â  camera.rotation.y = -0.8; 
Â  Â  Â  Â  Â  Â  camera.rotation.z = -0.5;

Â  Â  Â  Â  Â  Â  // Hand
Â  Â  Â  Â  Â  Â  handGroup = new THREE.Group();
Â  Â  Â  Â  Â  Â  handGroup.position.set(0.5, -0.6, -1);
Â  Â  Â  Â  Â  Â  camera.add(handGroup);
Â  Â  Â  Â  Â  Â  scene.add(camera);

Â  Â  Â  Â  Â  Â  renderer = new THREE.WebGLRenderer({ antialias: window.devicePixelRatio < 2, powerPreference: "high-performance" });
Â  Â  Â  Â  Â  Â  renderer.setSize(window.innerWidth, window.innerHeight);
Â  Â  Â  Â  Â  Â  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
Â  Â  Â  Â  Â  Â  renderer.setClearColor(0x020205);
Â  Â  Â  Â  Â  Â  renderer.shadowMap.enabled = true;
Â  Â  Â  Â  Â  Â  renderer.shadowMap.type = THREE.PCFSoftShadowMap;
Â  Â  Â  Â  Â  Â  renderer.physicallyCorrectLights = true; 
Â  Â  Â  Â  Â  Â  renderer.outputEncoding = THREE.sRGBEncoding;
Â  Â  Â  Â  Â  Â  document.body.appendChild(renderer.domElement);

Â  Â  Â  Â  Â  Â  // Lights
Â  Â  Â  Â  Â  Â  const ambientLight = new THREE.AmbientLight(0x202040, 0.4); 
Â  Â  Â  Â  Â  Â  scene.add(ambientLight);

Â  Â  Â  Â  Â  Â  const ceilingLight = new THREE.PointLight(0xffaa55, 60, 20); 
Â  Â  Â  Â  Â  Â  ceilingLight.position.set(0, 4.2, 0);
Â  Â  Â  Â  Â  Â  ceilingLight.castShadow = true;
Â  Â  Â  Â  Â  Â  ceilingLight.shadow.bias = -0.0005;
Â  Â  Â  Â  Â  Â  ceilingLight.shadow.mapSize.width = 1024;
Â  Â  Â  Â  Â  Â  ceilingLight.shadow.mapSize.height = 1024;
Â  Â  Â  Â  Â  Â  ceilingLight.userData = { isMainLight: true, baseInt: 60 };
Â  Â  Â  Â  Â  Â  scene.add(ceilingLight);

Â  Â  Â  Â  Â  Â  // Moon Light
Â  Â  Â  Â  Â  Â  const moonLight = new THREE.DirectionalLight(0xccccff, 0.8);
Â  Â  Â  Â  Â  Â  moonLight.position.set(200, 400, -300);
Â  Â  Â  Â  Â  Â  moonLight.castShadow = true;
Â  Â  Â  Â  Â  Â  moonLight.shadow.camera.left = -500;
Â  Â  Â  Â  Â  Â  moonLight.shadow.camera.right = 500;
Â  Â  Â  Â  Â  Â  moonLight.shadow.camera.top = 500;
Â  Â  Â  Â  Â  Â  moonLight.shadow.camera.bottom = -500;
Â  Â  Â  Â  Â  Â  moonLight.shadow.mapSize.width = 1024;
Â  Â  Â  Â  Â  Â  moonLight.shadow.mapSize.height = 1024;
Â  Â  Â  Â  Â  Â  scene.add(moonLight);

Â  Â  Â  Â  Â  Â  createRealisticEnvironment();
Â  Â  Â  Â  Â  Â  createGrasslandExterior(); 

Â  Â  Â  Â  Â  Â  controls = new THREE.PointerLockControls(camera, document.body);

Â  Â  Â  Â  Â  Â  // Listeners
Â  Â  Â  Â  Â  Â  document.addEventListener('keydown', onKeyDown);
Â  Â  Â  Â  Â  Â  document.addEventListener('keyup', onKeyUp);
Â  Â  Â  Â  Â  Â  document.addEventListener('mousedown', onMouseDown);
Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  // Start & Pause handlers
Â  Â  Â  Â  Â  Â  startScreen.addEventListener('click', startGame);
Â  Â  Â  Â  Â  Â  startScreen.addEventListener('touchstart', startGame);
Â  Â  Â  Â  Â  Â  pauseScreen.addEventListener('click', () => {
Â  Â  Â  Â  Â  Â  Â  Â  if(!isCutsceneActive) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  controls.lock();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  pauseScreen.style.display = 'none';
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  isPaused = false;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  });

Â  Â  Â  Â  Â  Â  controls.addEventListener('unlock', () => {
Â  Â  Â  Â  Â  Â  Â  Â  if (!isCutsceneActive && !isMobile()) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  isPaused = true;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  pauseScreen.style.display = 'flex';
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  });

Â  Â  Â  Â  Â  Â  interactBtn.addEventListener('touchstart', handleInteractMobile);
Â  Â  Â  Â  Â  Â  window.addEventListener('resize', onWindowResize);
Â  Â  Â  Â  Â  Â  setupTouchControls();
Â  Â  Â  Â  }

Â  Â  Â  Â  function createWoodTexture(colorHex) {
Â  Â  Â  Â  Â  Â  const canvas = document.createElement('canvas');
Â  Â  Â  Â  Â  Â  canvas.width = 512; canvas.height = 512;
Â  Â  Â  Â  Â  Â  const ctx = canvas.getContext('2d');
Â  Â  Â  Â  Â  Â  ctx.fillStyle = colorHex;
Â  Â  Â  Â  Â  Â  ctx.fillRect(0,0,512,512);
Â  Â  Â  Â  Â  Â  ctx.globalAlpha = 0.1;
Â  Â  Â  Â  Â  Â  ctx.fillStyle = '#000000';
Â  Â  Â  Â  Â  Â  for(let i=0; i<100; i++) {
Â  Â  Â  Â  Â  Â  Â  Â  const y = Math.random() * 512;
Â  Â  Â  Â  Â  Â  Â  Â  const h = Math.random() * 2 + 1;
Â  Â  Â  Â  Â  Â  Â  Â  ctx.fillRect(0, y, 512, h);
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  ctx.globalAlpha = 0.05;
Â  Â  Â  Â  Â  Â  for(let i=0; i<20; i++) {
Â  Â  Â  Â  Â  Â  Â  Â  ctx.beginPath();
Â  Â  Â  Â  Â  Â  Â  Â  ctx.moveTo(0, Math.random()*512);
Â  Â  Â  Â  Â  Â  Â  Â  ctx.bezierCurveTo(150, Math.random()*512, 350, Math.random()*512, 512, Math.random()*512);
Â  Â  Â  Â  Â  Â  Â  Â  ctx.lineWidth = 10;
Â  Â  Â  Â  Â  Â  Â  Â  ctx.strokeStyle = '#220000';
Â  Â  Â  Â  Â  Â  Â  Â  ctx.stroke();
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  const tex = new THREE.CanvasTexture(canvas);
Â  Â  Â  Â  Â  Â  tex.wrapS = THREE.RepeatWrapping;
Â  Â  Â  Â  Â  Â  tex.wrapT = THREE.RepeatWrapping;
Â  Â  Â  Â  Â  Â  return tex;
Â  Â  Â  Â  }

Â  Â  Â  Â  function createPlankTexture(colorHex) {
Â  Â  Â  Â  Â  Â  const canvas = document.createElement('canvas');
Â  Â  Â  Â  Â  Â  canvas.width = 512; canvas.height = 512;
Â  Â  Â  Â  Â  Â  const ctx = canvas.getContext('2d');
Â  Â  Â  Â  Â  Â  ctx.fillStyle = colorHex;
Â  Â  Â  Â  Â  Â  ctx.fillRect(0,0,512,512);
Â  Â  Â  Â  Â  Â  ctx.lineWidth = 4;
Â  Â  Â  Â  Â  Â  ctx.strokeStyle = '#1a0d05'; 
Â  Â  Â  Â  Â  Â  ctx.beginPath();
Â  Â  Â  Â  Â  Â  const planks = 8;
Â  Â  Â  Â  Â  Â  const step = 512/planks;
Â  Â  Â  Â  Â  Â  for(let i=0; i<=planks; i++) {
Â  Â  Â  Â  Â  Â  Â  Â  ctx.moveTo(0, i*step);
Â  Â  Â  Â  Â  Â  Â  Â  ctx.lineTo(512, i*step);
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  ctx.stroke();
Â  Â  Â  Â  Â  Â  ctx.globalAlpha = 0.5;
Â  Â  Â  Â  Â  Â  for(let i=0; i<planks; i++) {
Â  Â  Â  Â  Â  Â  Â  Â  const x = Math.random() * 512;
Â  Â  Â  Â  Â  Â  Â  Â  ctx.beginPath();
Â  Â  Â  Â  Â  Â  Â  Â  ctx.moveTo(x, i*step);
Â  Â  Â  Â  Â  Â  Â  Â  ctx.lineTo(x, (i+1)*step);
Â  Â  Â  Â  Â  Â  Â  Â  ctx.stroke();
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  const tex = new THREE.CanvasTexture(canvas);
Â  Â  Â  Â  Â  Â  tex.wrapS = THREE.RepeatWrapping;
Â  Â  Â  Â  Â  Â  tex.wrapT = THREE.RepeatWrapping;
Â  Â  Â  Â  Â  Â  return tex;
Â  Â  Â  Â  }

Â  Â  Â  Â  function createFabricTexture(colorHex) {
Â  Â  Â  Â  Â  Â  const canvas = document.createElement('canvas');
Â  Â  Â  Â  Â  Â  canvas.width = 256; canvas.height = 256;
Â  Â  Â  Â  Â  Â  const ctx = canvas.getContext('2d');
Â  Â  Â  Â  Â  Â  ctx.fillStyle = colorHex;
Â  Â  Â  Â  Â  Â  ctx.fillRect(0,0,256,256);
Â  Â  Â  Â  Â  Â  ctx.globalAlpha = 0.05;
Â  Â  Â  Â  Â  Â  ctx.fillStyle = '#ffffff';
Â  Â  Â  Â  Â  Â  for(let i=0; i<256; i+=4) {
Â  Â  Â  Â  Â  Â  Â  Â  ctx.fillRect(i, 0, 1, 256);
Â  Â  Â  Â  Â  Â  Â  Â  ctx.fillRect(0, i, 256, 1);
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  const tex = new THREE.CanvasTexture(canvas);
Â  Â  Â  Â  Â  Â  tex.wrapS = THREE.RepeatWrapping;
Â  Â  Â  Â  Â  Â  tex.wrapT = THREE.RepeatWrapping;
Â  Â  Â  Â  Â  Â  return tex;
Â  Â  Â  Â  }

Â  Â  Â  Â  function createRealisticEnvironment() {
Â  Â  Â  Â  Â  Â  const woodTex = createWoodTexture('#4a3c2a');
Â  Â  Â  Â  Â  Â  const floorTex = createPlankTexture('#2e1e12');
Â  Â  Â  Â  Â  Â  const fabricTex = createFabricTexture('#8f8f8f');
Â  Â  Â  Â  Â  Â  const blanketTex = createFabricTexture('#5e2c2c');
Â  Â  Â  Â  Â  Â  const wallTex = createWoodTexture('#3d2b1f');

Â  Â  Â  Â  Â  Â  const woodMat = new THREE.MeshStandardMaterial({ map: woodTex, roughness: 0.7, metalness: 0.0 });
Â  Â  Â  Â  Â  Â  const wallMat = new THREE.MeshStandardMaterial({ map: wallTex, roughness: 0.8, metalness: 0.0 });
Â  Â  Â  Â  Â  Â  const floorMat = new THREE.MeshStandardMaterial({ map: floorTex, roughness: 0.9, bumpMap: floorTex, bumpScale: 0.02 });
Â  Â  Â  Â  Â  Â  const fabricMat = new THREE.MeshStandardMaterial({ map: fabricTex, roughness: 1.0 });
Â  Â  Â  Â  Â  Â  const blanketMat = new THREE.MeshStandardMaterial({ map: blanketTex, roughness: 1.0 });
Â  Â  Â  Â  Â  Â  const glassMat = new THREE.MeshPhysicalMaterial({ 
Â  Â  Â  Â  Â  Â  Â  Â  color: 0x88ccff, metalness: 0, roughness: 0.1, transmission: 0.9, transparent: true, opacity: 0.3 
Â  Â  Â  Â  Â  Â  });

Â  Â  Â  Â  Â  Â  const floor = new THREE.Mesh(new THREE.PlaneGeometry(roomWidth, roomDepth), floorMat);
Â  Â  Â  Â  Â  Â  floor.rotation.x = -Math.PI / 2;
Â  Â  Â  Â  Â  Â  floor.receiveShadow = true;
Â  Â  Â  Â  Â  Â  scene.add(floor);

Â  Â  Â  Â  Â  Â  const ceilingMat = new THREE.MeshStandardMaterial({ color: 0x1a1a1a, roughness: 0.9 });
Â  Â  Â  Â  Â  Â  const ceiling = new THREE.Mesh(new THREE.PlaneGeometry(roomWidth, roomDepth), ceilingMat);
Â  Â  Â  Â  Â  Â  ceiling.rotation.x = Math.PI / 2;
Â  Â  Â  Â  Â  Â  ceiling.position.y = roomHeight;
Â  Â  Â  Â  Â  Â  scene.add(ceiling);

Â  Â  Â  Â  Â  Â  const bulbGroup = new THREE.Group();
Â  Â  Â  Â  Â  Â  bulbGroup.position.set(0, roomHeight, 0);
Â  Â  Â  Â  Â  Â  bulbGroup.add(new THREE.Mesh(new THREE.CylinderGeometry(0.01, 0.01, 0.5), new THREE.MeshBasicMaterial({color: 0x111111})).translateY(-0.25));
Â  Â  Â  Â  Â  Â  bulbGroup.add(new THREE.Mesh(new THREE.SphereGeometry(0.1, 16, 16), new THREE.MeshStandardMaterial({emissive: 0xffaa00, emissiveIntensity: 2, color: 0xffffff, roughness: 0.1})).translateY(-0.55));
Â  Â  Â  Â  Â  Â  scene.add(bulbGroup);

Â  Â  Â  Â  Â  Â  const plankH = 0.5;
Â  Â  Â  Â  Â  Â  const buildWall = (cx, cz, w, isRotated, hasDoor, hasWin) => {
Â  Â  Â  Â  Â  Â  Â  Â  const container = new THREE.Group();
Â  Â  Â  Â  Â  Â  Â  Â  container.position.set(cx, 0, cz);
Â  Â  Â  Â  Â  Â  Â  Â  if(isRotated) container.rotation.y = Math.PI / 2;

Â  Â  Â  Â  Â  Â  Â  Â  const rows = roomHeight / plankH;
Â  Â  Â  Â  Â  Â  Â  Â  const doorW = 3.0;
Â  Â  Â  Â  Â  Â  Â  Â  const doorH = 3.5;
Â  Â  Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  Â  Â  for(let i=0; i<rows; i++) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const y = i * plankH + plankH/2;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if(hasDoor && y < doorH) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const sideW = (w - doorW) / 2;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const left = new THREE.Mesh(new THREE.BoxGeometry(sideW, plankH-0.02, 0.4), wallMat);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  left.position.set(-w/2 + sideW/2, y, 0);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  left.castShadow = true; left.receiveShadow = true;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  container.add(left);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const right = new THREE.Mesh(new THREE.BoxGeometry(sideW, plankH-0.02, 0.4), wallMat);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  right.position.set(w/2 - sideW/2, y, 0);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  right.castShadow = true; right.receiveShadow = true;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  container.add(right);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if(i === 0) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const pivot = new THREE.Group();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  pivot.position.set(-doorW/2 + 0.1, 0, 0); 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const doorMesh = new THREE.Mesh(new THREE.BoxGeometry(doorW - 0.2, doorH, 0.2), new THREE.MeshStandardMaterial({map:woodTex, color: 0x2b1d0e}));
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  doorMesh.position.set((doorW - 0.2)/2, doorH/2, 0);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  doorMesh.castShadow = true; doorMesh.receiveShadow = true;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const handle = new THREE.Mesh(new THREE.SphereGeometry(0.1), new THREE.MeshStandardMaterial({color:0xdddddd, metalness:0.8}));
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  handle.position.set(doorW - 0.5, doorH/2, 0.15);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  pivot.add(doorMesh); pivot.add(handle);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  pivot.userData = { interactable: true, type: 'door', isOpen: false, label: 'Door' };
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  interactableObjects.push(pivot);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  container.add(pivot);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  else if (hasWin && i > 3 && i < 7) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const winW = 3.0;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const sideW = (w - winW) / 2;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const left = new THREE.Mesh(new THREE.BoxGeometry(sideW, plankH-0.02, 0.4), wallMat);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  left.position.set(-w/2 + sideW/2, y, 0);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  container.add(left);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const right = new THREE.Mesh(new THREE.BoxGeometry(sideW, plankH-0.02, 0.4), wallMat);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  right.position.set(w/2 - sideW/2, y, 0);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  container.add(right);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if(i===5) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const glass = new THREE.Mesh(new THREE.PlaneGeometry(winW, 1.5), glassMat);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  glass.position.set(0, y + 0.25, 0);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  container.add(glass);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const barV = new THREE.Mesh(new THREE.BoxGeometry(0.1, 1.5, 0.1), wallMat);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  barV.position.set(0, y+0.25, 0);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  container.add(barV);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const p = new THREE.Mesh(new THREE.BoxGeometry(w, plankH-0.02, 0.4), wallMat);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  p.position.set(0, y, 0);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  p.position.z += (Math.random()-0.5)*0.05;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  p.castShadow = true; p.receiveShadow = true;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  container.add(p);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  scene.add(container);
Â  Â  Â  Â  Â  Â  };

Â  Â  Â  Â  Â  Â  buildWall(0, -roomDepth/2, roomWidth, false, false, false); 
Â  Â  Â  Â  Â  Â  buildWall(0, roomDepth/2, roomWidth, false, true, false); 
Â  Â  Â  Â  Â  Â  buildWall(-roomWidth/2, 0, roomDepth, true, false, false); 
Â  Â  Â  Â  Â  Â  buildWall(roomWidth/2, 0, roomDepth, true, false, true); 

Â  Â  Â  Â  Â  Â  const bedGroup = new THREE.Group();
Â  Â  Â  Â  Â  Â  bedGroup.position.set(-roomWidth/2 + 2, 0, 0); 
Â  Â  Â  Â  Â  Â  bedGroup.add(new THREE.Mesh(new THREE.BoxGeometry(3, 0.5, 6), woodMat).translateY(0.25));
Â  Â  Â  Â  Â  Â  bedGroup.add(new THREE.Mesh(new THREE.BoxGeometry(2.8, 0.4, 5.8), fabricMat).translateY(0.7));
Â  Â  Â  Â  Â  Â  const pillow = new THREE.Mesh(new THREE.BoxGeometry(1.5, 0.2, 1), fabricMat);
Â  Â  Â  Â  Â  Â  pillow.position.set(0, 0.9, -2.2);
Â  Â  Â  Â  Â  Â  bedGroup.add(pillow);
Â  Â  Â  Â  Â  Â  const blanket = new THREE.Mesh(new THREE.BoxGeometry(3, 0.5, 4), blanketMat);
Â  Â  Â  Â  Â  Â  blanket.position.set(0, 0.8, 1);
Â  Â  Â  Â  Â  Â  bedGroup.add(blanket);
Â  Â  Â  Â  Â  Â  scene.add(bedGroup);

Â  Â  Â  Â  Â  Â  const tableGroup = new THREE.Group();
Â  Â  Â  Â  Â  Â  tableGroup.position.set(roomWidth/2 - 1.5, 0, 0); 
Â  Â  Â  Â  Â  Â  const tableTop = new THREE.Mesh(new THREE.BoxGeometry(2.5, 0.1, 4), woodMat);
Â  Â  Â  Â  Â  Â  tableTop.position.y = 2;
Â  Â  Â  Â  Â  Â  tableTop.receiveShadow = true; tableTop.castShadow = true;
Â  Â  Â  Â  Â  Â  tableGroup.add(tableTop);
Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  const legGeo = new THREE.CylinderGeometry(0.05, 0.05, 2);
Â  Â  Â  Â  Â  Â  const legMesh = new THREE.Mesh(legGeo, woodMat);
Â  Â  Â  Â  Â  Â  const l1=legMesh.clone(); l1.position.set(-1,1,-1.8); tableGroup.add(l1);
Â  Â  Â  Â  Â  Â  const l2=legMesh.clone(); l2.position.set(1,1,-1.8); tableGroup.add(l2);
Â  Â  Â  Â  Â  Â  const l3=legMesh.clone(); l3.position.set(-1,1,1.8); tableGroup.add(l3);
Â  Â  Â  Â  Â  Â  const l4=legMesh.clone(); l4.position.set(1,1,1.8); tableGroup.add(l4);
Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  createHyperDetailedBasket(tableGroup);
Â  Â  Â  Â  Â  Â  scene.add(tableGroup);
Â  Â  Â  Â  }

Â  Â  Â  Â  function createGrasslandExterior() {
Â  Â  Â  Â  Â  Â  // STARFIELD
Â  Â  Â  Â  Â  Â  const starGeo = new THREE.BufferGeometry();
Â  Â  Â  Â  Â  Â  const starCoords = [];
Â  Â  Â  Â  Â  Â  for (let i = 0; i < 6000; i++) {
Â  Â  Â  Â  Â  Â  Â  Â  const x = (Math.random() - 0.5) * 3000;
Â  Â  Â  Â  Â  Â  Â  Â  const y = Math.random() * 1500;
Â  Â  Â  Â  Â  Â  Â  Â  const z = (Math.random() - 0.5) * 3000;
Â  Â  Â  Â  Â  Â  Â  Â  starCoords.push(x, y, z);
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  starGeo.setAttribute('position', new THREE.Float32BufferAttribute(starCoords, 3));
Â  Â  Â  Â  Â  Â  const starMat = new THREE.PointsMaterial({ color: 0xFFFFFF, size: 0.8, transparent: true, opacity: 0.8 });
Â  Â  Â  Â  Â  Â  const stars = new THREE.Points(starGeo, starMat);
Â  Â  Â  Â  Â  Â  scene.add(stars);

Â  Â  Â  Â  Â  Â  // THE MOON (Visible sphere, made bright)
Â  Â  Â  Â  Â  Â  const moonGeo = new THREE.SphereGeometry(25, 32, 32);
Â  Â  Â  Â  Â  Â  const moonMat = new THREE.MeshBasicMaterial({ color: 0xFFFFFF }); // Basic material ignores fog/light
Â  Â  Â  Â  Â  Â  const moonMesh = new THREE.Mesh(moonGeo, moonMat);
Â  Â  Â  Â  Â  Â  moonMesh.position.set(300, 500, -800); // Position it high and far
Â  Â  Â  Â  Â  Â  scene.add(moonMesh);

Â  Â  Â  Â  Â  Â  // FLAT GRASSLAND TERRAIN
Â  Â  Â  Â  Â  Â  const terrainSize = 3000;
Â  Â  Â  Â  Â  Â  const res = 64;
Â  Â  Â  Â  Â  Â  const terrainGeo = new THREE.PlaneGeometry(terrainSize, terrainSize, res, res);
Â  Â  Â  Â  Â  Â  terrainGeo.rotateX(-Math.PI / 2);

Â  Â  Â  Â  Â  Â  const pos = terrainGeo.attributes.position;
Â  Â  Â  Â  Â  Â  const colors = [];
Â  Â  Â  Â  Â  Â  const color = new THREE.Color();
Â  Â  Â  Â  Â  Â  for (let i = 0; i < pos.count; i++) {
Â  Â  Â  Â  Â  Â  Â  Â  let h = (Math.random() - 0.5) * 0.15;
Â  Â  Â  Â  Â  Â  Â  Â  pos.setY(i, h);
Â  Â  Â  Â  Â  Â  Â  Â  const shade = 0.05 + Math.random() * 0.08;
Â  Â  Â  Â  Â  Â  Â  Â  color.setRGB(shade * 0.3, shade, shade * 0.2);
Â  Â  Â  Â  Â  Â  Â  Â  colors.push(color.r, color.g, color.b);
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  terrainGeo.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
Â  Â  Â  Â  Â  Â  terrainGeo.computeVertexNormals();

Â  Â  Â  Â  Â  Â  const terrainMat = new THREE.MeshStandardMaterial({ 
Â  Â  Â  Â  Â  Â  Â  Â  vertexColors: true, 
Â  Â  Â  Â  Â  Â  Â  Â  roughness: 1.0 
Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  const terrain = new THREE.Mesh(terrainGeo, terrainMat);
Â  Â  Â  Â  Â  Â  terrain.position.y = -0.1;
Â  Â  Â  Â  Â  Â  terrain.receiveShadow = true;
Â  Â  Â  Â  Â  Â  scene.add(terrain);

Â  Â  Â  Â  Â  Â  // FOREST (Scattered trees in the flat land)
Â  Â  Â  Â  Â  Â  const treeCount = 2000;
Â  Â  Â  Â  Â  Â  const treeTrunkGeo = new THREE.CylinderGeometry(0.2, 0.4, 10);
Â  Â  Â  Â  Â  Â  const treeFoliageGeo = new THREE.ConeGeometry(5, 18, 6);
Â  Â  Â  Â  Â  Â  const treeTrunkMat = new THREE.MeshStandardMaterial({ color: 0x1a0f0a });
Â  Â  Â  Â  Â  Â  const treeFoliageMat = new THREE.MeshStandardMaterial({ color: 0x051205 });

Â  Â  Â  Â  Â  Â  const instTrunks = new THREE.InstancedMesh(treeTrunkGeo, treeTrunkMat, treeCount);
Â  Â  Â  Â  Â  Â  const instFoliage = new THREE.InstancedMesh(treeFoliageGeo, treeFoliageMat, treeCount);

Â  Â  Â  Â  Â  Â  const dummy = new THREE.Object3D();
Â  Â  Â  Â  Â  Â  for (let i = 0; i < treeCount; i++) {
Â  Â  Â  Â  Â  Â  Â  Â  let x = (Math.random() - 0.5) * 2800;
Â  Â  Â  Â  Â  Â  Â  Â  let z = (Math.random() - 0.5) * 2800;
Â  Â  Â  Â  Â  Â  Â  Â  let r = Math.sqrt(x * x + z * z);
Â  Â  Â  Â  Â  Â  Â  Â  if (r < 40) continue; 

Â  Â  Â  Â  Â  Â  Â  Â  let s = 0.4 + Math.random() * 1.6;
Â  Â  Â  Â  Â  Â  Â  Â  dummy.position.set(x, 5 * s - 0.1, z);
Â  Â  Â  Â  Â  Â  Â  Â  dummy.scale.set(s, s, s);
Â  Â  Â  Â  Â  Â  Â  Â  dummy.updateMatrix();
Â  Â  Â  Â  Â  Â  Â  Â  instTrunks.setMatrixAt(i, dummy.matrix);

Â  Â  Â  Â  Â  Â  Â  Â  dummy.position.set(x, 12 * s - 0.1, z);
Â  Â  Â  Â  Â  Â  Â  Â  dummy.updateMatrix();
Â  Â  Â  Â  Â  Â  Â  Â  instFoliage.setMatrixAt(i, dummy.matrix);
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  scene.add(instTrunks);
Â  Â  Â  Â  Â  Â  scene.add(instFoliage);
Â  Â  Â  Â  }

Â  Â  Â  Â  function createHyperDetailedBasket(parentGroup) {
Â  Â  Â  Â  Â  Â  const basketGroup = new THREE.Group();
Â  Â  Â  Â  Â  Â  basketGroup.position.set(0, 2.05, 0);
Â  Â  Â  Â  Â  Â  basketGroup.rotation.y = Math.random();

Â  Â  Â  Â  Â  Â  const wickerMat = new THREE.MeshStandardMaterial({color: 0x8b5a2b, roughness: 1.0});
Â  Â  Â  Â  Â  Â  const uprightsCount = 16;
Â  Â  Â  Â  Â  Â  const radius = 0.4;
Â  Â  Â  Â  Â  Â  const height = 0.5;
Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  for(let i=0; i<uprightsCount; i++) {
Â  Â  Â  Â  Â  Â  Â  Â  const angle = (i / uprightsCount) * Math.PI * 2;
Â  Â  Â  Â  Â  Â  Â  Â  const rib = new THREE.Mesh(new THREE.CylinderGeometry(0.02, 0.02, height), wickerMat);
Â  Â  Â  Â  Â  Â  Â  Â  rib.position.set(Math.cos(angle) * radius, height/2, Math.sin(angle) * radius);
Â  Â  Â  Â  Â  Â  Â  Â  rib.rotation.z = (Math.random()-0.5)*0.1;
Â  Â  Â  Â  Â  Â  Â  Â  rib.rotation.x = (Math.random()-0.5)*0.1;
Â  Â  Â  Â  Â  Â  Â  Â  basketGroup.add(rib);
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  const strandCount = 15;
Â  Â  Â  Â  Â  Â  for(let j=0; j<strandCount; j++) {
Â  Â  Â  Â  Â  Â  Â  Â  const y = (j / strandCount) * height + 0.02;
Â  Â  Â  Â  Â  Â  Â  Â  const weaveRing = new THREE.Mesh(new THREE.TorusGeometry(radius, 0.015, 4, 32), wickerMat);
Â  Â  Â  Â  Â  Â  Â  Â  weaveRing.rotation.x = Math.PI / 2;
Â  Â  Â  Â  Â  Â  Â  Â  weaveRing.position.y = y;
Â  Â  Â  Â  Â  Â  Â  Â  const scaleNoise = 1 + (Math.random()-0.5)*0.05;
Â  Â  Â  Â  Â  Â  Â  Â  weaveRing.scale.set(scaleNoise, scaleNoise, 1);
Â  Â  Â  Â  Â  Â  Â  Â  basketGroup.add(weaveRing);
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  const bottom = new THREE.Mesh(new THREE.CylinderGeometry(radius, radius, 0.02, 32), wickerMat);
Â  Â  Â  Â  Â  Â  bottom.position.y = 0.01;
Â  Â  Â  Â  Â  Â  basketGroup.add(bottom);

Â  Â  Â  Â  Â  Â  const coalCount = 400; 
Â  Â  Â  Â  Â  Â  const coalGeo = new THREE.DodecahedronGeometry(0.06, 0); 
Â  Â  Â  Â  Â  Â  const coalMat = new THREE.MeshStandardMaterial({color: 0x111111, roughness: 0.6, metalness: 0.2});
Â  Â  Â  Â  Â  Â  const instancedCoal = new THREE.InstancedMesh(coalGeo, coalMat, coalCount);
Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  const dummy = new THREE.Object3D();
Â  Â  Â  Â  Â  Â  for(let i=0; i<coalCount; i++) {
Â  Â  Â  Â  Â  Â  Â  Â  const angle = Math.random() * Math.PI * 2;
Â  Â  Â  Â  Â  Â  Â  Â  const r = Math.sqrt(Math.random()) * (radius - 0.05); 
Â  Â  Â  Â  Â  Â  Â  Â  const hBase = Math.sqrt(1 - (r/radius)); 
Â  Â  Â  Â  Â  Â  Â  Â  const y = (Math.random() * 0.3) + (hBase * 0.3); 
Â  Â  Â  Â  Â  Â  Â  Â  dummy.position.set(Math.cos(angle) * r, y, Math.sin(angle) * r);
Â  Â  Â  Â  Â  Â  Â  Â  dummy.rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, Math.random()*Math.PI);
Â  Â  Â  Â  Â  Â  Â  Â  const s = 0.5 + Math.random() * 0.8;
Â  Â  Â  Â  Â  Â  Â  Â  dummy.scale.set(s, s, s);
Â  Â  Â  Â  Â  Â  Â  Â  dummy.updateMatrix();
Â  Â  Â  Â  Â  Â  Â  Â  instancedCoal.setMatrixAt(i, dummy.matrix);
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  instancedCoal.castShadow = true;
Â  Â  Â  Â  Â  Â  instancedCoal.receiveShadow = true;
Â  Â  Â  Â  Â  Â  basketGroup.add(instancedCoal);

Â  Â  Â  Â  Â  Â  basketGroup.userData = { interactable: true, type: 'pickup', label: 'Basket of Coal' };
Â  Â  Â  Â  Â  Â  interactableObjects.push(basketGroup);
Â  Â  Â  Â  Â  Â  parentGroup.add(basketGroup);
Â  Â  Â  Â  }

Â  Â  Â  Â  // --- CONTROLS LOGIC ---
Â  Â  Â  Â  function setupTouchControls() {
Â  Â  Â  Â  Â  Â  const zoneMove = document.getElementById('zone-move');
Â  Â  Â  Â  Â  Â  const zoneLook = document.getElementById('zone-look');

Â  Â  Â  Â  Â  Â  zoneMove.addEventListener('touchstart', (e) => {
Â  Â  Â  Â  Â  Â  Â  Â  e.preventDefault();
Â  Â  Â  Â  Â  Â  Â  Â  touchMoveOrigin = { x: e.touches[0].clientX, y: e.touches[0].clientY };
Â  Â  Â  Â  Â  Â  }, { passive: false });

Â  Â  Â  Â  Â  Â  zoneMove.addEventListener('touchmove', (e) => {
Â  Â  Â  Â  Â  Â  Â  Â  e.preventDefault();
Â  Â  Â  Â  Â  Â  Â  Â  if (!touchMoveOrigin) return;
Â  Â  Â  Â  Â  Â  Â  Â  const currentX = e.touches[0].clientX;
Â  Â  Â  Â  Â  Â  Â  Â  const currentY = e.touches[0].clientY;
Â  Â  Â  Â  Â  Â  Â  Â  const maxDist = 50; 
Â  Â  Â  Â  Â  Â  Â  Â  let dx = (currentX - touchMoveOrigin.x) / maxDist;
Â  Â  Â  Â  Â  Â  Â  Â  let dy = (currentY - touchMoveOrigin.y) / maxDist;
Â  Â  Â  Â  Â  Â  Â  Â  if (dx > 1) dx = 1; if (dx < -1) dx = -1;
Â  Â  Â  Â  Â  Â  Â  Â  if (dy > 1) dy = 1; if (dy < -1) dy = -1;
Â  Â  Â  Â  Â  Â  Â  Â  mobileMoveVector = { x: dx, y: dy };
Â  Â  Â  Â  Â  Â  }, { passive: false });

Â  Â  Â  Â  Â  Â  zoneMove.addEventListener('touchend', (e) => {
Â  Â  Â  Â  Â  Â  Â  Â  e.preventDefault();
Â  Â  Â  Â  Â  Â  Â  Â  touchMoveOrigin = null;
Â  Â  Â  Â  Â  Â  Â  Â  mobileMoveVector = { x: 0, y: 0 };
Â  Â  Â  Â  Â  Â  }, { passive: false });

Â  Â  Â  Â  Â  Â  zoneLook.addEventListener('touchstart', (e) => {
Â  Â  Â  Â  Â  Â  Â  Â  e.preventDefault();
Â  Â  Â  Â  Â  Â  Â  Â  if(e.target.id === 'interact-btn') return;
Â  Â  Â  Â  Â  Â  Â  Â  touchLookLast = { x: e.touches[0].clientX, y: e.touches[0].clientY };
Â  Â  Â  Â  Â  Â  }, { passive: false });

Â  Â  Â  Â  Â  Â  zoneLook.addEventListener('touchmove', (e) => {
Â  Â  Â  Â  Â  Â  Â  Â  e.preventDefault();
Â  Â  Â  Â  Â  Â  Â  Â  if (!touchLookLast) return;
Â  Â  Â  Â  Â  Â  Â  Â  const currentX = e.touches[0].clientX;
Â  Â  Â  Â  Â  Â  Â  Â  const currentY = e.touches[0].clientY;
Â  Â  Â  Â  Â  Â  Â  Â  const sensitivity = 0.003; 
Â  Â  Â  Â  Â  Â  Â  Â  const dx = currentX - touchLookLast.x;
Â  Â  Â  Â  Â  Â  Â  Â  const dy = currentY - touchLookLast.y;
Â  Â  Â  Â  Â  Â  Â  Â  camera.rotation.y -= dx * sensitivity;
Â  Â  Â  Â  Â  Â  Â  Â  camera.rotation.x -= dy * sensitivity; 
Â  Â  Â  Â  Â  Â  Â  Â  camera.rotation.x = Math.max(-pitchLimit, Math.min(pitchLimit, camera.rotation.x));
Â  Â  Â  Â  Â  Â  Â  Â  camera.rotation.z = 0;
Â  Â  Â  Â  Â  Â  Â  Â  touchLookLast = { x: currentX, y: currentY };
Â  Â  Â  Â  Â  Â  }, { passive: false });

Â  Â  Â  Â  Â  Â  zoneLook.addEventListener('touchend', (e) => {
Â  Â  Â  Â  Â  Â  Â  Â  e.preventDefault();
Â  Â  Â  Â  Â  Â  Â  Â  touchLookLast = null;
Â  Â  Â  Â  Â  Â  }, { passive: false });
Â  Â  Â  Â  }
Â  Â  Â  Â  
Â  Â  Â  Â  function attemptInteraction() {
Â  Â  Â  Â  Â  Â  if (currentTarget) {
Â  Â  Â  Â  Â  Â  Â  Â  const obj = currentTarget.object;
Â  Â  Â  Â  Â  Â  Â  Â  if (obj.userData.type === 'pickup') {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (heldItem) dropItem();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  heldItem = obj;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  let parent = obj.parent;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  parent.remove(obj);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  handGroup.add(obj);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  obj.position.set(0, 0, 0);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  obj.rotation.set(0, 0, 0);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  obj.scale.set(0.5, 0.5, 0.5); 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  interactLabel.style.display = 'none';
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  currentTarget = null;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  else if (obj.userData.type === 'door') {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  obj.userData.isOpen = !obj.userData.isOpen;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const targetRot = obj.userData.isOpen ? -Math.PI / 2 : 0;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const duration = 500;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const startRot = obj.rotation.y;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const startTime = performance.now();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  function animateDoor(time) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const elapsed = time - startTime;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const progress = Math.min(elapsed / duration, 1);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const ease = 1 - Math.pow(1 - progress, 3);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  obj.rotation.y = startRot + (targetRot - startRot) * ease;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (progress < 1) requestAnimationFrame(animateDoor);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  requestAnimationFrame(animateDoor);
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  } 
Â  Â  Â  Â  Â  Â  else if (heldItem) {
Â  Â  Â  Â  Â  Â  Â  Â  dropItem();
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }

Â  Â  Â  Â  function dropItem() {
Â  Â  Â  Â  Â  Â  if(!heldItem) return;
Â  Â  Â  Â  Â  Â  handGroup.remove(heldItem);
Â  Â  Â  Â  Â  Â  scene.add(heldItem);
Â  Â  Â  Â  Â  Â  const dropPos = new THREE.Vector3();
Â  Â  Â  Â  Â  Â  camera.getWorldPosition(dropPos);
Â  Â  Â  Â  Â  Â  const dir = new THREE.Vector3();
Â  Â  Â  Â  Â  Â  camera.getWorldDirection(dir);
Â  Â  Â  Â  Â  Â  dropPos.add(dir.clone().multiplyScalar(1.0)); 
Â  Â  Â  Â  Â  Â  heldItem.position.copy(dropPos);
Â  Â  Â  Â  Â  Â  heldItem.scale.set(1, 1, 1);
Â  Â  Â  Â  Â  Â  heldItem.userData.velocity = new THREE.Vector3(dir.x * 5, 2, dir.z * 5);
Â  Â  Â  Â  Â  Â  fallingObjects.push(heldItem);
Â  Â  Â  Â  Â  Â  heldItem = null;
Â  Â  Â  Â  Â  Â  interactLabel.style.display = 'none';
Â  Â  Â  Â  }

Â  Â  Â  Â  function handleInteractMobile(e) {
Â  Â  Â  Â  Â  Â  e.preventDefault(); e.stopPropagation();
Â  Â  Â  Â  Â  Â  attemptInteraction();
Â  Â  Â  Â  Â  Â  interactBtn.style.background = 'rgba(255,255,255,0.5)';
Â  Â  Â  Â  Â  Â  setTimeout(() => { interactBtn.style.background = 'rgba(255,255,255,0.1)'; }, 100);
Â  Â  Â  Â  }

Â  Â  Â  Â  function startGame() {
Â  Â  Â  Â  Â  Â  startScreen.style.opacity = '0';
Â  Â  Â  Â  Â  Â  setTimeout(() => {
Â  Â  Â  Â  Â  Â  Â  Â  startScreen.style.display = 'none';
Â  Â  Â  Â  Â  Â  Â  Â  playCutscene();
Â  Â  Â  Â  Â  Â  }, 500);
Â  Â  Â  Â  }

Â  Â  Â  Â  function playCutscene() {
Â  Â  Â  Â  Â  Â  const t_text1 = 1500, t_blink1 = 4500, t_text2 = 7000, t_blink2 = 10000, t_blink3 = 12000, t_realization = 13500, t_panic = 16000, t_stand = 17500;
Â  Â  Â  Â  Â  Â  const showText = (text, duration) => {
Â  Â  Â  Â  Â  Â  Â  Â  textElement.innerText = text; textElement.style.opacity = 1;
Â  Â  Â  Â  Â  Â  Â  Â  setTimeout(() => { textElement.style.opacity = 0; }, duration - 500);
Â  Â  Â  Â  Â  Â  };
Â  Â  Â  Â  Â  Â  setTimeout(() => showText("Damn. What was last night's dream...", 3000), t_text1);
Â  Â  Â  Â  Â  Â  setTimeout(() => { eyelids.style.opacity = 0.3; textElement.innerText = ""; }, t_blink1);
Â  Â  Â  Â  Â  Â  setTimeout(() => { eyelids.style.opacity = 1; }, t_blink1 + 1000); 
Â  Â  Â  Â  Â  Â  setTimeout(() => showText("I think I should take more rest...", 3000), t_text2);
Â  Â  Â  Â  Â  Â  setTimeout(() => { eyelids.style.opacity = 0.2; }, t_blink2);
Â  Â  Â  Â  Â  Â  setTimeout(() => { eyelids.style.opacity = 1; }, t_blink2 + 800);
Â  Â  Â  Â  Â  Â  setTimeout(() => { eyelids.style.opacity = 0; }, t_blink3);
Â  Â  Â  Â  Â  Â  setTimeout(() => showText("Wait... what time is it??!!??", 2000), t_realization);
Â  Â  Â  Â  Â  Â  setTimeout(() => showText("OH NO I'M LATE", 1500), t_panic);
Â  Â  Â  Â  Â  Â  setTimeout(() => { standUpAnimation(); }, t_stand);
Â  Â  Â  Â  }

Â  Â  Â  Â  function standUpAnimation() {
Â  Â  Â  Â  Â  Â  let startTime = null; const duration = 2000; 
Â  Â  Â  Â  Â  Â  const startPos = camera.position.clone();
Â  Â  Â  Â  Â  Â  const startRotX = camera.rotation.x, startRotY = camera.rotation.y, startRotZ = camera.rotation.z;
Â  Â  Â  Â  Â  Â  const endPos = new THREE.Vector3(startPos.x + 1.5, defaultCamHeight, 0); 
Â  Â  Â  Â  Â  Â  function anim(time) {
Â  Â  Â  Â  Â  Â  Â  Â  if (!startTime) startTime = time;
Â  Â  Â  Â  Â  Â  Â  Â  const progress = Math.min((time - startTime) / duration, 1);
Â  Â  Â  Â  Â  Â  Â  Â  const ease = 1 - Math.pow(1 - progress, 3);
Â  Â  Â  Â  Â  Â  Â  Â  camera.position.lerpVectors(startPos, endPos, ease);
Â  Â  Â  Â  Â  Â  Â  Â  camera.rotation.x = startRotX + (0 - startRotX) * ease;
Â  Â  Â  Â  Â  Â  Â  Â  camera.rotation.y = startRotY + (0 - startRotY) * ease;
Â  Â  Â  Â  Â  Â  Â  Â  camera.rotation.z = startRotZ + (0 - startRotZ) * ease;
Â  Â  Â  Â  Â  Â  Â  Â  if (progress < 1) requestAnimationFrame(anim);
Â  Â  Â  Â  Â  Â  Â  Â  else enableGameplay();
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  requestAnimationFrame(anim);
Â  Â  Â  Â  }

Â  Â  Â  Â  function enableGameplay() {
Â  Â  Â  Â  Â  Â  isCutsceneActive = false; crosshair.style.display = 'block'; textElement.innerText = ""; 
Â  Â  Â  Â  Â  Â  if(!isMobile()) {
Â  Â  Â  Â  Â  Â  Â  Â  pauseScreen.style.display = 'flex';
Â  Â  Â  Â  Â  Â  Â  Â  pauseScreen.querySelector('h1').innerText = "CLICK TO START";
Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  document.getElementById('mobile-ui').style.display = 'block';
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }

Â  Â  Â  Â  function isMobile() {
Â  Â  Â  Â  Â  Â  return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth < 900;
Â  Â  Â  Â  }

Â  Â  Â  Â  function onKeyDown(event) {
Â  Â  Â  Â  Â  Â  switch (event.code) {
Â  Â  Â  Â  Â  Â  Â  Â  case 'ArrowUp': case 'KeyW': moveForward = true; break;
Â  Â  Â  Â  Â  Â  Â  Â  case 'ArrowLeft': case 'KeyA': moveLeft = true; break;
Â  Â  Â  Â  Â  Â  Â  Â  case 'ArrowDown': case 'KeyS': moveBackward = true; break;
Â  Â  Â  Â  Â  Â  Â  Â  case 'ArrowRight': case 'KeyD': moveRight = true; break;
Â  Â  Â  Â  Â  Â  Â  Â  case 'KeyE': attemptInteraction(); break;
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  Â  function onKeyUp(event) {
Â  Â  Â  Â  Â  Â  switch (event.code) {
Â  Â  Â  Â  Â  Â  Â  Â  case 'ArrowUp': case 'KeyW': moveForward = false; break;
Â  Â  Â  Â  Â  Â  Â  Â  case 'ArrowLeft': case 'KeyA': moveLeft = false; break;
Â  Â  Â  Â  Â  Â  Â  Â  case 'ArrowDown': case 'KeyS': moveBackward = false; break;
Â  Â  Â  Â  Â  Â  Â  Â  case 'ArrowRight': case 'KeyD': moveRight = false; break;
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  Â  function onMouseDown(event) {
Â  Â  Â  Â  Â  Â  if(!isCutsceneActive && controls.isLocked && event.button === 0) attemptInteraction();
Â  Â  Â  Â  }
Â  Â  Â  Â  function onWindowResize() {
Â  Â  Â  Â  Â  Â  camera.aspect = window.innerWidth / window.innerHeight;
Â  Â  Â  Â  Â  Â  camera.updateProjectionMatrix();
Â  Â  Â  Â  Â  Â  renderer.setSize(window.innerWidth, window.innerHeight);
Â  Â  Â  Â  }

Â  Â  Â  Â  function updateInteractionUI() {
Â  Â  Â  Â  Â  Â  if(heldItem && !currentTarget) {
Â  Â  Â  Â  Â  Â  Â  Â  Â interactLabel.style.display = 'block';
Â  Â  Â  Â  Â  Â  Â  Â  Â interactLabel.innerHTML = `Drop ${heldItem.userData.label} <span class="key-hint">[E]</span>`;
Â  Â  Â  Â  Â  Â  } else if (!currentTarget && !heldItem) {
Â  Â  Â  Â  Â  Â  Â  Â  interactLabel.style.display = 'none';
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  raycaster.setFromCamera(center, camera);
Â  Â  Â  Â  Â  Â  const intersects = raycaster.intersectObjects(interactableObjects, true); 
Â  Â  Â  Â  Â  Â  let hit = null;
Â  Â  Â  Â  Â  Â  if(intersects.length > 0) {
Â  Â  Â  Â  Â  Â  Â  Â  let obj = intersects[0].object;
Â  Â  Â  Â  Â  Â  Â  Â  let dist = intersects[0].distance;
Â  Â  Â  Â  Â  Â  Â  Â  while(obj) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if(obj.userData && obj.userData.interactable) break;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  obj = obj.parent;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  if (obj && dist < 3.5) hit = obj;
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  if(hit) {
Â  Â  Â  Â  Â  Â  Â  Â  currentTarget = { object: hit };
Â  Â  Â  Â  Â  Â  Â  Â  interactLabel.style.display = 'block';
Â  Â  Â  Â  Â  Â  Â  Â  const action = hit.userData.type === 'door' ? (hit.userData.isOpen ? 'Close' : 'Open') : 'Grab';
Â  Â  Â  Â  Â  Â  Â  Â  interactLabel.innerHTML = `${action} ${hit.userData.label} <span class="key-hint">[E]</span>`;
Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  currentTarget = null;
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }

Â  Â  Â  Â  function animate() {
Â  Â  Â  Â  Â  Â  requestAnimationFrame(animate);
Â  Â  Â  Â  Â  Â  if (!isCutsceneActive && !isPaused) {
Â  Â  Â  Â  Â  Â  Â  Â  const time = performance.now();
Â  Â  Â  Â  Â  Â  Â  Â  const delta = Math.min((time - prevTime) / 1000, 0.1); 
Â  Â  Â  Â  Â  Â  Â  Â  for(let i = fallingObjects.length - 1; i >= 0; i--) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const obj = fallingObjects[i];
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  obj.userData.velocity.y -= 20.0 * delta; 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  obj.position.add(obj.userData.velocity.clone().multiplyScalar(delta));
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const onTableX = obj.position.x > 2.25 && obj.position.x < 4.75;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const onTableZ = obj.position.z > -2 && obj.position.z < 2;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (onTableX && onTableZ && obj.position.y < 2.25 && obj.position.y > 1.5) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  obj.position.y = 2.25; obj.userData.velocity.set(0,0,0);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  fallingObjects.splice(i, 1); continue;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (obj.position.y < 0.25) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  obj.position.y = 0.25; obj.userData.velocity.set(0,0,0);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  fallingObjects.splice(i, 1); continue;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  velocity.x -= velocity.x * 10.0 * delta; velocity.z -= velocity.z * 10.0 * delta;
Â  Â  Â  Â  Â  Â  Â  Â  direction.z = Number(moveForward) - Number(moveBackward); direction.x = Number(moveRight) - Number(moveLeft);
Â  Â  Â  Â  Â  Â  Â  Â  let inputZ = direction.z; let inputX = direction.x;
Â  Â  Â  Â  Â  Â  Â  Â  if (Math.abs(mobileMoveVector.y) > 0) inputZ = -mobileMoveVector.y; 
Â  Â  Â  Â  Â  Â  Â  Â  if (Math.abs(mobileMoveVector.x) > 0) inputX = mobileMoveVector.x;
Â  Â  Â  Â  Â  Â  Â  Â  const speed = 40.0; 
Â  Â  Â  Â  Â  Â  Â  Â  if (inputZ !== 0) velocity.z -= inputZ * speed * delta;
Â  Â  Â  Â  Â  Â  Â  Â  if (inputX !== 0) velocity.x -= inputX * speed * delta;
Â  Â  Â  Â  Â  Â  Â  Â  controls.moveRight(-velocity.x * delta); controls.moveForward(-velocity.z * delta);
Â  Â  Â  Â  Â  Â  Â  Â  if (Math.abs(velocity.x) > 1 || Math.abs(velocity.z) > 1) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  bobTimer += delta * bobFrequency;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  camera.position.y = defaultCamHeight + Math.sin(bobTimer) * bobAmplitude;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  swayX = Math.sin(bobTimer * 0.5) * 0.05; swayY = Math.abs(Math.cos(bobTimer)) * 0.05;
Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  camera.position.y = THREE.MathUtils.lerp(camera.position.y, defaultCamHeight, delta * 5);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  swayX = THREE.MathUtils.lerp(swayX, 0, delta * 5); swayY = THREE.MathUtils.lerp(swayY, 0, delta * 5);
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  handGroup.position.x = 0.5 + swayX; handGroup.position.y = -0.6 + swayY; handGroup.rotation.z = swayX;
Â  Â  Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  Â  Â  // COLLISION AND BOUNDARIES
Â  Â  Â  Â  Â  Â  Â  Â  const doorBound = roomDepth/2 - 1.2; 
Â  Â  Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  Â  Â  // If deep inside the cottage area
Â  Â  Â  Â  Â  Â  Â  Â  if(camera.position.z < doorBound) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if(camera.position.x < -roomWidth/2 + 1) camera.position.x = -roomWidth/2 + 1;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if(camera.position.x > roomWidth/2 - 1) camera.position.x = roomWidth/2 - 1;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if(camera.position.z < -roomDepth/2 + 1) camera.position.z = -roomDepth/2 + 1;
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  // Boundary logic near the door exit
Â  Â  Â  Â  Â  Â  Â  Â  const door = interactableObjects.find(o => o.userData.type === 'door');
Â  Â  Â  Â  Â  Â  Â  Â  const isDoorOpen = door && door.userData.isOpen;
Â  Â  Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  Â  Â  // If approaching or at the door threshold
Â  Â  Â  Â  Â  Â  Â  Â  if(camera.position.z >= doorBound && camera.position.z < doorBound + 1.0) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const isAligned = Math.abs(camera.position.x) < 1.2; 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (!isDoorOpen || !isAligned) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Not going through door? Block them.
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  camera.position.z = doorBound;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  Â  Â  // Once well outside (z > threshold), movement is completely free
Â  Â  Â  Â  Â  Â  Â  Â  // No constraints applied to x or z here.
Â  Â  Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  Â  Â  updateInteractionUI(); prevTime = time;
Â  Â  Â  Â  Â  Â  } else { prevTime = performance.now(); }
Â  Â  Â  Â  Â  Â  if(Math.random() > 0.95) {
Â  Â  Â  Â  Â  Â  Â  Â scene.children.forEach(c => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â if(c.userData && c.userData.isMainLight) c.intensity = c.userData.baseInt * (0.8 + Math.random() * 0.4);
Â  Â  Â  Â  Â  Â  Â  Â });
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  renderer.render(scene, camera);
Â  Â  Â  Â  }
Â  Â  Â  Â  THREE.Mesh.prototype.translateY = function(d) { this.position.y += d; return this; }
Â  Â  </script>
</body>
</html>

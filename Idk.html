<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Liminal Dreamscape Simulator</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
        canvas { display: block; }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #fff;
            font-family: monospace;
            font-size: 24px;
            cursor: pointer;
            text-align: center;
        }
        #status {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #fff;
            font-family: monospace;
            font-size: 16px;
            opacity: 0;
            transition: opacity 1s;
        }
        #fade {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: white; /* Used for the quick flash */
            opacity: 0;
            pointer-events: none;
            transition: opacity 3s;
        }
        #console {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 250px;
            background: rgba(0, 0, 0, 0.9);
            color: lime;
            font-family: monospace;
            padding: 10px;
            box-sizing: border-box;
            display: none;
            opacity: 0;
            transition: opacity 0.3s;
        }
        #output {
            height: 80%;
            overflow-y: scroll;
            margin-bottom: 5px;
            border-bottom: 1px solid lime;
        }
        #input {
            width: calc(100% - 10px);
            background: transparent;
            border: none;
            color: lime;
            font-family: monospace;
            outline: none;
            font-size: 16px;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/0.165.0/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.165.0/examples/js/controls/PointerLockControls.js"></script>
</head>
<body>

    <div id="loading">Click to Start Dream (W/A/S/D to move, / to open console)</div>
    <div id="status">
        Map: <span id="mapName">Loading...</span><br>
        Dream Count: <span id="dream">0</span><br>
        Stability: <span id="stability">100</span>
    </div>
    <div id="fade"></div>
    <div id="console">
        <div id="output">
            --- DREAM CONSOLE v1.1 ---<br>
            Available commands: `map man`, `skip map`<br>
        </div>
        &gt; <input type="text" id="input">
    </div>

    <script>
        // --- Core Variables ---
        let scene, camera, renderer, controls;
        let move = {forward:false, backward:false, left:false, right:false};
        let velocity = new THREE.Vector3();
        let clock = new THREE.Clock();
        let dreamCount = 0;
        let sanity = 100;
        let isShifting = false;
        let fadeScreen = document.getElementById('fade');
        let currentWorld = [];
        let nextShift = 15 + Math.random() * 30;
        let manPosition = new THREE.Vector3();
        let isManMapActive = false;
        let consoleOpen = false;
        let textureLoader = new THREE.TextureLoader();

        // --- Audio Variables ---
        let audioContext;
        let currentMusic = null;
        let creepyTracks = [
            "https://files.catbox.moe/4g5v3r.ogg", "https://files.catbox.moe/9p1r7t.ogg", 
            "https://files.catbox.moe/m3b8v9.ogg", "https://files.catbox.moe/q1w5e2.ogg"
        ];
        let currentAmbientSound = null;

        // --- MAP CONFIGURATION ---
        const MAP_CATALOG = [
            { id: 0, name: "Trippy Liminal", generator: generateTrippyLiminal, sound: "https://files.catbox.moe/9p1r7t.ogg" },
            { id: 1, name: "4D Impossible", generator: generate4DImpossible, sound: "https://files.catbox.moe/m3b8v9.ogg" },
            { id: 2, name: "Red Void", generator: generateRedVoid, sound: "https://files.catbox.moe/4g5v3r.ogg" },
            { id: 3, name: "Endless Fall", generator: generateEndlessFall, sound: "https://files.catbox.moe/q1w5e2.ogg" },
            { id: 4, name: "Mirror Maze", generator: generateMirrorMaze, sound: "https://files.catbox.moe/m3b8v9.ogg" },
            { id: 5, name: "Backrooms Classic", generator: generateBackroomsClassic, sound: "https://files.catbox.moe/4g5v3r.ogg" },
            { id: 6, name: "Empty Mall", generator: generateEmptyMall, sound: "https://files.catbox.moe/q1w5e2.ogg" },
            { id: 7, name: "Infinite Hotel", generator: generateInfiniteHotel, sound: "https://files.catbox.moe/9p1r7t.ogg" },
            { id: 8, name: "Poolrooms", generator: generatePoolrooms, sound: "https://files.catbox.moe/4g5v3r.ogg" }, 
            { id: 9, name: "Office Hell", generator: generateOfficeHell, sound: "https://files.catbox.moe/m3b8v9.ogg" }, 
            { id: 10, name: "Retro Arcade", generator: generateRetroArcade, sound: "https://files.catbox.moe/q1w5e2.ogg" }, 
            { id: 11, name: "Neon City Rooftops", generator: generateNeonRooftops, sound: "https://files.catbox.moe/9p1r7t.ogg" }, 
            { id: 12, name: "VHS Static Desert", generator: generateStaticDesert, sound: "https://files.catbox.moe/4g5v3r.ogg" }, 
            { id: 13, name: "Submerged Highway", generator: generateSubmergedHighway, sound: "https://files.catbox.moe/m3b8v9.ogg" }, 
            { id: 14, name: "Endless Train Platform", generator: generateTrainPlatform, sound: "https://files.catbox.moe/q1w5e2.ogg" }, 
            { id: 15, name: "The Quiet Street", generator: generateQuietStreet, sound: "https://files.catbox.moe/9p1r7t.ogg" }, 
            { id: 16, name: "Backrooms Hell", generator: generateBackroomsHell, sound: "https://files.catbox.moe/4g5v3r.ogg" }, 
        ];

        init();
        initAudio();
        animate();

        // --- Initialization and Setup ---
        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 3000);
            camera.position.set(0, 1.8, 10);
            
            renderer = new THREE.WebGLRenderer({antialias:true});
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);

            const sun = new THREE.DirectionalLight(0xffffff, 1.2);
            sun.position.set(50, 100, 30);
            sun.castShadow = true;
            sun.shadow.mapSize.width = 2048; 
            sun.shadow.mapSize.height = 2048;
            scene.add(new THREE.AmbientLight(0xffffff, 0.4));
            scene.add(sun);

            controls = new THREE.PointerLockControls(camera, document.body);
            scene.add(controls.getObject());

            document.addEventListener('click', () => {
                if(!controls.isLocked) {
                    controls.lock();
                    document.getElementById('loading').style.display = 'none';
                    document.getElementById('status').style.opacity = '1';
                    playRandomMusic();
                }
            });
            document.addEventListener('keydown', e => {
                if (e.code === 'Slash' && !consoleOpen) { e.preventDefault(); showConsole(); }
                if (e.code === 'Backslash') { e.preventDefault(); hideConsole(); }
                if (consoleOpen && (e.code === 'Enter' || e.code === 'NumpadEnter')) return;
                switch(e.code) {
                    case 'KeyW': case 'ArrowUp': move.forward = true; break;
                    case 'KeyS': case 'ArrowDown': move.backward = true; break;
                    case 'KeyA': case 'ArrowLeft': move.left = true; break;
                    case 'KeyD': case 'ArrowRight': move.right = true; break;
                }
            });
            document.addEventListener('keyup', e => {
                switch(e.code) {
                    case 'KeyW': case 'ArrowUp': move.forward = false; break;
                    case 'KeyS': case 'ArrowDown': move.backward = false; break;
                    case 'KeyA': case 'ArrowLeft': move.left = false; break;
                    case 'KeyD': case 'ArrowRight': move.right = false; break;
                }
            });
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
            
            generateDreamWorld();
        }

        // --- Audio Functions ---
        function initAudio() {
            document.addEventListener('click', () => {
                if (audioContext) return;
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }, {once: true});
        }
        function playRandomMusic() {
            if(currentMusic) currentMusic.pause();
            const track = creepyTracks[Math.floor(Math.random()*creepyTracks.length)];
            currentMusic = new Audio(track);
            currentMusic.loop = true;
            currentMusic.volume = 0.45;
            currentMusic.play().catch(()=>{});
        }
        function changeMusic() {
            if(currentMusic) {
                let v = 0.45;
                const fade = setInterval(() => {
                    v = Math.max(0, v - 0.02);
                    currentMusic.volume = v;
                    if(v <= 0.01) { clearInterval(fade); playRandomMusic(); }
                }, 50);
            } else {
                playRandomMusic();
            }
        }
        function changeAmbientSound(trackURL) {
            if (currentAmbientSound) { currentAmbientSound.pause(); currentAmbientSound = null; }
            if (trackURL) {
                currentAmbientSound = new Audio(trackURL);
                currentAmbientSound.loop = true;
                currentAmbientSound.volume = 0.8;
                currentAmbientSound.play().catch(()=>{});
            }
        }
        function playShiftSound() {
            if (!audioContext) return;
            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();
            osc.frequency.setValueAtTime(400, audioContext.currentTime);
            osc.frequency.exponentialRampToValueAtTime(80, audioContext.currentTime + 1.2);
            gain.gain.setValueAtTime(0.2, audioContext.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 1.2);
            osc.connect(gain).connect(audioContext.destination);
            osc.start();
            osc.stop(audioContext.currentTime + 1.2);
        }

        // --- Console/Command Functions ---
        function showConsole() {
            const con = document.getElementById('console');
            const input = document.getElementById('input');
            const output = document.getElementById('output');
            con.style.display = 'block';
            setTimeout(() => con.style.opacity = '1', 10);
            input.focus();
            consoleOpen = true;
            controls.unlock();
            input.onkeydown = e => {
                if (e.key === 'Enter') {
                    const cmd = input.value.trim().toLowerCase();
                    output.innerHTML += '&gt; ' + input.value + '<br>';
                    if (cmd === 'map man') activateManMap();
                    else if (cmd === 'skip map') smoothShift(true);
                    else if (cmd !== '') output.innerHTML += 'UNKNOWN COMMAND<br>';
                    input.value = '';
                    output.scrollTop = output.scrollHeight;
                }
            };
        }
        function hideConsole() {
            const con = document.getElementById('console');
            con.style.opacity = '0';
            setTimeout(() => { con.style.display = 'none'; }, 300);
            consoleOpen = false;
            controls.lock();
        }

        // --- World Management Functions ---
        function clearWorld() {
            currentWorld.forEach(obj => {
                if (obj.isMesh) {
                    obj.geometry.dispose();
                    if (Array.isArray(obj.material)) {
                        obj.material.forEach(mat => mat.dispose());
                    } else {
                        obj.material.dispose();
                    }
                }
                scene.remove(obj);
            });
            currentWorld = [];
            isManMapActive = false;
        }

        /**
         * Ensures a floor always exists at Y=0 for safe player spawning.
         * @param {number} color - Hex color of the floor.
         * @param {number} size - Size of the square floor plane.
         */
        function addDefaultFloor(color = 0x1a1a1a, size = 5000) {
            const floor = new THREE.Mesh(
                new THREE.PlaneGeometry(size, size), 
                new THREE.MeshStandardMaterial({color: color})
            );
            floor.rotation.x = -Math.PI/2;
            floor.receiveShadow = true;
            floor.name = "DefaultFloor"; 
            scene.add(floor);
            currentWorld.push(floor);
        }

        /**
         * Utility function to remove the default floor if a generator overrides it.
         */
        function removeDefaultFloor() {
            const defaultFloor = scene.getObjectByName("DefaultFloor");
            if(defaultFloor) { scene.remove(defaultFloor); currentWorld.splice(currentWorld.indexOf(defaultFloor), 1); }
        }

        // --- Core Map Generator Functions ---
        
        // --- Custom Generator Function Definitions (Simplified for brevity) ---
        function generateTrippyLiminal() {
            removeDefaultFloor(); 
            const colors = [0xff99cc,0x99ccff,0xffff99,0x99ff99,0xffcc99];
            const sky = colors[Math.floor(Math.random()*5)];
            renderer.setClearColor(sky); scene.fog = new THREE.FogExp2(sky, 0.0008);
            const floor = new THREE.Mesh(new THREE.PlaneGeometry(2000,2000), new THREE.MeshStandardMaterial({color:0x222222}));
            floor.rotation.x = -Math.PI/2; scene.add(floor); currentWorld.push(floor);
            for(let i=0;i<120;i++){
                const obj = new THREE.Mesh(new THREE.BoxGeometry(15+Math.random()*50,15+Math.random()*80,15+Math.random()*50),
                    new THREE.MeshLambertMaterial({color:Math.random()*0xffffff}));
                obj.position.set((Math.random()-0.5)*1800,Math.random()*40+20,(Math.random()-0.5)*1800);
                scene.add(obj); currentWorld.push(obj);
            }
        }
        function generate4DImpossible() {
            removeDefaultFloor();
            renderer.setClearColor(0x000011); scene.fog = new THREE.FogExp2(0x000022, 0.0005);
            const platform = new THREE.Mesh(new THREE.RingGeometry(100, 160, 64), new THREE.MeshBasicMaterial({color:0x111133, side:THREE.DoubleSide}));
            platform.rotation.x = -Math.PI/2; scene.add(platform); currentWorld.push(platform);
            const knot = new THREE.Mesh(new THREE.TorusKnotGeometry(50, 10, 256, 32), new THREE.MeshBasicMaterial({color:0xff0044, wireframe:true}));
            scene.add(knot); currentWorld.push(knot);
            const spin = () => {
                if(currentWorld.includes(knot)) {
                    knot.rotation.x += 0.004;
                    knot.rotation.y += 0.007;
                    knot.rotation.z += 0.002;
                    platform.rotation.z += 0.001;
                    requestAnimationFrame(spin);
                }
            };
            spin();
        }
        function generateRedVoid() {
            renderer.setClearColor(0x220000); scene.fog = new THREE.FogExp2(0x440000, 0.0004);
            for(let i=0;i<60;i++){
                const head = new THREE.Mesh(new THREE.SphereGeometry(4+Math.random()*8), new THREE.MeshBasicMaterial({color:0x880000}));
                head.position.set((Math.random()-0.5)*3000, 10+Math.random()*400, (Math.random()-0.5)*3000);
                scene.add(head); currentWorld.push(head);
            }
        }
        function generateEndlessFall() {
            removeDefaultFloor(); // Crucial to remove the default floor here!
            renderer.setClearColor(0x000011); scene.fog = new THREE.FogExp2(0x000011, 0.001);
            const fall = () => {
                if(currentWorld.length < 10) {
                    camera.position.y -= 0.7;
                    if(camera.position.y < -300) camera.position.y = 400;
                    controls.getObject().position.copy(camera.position);
                    requestAnimationFrame(fall);
                }
            };
            fall();
            for(let i=0; i<5; i++){
                const shape = new THREE.Mesh(new THREE.DodecahedronGeometry(200), new THREE.MeshBasicMaterial({color:0x8888ff, wireframe:true}));
                shape.position.set((Math.random()-0.5)*2000, (Math.random()-0.5)*2000, (Math.random()-0.5)*2000);
                scene.add(shape); currentWorld.push(shape);
            }
        }
        function generateMirrorMaze() {
            removeDefaultFloor();
            renderer.setClearColor(0x001133); scene.fog = new THREE.FogExp2(0x001133, 0.0001);
            const mirror = new THREE.MeshBasicMaterial({color:0x0088ff, side:THREE.BackSide, transparent:true, opacity:0.8});
            const box = new THREE.Mesh(new THREE.BoxGeometry(3000,400,3000), mirror);
            scene.add(box); currentWorld.push(box);
        }
        function generateBackroomsClassic() {
            removeDefaultFloor();
            renderer.setClearColor(0xffffdd); scene.fog = new THREE.FogExp2(0xffffdd, 0.005);
            const floor = new THREE.Mesh(new THREE.PlaneGeometry(3000,3000), new THREE.MeshStandardMaterial({color:0xddddaa}));
            floor.rotation.x = -Math.PI/2; scene.add(floor); currentWorld.push(floor);
            const wallMat = new THREE.MeshStandardMaterial({color:0xf0e68c});
            const wallHeight = 8;
            for(let i=0; i<500; i++){
                const wall = new THREE.Mesh(new THREE.BoxGeometry(20, wallHeight, 0.2), wallMat);
                wall.position.set((Math.random()-0.5)*2800, wallHeight/2, (Math.random()-0.5)*2800);
                wall.rotation.y = Math.floor(Math.random()*4)*Math.PI/2;
                scene.add(wall); currentWorld.push(wall);
            }
        }
        function generateEmptyMall() {
            renderer.setClearColor(0x112233); scene.fog = new THREE.FogExp2(0x112233, 0.001);
            const floor = new THREE.Mesh(new THREE.PlaneGeometry(3000,3000), new THREE.MeshBasicMaterial({color:0x223344}));
            floor.rotation.x = -Math.PI/2; scene.add(floor); currentWorld.push(floor);
        }
        function generateInfiniteHotel() {
            removeDefaultFloor();
            renderer.setClearColor(0x333333); scene.fog = new THREE.FogExp2(0x333333, 0.0005);
            const floorMat = new THREE.MeshStandardMaterial({color: 0x555555});
            const floor = new THREE.Mesh(new THREE.PlaneGeometry(5000, 5000), floorMat);
            floor.rotation.x = -Math.PI/2; floor.receiveShadow = true; scene.add(floor); currentWorld.push(floor);
            const wallMat = new THREE.MeshStandardMaterial({color: 0x888888});
            const doorMat = new THREE.MeshStandardMaterial({color: 0xaa9933});
            for(let i=-20; i<20; i++){
                const corridor = new THREE.Group();
                const wallR = new THREE.Mesh(new THREE.BoxGeometry(400, 4, 0.2), wallMat);
                wallR.position.set(10, 2, i * 400); corridor.add(wallR);
                const wallL = new THREE.Mesh(new THREE.BoxGeometry(400, 4, 0.2), wallMat);
                wallL.position.set(-10, 2, i * 400); corridor.add(wallL);
                for(let j=-5; j<5; j++){
                    const door = new THREE.Mesh(new THREE.BoxGeometry(0.2, 3.5, 3), doorMat);
                    door.position.set(10, 1.75, i * 400 + j * 40); corridor.add(door);
                }
                scene.add(corridor); currentWorld.push(corridor);
            }
        }
        function generatePoolrooms() {
            removeDefaultFloor();
            renderer.setClearColor(0x87cefa); scene.fog = new THREE.FogExp2(0x87cefa, 0.001);
            const water = new THREE.MeshStandardMaterial({color:0x4169e1, transparent:true, opacity:0.6});
            const waterPlane = new THREE.Mesh(new THREE.PlaneGeometry(3000,3000), water);
            waterPlane.rotation.x = -Math.PI/2; scene.add(waterPlane); currentWorld.push(waterPlane);
            for(let i=0; i<100; i++){
                const p = new THREE.Mesh(new THREE.CylinderGeometry(4, 4, 30), new THREE.MeshStandardMaterial({color:0xcccccc}));
                p.position.set((Math.random()-0.5)*2800, 15, (Math.random()-0.5)*2800);
                scene.add(p); currentWorld.push(p);
            }
        }
        function generateOfficeHell() {
            renderer.setClearColor(0xd3d3d3); scene.fog = new THREE.FogExp2(0xd3d3d3, 0.001);
            const floor = new THREE.Mesh(new THREE.PlaneGeometry(3000,3000), new THREE.MeshStandardMaterial({color:0x8b8b83}));
            floor.rotation.x = -Math.PI/2; scene.add(floor); currentWorld.push(floor);
            for(let i=0; i<50; i++){
                const desk = new THREE.Mesh(new THREE.BoxGeometry(3, 1.5, 6), new THREE.MeshStandardMaterial({color:0x404040}));
                desk.position.set((Math.random()-0.5)*2800, 0.75, (Math.random()-0.5)*2800);
                scene.add(desk); currentWorld.push(desk);
            }
        }
        function generateRetroArcade() {
            renderer.setClearColor(0x0a0a0f); scene.fog = new THREE.FogExp2(0x0a0a0f, 0.001);
            const floor = new THREE.Mesh(new THREE.PlaneGeometry(3000,3000), new THREE.MeshBasicMaterial({color:0x000000}));
            floor.rotation.x = -Math.PI/2; scene.add(floor); currentWorld.push(floor);
            for(let i=0; i<50; i++){
                const cabinet = new THREE.Mesh(new THREE.BoxGeometry(1.5, 2.5, 1), new THREE.MeshBasicMaterial({color:0xff00ff}));
                cabinet.position.set((Math.random()-0.5)*2800, 1.25, (Math.random()-0.5)*2800);
                scene.add(cabinet); currentWorld.push(cabinet);
                const light = new THREE.PointLight(0x00ffff, 2, 50);
                light.position.copy(cabinet.position);
                light.position.y += 3;
                scene.add(light); currentWorld.push(light);
            }
        }
        function generateNeonRooftops() {
            renderer.setClearColor(0x000033); scene.fog = new THREE.FogExp2(0x000033, 0.001);
            const platform = new THREE.Mesh(new THREE.BoxGeometry(500, 2, 500), new THREE.MeshStandardMaterial({color:0x000000}));
            platform.position.y = -1; scene.add(platform); currentWorld.push(platform);
            for(let i=0; i<50; i++){
                const h = 50 + Math.random() * 200;
                const b = new THREE.Mesh(new THREE.BoxGeometry(10, h, 10), new THREE.MeshStandardMaterial({color:0x111122}));
                b.position.set((Math.random()-0.5)*2000, h/2 - 1, (Math.random()-0.5)*2000);
                scene.add(b); currentWorld.push(b);
                const sign = new THREE.PointLight(0xff0000, 1.5, 50);
                sign.position.copy(b.position);
                sign.position.y += h/2 + 2;
                scene.add(sign); currentWorld.push(sign);
            }
        }
        function generateStaticDesert() {
            renderer.setClearColor(0xaaaaaa); scene.fog = new THREE.FogExp2(0xbbbbbb, 0.0005);
            const floor = new THREE.Mesh(new THREE.PlaneGeometry(5000,5000), new THREE.MeshStandardMaterial({color:0x666666}));
            floor.rotation.x = -Math.PI/2; scene.add(floor); currentWorld.push(floor);
            for(let i=0; i<10; i++){
                const tv = new THREE.Mesh(new THREE.BoxGeometry(20, 15, 0.5), new THREE.MeshBasicMaterial({color:0xffffff}));
                tv.position.set((Math.random()-0.5)*4000, 7.5, (Math.random()-0.5)*4000);
                tv.rotation.y = Math.random() * Math.PI * 2;
                scene.add(tv); currentWorld.push(tv);
            }
        }
        function generateSubmergedHighway() {
            removeDefaultFloor();
            renderer.setClearColor(0x000055); scene.fog = new THREE.FogExp2(0x000055, 0.0005);
            const waterMat = new THREE.MeshBasicMaterial({color:0x0044ff, transparent:true, opacity:0.4, side:THREE.DoubleSide});
            const waterPlane = new THREE.Mesh(new THREE.PlaneGeometry(5000,5000), waterMat);
            waterPlane.rotation.x = -Math.PI/2; 
            waterPlane.position.y = -10;
            scene.add(waterPlane); currentWorld.push(waterPlane);
            const road = new THREE.Mesh(new THREE.BoxGeometry(100, 0.5, 4000), new THREE.MeshStandardMaterial({color:0x222222}));
            road.position.y = -10.25; scene.add(road); currentWorld.push(road);
        }
        function generateTrainPlatform() {
            renderer.setClearColor(0x333333); scene.fog = new THREE.FogExp2(0x333333, 0.0008);
            const floor = new THREE.Mesh(new THREE.PlaneGeometry(5000,20), new THREE.MeshStandardMaterial({color:0x444444}));
            floor.rotation.x = -Math.PI/2; scene.add(floor); currentWorld.push(floor);
            const railMat = new THREE.MeshStandardMaterial({color:0x888888});
            for(let i=-20; i<20; i++){
                const tie = new THREE.Mesh(new THREE.BoxGeometry(3, 0.2, 0.5), railMat);
                tie.position.set(0, -0.9, i * 200 - 2000); 
                scene.add(tie); currentWorld.push(tie);
            }
        }
        function generateQuietStreet() {
            renderer.setClearColor(0x111111); scene.fog = new THREE.FogExp2(0x111111, 0.0005);
            const road = new THREE.Mesh(new THREE.PlaneGeometry(20, 5000), new THREE.MeshStandardMaterial({color:0x444444}));
            road.rotation.x = -Math.PI/2; scene.add(road); currentWorld.push(road);
            for(let i=0; i<20; i++){
                const light = new THREE.PointLight(0xf0e0b0, 2, 80);
                light.position.set(0, 10, i * 200 - 2000);
                scene.add(light); currentWorld.push(light);
            }
        }
        function generateBackroomsHell() {
            renderer.setClearColor(0xf5f5dc); scene.fog = new THREE.FogExp2(0xf5f5dc, 0.005);
            const floor = new THREE.Mesh(new THREE.PlaneGeometry(3000,3000), new THREE.MeshStandardMaterial({color:0xd4c372}));
            floor.rotation.x = -Math.PI/2; scene.add(floor); currentWorld.push(floor);
            for(let i=0;i<400;i++){
                const w = new THREE.Mesh(new THREE.BoxGeometry(15+Math.random()*60,8+Math.random()*6,2),
                    new THREE.MeshStandardMaterial({color:0xf0e68c}));
                w.position.set((Math.random()-0.5)*2800,4+Math.random()*3,(Math.random()-0.5)*2800);
                w.rotation.y = Math.floor(Math.random()*8)*Math.PI/4;
                scene.add(w); currentWorld.push(w);
            }
        }
        // --- End of Custom Generator Functions ---

        /**
         * Generates a random dream world, ensuring safe spawn.
         */
        function generateDreamWorld() {
            clearWorld();

            // 1. ENFORCE SAFE SPAWN POSITION & DEFAULT PLATFORM
            camera.position.set(0, 1.8, 10);
            controls.getObject().position.copy(camera.position);
            // Add a large default floor at Y=0. Generators can remove it if they use a custom floor.
            addDefaultFloor(0x1a1a1a, 5000); 
            
            // Select Map (excluding Endless Fall initially)
            let mapIndex;
            do {
                 mapIndex = Math.floor(Math.random() * MAP_CATALOG.length);
            } while (MAP_CATALOG[mapIndex].generator === generateEndlessFall);

            const selectedMap = MAP_CATALOG[mapIndex];
            
            selectedMap.generator();

            // Update Status and Audio
            document.getElementById('mapName').textContent = selectedMap.name;
            changeAmbientSound(selectedMap.sound);
            changeMusic();
            
            dreamCount++;
            document.getElementById('dream').textContent = dreamCount;
            sanity = 100;
            document.getElementById('stability').textContent = '100';
        }

        /**
         * Activates the special "Map Man" environment.
         */
        function activateManMap() {
            clearWorld();
            isManMapActive = true;
            scene.fog = new THREE.FogExp2(0xaaaaaa, 0.0008);
            renderer.setClearColor(0xcccccc);

            // Floor
            const grassTexture = textureLoader.load('https://threejs.org/examples/textures/crate.gif');
            grassTexture.wrapS = grassTexture.wrapT = THREE.RepeatWrapping;
            grassTexture.repeat.set( 100, 100 );
            const grass = new THREE.Mesh(
                new THREE.PlaneGeometry(2000, 2000),
                new THREE.MeshStandardMaterial({color: 0x6b9e3f, map: grassTexture})
            );
            grass.rotation.x = -Math.PI/2;
            grass.receiveShadow = true;
            scene.add(grass);
            currentWorld.push(grass);

            // Grass Blades
            const bladeGeo = new THREE.PlaneGeometry(0.2, 1.2);
            const bladeMat = new THREE.MeshLambertMaterial({color: 0x228B22, side: THREE.DoubleSide});
            for (let i = 0; i < 20000; i++) {
                const b = new THREE.Mesh(bladeGeo, bladeMat);
                b.position.set((Math.random()-0.5)*1980, 0.6, (Math.random()-0.5)*1980);
                b.rotation.y = Math.random() * Math.PI;
                scene.add(b);
                currentWorld.push(b);
            }
            
            // Tree
            const tree = new THREE.Group();
            tree.add(new THREE.Mesh(new THREE.CylinderGeometry(1,1.2,8), new THREE.MeshStandardMaterial({color:0x8B4513})));
            tree.add(new THREE.Mesh(new THREE.SphereGeometry(5,16,16), new THREE.MeshStandardMaterial({color:0x228B22})));
            tree.position.set(-12,4,0);
            tree.children[1].position.y = 6;
            scene.add(tree); currentWorld.push(tree);

            // Man Entity
            const man = new THREE.Group();
            man.add(new THREE.Mesh(new THREE.BoxGeometry(0.6,2.2,0.4), new THREE.MeshBasicMaterial({color:0x000000})));
            man.add(new THREE.Mesh(new THREE.SphereGeometry(0.35), new THREE.MeshBasicMaterial({color:0x000000})));
            man.position.set(0,1.6,-0.5);
            man.children[1].position.y = 1.4;
            man.rotation.y = Math.PI;
            scene.add(man); currentWorld.push(man);
            manPosition.set(0,0,0);

            // Position the player
            camera.position.set(0, 1.8, 50);
            controls.getObject().position.copy(camera.position);

            // FIX: Removed the line controls.getObject().rotation.y = ... to prevent camera tilt.

            document.getElementById('mapName').textContent = "The Man's Field";
            changeAmbientSound(null);
            hideConsole();
        }

        /**
         * Creates a fast, seamless dream shift/transition.
         * @param {boolean} manual - Whether the shift was triggered by a command.
         */
        function smoothShift(manual = false) {
            if (isShifting) return;
            isShifting = true;
            sanity -= manual ? 40 : 20;
            document.getElementById('stability').textContent = Math.max(0, Math.floor(sanity));
            playShiftSound();

            // 1. SEAMLESS SHIFT: Quick visual flash/disorientation
            fadeScreen.style.transition = 'opacity 0.1s'; 
            fadeScreen.style.opacity = '1'; 

            // 2. Immediate World Swap (Happens while the screen is "flashed")
            setTimeout(() => {
                generateDreamWorld();
                
                // Fade the cue out almost instantly after the swap
                fadeScreen.style.opacity = '0';
                
                isShifting = false;
                nextShift = manual ? 5 : 15 + Math.random() * 30;
                
                // Restore the transition time for the next potential long fade/shift if needed
                fadeScreen.style.transition = 'opacity 3s'; 
                
            }, 100); // Total shift time is 100ms
        }

        function checkManProximity() {
            if (isManMapActive) {
                if (camera.position.distanceTo(manPosition) < 12) {
                    document.getElementById('output').innerHTML += '<br>THE MAN SEES YOU. SHIFTING...<br>';
                    smoothShift(true); 
                }
            }
        }

        // --- Animation Loop ---
        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();

            if (controls.isLocked) {
                velocity.x *= 0.8; velocity.z *= 0.8;
                const speed = isManMapActive ? 25 : 40;

                const dir = new THREE.Vector3();
                dir.z = Number(move.forward) - Number(move.backward);
                dir.x = Number(move.right) - Number(move.left);
                dir.normalize();

                if (move.forward || move.backward) velocity.z -= dir.z * speed * delta;
                if (move.left || move.right) velocity.x -= dir.x * speed * delta;

                controls.moveRight(-velocity.x * delta);
                controls.moveForward(-velocity.z * delta);

                checkManProximity();
                
                nextShift -= delta;
                if (nextShift <= 0) smoothShift();
            }
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Tokyo Drift Chase</title>
    <!-- Imported Pixel Font -->
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #14141e; /* COLOR_BG_VOID */
            font-family: 'Press Start 2P', cursive; /* Updated Font */
            touch-action: none; /* Prevent mobile scrolling */
        }
        canvas {
            display: block;
            /* Force pixelated rendering for crisp edges */
            image-rendering: pixelated; 
            image-rendering: crisp-edges;
        }
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
    </style>
</head>
<body>

<canvas id="gameCanvas"></canvas>

<script>
/**
 * TOKYO DRIFT CHASE - HTML5 PORT
 * with UNIQUE POWERS & SLIDING ANIMATIONS
 */

// --- Constants & Configuration ---
const FPS = 60;
const BLOCK_SIZE = 380;
const BUILDING_GAP = 20;

// Colors
const COLORS = {
    BG_VOID: '#14141e',
    ASPHALT: '#2d2d32',
    PAINT_YELLOW: '#d2b414',
    PAINT_WHITE: '#dcdcdc',
    SIDEWALK: '#828287',
    WOOD_DARK: '#50281e',
    WOOD_RED: '#8c1e14',
    CONCRETE: '#9696a0',
    CONCRETE_DARK: '#64646e',
    ROOF_TILE_JP: '#3c3c46',
    LANTERN_RED: '#dc3232',
    NEON_PINK: '#ff3296',
    NEON_BLUE: '#3296ff',
    NEON_CYAN: '#32ffff',
    NEON_GREEN: '#32ff64',
    VENDING_BLUE: '#3264c8',
    SCHOOL_BEIGE: '#e6dcbe',
    CLOCK_FACE: '#ffffff',
    WIN_LIT_WARM: '#fff0b4',
    WIN_LIT_COOL: '#c8dcff',
    WIN_DARK: '#282832',
    SAKURA_PINK: '#ffb4c8',
    SAKURA_DARK: '#c8788c',
    ZOO_BASE: '#328c32',
    WATER: '#3296fa',
    AC: '#b4b4be',
    PLAYER: '#dc2828',
    COP_BODY: '#0a0a0f',
    COP_DOOR: '#e6e6f0',
    HP_GREEN: '#32c832',
    HP_YELLOW: '#dcc832',
    HP_RED: '#c83232',
    TEXT_WHITE: '#ffffff'
};

const CAR_TYPES = {
    'sedan': { w: 48, h: 24, speed: 1.0, colors: ['#3c5a96', '#969696', '#dcdcdc', '#503250', '#8c2828'] },
    'coupe': { w: 44, h: 22, speed: 1.3, colors: ['#c83232', '#3264c8', '#e6e632', '#141414'] },
    'hatchback': { w: 40, h: 22, speed: 0.9, colors: ['#32965a', '#c87832', '#9696c8'] },
    'taxi': { w: 48, h: 24, speed: 1.1, colors: ['#e6af2d'] }, // Japanese Taxi
    'truck': { w: 56, h: 26, speed: 0.7, colors: ['#ffffff', '#32465a'] }
};

// --- PLAYER ROSTER (Updated with Unique Powers) ---
const PLAYER_ROSTER = [
    { 
        id: 'standard', 
        name: 'STREET LEGEND', 
        type: 'sedan', 
        color: '#dc2828', 
        desc: "Balanced. [Z]: Instant Repair (+50HP)",
        stats: { speed: 9.0, turn: 4.0, accel: 0.20, hp: 100 },
        hasSpoiler: true,
        powerData: { name: "Repair", color: "#32c832", cooldown: 45 * 60 }
    },
    { 
        id: 'drifter', 
        name: 'DRIFT KING', 
        type: 'coupe', 
        color: '#d2b414', 
        desc: "Loose handling. [Z]: Oil Slick",
        stats: { speed: 10.5, turn: 4.5, accel: 0.25, hp: 80 },
        hasSpoiler: true,
        powerData: { name: "Oil Slick", color: "#141414", cooldown: 15 * 60 }
    },
    { 
        id: 'tank', 
        name: 'THE BEAST', 
        type: 'truck', 
        color: '#14141e', 
        desc: "Heavy Armor. [Z]: Juggernaut (Invincible Ram)",
        stats: { speed: 7.5, turn: 3.0, accel: 0.15, hp: 200 },
        hasSpoiler: false,
        powerData: { name: "Juggernaut", color: "#c83232", cooldown: 40 * 60 }
    },
    { 
        id: 'mecha', 
        name: 'MECHA-V', 
        type: 'coupe', 
        color: '#32ffff', // Neon Cyan
        desc: "High Tech. [Z]: EMP Blast (Stun Cops)",
        stats: { speed: 11.0, turn: 5.5, accel: 0.30, hp: 60 },
        hasSpoiler: true,
        powerData: { name: "EMP Blast", color: "#3296ff", cooldown: 30 * 60 }
    },
    { 
        id: 'angel', 
        name: 'SERAPHIM', 
        type: 'coupe', 
        color: '#ffffff', 
        desc: "Divine Power. [Z]: Smite (Destroy Cops)",
        stats: { speed: 10.0, turn: 5.0, accel: 0.22, hp: 150 },
        hasSpoiler: false,
        unlockScore: 500,
        powerData: { name: "Smite", color: "#ffd700", cooldown: 60 * 60 }
    }
];

// Physics
const ACCELERATION = 0.20;
const FRICTION = 0.96;
const TURN_SPEED = 4.0;
const DRIFT_SLIDE = 0.99;
const MAX_SPEED_PLAYER = 9.0;
const MAX_SPEED_COP = 10.2;
const MAX_SPEED_CIVILIAN_BASE = 6.0;

// --- Utility Classes ---

class Vector2 {
    constructor(x, y) {
        this.x = x;
        this.y = y;
    }
    add(v) { return new Vector2(this.x + v.x, this.y + v.y); }
    sub(v) { return new Vector2(this.x - v.x, this.y - v.y); }
    mult(n) { return new Vector2(this.x * n, this.y * n); }
    mag() { return Math.sqrt(this.x * this.x + this.y * this.y); }
    normalize() {
        let m = this.mag();
        if (m === 0) return new Vector2(0, 0);
        return new Vector2(this.x / m, this.y / m);
    }
    dot(v) { return this.x * v.x + this.y * v.y; }
    rotate(angleDegrees) {
        let rad = angleDegrees * Math.PI / 180;
        let cos = Math.cos(rad);
        let sin = Math.sin(rad);
        return new Vector2(this.x * cos - this.y * sin, this.x * sin + this.y * cos);
    }
    distanceTo(v) {
        return Math.sqrt((this.x - v.x)**2 + (this.y - v.y)**2);
    }
    lerp(v, t) {
        return new Vector2(this.x + (v.x - this.x) * t, this.y + (v.y - this.y) * t,);
    }
}

class Rect {
    constructor(x, y, w, h) {
        this.x = x;
        this.y = y;
        this.w = w;
        this.h = h;
    }
    get left() { return this.x; }
    get right() { return this.x + this.w; }
    get top() { return this.y; }
    get bottom() { return this.y + this.h; }
    get centerx() { return this.x + this.w / 2; }
    get centery() { return this.y + this.h / 2; }
    
    set centerx(v) { this.x = v - this.w / 2; }
    set centery(v) { this.y = v - this.h / 2; }

    collidePoint(px, py) {
        return px >= this.x && px <= this.x + this.w && py >= this.y && py <= this.y + this.h;
    }
    collideRect(other) {
        return this.x < other.x + other.w && this.x + this.w > other.x &&
               this.y < other.y + other.h && this.y + this.h > other.y;
    }
    inflate(dw, dh) {
        return new Rect(this.x - dw/2, this.y - dh/2, this.w + dw, this.h + dh);
    }
}

// --- Seeded Random for Map Consistency ---
class SeededRNG {
    constructor(seed) {
        this.seed = seed;
    }
    // Simple LCG
    next() {
        this.seed = (this.seed * 9301 + 49297) % 233280;
        return this.seed / 233280;
    }
    randInt(min, max) {
        return Math.floor(this.next() * (max - min + 1)) + min;
    }
    randFloat(min, max) {
        return this.next() * (max - min) + min;
    }
    choice(arr) {
        return arr[Math.floor(this.next() * arr.length)];
    }
}

// --- Helper Functions (Standard) ---
function randInt(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; }
function randFloat(min, max) { return Math.random() * (max - min) + min; }
function randChoice(arr) { return arr[Math.floor(Math.random() * arr.length)]; }
function degToRad(deg) { return deg * Math.PI / 180; }

// --- Drawing Helpers ---
function drawRect(ctx, color, x, y, w, h, radius = 0) {
    ctx.fillStyle = color;
    if (radius > 0) {
        ctx.beginPath();
        if (ctx.roundRect) {
            ctx.roundRect(x, y, w, h, radius);
        } else {
            ctx.rect(x, y, w, h);
        }
        ctx.fill();
    } else {
        ctx.fillRect(x, y, w, h);
    }
}

function drawCircle(ctx, color, x, y, r) {
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.arc(x, y, r, 0, Math.PI * 2);
    ctx.fill();
}

// --- Asset Generation (Caching complex drawings) ---

function createRoadTexture(size) {
    const cvs = document.createElement('canvas');
    cvs.width = size;
    cvs.height = size;
    const ctx = cvs.getContext('2d');
    
    ctx.fillStyle = COLORS.ASPHALT;
    ctx.fillRect(0, 0, size, size);
    
    // Noise
    for (let i = 0; i < 800; i++) {
        const x = randInt(0, size);
        const y = randInt(0, size);
        const c = randInt(35, 55);
        ctx.fillStyle = `rgb(${c},${c},${c+5})`;
        ctx.fillRect(x, y, 2, 2);
    }
    
    // Cracks
    ctx.strokeStyle = '#222';
    ctx.lineWidth = 1;
    for(let i=0; i<5; i++) { // Added more cracks
        let x = randInt(0, size);
        let y = randInt(0, size);
        ctx.beginPath();
        ctx.moveTo(x, y);
        for(let j=0; j<7; j++) { // Longer cracks
            x += randInt(-15, 15);
            y += randInt(-15, 15);
            ctx.lineTo(x, y);
        }
        ctx.stroke();
    }

    // Potholes
    for(let i=0; i<3; i++) {
        let px = randInt(0, size);
        let py = randInt(0, size);
        ctx.fillStyle = '#1a1a1f';
        ctx.beginPath();
        ctx.ellipse(px, py, randInt(5,15), randInt(3,8), randFloat(0, Math.PI), 0, Math.PI*2);
        ctx.fill();
    }
    
    // Manhole
    const mx = size/2 + randInt(-50, 50);
    const my = size/2 + randInt(-50, 50);
    
    ctx.fillStyle = '#46464b';
    ctx.beginPath(); ctx.arc(mx, my, 14, 0, Math.PI*2); ctx.fill();
    ctx.strokeStyle = '#28282d';
    ctx.lineWidth = 2;
    ctx.stroke();

    ctx.strokeStyle = '#28282d';
    for(let i=0; i<360; i+=45) {
        let rad = degToRad(i);
        ctx.beginPath();
        ctx.moveTo(mx, my);
        ctx.lineTo(mx + Math.cos(rad)*10, my + Math.sin(rad)*10);
        ctx.stroke();
    }

    return cvs;
}

const roadPatternCanvas = createRoadTexture(BLOCK_SIZE);

// --- Game Objects ---

class Camera {
    constructor() {
        this.offset = new Vector2(0, 0);
        this.viewRect = new Rect(0, 0, 0, 0); // Updates in update()
    }

    update(target, gameW, gameH) {
        // Target is typically the player car
        // We want target to be in center. 
        // Camera offset shifts the WORLD, so if player moves right (+x), offset moves left (-x)
        const targetX = -target.pos.x + gameW / 2;
        const targetY = -target.pos.y + gameH / 2;

        this.offset.x += (targetX - this.offset.x) * 0.1;
        this.offset.y += (targetY - this.offset.y) * 0.1;

        // View rect determines what chunks to load. Inflate slightly for smooth loading.
        this.viewRect = new Rect(-this.offset.x - 600, -this.offset.y - 600, gameW + 1200, gameH + 1200);
    }

    apply(rect) {
        // Transforms a world rect to screen rect
        if (!rect) return new Rect(0,0,0,0); // Safety check
        return new Rect(rect.x + this.offset.x, rect.y + this.offset.y, rect.w, rect.h);
    }
}

class CarHealth {
    constructor(maxHp = 100) {
        this.maxHp = maxHp;
        this.parts = {
            'front_torso': maxHp,
            'back_torso': maxHp,
            'fl_wheel': maxHp,
            'fr_wheel': maxHp,
            'rl_wheel': maxHp,
            'rr_wheel': maxHp
        };
    }

    getColor(hp) {
        if (hp > this.maxHp * 0.5) return COLORS.HP_GREEN;
        if (hp > 0) return COLORS.HP_YELLOW;
        return COLORS.HP_RED;
    }

    checkFullyDestroyed() {
        for (let key in this.parts) {
            if (this.parts[key] > 0) return false;
        }
        return true;
    }

    takeDamage(amount) {
        let aliveKeys = Object.keys(this.parts).filter(k => this.parts[k] > 0);
        if (aliveKeys.length === 0) return;
        
        let target = randChoice(aliveKeys);
        this.parts[target] -= amount;

        // Splash damage
        if (Math.random() > 0.5) {
            if (this.parts['front_torso'] > 0) this.parts['front_torso'] -= amount / 2;
        } else {
            if (this.parts['back_torso'] > 0) this.parts['back_torso'] -= amount / 2;
        }
    }

    repair(amount) {
        for (let k in this.parts) {
            this.parts[k] = Math.min(this.maxHp, this.parts[k] + amount);
        }
    }

    drawUI(ctx, x, y) {
        const s = 2.5; // Scale
        const wBody = 16 * s;
        const hFront = 14 * s;
        const hBack = 14 * s;
        const wWheel = 4 * s;
        const hWheel = 8 * s;
        
        const cx = x + wBody / 2;

        // Helpers
        const drawPart = (color, px, py, pw, ph, rad=0) => {
            ctx.fillStyle = color;
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 2;
            ctx.beginPath();
            if (rad > 0) {
                 if (ctx.roundRect) ctx.roundRect(px, py, pw, ph, rad);
                 else ctx.rect(px, py, pw, ph);
            } else {
                ctx.rect(px, py, pw, ph);
            }
            ctx.fill();
            ctx.stroke();
        };

        // Wheels
        drawPart(this.getColor(this.parts['fl_wheel']), cx - wBody/2 - wWheel + 2, y + 4*s, wWheel, hWheel);
        drawPart(this.getColor(this.parts['fr_wheel']), cx + wBody/2 - 2, y + 4*s, wWheel, hWheel);
        drawPart(this.getColor(this.parts['rl_wheel']), cx - wBody/2 - wWheel + 2, y + hFront + 2*s, wWheel, hWheel);
        drawPart(this.getColor(this.parts['rr_wheel']), cx + wBody/2 - 2, y + hFront + 2*s, wWheel, hWheel);

        // Body
        // Front (Hood)
        ctx.fillStyle = this.getColor(this.parts['front_torso']);
        ctx.strokeStyle = '#000';
        ctx.beginPath();
        if (ctx.roundRect) ctx.roundRect(cx - wBody/2, y, wBody, hFront, [4*s, 4*s, 0, 0]);
        else ctx.rect(cx - wBody/2, y, wBody, hFront);
        ctx.fill(); ctx.stroke();

        // Back (Cabin)
        ctx.fillStyle = this.getColor(this.parts['back_torso']);
        ctx.beginPath();
        if (ctx.roundRect) ctx.roundRect(cx - wBody/2, y + hFront, wBody, hBack, [0, 0, 2*s, 2*s]);
        else ctx.rect(cx - wBody/2, y + hFront, wBody, hBack);
        ctx.fill(); ctx.stroke();

        // Windshield line
        ctx.beginPath();
        ctx.moveTo(cx - wBody/2, y + hFront);
        ctx.lineTo(cx + wBody/2, y + hFront);
        ctx.stroke();
    }
}

class Car {
    constructor(x, y, typeOrColor, isCop=false, isCivilian=false) {
        this.pos = new Vector2(x, y);
        this.vel = new Vector2(0, 0);
        this.angle = 0; // Degrees
        this.rotDirection = 0;
        this.accInput = 0;
        this.isCop = isCop;
        this.isCivilian = isCivilian;
        this.id = null; // Specific ID for special cars
        
        // Defaults
        this.width = 48;
        this.height = 24;
        this.speedTrait = 1.0;
        this.color = '#fff';
        this.type = 'sedan';
        this.hasSpoiler = false;
        
        // Custom Player Stats (populated later for player)
        this.customMaxSpeed = null;
        this.customTurnSpeed = null;
        this.customAccel = null;
        
        // Tracking for Ghostly Rider achievement
        this.lastRotDirection = 0;
        this.turnComplete = false;
        this.isCollidingWithBuilding = false;
        this.isCollidingWithCop = false;
        
        // Status Effects
        this.stunTimer = 0; // For EMP
        this.spinTimer = 0; // For Oil Slick
        this.dead = false;

        if (isCivilian) {
            this.type = typeOrColor || 'sedan'; // Pass type string for civilians
            const stats = CAR_TYPES[this.type];
            this.width = stats.w;
            this.height = stats.h;
            this.color = randChoice(stats.colors);
            // "Weirdly Perfection" - random variation on top of base speed
            this.speedTrait = stats.speed * randFloat(0.85, 1.15); 
        } else if (isCop) {
            this.color = COLORS.COP_BODY;
            this.speedTrait = 1.2;
        } else {
            // Player
            this.color = typeOrColor; // Hex for player
            // Default HP check, overridden in initGame
            this.health = new CarHealth(100); 
        }
        
        // Generate sprite
        this.sprite = this.createCarSprite();
        
        if (isCop || isCivilian) {
             this.health = null;
        }
        
        this.stuckTimer = 0;
        this.reversing = false; // For AI
        
        // Civilian specific
        this.targetHeading = null;
        this.blockedTimer = 0;
        this.cooldownTimer = 0;
        this.laneSwitchDir = 0; // -1 left, 1 right, 0 none
        this.patience = randInt(60, 150);
        this.brakingVisual = false;
        this.hitOnce = false;
    }

    createCarSprite() {
        const cvs = document.createElement('canvas');
        
        // Increase canvas size for Angel Wings if needed
        let padding = 0;
        if (this.id === 'angel') padding = 20;

        cvs.width = this.width + padding*2;
        cvs.height = this.height + padding*2;
        const ctx = cvs.getContext('2d');
        // Disable smoothing for sharp pixels on sprite generation
        ctx.imageSmoothingEnabled = false;
        
        // Center drawing if padded
        ctx.translate(padding, padding);
        
        const w = this.width, h = this.height;

        // Shadow/Underbody
        ctx.fillStyle = 'rgba(0,0,0,0.4)';
        ctx.beginPath(); 
        if (ctx.roundRect) ctx.roundRect(4, 6, w-2, h-6, 4); 
        else ctx.rect(4, 6, w-2, h-6);
        ctx.fill();

        // Wheels with more detail
        const tireColor = '#191919';
        const rimColor = this.isCop ? '#505050' : '#dcdcdc';
        const axleF = w - 12, axleR = 10;
        const tires = [[axleF, 1], [axleF, h-5], [axleR, 1], [axleR, h-5]];
        tires.forEach(([tx, ty]) => {
            ctx.fillStyle = tireColor;
            ctx.fillRect(tx, ty, 10, 4);
            // Rim detail
            ctx.fillStyle = rimColor;
            ctx.fillRect(tx+3, ty+1, 4, 2);
            ctx.fillStyle = '#000'; // Hubcap center
            ctx.fillRect(tx+4, ty+1.5, 2, 1);
            // Add spokes
            ctx.strokeStyle = '#aaa';
            ctx.lineWidth = 1;
            for(let k=0; k<4; k++) {
                let rx = tx + 5 + Math.cos(k*Math.PI/2)*2;
                let ry = ty + 2 + Math.sin(k*Math.PI/2)*1;
                ctx.beginPath();
                ctx.moveTo(tx+5, ty+2);
                ctx.lineTo(rx, ry);
                ctx.stroke();
            }
        });

        const bodyY = 3, bodyH = h - 6;
        
        // Body Base
        if (this.isCop) {
            ctx.fillStyle = '#0a0a0f'; // Dark Body
            ctx.beginPath(); 
            if (ctx.roundRect) ctx.roundRect(2, bodyY, w-4, bodyH, 1);
            else ctx.rect(2, bodyY, w-4, bodyH);
            ctx.fill();
            
            ctx.fillStyle = COLORS.COP_DOOR; // White Door
            ctx.fillRect(14, bodyY, 18, bodyH);
            
            // "POLICE" text hint
            ctx.fillStyle = '#000';
            ctx.fillRect(16, bodyY+2, 14, 2);
            
            ctx.fillStyle = '#9696a0'; // Pillar
            ctx.fillRect(23, bodyY, 1, bodyH);
        } else {
            ctx.fillStyle = this.color;
            ctx.beginPath(); 
            if (ctx.roundRect) ctx.roundRect(2, bodyY, w-4, bodyH, 4);
            else ctx.rect(2, bodyY, w-4, bodyH);
            ctx.fill();
            
            // Texture details based on type
            if (this.type === 'taxi') {
                ctx.fillStyle = '#000'; // Stripe
                ctx.fillRect(0, bodyY+bodyH/2-1, w, 2);
            }
            
            // Hood Vents
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.fillRect(w - 12, bodyY + 4, 4, 2);
            ctx.fillRect(w - 12, bodyY + bodyH - 6, 4, 2);
            // More vents
            ctx.fillRect(w - 18, bodyY + 4, 2, 2);
            ctx.fillRect(w - 18, bodyY + bodyH - 6, 2, 2);

            // Side Skirt Shadow
            ctx.fillStyle = 'rgba(0,0,0,0.2)';
            ctx.fillRect(10, bodyY + bodyH - 2, 28, 1);
            // Add stripe detail
            if (!this.isCivilian) {
                ctx.fillStyle = 'rgba(255,255,255,0.1)';
                ctx.fillRect(8, bodyY + 2, w-16, 1);
                ctx.fillRect(8, bodyY + bodyH - 3, w-16, 1);
            }
        }

        // Bumpers (Detailed)
        ctx.fillStyle = '#222';
        ctx.fillRect(w-3, bodyY, 2, bodyH); // Front Bumper
        ctx.fillRect(w-4, bodyY+1, 1, bodyH-2); // Front detail
        // Grill
        ctx.fillStyle = '#111';
        ctx.fillRect(w-5, bodyY + bodyH/2 - 3, 4, 6);
        for(let g=0; g<3; g++) {
            ctx.fillStyle = '#333';
            ctx.fillRect(w-5, bodyY + bodyH/2 - 3 + g*2, 4, 1);
        }
        
        ctx.fillStyle = '#222';
        ctx.fillRect(1, bodyY, 2, bodyH);   // Rear Bumper
        // Exhaust
        ctx.fillStyle = '#333';
        ctx.fillRect(2, bodyY + bodyH - 6, 2, 4);
        
        // Cabin/Glass
        let cabinRect = this.isCop ? {x:10, y:bodyY+2, w:24, h:bodyH-4} : {x:12, y:bodyY+3, w:20, h:bodyH-6};
        
        // Type adjustments
        if (this.type === 'truck') cabinRect = {x: 8, y: bodyY+2, w: 16, h: bodyH-4};
        if (this.type === 'coupe') cabinRect = {x: 10, y: bodyY+3, w: 18, h: bodyH-6};

        ctx.fillStyle = '#2d3c46'; // Dark Glass
        ctx.beginPath(); 
        if (ctx.roundRect) ctx.roundRect(cabinRect.x, cabinRect.y, cabinRect.w, cabinRect.h, 2);
        else ctx.rect(cabinRect.x, cabinRect.y, cabinRect.w, cabinRect.h);
        ctx.fill();
        
        // Glass Reflection
        ctx.fillStyle = '#506e82';
        ctx.beginPath();
        ctx.moveTo(cabinRect.x + 4, cabinRect.y);
        ctx.lineTo(cabinRect.x + 8, cabinRect.y);
        ctx.lineTo(cabinRect.x + 4, cabinRect.y + cabinRect.h);
        ctx.lineTo(cabinRect.x, cabinRect.y + cabinRect.h);
        ctx.fill();
        // More reflection
        ctx.fillStyle = 'rgba(255,255,255,0.1)';
        ctx.fillRect(cabinRect.x + 2, cabinRect.y + 2, 2, cabinRect.h - 4);

        // Roof
        let roofColor = this.isCop ? '#0a0a0f' : this.color;
        let roofRect = {x:cabinRect.x+2, y:cabinRect.y+1, w:cabinRect.w-4, h:cabinRect.h-2};
        
        if (this.type === 'truck') {
            // Truck Bed
            ctx.fillStyle = '#333';
            ctx.fillRect(24, bodyY+2, w-30, bodyH-4);
            ctx.fillStyle = '#222'; // Bed lines
            for(let i=26; i<w-6; i+=4) ctx.fillRect(i, bodyY+2, 1, bodyH-4);
            // Add cargo detail
            ctx.fillStyle = '#444';
            ctx.fillRect(28, bodyY+4, 20, bodyH-8);
        }

        ctx.fillStyle = roofColor;
        ctx.fillRect(roofRect.x, roofRect.y, roofRect.w, roofRect.h);
        
        // Taxi sign
        if (this.type === 'taxi') {
            ctx.fillStyle = '#fff';
            ctx.fillRect(roofRect.x + roofRect.w/2 - 2, roofRect.y + 1, 4, roofRect.h - 2);
            // Add light
            ctx.fillStyle = '#ffff00';
            ctx.fillRect(roofRect.x + roofRect.w/2 - 1, roofRect.y + 2, 2, 2);
        }

        // Sunroof (Player only or Coupe)
        if (!this.isCop && !this.isCivilian || this.type === 'coupe') {
            ctx.fillStyle = '#111';
            ctx.fillRect(roofRect.x + 4, roofRect.y + 2, roofRect.w - 8, roofRect.h - 4);
            ctx.fillStyle = '#222'; // Sunroof shine
            ctx.fillRect(roofRect.x + 4, roofRect.y + 2, 2, roofRect.h - 4);
        }

        // Lights
        // Headlights (Detailed)
        ctx.fillStyle = '#e6e6e6'; // Casing
        ctx.fillRect(w-5, bodyY+1, 4, 4);
        ctx.fillRect(w-5, bodyY+bodyH-5, 4, 4);
        ctx.fillStyle = '#fff'; // Bulb
        ctx.fillRect(w-3, bodyY+2, 2, 2);
        ctx.fillRect(w-3, bodyY+bodyH-4, 2, 2);
        // Add fog light
        if (!this.isCop) {
            ctx.fillStyle = '#ffffaa';
            ctx.fillRect(w-6, bodyY + bodyH/2 -1, 2, 2);
        }
        
        // Taillights (Detailed)
        ctx.fillStyle = '#800000'; // Dark Red Housing
        ctx.fillRect(1, bodyY+1, 3, 5);
        ctx.fillRect(1, bodyY+bodyH-6, 3, 5);
        
        // Brake Lights (Will be drawn dynamically if braking, else dim)
        // Draw static part
        ctx.fillStyle = '#500000'; // Off state
        ctx.fillRect(1, bodyY+2, 2, 3);
        ctx.fillRect(1, bodyY+bodyH-5, 2, 3);

        // Accessories
        if (this.isCop) {
            // Lightbar
            let barX = roofRect.x + roofRect.w/2 - 2;
            ctx.fillStyle = '#141414';
            ctx.fillRect(barX, roofRect.y-1, 4, roofRect.h+2);
            ctx.fillStyle = '#dc0000'; // Red
            ctx.fillRect(barX, roofRect.y-2, 4, 4);
            ctx.fillStyle = '#fff'; // Center white
            ctx.fillRect(barX+1, roofRect.y, 2, roofRect.h);
            ctx.fillStyle = '#0032ff'; // Blue
            ctx.fillRect(barX, roofRect.y + roofRect.h - 2, 4, 4);
            
            // Push bar
            ctx.fillStyle = '#333';
            ctx.fillRect(w-1, bodyY+4, 1, bodyH-8);
            ctx.fillStyle = '#111';
            ctx.fillRect(w-2, bodyY+4, 1, 2);
            ctx.fillRect(w-2, bodyY+bodyH-6, 1, 2);
            // Add grill detail
            ctx.fillStyle = '#444';
            ctx.fillRect(w-3, bodyY+ bodyH/2 -2, 2, 4);
        } else if (!this.isCivilian) {
            // Spoiler logic
            if (this.hasSpoiler) {
                // Spoiler (Player only)
                ctx.fillStyle = '#141414';
                ctx.fillRect(5, bodyY+1, 2, 3);
                ctx.fillRect(5, bodyY+bodyH-4, 2, 3);
                ctx.fillStyle = '#1e1e1e'; // Wing
                ctx.fillRect(3, bodyY, 3, bodyH);
                ctx.fillStyle = '#333'; // Carbon highlight
                ctx.fillRect(3, bodyY+2, 1, bodyH-4);
                // Add supports
                ctx.fillStyle = '#222';
                ctx.fillRect(4, bodyY + bodyH/2 -1, 1, 2);
            }
            
            // ANGEL WINGS logic
            if (this.id === 'angel') {
                ctx.fillStyle = '#fff'; // White feather
                ctx.strokeStyle = '#e0e0e0'; // Grey outline
                
                // Left Wing
                ctx.beginPath();
                ctx.moveTo(10, bodyY);
                ctx.lineTo(0, bodyY - 8);
                ctx.lineTo(12, bodyY - 12);
                ctx.lineTo(20, bodyY);
                ctx.fill();
                ctx.stroke();
                
                // Right Wing
                ctx.beginPath();
                ctx.moveTo(10, bodyY + bodyH);
                ctx.lineTo(0, bodyY + bodyH + 8);
                ctx.lineTo(12, bodyY + bodyH + 12);
                ctx.lineTo(20, bodyY + bodyH);
                ctx.fill();
                ctx.stroke();
                
                // Halo hint
                ctx.strokeStyle = '#ffd700';
                ctx.beginPath();
                ctx.arc(w - 10, bodyY + bodyH/2, 6, 0, Math.PI * 2);
                ctx.stroke();
            }
        }

        return cvs;
    }

    getRect() {
        return new Rect(this.pos.x - this.width/2, this.pos.y - this.height/2, this.width, this.height);
    }
    
    getHitbox() {
        // Hitbox is slightly smaller than sprite
        return new Rect(this.pos.x - (this.width-10)/2, this.pos.y - (this.height-10)/2, this.width-10, this.height-10);
    }

    // New Smart Raycast System
    checkSensors(allCars, player, buildings) {
        let results = {
            front: false,
            left: false,
            right: false,
            frontDist: 999,
            rightClear: true,
            leftClear: true
        };

        const rayDist = 200;
        const sideRayDist = 60;
        const rad = degToRad(this.angle);
        const forward = new Vector2(Math.cos(rad), -Math.sin(rad));
        const right = new Vector2(Math.cos(rad + Math.PI/2), -Math.sin(rad + Math.PI/2));
        const left = new Vector2(Math.cos(rad - Math.PI/2), -Math.sin(rad - Math.PI/2));

        // Helper for point-box collision (simplified)
        const checkRay = (start, dir, length, widthCheck=30) => {
            let hit = false;
            let minDist = length;
            
            let end = start.add(dir.mult(length));
            
            // Check cars
            // Handle null player for menu
            let objects = [...allCars];
            if (player) objects.push(player);

            for (let obj of objects) {
                if (obj === this) continue;
                
                // Simple distance check first
                let d = this.pos.distanceTo(obj.pos);
                if (d > length + 50) continue;

                // Project obj pos onto ray
                let toObj = obj.pos.sub(start);
                let dot = toObj.dot(dir);
                let latDist = Math.abs(toObj.dot(new Vector2(-dir.y, dir.x))); // Perpendicular distance

                if (dot > 0 && dot < length && latDist < widthCheck) {
                    hit = true;
                    if (dot < minDist) minDist = dot;
                }
            }
            return { hit, dist: minDist };
        };

        // Front Ray (Traffic)
        let fRay = checkRay(this.pos, forward, rayDist, 25);
        if (fRay.hit) {
            results.front = true;
            results.frontDist = fRay.dist;
        }

        // Side Rays (Blind spots for lane change)
        let rRay = checkRay(this.pos, right, sideRayDist, 40);
        if (rRay.hit) results.rightClear = false;

        let lRay = checkRay(this.pos, left, sideRayDist, 40);
        if (lRay.hit) results.leftClear = false;

        return results;
    }

    physics(buildings, drift, fireWheelActive) {
        // USE CUSTOM STATS IF AVAILABLE (PLAYER), ELSE DEFAULTS
        let turnSpeed = this.customTurnSpeed || TURN_SPEED;
        let maxSpeed = this.customMaxSpeed || (this.isCop ? MAX_SPEED_COP : (this.isCivilian ? MAX_SPEED_CIVILIAN_BASE : MAX_SPEED_PLAYER));
        let acceleration = this.customAccel || ACCELERATION;
        
        // --- Fire Wheel Skill Check ---
        if (!this.isCop && !this.isCivilian && fireWheelActive) {
             maxSpeed *= 1.5; // 5x faster in both modes
             acceleration *= 2;
        }

        if (this.isCivilian) maxSpeed *= this.speedTrait;

        let acc = this.accInput;

        // Damage Effects
        if (this.health) {
            let rr = this.health.parts['rr_wheel'] <= 0;
            let rl = this.health.parts['rl_wheel'] <= 0;
            if (rr && rl) { acc = 0; maxSpeed = 0; }
            else if (rr || rl) { maxSpeed *= 0.6; acc *= 0.6; }

            if (this.health.parts['back_torso'] <= 0) maxSpeed *= 0.75;

            if (this.rotDirection === -1 && this.health.parts['fl_wheel'] <= 0) turnSpeed *= 0.2;
            if (this.rotDirection === 1 && this.health.parts['fr_wheel'] <= 0) turnSpeed *= 0.2;
        }
        
        // Ghostly Rider Achievement Tracking (Player only) - DEPRECATED LOGIC
        if (!this.isCop && !this.isCivilian) {
            if (this.rotDirection !== 0 && this.lastRotDirection === 0 && this.vel.mag() > 0.5) {
                // Starting a turn
                this.turnComplete = true; // Set to true at start, cleared if hit building
            }
            if (this.rotDirection === 0 && this.lastRotDirection !== 0 && this.vel.mag() > 0.5) {
                // Ending a turn (successfully if turnComplete is still true)
                // The check and increment is done outside to track state across frames.
            }
            this.lastRotDirection = this.rotDirection;
        }


        // Turning
        if (this.rotDirection !== 0 && this.vel.mag() > 0.5) {
            let rad = degToRad(this.angle);
            let headingVec = new Vector2(Math.cos(rad), -Math.sin(rad));
            let dot = this.vel.dot(headingVec);
            let flip = dot > 0 ? 1 : -1;
            
            this.angle -= this.rotDirection * turnSpeed * flip;
        }

        // Velocity
        let rad = degToRad(this.angle);
        let forward = new Vector2(Math.cos(rad), -Math.sin(rad));
        
        this.vel = this.vel.add(forward.mult(acc));

        let speed = this.vel.mag();
        
        // Friction / Drift
        if (drift && speed > 3) {
            this.vel = this.vel.mult(DRIFT_SLIDE);
        } else {
            if (speed > 0.1) {
                let dot = this.vel.dot(forward);
                let direction = dot > 0 ? 1 : -1;
                let targetVel = forward.mult(speed * direction);
                this.vel = this.vel.lerp(targetVel, 0.12);
                this.vel = this.vel.mult(FRICTION);
            } else {
                if (Math.abs(acc) < 0.01) this.vel = new Vector2(0, 0);
            }
        }

        if (this.vel.mag() > maxSpeed) {
            this.vel = this.vel.normalize().mult(maxSpeed);
        }

        this.pos = this.pos.add(this.vel);

        // Building Collisions
        let hitbox = this.getHitbox();
        this.isCollidingWithBuilding = false; // Reset collision state
        for (let b of buildings) {
            if (hitbox.collideRect(b.rect)) {
                
                if (!this.isCop && !this.isCivilian) {
                    this.turnComplete = false; // Failed Ghostly Rider check
                    this.isCollidingWithBuilding = true;
                }
                
                let dx = hitbox.centerx - b.rect.centerx;
                let dy = hitbox.centery - b.rect.centery;
                let wCombined = (hitbox.w + b.rect.w) / 2;
                let hCombined = (hitbox.h + b.rect.h) / 2;
                
                let ox = wCombined - Math.abs(dx);
                let oy = hCombined - Math.abs(dy);

                if (ox < oy) {
                    if (dx > 0) this.pos.x += ox; else this.pos.x -= ox;
                    this.vel.x *= 0.5;
                } else {
                    if (dy > 0) this.pos.y += oy; else this.pos.y -= oy;
                    this.vel.y *= 0.5;
                }
                hitbox = this.getHitbox();
                
                if (this.isCivilian) {
                    this.reversing = !this.reversing;
                    this.stuckTimer = 0;
                }
            }
        }
    }

    updateCop(player, buildings, isGhostlyRiderActive) {
        if (!this.isCop) return;
        
        // Stunned Logic
        if (this.stunTimer > 0) {
            this.stunTimer--;
            this.vel = this.vel.mult(0.9); // Slow down significantly
            return; // No AI when stunned
        }
        
        // Oil Slick Spin Logic
        if (this.spinTimer > 0) {
            this.spinTimer--;
            this.angle += 15; // Spin uncontrollably
            this.vel = this.vel.mult(0.96); // Slide
            this.physics(buildings, true, false); // Physics with drift enabled
            return;
        }
        
        // If player is invisible, ignore them!
        if (isGhostlyRiderActive) {
            this.accInput = ACCELERATION * 0.1; // Just cruise slowly
            this.rotDirection = 0; 
            this.physics(buildings, false, false);
            return; 
        }

        let futurePos = player.pos.add(player.vel.mult(25));
        let diff = futurePos.sub(this.pos);
        
        if (this.vel.mag() < 1.0) this.stuckTimer++;
        else this.stuckTimer = 0;

        if (this.stuckTimer > 50) this.reversing = true;
        if (this.stuckTimer > 90) { this.reversing = false; this.stuckTimer = 0; }

        if (this.reversing) {
            this.accInput = -ACCELERATION * 0.6;
            this.rotDirection = 1;
        } else {
            this.accInput = ACCELERATION * 0.98;
            let targetAngle = Math.atan2(-diff.y, diff.x) * 180 / Math.PI;
            
            let currentAngle = this.angle;
            let angleDiff = (targetAngle - currentAngle + 180) % 360 - 180;
             if (angleDiff < -180) angleDiff += 360;
             if (angleDiff > 180) angleDiff -= 360;

            if (angleDiff > 8) this.rotDirection = -1;
            else if (angleDiff < -8) this.rotDirection = 1;
            else this.rotDirection = 0;
        }

        this.physics(buildings, false, false);
    }
    
    updateCivilian(buildings, allCars, player) {
        if (!this.isCivilian) return;

        // Grid info
        const gx = Math.floor(this.pos.x / BLOCK_SIZE);
        const gy = Math.floor(this.pos.y / BLOCK_SIZE);
        const cx = gx * BLOCK_SIZE + BLOCK_SIZE/2;
        const cy = gy * BLOCK_SIZE + BLOCK_SIZE/2;
        const isIntersection = (gx % 3 === 0) && (gy % 3 === 0);
        
        // Init heading if null
        if (this.targetHeading === null) {
            this.targetHeading = Math.round(this.angle / 90) * 90;
        }

        // --- 1. SENSOR CHECK ---
        const sensors = this.checkSensors(allCars, player, buildings);
        let braking = false;
        let coasting = false; // NEW: Coasting state
        let yielding = false;

        // --- 2. INTERSECTION & YIELD LOGIC ---
        let distToCenter = Math.sqrt((this.pos.x - cx)**2 + (this.pos.y - cy)**2);
        let insideBox = isIntersection && distToCenter < 140; 

        // If approaching intersection, check for cross traffic
        if (isIntersection && !insideBox && distToCenter < 280) {
            let intendedTurn = (this.targetHeading - this.angle + 360) % 360; 
            let isRightTurn = (Math.abs(intendedTurn - 90) < 45); 

            for(let other of allCars) {
                if (other === this) continue;
                let otherDist = Math.sqrt((other.pos.x - cx)**2 + (other.pos.y - cy)**2);
                
                // General Intersection Yield (stop crashes)
                // Only yield if other car is closer or already entering
                if (otherDist < distToCenter * 0.8 || otherDist < 120) {
                    let angleDiff = Math.abs(this.angle - other.angle);
                    // If perpendicular (cross traffic)
                    if (angleDiff > 80 && angleDiff < 100 || angleDiff > 260 && angleDiff < 280) {
                        yielding = true;
                    }
                    // Special Right Turn Yield (Oncoming)
                    if (isRightTurn && Math.abs(angleDiff - 180) < 20) {
                        // Oncoming traffic within range
                        if (otherDist < 250) yielding = true;
                    }
                }
            }
        }

        // Inside box = Right of way (Clear it!)
        if (insideBox) {
            yielding = false;
            // Only stop if literally touching bumper to bumper
            if (sensors.front && sensors.frontDist > 50) braking = false;
        } else {
            // Front sensor brake logic modified for coasting
            if (sensors.front) {
                if (sensors.frontDist < 30) braking = true; // Panic stop only when VERY close
                else if (sensors.frontDist < 100) coasting = true; // Just lift off gas
            }
            if (yielding) braking = true;
        }

        // --- 3. LANE LOGIC & OVERTAKING ---
        if ((braking || coasting) && !yielding && !insideBox) {
            this.blockedTimer++;
            // If stuck behind someone slow, try to overtake
            if (this.blockedTimer > this.patience && this.speedTrait > 1.0) {
                 // Check if lane change is safe
                 if (this.laneSwitchDir === 0) {
                    // Prefer passing on Right (center) if safe
                    if (sensors.rightClear) this.laneSwitchDir = 1;
                    else if (sensors.leftClear) this.laneSwitchDir = -1;
                 }
            }
        } else {
            this.blockedTimer = 0;
            this.laneSwitchDir = 0;
        }

        // --- 4. STUCK/REVERSE ---
        if (this.vel.mag() < 0.5 && !braking) this.stuckTimer++;
        else this.stuckTimer = 0;

        if (this.stuckTimer > 100) this.reversing = true;
        if (this.stuckTimer > 150 || (this.reversing && this.vel.mag() > 2)) { 
            this.reversing = false; 
            this.stuckTimer = 0; 
            this.angle += 45; // Hard steer to unstick
        }

        // --- 5. EXECUTION ---
        this.brakingVisual = false;

        if (this.reversing) {
             this.accInput = -ACCELERATION * 0.5;
             this.rotDirection = -1; 
             // Reverse lights (not red)
        } else {
            if (braking) {
                // Hard Brake
                this.accInput = -ACCELERATION * 1.5; 
                this.brakingVisual = true; 
                
                if (this.vel.mag() < 0.1) {
                    this.vel = new Vector2(0, 0);
                    this.accInput = 0;
                }
            } else if (coasting) {
                // Gentle Slow Down (No Brake Lights)
                this.accInput = 0; // Lift off gas
                // Friction will naturally slow the car
            } else {
                this.accInput = ACCELERATION * 0.4; 
            }

            // --- LHT LANE CALCULATIONS ---
            let laneOffset = 80;
            if (this.laneSwitchDir === 1) laneOffset = 20; // Move to center (Overtake)
            if (this.laneSwitchDir === -1) laneOffset = 140; // Move to shoulder?

            let targetX = this.pos.x;
            let targetY = this.pos.y;
            let h = (this.targetHeading % 360 + 360) % 360;
            
            if (h === 0) targetY = cy - laneOffset;       
            else if (h === 180) targetY = cy + laneOffset; 
            else if (h === 90) targetX = cx + laneOffset;  
            else if (h === 270) targetX = cx - laneOffset; 

            let lookAhead = 150;
            let steeringTarget = new Vector2(targetX, targetY);
            if (h === 0 || h === 180) steeringTarget.x = this.pos.x + (h===0?lookAhead:-lookAhead);
            else steeringTarget.y = this.pos.y + (h===90?lookAhead:-lookAhead);

            let diff = steeringTarget.sub(this.pos);
            let desiredAngle = Math.atan2(-diff.y, diff.x) * 180 / Math.PI;

            // Pick Heading at Intersection
            if (this.cooldownTimer > 0) this.cooldownTimer--;
            if (isIntersection && distToCenter < 60 && this.cooldownTimer <= 0) {
                // Bias towards going straight (less chaos)
                const directions = [0, 90, 180, 270];
                // Remove U-turn
                let valid = directions.filter(d => Math.abs(d - this.targetHeading) !== 180);
                const newHeading = randChoice(valid);
                this.targetHeading = newHeading;
                this.cooldownTimer = 200; 
            }

            let currentAngle = this.angle;
            let targetSteer = (isIntersection && distToCenter < 90) ? this.targetHeading : desiredAngle;
            
            let angleDiff = (targetSteer - currentAngle + 180) % 360 - 180;
            if (angleDiff < -180) angleDiff += 360;
            if (angleDiff > 180) angleDiff -= 360;

            if (angleDiff > 4) this.rotDirection = -1;
            else if (angleDiff < -4) this.rotDirection = 1;
            else this.rotDirection = 0;
        }

        // Deadlock Breaker: If stuck yielding for too long, just go
        if (yielding) {
            this.blockedTimer++;
            if (this.blockedTimer > 150) yielding = false; // "I'm going!"
        }

        this.physics(buildings, false, false);
    }

    draw(ctx) {
        ctx.save();
        
        let padding = (this.id === 'angel') ? 20 : 0;
        
        ctx.translate(this.pos.x, this.pos.y);
        ctx.rotate(-degToRad(this.angle));
        
        // Draw car sprite centered properly even with padding
        ctx.drawImage(this.sprite, -this.width/2 - padding, -this.height/2 - padding);
        
        // Draw Dynamic Brake Lights
        if (this.brakingVisual) {
            ctx.fillStyle = '#ff0000';
            ctx.shadowBlur = 10;
            ctx.shadowColor = '#ff0000';
            const bodyY = 3, bodyH = this.height - 6;
            ctx.fillRect(1, bodyY+2, 3, 3);
            ctx.fillRect(1, bodyY+bodyH-5, 3, 3);
            ctx.shadowBlur = 0;
        }
        
        // EMP Visual Indicator (on car)
        if (this.stunTimer > 0) {
            ctx.strokeStyle = '#3296ff';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(0, 0, this.width, 0, Math.PI*2);
            ctx.stroke();
        }
        
        ctx.restore();
    }
}

class Person {
    constructor(x, y, walkArea) {
        this.pos = new Vector2(x, y);
        this.angle = -randFloat(0, Math.PI * 2) * 180 / Math.PI;
        
        this.skinColor = randChoice(['#ffdbac', '#f1c27d', '#e0ac69', '#8d5524', '#c68642']);
        this.shirtColor = randChoice(['#ffffff', '#14141e', '#c83232', '#3264c8', '#32c864', '#ffff32', '#ff96c8', '#a0a0a0', '#503250']);
        this.pantColor = randChoice(['#1e1e28', '#2d2d3c', '#283250', '#50463c', '#3c3c46', '#202020']);
        this.hairColor = randChoice(['#000000', '#281e14', '#4b3c28', '#e6c86e', '#8c2828', '#c8c8c8', '#e6e6e6']);
        this.hairStyle = randChoice(['bald', 'short', 'short_messy', 'long', 'ponytail', 'cap', 'afro', 'mohawk']);
        this.shoeColor = randChoice(['#000000', '#ffffff', '#50321e', '#323232']);
        this.accessory = randChoice([null, 'bag', 'hat', 'glasses']);
        
        let angleRad = randFloat(0, Math.PI * 2);
        this.vel = new Vector2(Math.cos(angleRad), Math.sin(angleRad)).mult(0.4);
        this.angle = -angleRad * 180 / Math.PI;
        this.walkArea = walkArea;
        this.rect = new Rect(x-7, y-7, 14, 14);

        this.isDead = false;
        this.isAngry = false;
        this.shoutTimer = 0;
        this.curseWord = "";
        this.frame = randFloat(0, 10);
        this.curseList = ["HEY!", "WATCH IT!", "I'M WALKIN!", "IDIOT!", "NOOO!", "WHAT?!", "CRAZY!"];
    }

    die(bloodGroup) {
        if (this.isDead) return;
        this.isDead = true;
        this.vel = new Vector2(0,0);
        for (let i=0; i<2; i++) {
            bloodGroup.push(new Blood(this.pos.x + randInt(-5,5), this.pos.y + randInt(-5,5)));
        }
    }

    update(player, bloodGroup) {
        if (this.isDead) return;

        let dist = this.pos.distanceTo(player.pos);

        if (dist < 30 && player.vel.mag() > 2.0) {
            this.die(bloodGroup);
            return;
        }

        if (dist < 70 && !this.isAngry) {
            this.isAngry = true;
            this.shoutTimer = 120;
            this.curseWord = randChoice(this.curseList);
            this.vel = new Vector2(0,0);
        }

        if (this.isAngry) {
            this.shoutTimer--;
            if (this.shoutTimer <= 0) {
                this.isAngry = false;
                let angleRad = randFloat(0, Math.PI * 2);
                this.vel = new Vector2(Math.cos(angleRad), Math.sin(angleRad)).mult(0.4);
                this.angle = -angleRad * 180 / Math.PI;
            }
        } else {
            if (this.walkArea) {
                let futurePos = this.pos.add(this.vel.mult(5));
                if (!this.walkArea.collidePoint(futurePos.x, futurePos.y)) {
                    this.vel = this.vel.rotate(180);
                    this.angle = (this.angle + 180) % 360;
                }
            }
            this.pos = this.pos.add(this.vel);
            if (Math.random() < 0.01) {
                let rot = randChoice([90, -90, 180]);
                this.vel = this.vel.rotate(rot);
                this.angle = (this.angle + rot) % 360;
            }
        }

        this.rect.centerx = this.pos.x;
        this.rect.centery = this.pos.y;
        this.frame += 0.2;
    }

    draw(ctx) {
        ctx.save();
        ctx.translate(this.pos.x, this.pos.y);
        
        if (this.isDead) {
            ctx.rotate(-degToRad(this.angle));
            ctx.fillStyle = '#960000';
            ctx.beginPath(); ctx.ellipse(0, 0, 14, 8, 0, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = this.shirtColor;
            ctx.fillRect(-6, -4, 12, 8);
            ctx.fillStyle = this.skinColor;
            ctx.fillRect(4, -3, 6, 6);
        } else {
            ctx.rotate(-degToRad(this.angle));
            let speed = this.isAngry ? 0 : 1;
            let walkCycle = this.frame * 0.8 * speed; 
            let leftLeg = Math.sin(walkCycle) * 4;
            let rightLeg = Math.sin(walkCycle + Math.PI) * 4;
            let leftArm = Math.sin(walkCycle + Math.PI) * 4;
            let rightArm = Math.sin(walkCycle) * 4;
            
            if (this.isAngry) {
                leftLeg = 0; rightLeg = 0;
                leftArm = 0; rightArm = 0;
            }

            ctx.fillStyle = this.pantColor;
            ctx.fillRect(leftLeg - 2, -6, 6, 4);
            ctx.fillRect(rightLeg - 2, 2, 6, 4);

            ctx.fillStyle = this.shoeColor;
            ctx.fillRect(leftLeg + 2, -6, 3, 4);
            ctx.fillRect(rightLeg + 2, 2, 3, 4);

            ctx.fillStyle = this.shirtColor; 
            ctx.fillRect(leftArm - 2, -9, 7, 3);
            ctx.fillRect(rightArm - 2, 6, 7, 3);
            
            ctx.fillStyle = this.skinColor;
            if (this.isAngry) {
                let shake = randInt(-1, 1);
                ctx.fillRect(2 + shake, -10, 5, 5);
                ctx.fillRect(2 + shake, 5, 5, 5);
            } else {
                ctx.fillRect(leftArm + 4, -9, 3, 3); 
                ctx.fillRect(rightArm + 4, 6, 3, 3); 
            }

            ctx.fillStyle = this.shirtColor;
            ctx.fillRect(-4, -6, 10, 12);
            ctx.fillStyle = 'rgba(0,0,0,0.15)';
            ctx.fillRect(0, -2, 2, 4);

            ctx.fillStyle = this.skinColor;
            ctx.fillRect(-2, -4, 7, 8);
            
            if (this.hairStyle === 'cap') {
                ctx.fillStyle = this.hairColor;
                ctx.fillRect(-3, -5, 7, 10);
                ctx.fillStyle = 'rgba(0,0,0,0.2)';
                ctx.fillRect(2, -5, 3, 10);
            } else if (this.hairStyle === 'mohawk') {
                ctx.fillStyle = this.skinColor;
                ctx.fillRect(-3, -5, 6, 10);
                ctx.fillStyle = this.hairColor;
                ctx.fillRect(-4, -1, 8, 2); 
            } else if (this.hairStyle === 'afro') {
                ctx.fillStyle = this.hairColor;
                ctx.fillRect(-4, -6, 10, 12);
            } else if (this.hairStyle !== 'bald') {
                ctx.fillStyle = this.hairColor;
                if (this.hairStyle === 'short') {
                    ctx.fillRect(-3, -5, 6, 10);
                } else if (this.hairStyle === 'short_messy') {
                    ctx.fillRect(-3, -5, 7, 10);
                    ctx.fillRect(-4, -3, 2, 2);
                    ctx.fillRect(-4, 1, 2, 2);
                } else if (this.hairStyle === 'long') {
                    ctx.fillRect(-4, -5, 6, 10);
                    ctx.fillRect(-6, -6, 4, 12); 
                } else if (this.hairStyle === 'ponytail') {
                    ctx.fillRect(-3, -5, 6, 10);
                    ctx.fillRect(-7, -2, 4, 4); 
                }
            }

            // Add accessory
            if (this.accessory === 'bag') {
                ctx.fillStyle = '#8b4513';
                ctx.fillRect(4, 0, 4, 6);
            } else if (this.accessory === 'hat') {
                ctx.fillStyle = '#ff0000';
                ctx.fillRect(-4, -6, 8, 2);
            } else if (this.accessory === 'glasses') {
                ctx.fillStyle = '#000';
                ctx.fillRect(-1, -2, 2, 1);
                ctx.fillRect(3, -2, 2, 1);
                ctx.fillRect(1, -2, 1, 1);
            }
        }
        ctx.restore();
    }
}

class Building {
    constructor(gx, gy, isPark) {
        this.gx = gx;
        this.gy = gy;
        let x = gx * BLOCK_SIZE + BLOCK_SIZE/2;
        let y = gy * BLOCK_SIZE + BLOCK_SIZE/2;
        this.pos = new Vector2(x, y);
        this.w = BLOCK_SIZE - BUILDING_GAP * 2;
        this.h = BLOCK_SIZE - BUILDING_GAP * 2;
        this.rect = new Rect(x - this.w/2, y - this.h/2, this.w, this.h);
        
        this.rng = new SeededRNG(Math.abs(gx * 73856093 ^ gy * 19349663));
        
        this.sprite = this.generateSprite(isPark);
        this.style = isPark ? 'park' : 'building';
    }

    generateSprite(isPark) {
        const cvs = document.createElement('canvas');
        cvs.width = this.w;
        cvs.height = this.h;
        const ctx = cvs.getContext('2d');
        ctx.imageSmoothingEnabled = false;
        
        const w = this.w, h = this.h;
        const rng = this.rng;

        if (isPark) {
            ctx.fillStyle = COLORS.ZOO_BASE;
            ctx.fillRect(0, 0, w, h);
            
            ctx.fillStyle = '#2d7d2d';
            for(let i=0; i<300; i++) {
                ctx.fillRect(rng.randInt(0,w), rng.randInt(0,h), 2, 2);
            }

            ctx.fillStyle = '#b4aa96';
            ctx.fillRect(w/2 - 20, 0, 40, h);
            ctx.fillRect(0, h/2 - 20, w, 40);
            
            for (let r=60; r>10; r-=5) {
                ctx.fillStyle = `rgb(50, 150, ${250-r})`;
                ctx.beginPath(); ctx.arc(w/2+80, h/2-80, r, 0, Math.PI*2); ctx.fill();
            }
            // Add trees
            for(let i=0; i<5; i++) {
                let tx = rng.randInt(20, w-20);
                let ty = rng.randInt(20, h-20);
                ctx.fillStyle = '#228b22';
                ctx.beginPath(); ctx.arc(tx, ty, 10, 0, Math.PI*2); ctx.fill();
                ctx.fillStyle = '#8b4513';
                ctx.fillRect(tx-2, ty+10, 4, 10);
            }
        } else {
            ctx.fillStyle = COLORS.SIDEWALK;
            ctx.fillRect(0, 0, w, h);
            
            ctx.fillStyle = '#737378';
            for(let i=0; i<w; i+=20) {
                ctx.fillRect(i, 0, 1, h);
                ctx.fillRect(0, i, w, 1);
            }

            for (let i=0; i<8; i++) { // More props
                let px = rng.randInt(5, w-20);
                let py = rng.randInt(5, h-20);
                if (px > 30 && px < w-30 && py > 30 && py < h-50) continue; 

                let type = rng.choice(['planter', 'box', 'vent', 'bench', 'lamp']);
                if (type === 'planter') {
                    ctx.fillStyle = '#644632'; ctx.fillRect(px, py, 12, 12);
                    ctx.fillStyle = '#3c8c3c'; ctx.beginPath(); ctx.arc(px+6, py+6, 5, 0, Math.PI*2); ctx.fill();
                } else if (type === 'box') {
                    ctx.fillStyle = '#64646e'; ctx.fillRect(px, py, 10, 16);
                    ctx.fillStyle = '#50505a'; ctx.fillRect(px+1, py+1, 8, 14);
                } else if (type === 'vent') {
                    ctx.fillStyle = '#aaa'; ctx.fillRect(px, py, 12, 12);
                    ctx.fillStyle = '#555'; 
                    ctx.fillRect(px+2, py+2, 8, 2);
                    ctx.fillRect(px+2, py+5, 8, 2);
                    ctx.fillRect(px+2, py+8, 8, 2);
                } else if (type === 'bench') {
                    ctx.fillStyle = '#8b4513';
                    ctx.fillRect(px, py, 16, 4);
                    ctx.fillRect(px+2, py+4, 12, 2);
                } else if (type === 'lamp') {
                    ctx.fillStyle = '#333';
                    ctx.fillRect(px+4, py, 4, 12);
                    ctx.fillStyle = '#ffff00';
                    ctx.beginPath(); ctx.arc(px+6, py-2, 4, 0, Math.PI*2); ctx.fill();
                }
            }

            let pad = 12;
            let wallH = 35;
            let iw = w - pad*2, ih = h - pad*2;
            let roofRect = {x:pad, y:pad, w:iw, h:ih - wallH};
            let wallRect = {x:pad, y:pad+ih-wallH, w:iw, h:wallH};

            let styles = ['modern', 'izakaya', 'brick', 'school'];
            let style = rng.choice(styles);
            this.buildingStyle = style;

            if (style === 'school') {
                ctx.fillStyle = COLORS.SCHOOL_BEIGE; ctx.fillRect(roofRect.x, roofRect.y, roofRect.w, roofRect.h);
                ctx.fillStyle = '#dcd2b4';
                for(let i=0; i<roofRect.w; i+=4) ctx.fillRect(roofRect.x+i, roofRect.y, 1, roofRect.h);

                ctx.fillStyle = '#c8beace'; ctx.fillRect(wallRect.x, wallRect.y, wallRect.w, wallRect.h);
                ctx.fillStyle = '#b4aa96'; ctx.fillRect(roofRect.x+roofRect.w/2-20, roofRect.y+roofRect.h/2-20, 40, 40);
                drawCircle(ctx, COLORS.CLOCK_FACE, roofRect.x+roofRect.w/2, roofRect.y+roofRect.h/2, 15);
                ctx.strokeStyle = '#000'; ctx.beginPath(); ctx.moveTo(roofRect.x+roofRect.w/2, roofRect.y+roofRect.h/2); ctx.lineTo(roofRect.x+roofRect.w/2, roofRect.y+roofRect.h/2-10); ctx.stroke();
                ctx.fillStyle = '#6496c8';
                for(let r=0; r<3; r++) {
                    for(let c=0; c<6; c++) {
                        if (rng.next()>0.2) {
                            let wx = roofRect.x + c*(iw/6)+8;
                            let wy = roofRect.y + r*25+15;
                            ctx.fillStyle = '#465a6e'; 
                            ctx.fillRect(wx-1, wy-1, 22, 17);
                            ctx.fillStyle = '#6496c8'; 
                            ctx.fillRect(wx, wy, 20, 15);
                            ctx.fillStyle = '#a0c8fa'; 
                            ctx.beginPath(); ctx.moveTo(wx+12, wy); ctx.lineTo(wx+16, wy); ctx.lineTo(wx+4, wy+15); ctx.lineTo(wx, wy+15); ctx.fill();
                            // Add curtain detail
                            ctx.fillStyle = '#ffffff';
                            ctx.fillRect(wx+1, wy+1, 1, 14);
                        }
                    }
                }
            } else if (style === 'izakaya') {
                ctx.fillStyle = COLORS.WOOD_DARK; ctx.fillRect(roofRect.x-2, roofRect.y-2, roofRect.w+4, roofRect.h+4);
                ctx.fillStyle = COLORS.ROOF_TILE_JP; ctx.fillRect(roofRect.x, roofRect.y, roofRect.w, roofRect.h);
                ctx.fillStyle = '#2d2d32'; 
                for(let i=0; i<roofRect.h; i+=6) {
                    ctx.fillRect(roofRect.x, roofRect.y+i, roofRect.w, 2);
                }

                ctx.fillStyle = COLORS.WOOD_RED; ctx.fillRect(wallRect.x, wallRect.y, wallRect.w, wallRect.h);
                for(let i=0; i<4; i++) {
                    let lx = wallRect.x + (iw/4)*i + 20;
                    let ly = wallRect.y+5;
                    drawCircle(ctx, '#000', lx, ly-2, 2); 
                    drawCircle(ctx, COLORS.LANTERN_RED, lx, ly, 6);
                    ctx.fillStyle = '#ffaa32'; 
                    ctx.fillRect(lx-2, ly-2, 4, 4);
                }
                // Add sign
                ctx.fillStyle = '#0000ff';
                ctx.fillRect(wallRect.x + 10, wallRect.y - 10, 20, 10);
            } else if (style === 'modern') {
                ctx.fillStyle = '#9696a0'; ctx.fillRect(roofRect.x, roofRect.y, roofRect.w, roofRect.h);
                for(let i=0; i<200; i++) {
                    ctx.fillStyle = rng.next() > 0.5 ? '#a0a0aa' : '#8c8c96';
                    ctx.fillRect(roofRect.x + rng.randInt(0, roofRect.w), roofRect.y + rng.randInt(0, roofRect.h), 2, 2);
                }
                
                ctx.strokeStyle = '#555'; ctx.lineWidth = 2;
                ctx.strokeRect(roofRect.x+4, roofRect.y+4, roofRect.w-8, roofRect.h-8);

                ctx.fillStyle = '#787882'; ctx.fillRect(wallRect.x, wallRect.y, wallRect.w, wallRect.h);
                let winW = iw/3 - 5, winH = (ih-wallH)/3 - 5;
                for(let r=0; r<3; r++) {
                    for(let c=0; c<3; c++) {
                        let wx = roofRect.x + c*(winW+5) + 8, wy = roofRect.y + r*(winH+5) + 8;
                        ctx.fillStyle = rng.choice([COLORS.WIN_LIT_COOL, COLORS.WIN_LIT_WARM, COLORS.WIN_DARK]);
                        ctx.fillRect(wx, wy, winW, winH);
                        if (rng.next() > 0.6) {
                            ctx.fillStyle = COLORS.AC;
                            ctx.fillRect(wx+winW-10, wy+winH, 10, 8);
                            drawCircle(ctx, '#333', wx+winW-5, wy+winH+4, 3); 
                            // Add vent
                            ctx.fillStyle = '#aaa';
                            ctx.fillRect(wx+winW-12, wy+winH+2, 2, 4);
                        }
                        // Add blinds
                        if (rng.next() > 0.5) {
                            ctx.fillStyle = '#ddd';
                            for(let b=0; b<winH; b+=3) {
                                ctx.fillRect(wx+1, wy+b, winW-2, 1);
                            }
                        }
                    }
                }
                // Add antenna
                if (rng.next() > 0.7) {
                    ctx.fillStyle = '#555';
                    ctx.fillRect(roofRect.x + roofRect.w/2, roofRect.y - 10, 2, 10);
                    ctx.beginPath(); ctx.moveTo(roofRect.x + roofRect.w/2 +1, roofRect.y -10); ctx.lineTo(roofRect.x + roofRect.w/2 +10, roofRect.y -15); ctx.stroke();
                }
            } else { // Brick
                ctx.fillStyle = '#a06450'; ctx.fillRect(roofRect.x, roofRect.y, roofRect.w, roofRect.h);
                ctx.fillStyle = '#8c5040';
                for(let by = roofRect.y; by < roofRect.bottom; by+=6) {
                    ctx.fillRect(roofRect.x, by, roofRect.w, 1);
                    for(let bx = roofRect.x + (by%12===0?0:6); bx < roofRect.right; bx+=12) {
                        ctx.fillRect(bx, by, 1, 6);
                    }
                }

                ctx.fillStyle = COLORS.SIDEWALK; ctx.fillRect(wallRect.x, wallRect.y, wallRect.w, wallRect.h);
                let ww = iw/5, wh = (ih-wallH)/4;
                for(let r=0; r<4; r++) {
                    for(let c=0; c<5; c++) {
                        ctx.fillStyle = rng.choice([COLORS.WIN_LIT_WARM, COLORS.WIN_DARK]);
                        ctx.fillRect(roofRect.x + c*ww + 8, roofRect.y + r*wh + 8, ww-16, wh-20);
                        ctx.fillStyle = '#555';
                        ctx.fillRect(roofRect.x + c*ww + 7, roofRect.y + r*wh + 8 + wh - 20, ww-14, 2);
                        // Add frame
                        ctx.strokeStyle = '#777';
                        ctx.strokeRect(roofRect.x + c*ww + 8, roofRect.y + r*wh + 8, ww-16, wh-20);
                    }
                }
            }
        }
        return cvs;
    }

    draw(ctx) {
        ctx.fillStyle = 'rgba(0,0,0,0.25)';
        ctx.fillRect(this.rect.x+8, this.rect.y+8, this.w, this.h);
        ctx.drawImage(this.sprite, this.rect.x, this.rect.y);
    }
}

class Sakura {
    constructor(x, y) {
        this.pos = new Vector2(x, y);
        this.rect = new Rect(x-20, y-20, 40, 40);
        this.sprite = this.generate();
        this.petals = [];
        for(let i=0; i<5; i++) {
            this.petals.push({x: randInt(-15, 15), y: randInt(10, 20), c: randChoice([COLORS.SAKURA_PINK, '#fff'])});
        }
    }
    generate() {
        const cvs = document.createElement('canvas');
        cvs.width = 40; cvs.height = 40;
        const ctx = cvs.getContext('2d');
        ctx.fillStyle = '#46281e'; ctx.fillRect(18, 20, 4, 20);
        for(let i=0; i<15; i++) {
            ctx.fillStyle = COLORS.SAKURA_DARK;
            drawCircle(ctx, ctx.fillStyle, randInt(5,35), randInt(10,35), randInt(3,5));
        }
        for(let i=0; i<20; i++) {
            ctx.fillStyle = COLORS.SAKURA_PINK;
            drawCircle(ctx, ctx.fillStyle, randInt(5,35), randInt(5,30), randInt(3,5));
        }
        for(let i=0; i<10; i++) {
            ctx.fillStyle = '#ffdcdc';
            drawCircle(ctx, ctx.fillStyle, randInt(10,30), randInt(5,25), randInt(1,3));
        }
        return cvs;
    }
    draw(ctx) {
        this.petals.forEach(p => {
            ctx.fillStyle = p.c;
            ctx.fillRect(this.pos.x + p.x, this.pos.y + p.y, 3, 3);
        });
        ctx.drawImage(this.sprite, this.rect.x, this.rect.y);
    }
}

class Blood {
    constructor(x, y) {
        this.pos = new Vector2(x, y);
        this.size = randInt(15, 30);
        this.color = '#b40000';
        this.rect = new Rect(x-this.size/2, y-this.size/2, this.size, this.size);
    }
    draw(ctx) {
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.pos.x, this.pos.y, this.size/2, 0, Math.PI*2);
        ctx.fill();
        ctx.fillStyle = '#8c0000';
        ctx.beginPath();
        ctx.arc(this.pos.x + randInt(-5,5), this.pos.y + randInt(-5,5), this.size/3, 0, Math.PI*2);
        ctx.fill();
    }
}

class Particle {
    constructor(x, y, type) {
        this.pos = new Vector2(x, y);
        this.type = type;
        this.life = type === 'smoke' ? 40 : 20;
        this.maxLife = this.life;
        
        if (type === 'smoke') {
            this.vel = new Vector2(randFloat(-1, 1), randFloat(-1, 1));
            this.size = randInt(4, 10);
            let c = randInt(50, 100);
            this.color = `rgb(${c},${c},${c})`;
        } else if (type === 'spark') {
            this.vel = new Vector2(randFloat(-4, 4), randFloat(-4, 4));
            this.size = 5;
            this.color = '#ff6400';
        }
    }
    update() {
        this.pos = this.pos.add(this.vel);
        this.life--;
    }
    draw(ctx) {
        ctx.fillStyle = this.color;
        ctx.fillRect(this.pos.x - this.size/2, this.pos.y - this.size/2, this.size, this.size);
    }
}

class Skid {
    constructor(x, y, angle) {
        this.pos = new Vector2(x, y);
        this.angle = angle;
        this.life = 100;
        this.rect = new Rect(x-10, y-10, 20, 20);
    }
    update() { this.life -= 2; }
    draw(ctx) {
        ctx.save();
        ctx.translate(this.pos.x, this.pos.y);
        ctx.rotate(-degToRad(this.angle));
        ctx.fillStyle = `rgba(30, 30, 30, ${this.life/100 * 0.6})`;
        ctx.fillRect(-5, -2, 10, 4);
        ctx.restore();
    }
}

// New: Fire Trail for Floor (Fire Wheel)
class FireTrail {
    constructor(x, y, angle) {
        this.pos = new Vector2(x, y);
        this.angle = angle;
        this.life = 40;
        this.maxLife = 40;
    }
    update() { this.life--; }
    draw(ctx) {
        ctx.save();
        ctx.translate(this.pos.x, this.pos.y);
        ctx.rotate(-degToRad(this.angle));
        
        let alpha = this.life / this.maxLife;
        let fireColors = ['#ff0000', '#ff6400', '#ffff00', '#ff4500'];
        for(let i=0; i<20; i++) { // More particles for fire vibe
            let px = randInt(-20, 20);
            let py = randInt(-6, 6);
            let psize = randInt(2, 5);
            ctx.fillStyle = randChoice(fireColors);
            ctx.globalAlpha = alpha * randFloat(0.5, 1.0);
            ctx.fillRect(px, py, psize, psize);
        }
        ctx.globalAlpha = 1.0;
        
        ctx.restore();
    }
}

// New: Oil Slick for Drifter
class OilSlick {
    constructor(x, y) {
        this.pos = new Vector2(x, y);
        this.life = 10 * 60; // 10 seconds
        this.radius = 25;
    }
    update() { this.life--; }
    draw(ctx) {
        let alpha = Math.min(1.0, this.life / 60);
        ctx.fillStyle = `rgba(20, 20, 20, ${alpha})`;
        ctx.beginPath();
        ctx.arc(this.pos.x, this.pos.y, this.radius, 0, Math.PI*2);
        ctx.fill();
        // Shine
        ctx.fillStyle = `rgba(100, 100, 100, ${alpha * 0.3})`;
        ctx.beginPath();
        ctx.ellipse(this.pos.x - 5, this.pos.y - 5, 8, 4, 0.5, 0, Math.PI*2);
        ctx.fill();
    }
}

// New: Shockwave for Angel Ability & EMP
class Shockwave {
    constructor(x, y, color, maxR) {
        this.pos = new Vector2(x, y);
        this.r = 10;
        this.maxR = maxR || 400; 
        this.color = color || '#fff';
        this.active = true;
    }
    update() {
        this.r += 15; // Expand fast
        if (this.r > this.maxR) this.active = false;
    }
    draw(ctx) {
        let alpha = 1.0 - (this.r / this.maxR);
        ctx.strokeStyle = this.color;
        ctx.globalAlpha = alpha;
        ctx.lineWidth = 10;
        ctx.beginPath();
        ctx.arc(this.pos.x, this.pos.y, this.r, 0, Math.PI*2);
        ctx.stroke();
        ctx.globalAlpha = 1.0;
    }
}

// --- Main Game Class ---

class Game {
    constructor() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.ctx.imageSmoothingEnabled = false;
        
        this.resize();
        window.addEventListener('resize', () => this.resize());

        // Inputs
        this.keys = {};
        this.kPressed = false; // For K key toggle
        this.zPressed = false; // For Power Ability
        this.leftPressed = false; // Menu navigation
        this.rightPressed = false; // Menu navigation
        this.fPressed = false;
        this.ePressed = false;
        
        window.addEventListener('keydown', e => this.keys[e.key.toLowerCase()] = true);
        window.addEventListener('keyup', e => this.keys[e.key.toLowerCase()] = false);
        this.canvas.addEventListener('mousedown', e => this.onClick(e));

        // Game State
        this.state = 'MENU'; // MENU, CAR_SELECT, PLAY, GAMEOVER, SETTINGS
        this.selectedCarIndex = 0; // Default car selection
        
        this.score = 0;
        this.highScore = 0;
        this.achievements = []; // { name: '...', timer: 180 }
        
        // Buttons
        this.restartRect = new Rect(0,0,0,0);
        this.playRect = new Rect(0,0,0,0);
        this.selectRect = new Rect(0,0,0,0); 
        this.settingsRect = new Rect(0,0,0,0); 
        this.resetProgressRect = new Rect(0,0,0,0); 
        this.backRect = new Rect(0,0,0,0);
        this.tvToggleRect = new Rect(0,0,0,0);
        
        // --- ACHIEVEMENT & SKILL MECHANISMS ---
        this.hasGhostlyRider = false;
        this.ghostlyRiderActive = false;
        this.ghostlyRiderCooldown = 0; 
        this.ghostlyRiderDuration = 0; 
        this.ghostlyRiderCooldownMax = 15 * FPS; 
        this.ghostlyRiderDurationMax = 15 * FPS; 

        this.hasFireWheel = false;
        this.fireWheelActive = false;
        this.fireWheelCooldown = 0;
        this.fireWheelDuration = 0;
        this.fireWheelCooldownMax = 15 * FPS; 
        this.fireWheelDurationMax = 15 * FPS; 
        
        // Z Power
        this.powerCooldown = 0;
        this.powerActive = false; // For duration based powers (Ramming)
        this.powerTimer = 0;
        
        this.turnCount = 0; 
        this.driftTime = 0; 
        
        this.showProgress = false; 
        
        // TV Mode Settings
        this.tvMode = true; // Default ON

        // Intersection turn tracking
        this.isInsideIntersection = false;
        this.playerInitialAngle = null;
        
        // Out of car
        this.outOfCar = false;
        this.playerPerson = null;
        this.repairTimer = 0;

        // Load Data
        this.loadData();

        // Initialize game world so background renders in Menu
        this.initGame();

        this.loop = this.loop.bind(this);
        requestAnimationFrame(this.loop);
    }
    
    // --- Persistence ---
    saveData() {
        const data = {
            highScore: Math.max(this.score, this.highScore),
            hasGhostlyRider: this.hasGhostlyRider,
            hasFireWheel: this.hasFireWheel,
            tvMode: this.tvMode,
            turnCount: this.turnCount,
            driftTime: this.driftTime
        };
        localStorage.setItem('tokyo_drift_chase_v2', JSON.stringify(data));
        this.highScore = data.highScore;
    }
    
    loadData() {
        const saved = localStorage.getItem('tokyo_drift_chase_v2');
        if (saved) {
            const data = JSON.parse(saved);
            this.highScore = data.highScore || 0;
            this.hasGhostlyRider = data.hasGhostlyRider || false;
            this.hasFireWheel = data.hasFireWheel || false;
            if (data.tvMode !== undefined) this.tvMode = data.tvMode;
            this.turnCount = data.turnCount || 0;
            this.driftTime = data.driftTime || 0;
        }
    }
    
    resetData() {
        localStorage.removeItem('tokyo_drift_chase_v2');
        this.highScore = 0;
        this.hasGhostlyRider = false;
        this.hasFireWheel = false;
        this.tvMode = true; // Default back to true
        this.turnCount = 0;
        this.driftTime = 0;
    }

    initGame() {
        // Init player based on Selection
        let carSpec = PLAYER_ROSTER[this.selectedCarIndex];
        
        // Create car
        this.player = new Car(0, 0, carSpec.color);
        
        // Apply stats & ID
        this.player.type = carSpec.type;
        this.player.id = carSpec.id; // Important for sprite gen
        this.player.hasSpoiler = carSpec.hasSpoiler;
        this.player.sprite = this.player.createCarSprite(); 
        
        this.player.customMaxSpeed = carSpec.stats.speed;
        this.player.customTurnSpeed = carSpec.stats.turn;
        this.player.customAccel = carSpec.stats.accel;
        this.player.health = new CarHealth(carSpec.stats.hp); 
        this.player.powerData = carSpec.powerData;

        this.camera = new Camera();
        this.buildings = [];
        this.people = [];
        this.cops = [];
        this.civilians = [];
        this.sakura = [];
        this.particles = [];
        this.skids = [];
        this.floorEffects = []; // New layer for floor trails & oil
        this.shockwaves = []; // New list for Angel ability
        this.blood = [];
        this.loadedChunks = new Set();
        
        // Setup menu camera pos
        this.menuCamPos = new Vector2(0, 0);

        this.spawnTimer = 0;
        this.score = 0;
        
        // Reset state
        this.ghostlyRiderActive = false;
        this.ghostlyRiderCooldown = 0; 
        this.ghostlyRiderDuration = 0; 
        this.fireWheelActive = false;
        this.fireWheelDuration = 0;
        this.fireWheelCooldown = 0;
        
        this.powerCooldown = 0;
        this.powerActive = false;
        this.powerTimer = 0;
        
        // Keep achievements array for popups active
        
        this.isInsideIntersection = false;
        this.playerInitialAngle = null;

        this.outOfCar = false;
        this.playerPerson = null;
    }

    resize() {
        this.canvas.width = window.innerWidth;
        this.canvas.height = window.innerHeight;
        this.ctx.imageSmoothingEnabled = false;
    }

    onClick(e) {
        const mx = e.clientX;
        const my = e.clientY;

        if (this.state === 'MENU') {
            if (this.playRect.collidePoint(mx, my)) {
                this.state = 'CAR_SELECT'; 
            }
            if (this.settingsRect.collidePoint(mx, my)) {
                this.state = 'SETTINGS';
            }
        } else if (this.state === 'SETTINGS') {
            if (this.backRect.collidePoint(mx, my)) {
                this.state = 'MENU';
                this.saveData(); // Save settings when leaving
            }
            if (this.resetProgressRect.collidePoint(mx, my)) {
                this.resetData();
                alert("Progress Reset!");
            }
            if (this.tvToggleRect.collidePoint(mx, my)) {
                this.tvMode = !this.tvMode;
            }
        } else if (this.state === 'CAR_SELECT') {
            // Check for drive button
            if (this.selectRect.collidePoint(mx, my)) {
                // Check lock
                let spec = PLAYER_ROSTER[this.selectedCarIndex];
                if (spec.unlockScore && this.highScore < spec.unlockScore) {
                    // Locked sound or visual shake?
                    return; 
                }
                this.initGame(); 
                this.state = 'PLAY';
            }
        } else if (this.state === 'GAMEOVER') {
            if (this.restartRect.collidePoint(mx, my)) {
                this.initGame();
                this.state = 'PLAY';
            }
        }
    }
    
    // --- New Achievement Logic ---

    showAchievement(name) {
        // Only show if not already showing the same one and not in the list
        if (!this.achievements.some(a => a.name === name)) {
            this.achievements.push({ name: name, timer: 180 }); // 3 seconds @ 60 FPS
            this.saveData(); // Save unlock immediately
        }
    }

    updateAchievementLogic(drift) {
        const player = this.player;

        // --- 1. Ghostly Rider: 10 non-bumping intersection turns ---
        if (!this.hasGhostlyRider) {
            
            const playerX = player.pos.x;
            const playerY = player.pos.y;
            const blockX = Math.floor(playerX / BLOCK_SIZE);
            const blockY = Math.floor(playerY / BLOCK_SIZE);

            const isRoadX = (blockX % 3 === 0);
            const isRoadY = (blockY % 3 === 0);
            const inIntersectionBlock = isRoadX && isRoadY;
            
            const getCardinalAngle = (angle) => Math.round(((angle % 360) + 360) % 360 / 90) * 90;
            const currentCardinalAngle = getCardinalAngle(player.angle);

            if (inIntersectionBlock) {
                if (!this.isInsideIntersection) {
                    this.isInsideIntersection = true;
                    this.playerInitialAngle = currentCardinalAngle;
                }
            } else if (this.isInsideIntersection) {
                this.isInsideIntersection = false;
                const turnSuccess = (currentCardinalAngle !== this.playerInitialAngle);

                if (turnSuccess && !player.isCollidingWithBuilding) {
                    this.turnCount++;
                } else if (player.isCollidingWithBuilding) {
                    this.turnCount = 0; 
                }
                player.isCollidingWithBuilding = false;
                this.playerInitialAngle = null;
            }
            
            if (player.isCollidingWithBuilding) {
                this.turnCount = 0;
            }

            if (this.turnCount >= 10) {
                this.hasGhostlyRider = true;
                this.showAchievement("Ghostly Rider Unlocked!");
            }
        }
        
        // --- 2. Fire Wheel: 30 seconds of drifting without hitting a cop ---
        if (!this.hasFireWheel) {
            if (drift && player.vel.mag() > 4) {
                let copCollision = this.cops.some(cop => cop.getHitbox().collideRect(player.getHitbox()));
                if (!copCollision) {
                    this.driftTime++;
                } else {
                    this.driftTime = 0; 
                    player.isCollidingWithCop = true;
                }
            } else {
                this.driftTime = 0;
            }
            if (this.driftTime >= 30 * FPS) {
                this.hasFireWheel = true;
                this.showAchievement("Fire Wheel Unlocked!");
            }
        }
        
        // Update achievement pop-up timers
        this.achievements.forEach(a => a.timer--);
        this.achievements = this.achievements.filter(a => a.timer > 0);
    }
    
    updateSkillMechanics() {
        // K key toggle logic
        if (this.keys['k'] && !this.kPressed) { 
            this.showProgress = !this.showProgress;
            this.kPressed = true;
        }
        if (!this.keys['k']) this.kPressed = false;
        
        // --- Ghostly Rider ---
        if (this.hasGhostlyRider) {
            if ((this.keys['x'] || this.keys['X']) && !this.ghostlyRiderActive && this.ghostlyRiderCooldown <= 0) {
                this.ghostlyRiderActive = true;
                this.ghostlyRiderDuration = this.ghostlyRiderDurationMax;
                this.ghostlyRiderCooldown = this.ghostlyRiderCooldownMax;
            }
        }
        if (this.ghostlyRiderActive) {
            this.ghostlyRiderDuration--;
            if (this.ghostlyRiderDuration <= 0) this.ghostlyRiderActive = false;
        } else if (this.ghostlyRiderCooldown > 0) {
            this.ghostlyRiderCooldown--;
        }
        
        // --- Fire Wheel ---
        if (this.hasFireWheel) {
             if ((this.keys['c'] || this.keys['C']) && !this.fireWheelActive && this.fireWheelCooldown <= 0) {
                 this.fireWheelActive = true;
                 this.fireWheelDuration = this.fireWheelDurationMax;
                 this.fireWheelCooldown = this.fireWheelCooldownMax;
             }
        }
        if (this.fireWheelActive) {
            this.fireWheelDuration--;
            if (this.fireWheelDuration <= 0) this.fireWheelActive = false;
        } else if (this.fireWheelCooldown > 0) {
            this.fireWheelCooldown--;
        }
        
        // --- Z POWER (Unique per Car) ---
        if ((this.keys['z'] || this.keys['Z']) && !this.zPressed && this.powerCooldown <= 0) {
            this.zPressed = true;
            this.activatePower();
        }
        if (!this.keys['z'] && !this.keys['Z']) this.zPressed = false;
        
        if (this.powerCooldown > 0) this.powerCooldown--;
        if (this.powerActive) {
            this.powerTimer--;
            if (this.powerTimer <= 0) this.powerActive = false;
        }
        
        // --- Process Active Powers ---
        
        // Juggernaut (Tank): Visual Effect
        if (this.player.id === 'tank' && this.powerActive) {
            // Visual handled in draw loop
        }
        
        // Update Shockwaves (Angel & Mecha)
        for (let i = this.shockwaves.length - 1; i >= 0; i--) {
            let sw = this.shockwaves[i];
            sw.update();
            if (!sw.active) {
                this.shockwaves.splice(i, 1);
                continue;
            }
            
            // Collision
            this.cops.forEach(cop => {
                if (cop.dead) return;
                let d = cop.pos.distanceTo(sw.pos);
                if (d < sw.r + 20 && d > sw.r - 40) { 
                    if (this.player.id === 'angel') {
                        // Kill
                        cop.dead = true;
                        this.score += 50;
                        for(let k=0; k<10; k++) this.particles.push(new Particle(cop.pos.x, cop.pos.y, 'spark'));
                    } else if (this.player.id === 'mecha') {
                        // Stun
                        cop.stunTimer = 300; // 5 seconds
                        cop.vel = new Vector2(0,0);
                    }
                }
            });
        }
    }
    
    activatePower() {
        if (!this.player.powerData) return;
        
        const pid = this.player.id;
        
        // 1. Street Legend: Repair
        if (pid === 'standard') {
            // Heal 50
            if (this.player.health) {
                // Hacky heal: add to parts
                for (let k in this.player.health.parts) {
                    this.player.health.parts[k] = Math.min(this.player.health.maxHp, this.player.health.parts[k] + 50);
                }
            }
            this.powerCooldown = this.player.powerData.cooldown;
        }
        // 2. Drift King: Oil Slick
        else if (pid === 'drifter') {
            this.floorEffects.push(new OilSlick(this.player.pos.x, this.player.pos.y));
            this.powerCooldown = this.player.powerData.cooldown;
        }
        // 3. The Beast: Juggernaut
        else if (pid === 'tank') {
            this.powerActive = true;
            this.powerTimer = 300; // 5 seconds
            this.powerCooldown = this.player.powerData.cooldown;
        }
        // 4. Mecha-V: EMP Blast
        else if (pid === 'mecha') {
            this.shockwaves.push(new Shockwave(this.player.pos.x, this.player.pos.y, '#32ffff', 400));
            this.powerCooldown = this.player.powerData.cooldown;
        }
        // 5. Seraphim: Smite
        else if (pid === 'angel') {
            this.shockwaves.push(new Shockwave(this.player.pos.x, this.player.pos.y, '#ffd700', 300));
            this.powerCooldown = this.player.powerData.cooldown;
        }
    }

    isOnRoad() {
        const gx = Math.floor(this.player.pos.x / BLOCK_SIZE);
        const gy = Math.floor(this.player.pos.y / BLOCK_SIZE);
        return (gx % 3 === 0) || (gy % 3 === 0);
    }

    generateChunk(gx, gy) {
        const isRoadX = (gx % 3 === 0);
        const isRoadY = (gy % 3 === 0);
        const cx = gx * BLOCK_SIZE + BLOCK_SIZE/2;
        const cy = gy * BLOCK_SIZE + BLOCK_SIZE/2;
        
        let seed = Math.abs(gx * 73856093 ^ gy * 19349663);
        let rng = new SeededRNG(seed);

        if (isRoadX || isRoadY) {
            if (rng.next() < 0.1) {
                this.people.push(new Person(cx + rng.randInt(-50,50), cy + rng.randInt(-50,50), null));
            }
            let density = rng.choice([0, 1, 1, 2, 2, 3]); 
            
            for(let i=0; i<density; i++) {
                 let heading = 0;
                 if (isRoadX && !isRoadY) heading = rng.choice([90, 270]); 
                 else if (!isRoadX && isRoadY) heading = rng.choice([0, 180]); 
                 else heading = rng.choice([0, 90, 180, 270]); 

                 let laneOffset = 80;
                 let jitter = rng.randInt(-20, 20); 
                 let longScatter = rng.randInt(-150, 150); 

                 let spawnX = cx;
                 let spawnY = cy;

                 if (heading === 0) { spawnY = cy - laneOffset + jitter; spawnX = cx + longScatter; } 
                 else if (heading === 180) { spawnY = cy + laneOffset + jitter; spawnX = cx + longScatter; } 
                 else if (heading === 90) { spawnX = cx + laneOffset + jitter; spawnY = cy + longScatter; } 
                 else if (heading === 270) { spawnX = cx - laneOffset + jitter; spawnY = cy + longScatter; }

                 let type = rng.choice(Object.keys(CAR_TYPES));
                 let civCar = new Car(spawnX, spawnY, type, false, true);
                 civCar.angle = heading;
                 civCar.targetHeading

<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>3D Rubik's Cube — Keyboard Controls</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  html,body { height:100%; margin:0; background:#111; color:#eee; font-family:system-ui,Segoe UI,Roboto,Arial; }
  #info { position: absolute; left:12px; top:12px; z-index:2; background:rgba(0,0,0,0.45); padding:10px; border-radius:8px; max-width:360px; }
  button { margin:4px; padding:6px 10px; border-radius:6px; border:1px solid #444; background:#222; color:#fff; cursor:pointer;}
  button:hover{filter:brightness(1.2)}
  #map { font-size:13px; margin-top:8px; line-height:1.4; color:#ddd; }
  canvas { display:block; }
</style>
</head>
<body>
<div id="info">
  <strong>Rubik's Cube — Keyboard Controls</strong>
  <div id="map">
    Lowercase = clockwise (facing the face). Uppercase / Shift = counterclockwise (prime).<br>
    Keys: <strong>F U R B L D</strong> (and lowercase). Example: <code>f</code> = Front clockwise, <code>F</code> (or Shift+f) = Front counterclockwise.
  </div>
  <div style="margin-top:8px;">
    <button id="scramble">Scramble</button>
    <button id="reset">Reset</button>
  </div>
  <div style="margin-top:8px; font-size:12px; color:#bbb">
    Mouse: drag to orbit, scroll to zoom.
  </div>
</div>
<script type="module">
// --- Dependencies: three.js and OrbitControls from CDN ---
import * as THREE from 'https://unpkg.com/three@0.156.0/build/three.module.js';
import { OrbitControls } from 'https://unpkg.com/three@0.156.0/examples/jsm/controls/OrbitControls.js';

// Basic scene
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x0b0b0b);
const camera = new THREE.PerspectiveCamera(50, innerWidth/innerHeight, 0.1, 1000);
camera.position.set(5,5,7);
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth, innerHeight);
document.body.appendChild(renderer.domElement);

// light
const hemi = new THREE.HemisphereLight(0xffffff, 0x222222, 0.9); scene.add(hemi);
const dir = new THREE.DirectionalLight(0xffffff, 0.5); dir.position.set(5,10,7); scene.add(dir);

// orbit
const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;

// cube parameters
const CUBIE = 0.98; // size of one small cube (slightly less than 1 to show seams)
const GAP = 0.02;
const SIZE = 3; // 3x3x3

// colors for faces in standard scheme
const COLORS = {
  U: 0xffffff, // white (up)
  D: 0xffff00, // yellow (down)
  F: 0xff0000, // red (front)
  B: 0xff8000, // orange (back) - using different orange for visibility
  R: 0x0000ff, // blue (right)
  L: 0x00ff00  // green (left)
};

// helper to create material for each face (six faces)
function faceMaterials(stickers) {
  // stickers is an object with optional keys: U,D,F,B,R,L mapping to color hex, others default to black
  const black = new THREE.MeshBasicMaterial({color:0x000000});
  const mats = [];
  // BoxGeometry face order in three.js: +X, -X, +Y, -Y, +Z, -Z
  // Map to R, L, U, D, F, B respectively
  mats.push( stickers.R ? new THREE.MeshStandardMaterial({color:stickers.R}) : black ); // +X
  mats.push( stickers.L ? new THREE.MeshStandardMaterial({color:stickers.L}) : black ); // -X
  mats.push( stickers.U ? new THREE.MeshStandardMaterial({color:stickers.U}) : black ); // +Y
  mats.push( stickers.D ? new THREE.MeshStandardMaterial({color:stickers.D}) : black ); // -Y
  mats.push( stickers.F ? new THREE.MeshStandardMaterial({color:stickers.F}) : black ); // +Z
  mats.push( stickers.B ? new THREE.MeshStandardMaterial({color:stickers.B}) : black ); // -Z
  return mats;
}

// store cubies
const cubies = []; // objects {mesh, pos: {x,y,z} integers -1,0,1}
const group = new THREE.Group();
scene.add(group);

// create 3x3x3 cubies
for (let x=-1; x<=1; x++){
  for (let y=-1; y<=1; y++){
    for (let z=-1; z<=1; z++){
      const stickers = {};
      if (y===1) stickers.U = COLORS.U;
      if (y===-1) stickers.D = COLORS.D;
      if (z===1) stickers.F = COLORS.F;
      if (z===-1) stickers.B = COLORS.B;
      if (x===1) stickers.R = COLORS.R;
      if (x===-1) stickers.L = COLORS.L;

      const geo = new THREE.BoxGeometry(CUBIE, CUBIE, CUBIE);
      const mats = faceMaterials(stickers);
      const mesh = new THREE.Mesh(geo, mats);
      // position
      mesh.position.set(x*(CUBIE+GAP), y*(CUBIE+GAP), z*(CUBIE+GAP));
      mesh.userData.cubeIndex = `${x},${y},${z}`;
      scene.add(mesh);
      cubies.push({mesh, pos:{x,y,z}});
    }
  }
}

// helpers: select cubies on face
function selectFace(faceChar) {
  // faces: F (z=+1), B (z=-1), U (y=+1), D (y=-1), R (x=+1), L (x=-1)
  let axis = null, coord = null;
  switch(faceChar.toUpperCase()){
    case 'F': axis='z'; coord=1; break;
    case 'B': axis='z'; coord=-1; break;
    case 'U': axis='y'; coord=1; break;
    case 'D': axis='y'; coord=-1; break;
    case 'R': axis='x'; coord=1; break;
    case 'L': axis='x'; coord=-1; break;
  }
  if (!axis) return [];
  // tolerance for floating point
  return cubies.filter(c => Math.abs(c.mesh.position[axis] - coord*(CUBIE+GAP)) < 0.001).map(c => c.mesh);
}

// animate rotation of a face
let isAnimating = false;
async function rotateFace(faceChar, clockwise=true, duration=250){
  if (isAnimating) return;
  isAnimating = true;
  const sel = selectFace(faceChar);
  if (sel.length===0){ isAnimating=false; return; }

  // create temporary group at origin
  const rotGroup = new THREE.Group();
  scene.add(rotGroup);

  // move selected cubies into rotGroup, preserving world transforms
  for (const m of sel){
    THREE.SceneUtils ? null : null; // SceneUtils may not be present; we'll reparent by world transforms:
    const worldPos = new THREE.Vector3();
    m.getWorldPosition(worldPos);
    m.parent.remove(m);
    // convert world position to rotGroup local:
    rotGroup.add(m);
    m.position.copy(worldPos);
    m.position.setFromMatrixPosition(m.matrixWorld); // ensure correct
    // set position relative to rotGroup by converting world to local:
    rotGroup.worldToLocal(m.position);
  }

  // determine rotation axis in rotGroup's local coords
  let axisVec = new THREE.Vector3();
  switch(faceChar.toUpperCase()){
    case 'F': axisVec.set(0,0,1); break;
    case 'B': axisVec.set(0,0,1); break;
    case 'U': axisVec.set(0,1,0); break;
    case 'D': axisVec.set(0,1,0); break;
    case 'R': axisVec.set(1,0,0); break;
    case 'L': axisVec.set(1,0,0); break;
  }

  // B and L need orientation flip to keep "looking at face" rule consistent
  // We'll unify: clockwise true means rotate +90 when looking at face from outside.
  // For faces where the axis direction points inward, flip sign.
  const signFlip = (faceChar.toUpperCase()==='B' || faceChar.toUpperCase()==='L' || faceChar.toUpperCase()==='D') ? -1 : 1;
  const angle = (Math.PI/2) * (clockwise ? 1 : -1) * signFlip;

  // animation
  const start = performance.now();
  const end = start + duration;
  return new Promise(resolve=>{
    function tick(now){
      const t = Math.min(1, (now-start)/(end-start));
      const eased = (1 - Math.cos(Math.PI*t))/2; // easeInOut
      rotGroup.rotation.set(0,0,0);
      rotGroup.rotateOnAxis(axisVec, angle * eased);
      if (t<1){
        requestAnimationFrame(tick);
      } else {
        // finalize: detach children back to scene and snap positions/rotations to grid
        for (const m of sel){
          // convert local position to world then back to scene local
          const worldPos = new THREE.Vector3();
          m.getWorldPosition(worldPos);
          scene.add(m);
          m.position.copy(worldPos);
          scene.worldToLocal(m.position);
          // snap positions to -1,0,1 slots
          const slot = {x: Math.round(m.position.x/(CUBIE+GAP)), y: Math.round(m.position.y/(CUBIE+GAP)), z: Math.round(m.position.z/(CUBIE+GAP))};
          m.position.set(slot.x*(CUBIE+GAP), slot.y*(CUBIE+GAP), slot.z*(CUBIE+GAP));
          // normalize rotation to multiples of 90deg
          const rx = Math.round(m.rotation.x / (Math.PI/2)) * (Math.PI/2);
          const ry = Math.round(m.rotation.y / (Math.PI/2)) * (Math.PI/2);
          const rz = Math.round(m.rotation.z / (Math.PI/2)) * (Math.PI/2);
          m.rotation.set(rx,ry,rz);
        }
        // remove rotGroup
        scene.remove(rotGroup);
        // update cubies array positions to reflect new coordinates
        for (const c of cubies){
          c.pos.x = Math.round(c.mesh.position.x/(CUBIE+GAP));
          c.pos.y = Math.round(c.mesh.position.y/(CUBIE+GAP));
          c.pos.z = Math.round(c.mesh.position.z/(CUBIE+GAP));
        }
        isAnimating = false;
        resolve();
      }
    }
    requestAnimationFrame(tick);
  });
}

// key handling: lowercase = clockwise; uppercase = counterclockwise.
// Accept both key character detection and event.shiftKey.
window.addEventListener('keydown', async (e) => {
  // ignore if typing in input (no inputs here)
  if (isAnimating) return;
  const k = e.key;
  // map letters f,u,r,b,l,d (case-insensitive)
  if (!k) return;
  const letter = k.toLowerCase();
  if (!'furbl d'.includes(letter) && !'furbld'.includes(letter)) {
    // continue — only respond to our keys
  }
  const valid = ['f','u','r','b','l','d'];
  if (!valid.includes(letter)) return;
  // decide clockwise vs counterclockwise:
  // if letter is lowercase and no shift -> clockwise.
  // if letter is uppercase (k === k.toUpperCase()) or e.shiftKey -> counterclockwise.
  let clockwise = true;
  if (k !== k.toLowerCase() || e.shiftKey) clockwise = false;
  // but user wanted mapping: lowercase = clockwise; Big letter or Shift = prime (counterclockwise).
  // call rotation
  await rotateFace(letter.toUpperCase(), clockwise);
});

// simple scramble
async function scrambleMoves(n=20){
  const faces = ['F','R','U','B','L','D'];
  for (let i=0;i<n;i++){
    const f = faces[Math.floor(Math.random()*faces.length)];
    const cw = Math.random() < 0.5;
    await rotateFace(f, cw, 160);
  }
}

// reset: rebuild cube positions and rotations
function resetCube(){
  // remove all meshes
  for (const c of cubies){ scene.remove(c.mesh); }
  cubies.length = 0;
  // recreate
  for (let x=-1; x<=1; x++){
    for (let y=-1; y<=1; y++){
      for (let z=-1; z<=1; z++){
        const stickers = {};
        if (y===1) stickers.U = COLORS.U;
        if (y===-1) stickers.D = COLORS.D;
        if (z===1) stickers.F = COLORS.F;
        if (z===-1) stickers.B = COLORS.B;
        if (x===1) stickers.R = COLORS.R;
        if (x===-1) stickers.L = COLORS.L;
        const geo = new THREE.BoxGeometry(CUBIE, CUBIE, CUBIE);
        const mats = faceMaterials(stickers);
        const mesh = new THREE.Mesh(geo, mats);
        mesh.position.set(x*(CUBIE+GAP), y*(CUBIE+GAP), z*(CUBIE+GAP));
        scene.add(mesh);
        cubies.push({mesh, pos:{x,y,z}});
      }
    }
  }
}

document.getElementById('scramble').addEventListener('click', ()=>{ if(!isAnimating) scrambleMoves(25); });
document.getElementById('reset').addEventListener('click', ()=>{ if(!isAnimating) resetCube(); });

// handle resize
window.addEventListener('resize', ()=>{
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});

// render loop
(function animate(){
  requestAnimationFrame(animate);
  controls.update();
  renderer.render(scene, camera);
})();

</script>
</body>
</html>

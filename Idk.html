<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>THE DRIFT • True Backrooms Experience</title>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/PointerLockControls.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin:0; overflow:hidden; background:#000; font-family:'Courier New', monospace; }
        #ui { pointer-events:none; }
        #loading { 
            position:fixed; inset:0; background:#111; display:flex; align-items:center; justify-content:center; 
            color:#ffff99; font-size:48px; letter-spacing:8px; z-index:999; 
            animation: flicker 4s infinite; 
        }
        @keyframes flicker {
            0%,100% { opacity:1; }
            50% { opacity:0.7; }
            52% { opacity:0.9; }
            55% { opacity:0.6; }
        }
        #status { 
            position:fixed; top:20px; left:20px; background:rgba(0,0,0,0.7); padding:10px 20px; 
            color:#ffff99; font-size:18px; border:2px solid #ffff99; z-index:100; opacity:0; transition:opacity 2s;
        }
        .hum { position:fixed; inset:0; background:linear-gradient(transparent, #0008); pointer-events:none; }
    </style>
</head>
<body>
    <div id="loading">NOCLIP DETECTED</div>
    <div id="status">Level <span id="level">0</span> • Entities: None</div>
    <div class="hum"></div>

    <script>
        // TRUE BACKROOMS / DREAMCORE DRIFT — NO SPINNING HOUSES, ONLY MOIST CARPET AND FLUORESCENT HELL
        let scene, camera, renderer, controls;
        let move = {forward:false, backward:false, left:false, right:false};
        let velocity = new THREE.Vector3();
        let clock = new THREE.Clock();
        let level = 0;
        let timeInLevel = 0;
        let nextShift = 60 + Math.random() * 120;
        let isShifting = false;
        let ceiling, floorMesh, walls = [], lights = [], props = [];

        const levels = [
            // 0 — Classic Backrooms (Moist Carpet)
            { name: "Level 0", floorColor: 0xd4c372, wallColor: 0xf0e68c, ceilingColor: 0xf5f5dc, 
              lightColor: 0xffff99, lightIntensity: 0.4, lightFlicker: true, carpetNoise: true },
            // 1 — Run For Your Life (darker, red emergency lights)
            { name: "Level !", floorColor: 0x331100, wallColor: 0x440000, ceilingColor: 0x220000, 
              lightColor: 0xff0000, lightIntensity: 0.2, lightFlicker: true, carpetNoise: false },
            // 2 — Poolrooms
            { name: "Level 37", floorColor: 0x4169e1, wallColor: 0x87cefa, ceilingColor: 0xb0e0e6, 
              lightColor: 0xffffff, lightIntensity: 0.6, lightFlicker: false, carpetNoise: false },
            // 3 — Abandoned Office
            { name: "Level 4", floorColor: 0x8b8b83, wallColor: 0xd3d3d3, ceilingColor: 0xffffff, 
              lightColor: 0xffffff, lightIntensity: 0.5, lightFlicker: true, carpetNoise: false },
            // 4 — The End? (Fake library)
            { name: "Level 6.1", floorColor: 0x331a00, wallColor: 0x1a0d00, ceilingColor: 0x0d0d0d, 
              lightColor: 0x333333, lightIntensity: 0.1, lightFlicker: true, carpetNoise: false },
            // 5 — Manila Rooms
            { name: "Level 188", floorColor: 0xfffacd, wallColor: 0xffe4b5, ceilingColor: 0xffdab9, 
              lightColor: 0xffd700, lightIntensity: 0.8, lightFlicker: false, carpetNoise: false }
        ];

        init();
        animate();

        function init() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x111111, 0.0008);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
            camera.position.set(0, 1.6, 5);

            renderer = new THREE.WebGLRenderer({antialias:true});
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x111111);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);

            // Controls
            controls = new THREE.PointerLockControls(camera, document.body);
            scene.add(controls.getObject());

            document.addEventListener('click', () => {
                controls.lock();
                document.getElementById('loading').style.display = 'none';
                document.getElementById('status').style.opacity = '1';
            });

            document.addEventListener('keydown', e => {
                switch(e.code){
                    case 'KeyW': move.forward = true; break;
                    case 'KeyS': move.backward = true; break;
                    case 'KeyA': move.left = true; break;
                    case 'KeyD': move.right = true; break;
                }
            });
            document.addEventListener('keyup', e => {
                switch(e.code){
                    case 'KeyW': move.forward = false; break;
                    case 'KeyS': move.backward = false; break;
                    case 'KeyA': move.left = false; break;
                    case 'KeyD': move.right = false; break;
                }
            });

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth/window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });

            generateLevel();
        }

        function clearLevel() {
            walls.forEach(w => scene.remove(w));
            lights.forEach(l => scene.remove(l));
            props.forEach(p => scene.remove(p));
            if(floorMesh) scene.remove(floorMesh);
            if(ceiling) scene.remove(ceiling);
            walls = []; lights = []; props = [];
        }

        function generateLevel() {
            clearLevel();
            const lvl = levels[level % levels.length];

            document.getElementById('level').textContent = lvl.name;

            // FLOOR
            const floorGeo = new THREE.PlaneGeometry(500, 500, 64, 64);
            const floorMat = new THREE.MeshStandardMaterial({
                color: lvl.floorColor,
                roughness: 0.9,
                metalness: 0.1
            });
            if (lvl.carpetNoise) {
                floorMat.map = createCarpetTexture();
                floorMat.map.wrapS = floorMat.map.wrapT = THREE.RepeatWrapping;
                floorMat.map.repeat.set(50,50);
            }
            floorMesh = new THREE.Mesh(floorGeo, floorMat);
            floorMesh.rotation.x = -Math.PI/2;
            floorMesh.receiveShadow = true;
            scene.add(floorMesh);

            // CEILING
            const ceilingGeo = new THREE.PlaneGeometry(500, 500);
            const ceilingMat = new THREE.MeshStandardMaterial({color: lvl.ceilingColor});
            ceiling = new THREE.Mesh(ceilingGeo, ceilingMat);
            ceiling.position.y = 4;
            ceiling.rotation.x = Math.PI/2;
            scene.add(ceiling);

            // WALLS — endless maze-like corridors
            const wallGeo = new THREE.BoxGeometry(20, 5, 2);
            const wallMat = new THREE.MeshStandardMaterial({color: lvl.wallColor, roughness: 0.95});
            const wallMatThick = new THREE.MeshStandardMaterial({color: lvl.wallColor});

            for(let i = 0; i < 300; i++) {
                const wall = new THREE.Mesh(
                    Math.random() > 0.7 ? new THREE.BoxGeometry(2, 5, 20) : wallGeo,
                    Math.random() > 0.9 ? wallMatThick : wallMat
                );
                wall.position.set(
                    (Math.random() - 0.5) * 480,
                    2,
                    (Math.random() - 0.5) * 480
                );
                wall.rotation.y = Math.floor(Math.random() * 4) * Math.PI/2;
                wall.castShadow = true;
                wall.receiveShadow = true;
                walls.push(wall);
                scene.add(wall);
            }

            // FLUORESCENT LIGHTS
            for(let i = 0; i < 80; i++) {
                const lightGroup = new THREE.Group();
                const tube = new THREE.Mesh(
                    new THREE.BoxGeometry(8, 0.2, 0.4),
                    new THREE.MeshBasicMaterial({color: lvl.lightColor})
                );
                const flicker = lvl.lightFlicker;
                const light = new THREE.PointLight(lvl.lightColor, flicker ? 0 : lvl.lightIntensity, 20);
                light.position.y = 3.8;
                light.castShadow = true;
                lightGroup.add(tube, light);
                lightGroup.position.set(
                    (Math.random() - 0.5) * 400,
                    3.9,
                    (Math.random() - 0.5) * 400
                );
                lights.push({group: lightGroup, light, flicker});
                scene.add(lightGroup);
            }

            // PROPS — office chairs, filing cabinets, wet floor signs
            for(let i = 0; i < 40; i++) {
                const type = Math.floor(Math.random() * 6);
                let prop;
                if(type === 0) { // almond water bottle
                    prop = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.3, 0.3, 1),
                        new THREE.MeshLambertMaterial({color: 0x87cefa})
                    );
                    prop.position.y = 0.5;
                } else if(type === 1) { // broken office chair
                    const chair = new THREE.Group();
                    const seat = new THREE.Mesh(new THREE.BoxGeometry(1,0.1,1), new THREE.MeshLambertMaterial({color:0x333333}));
                    const back = new THREE.Mesh(new THREE.BoxGeometry(1,1.5,0.1), new THREE.MeshLambertMaterial({color:0x222222}));
                    back.position.y = 0.75; back.position.z = -0.4;
                    chair.add(seat, back);
                    chair.rotation.y = Math.random() * Math.PI;
                    prop = chair;
                } else if(type === 2) { // filing cabinet
                    prop = new THREE.Mesh(
                        new THREE.BoxGeometry(1, 2, 1.5),
                        new THREE.MeshLambertMaterial({color:0x555555})
                    );
                    prop.position.y = 1;
                } else if(type === 3) { // wet floor sign
                    const sign = new THREE.Group();
                    const board = new THREE.Mesh(new THREE.BoxGeometry(0.8,1.2,0.05), new THREE.MeshLambertMaterial({color:0xffff00}));
                    sign.add(board);
                    prop = sign;
                    prop.position.y = 0.6;
                } else if(type === 4) { // flickering monitor
                    const mon = new THREE.Mesh(
                        new THREE.BoxGeometry(1.2, 0.9, 0.4),
                        new THREE.MeshBasicMaterial({color: Math.random()>0.5 ? 0x00ff00 : 0x0000ff})
                    );
                    mon.position.y = 0.8;
                    prop = mon;
                } else { // random debris
                    prop = new THREE.Mesh(
                        new THREE.BoxGeometry(1+Math.random(), 0.2, 1+Math.random()),
                        new THREE.MeshLambertMaterial({color:0x444444})
                    );
                    prop.position.y = 0.1;
                }
                prop.position.x = (Math.random()-0.5)*450;
                prop.position.z = (Math.random()-0.5)*450;
                props.push(prop);
                scene.add(prop);
            }
        }

        function createCarpetTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 512; canvas.height = 512;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#d4c372';
            ctx.fillRect(0,0,512,512);
            for(let i=0; i<8000; i++) {
                ctx.fillStyle = `rgba(100,80,40,${Math.random()*0.3})`;
                ctx.fillRect(Math.random()*512, Math.random()*512, 2+Math.random()*4, 2+Math.random()*4);
            }
            const tex = new THREE.CanvasTexture(canvas);
            return tex;
        }

        function shiftLevel() {
            if(isShifting) return;
            isShifting = true;

            // Flash + humhtc hum
            renderer.setClearColor(0x000000);
            const audio = new Audio('data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQAAAAA='); // silence trick
            audio.play();

            setTimeout(() => {
                level++;
                timeInLevel = 0;
                nextShift = 60 + Math.random() * 180;
                generateLevel();
                renderer.setClearColor(0x111111);
                isShifting = false;
            }, 1200);
        }

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            timeInLevel += delta;

            if(!controls.isLocked) {
                renderer.render(scene, camera);
                return;
            }

            // Movement
            velocity.x *= 0.85;
            velocity.z *= 0.85;
            const dir = new THREE.Vector3();
            dir.z = Number(move.forward) - Number(move.backward);
            dir.x = Number(move.right) - Number(move.left);
            dir.normalize();
            if(move.forward || move.backward) velocity.z -= dir.z * 30 * delta;
            if(move.left || move.right) velocity.x -= dir.x * 30 * delta;
            controls.moveRight(-velocity.x * delta);
            controls.moveForward(-velocity.z * delta);

            // Random no-clip shift
            if(timeInLevel > nextShift && Math.random() < 0.008) {
                shiftLevel();
            }

            // Flickering lights
            lights.forEach(l => {
                if(l.flicker && Math.random() < 0.05) {
                    l.light.intensity = Math.random() > 0.7 ? 0 : levels[level % levels.length].lightIntensity;
                }
            });

            // Subtle hum effect on props
            props.forEach(p => {
                p.position.y += Math.sin(clock.elapsedTime * 3) * 0.0005;
            });

            renderer.render(scene, camera);
        }
    </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Liminal Dreamscape Simulator v2.1</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
        canvas { display: block; }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #fff;
            font-family: monospace;
            font-size: 24px;
            cursor: pointer;
            text-align: center;
        }
        #status {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #fff;
            font-family: monospace;
            font-size: 16px;
            opacity: 0;
            transition: opacity 1s;
        }
        #fade {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: white; 
            opacity: 0;
            pointer-events: none;
            transition: opacity 3s;
        }
        #bloodOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            /* Start transparent */
            background-color: rgba(255, 0, 0, 0); 
            pointer-events: none;
            /* Transition opacity smoothly */
            transition: background-color 0.5s ease-out; 
        }
        #console {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 250px;
            background: rgba(0, 0, 0, 0.9);
            color: lime;
            font-family: monospace;
            padding: 10px;
            box-sizing: border-box;
            display: none;
            opacity: 0;
            transition: opacity 0.3s;
        }
        #output {
            height: 80%;
            overflow-y: scroll;
            margin-bottom: 5px;
            border-bottom: 1px solid lime;
        }
        #input {
            width: calc(100% - 10px);
            background: transparent;
            border: none;
            color: lime;
            font-family: monospace;
            outline: none;
            font-size: 16px;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/0.165.0/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.165.0/examples/js/controls/PointerLockControls.js"></script>
</head>
<body>

    <div id="loading">Click to Start Dream (W/A/S/D to move, / to open console)</div>
    <div id="status">
        Map: <span id="mapName">Loading...</span><br>
        Dream Count: <span id="dream">0</span><br>
        Stability: <span id="stability">100</span>%
    </div>
    <div id="fade"></div>
    <div id="bloodOverlay"></div>
    <div id="console">
        <div id="output">
            --- DREAM CONSOLE v2.1 (100 Maps) ---<br>
            Available commands: `map man`, `skip map`<br>
        </div>
        &gt; <input type="text" id="input">
    </div>

    <script>
        // --- Core Variables ---
        let scene, camera, renderer, controls;
        let move = {forward:false, backward:false, left:false, right:false};
        let velocity = new THREE.Vector3();
        let clock = new THREE.Clock();
        let dreamCount = 0;
        let sanity = 100;
        let isShifting = false;
        let isDead = false;
        let fadeScreen = document.getElementById('fade');
        let bloodOverlay = document.getElementById('bloodOverlay');
        let currentWorld = [];
        let nextShift = 20 + Math.random() * 30;
        let manPosition = new THREE.Vector3();
        let isManMapActive = false;
        let consoleOpen = false;
        let textureLoader = new THREE.TextureLoader();
        let currentMapDanger = 1.0; 

        // --- Audio Variables ---
        let audioContext;
        let currentMusic = null;
        let creepyTracks = [
            "https://files.catbox.moe/4g5v3r.ogg", "https://files.catbox.moe/9p1r7t.ogg", 
            "https://files.catbox.moe/m3b8v9.ogg", "https://files.catbox.moe/q1w5e2.ogg"
        ];
        let currentAmbientSound = null;
        const JUMPSCARE_SOUND = 'https://files.catbox.moe/k6t7u3.ogg';
        const DRIP_SOUND = 'https://files.catbox.moe/p8s2r4.ogg';
        
        let screamAudio = null;
        let dripAudio = null;


        // --- MAP ARCHETYPES (Procedural Factory) ---
        const MAP_ARCHETYPES = [
            { name: "Infinite Hotel", generator: generateInfiniteHotel, sound: "https://files.catbox.moe/9p1r7t.ogg", danger: 0.8 },
            { name: "Quiet Street", generator: generateQuietStreet, sound: "https://files.catbox.moe/9p1r7t.ogg", danger: 1.0 },
            { name: "Empty Mall", generator: generateEmptyMall, sound: "https://files.catbox.moe/q1w5e2.ogg", danger: 1.0 },
            { name: "Office Cubicles", generator: generateOfficeHell, sound: "https://files.catbox.moe/m3b8v9.ogg", danger: 1.2 },
            { name: "Poolrooms", generator: generatePoolrooms, sound: "https://files.catbox.moe/4g5v3r.ogg", danger: 1.2 },
            { name: "Backrooms Classic", generator: generateBackroomsClassic, sound: "https://files.catbox.moe/4g5v3r.ogg", danger: 1.3 },
            { name: "Retro Arcade", generator: generateRetroArcade, sound: "https://files.catbox.moe/q1w5e2.ogg", danger: 1.5 },
            { name: "Trippy Liminal", generator: generateTrippyLiminal, sound: "https://files.catbox.moe/9p1r7t.ogg", danger: 1.8 },
            { name: "Neon Rooftops", generator: generateNeonRooftops, sound: "https://files.catbox.moe/9p1r7t.ogg", danger: 1.8 },
            { name: "Train Platform", generator: generateTrainPlatform, sound: "https://files.catbox.moe/q1w5e2.ogg", danger: 2.0 },
            { name: "Mirror Maze", generator: generateMirrorMaze, sound: "https://files.catbox.moe/m3b8v9.ogg", danger: 2.0 },
            { name: "VHS Static Desert", generator: generateStaticDesert, sound: "https://files.catbox.moe/4g5v3r.ogg", danger: 2.2 },
            { name: "Submerged Highway", generator: generateSubmergedHighway, sound: "https://files.catbox.moe/m3b8v9.ogg", danger: 2.3 },
            { name: "Red Void", generator: generateRedVoid, sound: "https://files.catbox.moe/4g5v3r.ogg", danger: 2.8 },
            { name: "Backrooms Hell", generator: generateBackroomsHell, sound: "https://files.catbox.moe/4g5v3r.ogg", danger: 3.0 },
            { name: "Impossible Geometry", generator: generate4DImpossible, sound: "https://files.catbox.moe/m3b8v9.ogg", danger: 3.2 },
            { name: "Endless Fall", generator: generateEndlessFall, sound: "https://files.catbox.moe/q1w5e2.ogg", danger: 4.0 }, 
        ];

        // --- MAP CATALOG (100 Entries Generated) ---
        const MAP_CATALOG = [];
        let i = 0;
        while (MAP_CATALOG.length < 100) {
            const archetype = MAP_ARCHETYPES[i % MAP_ARCHETYPES.length];
            let suffix = MAP_CATALOG.length + 1;
            if (MAP_CATALOG.length >= 17) {
                suffix = (MAP_CATALOG.length - 17) + (i % 5 > 2 ? 'b' : 'a');
            }
            
            MAP_CATALOG.push({
                id: MAP_CATALOG.length,
                name: `${archetype.name} ${suffix}`,
                generator: archetype.generator,
                sound: archetype.sound,
                danger: archetype.danger + (Math.random() * 0.5 - 0.25)
            });
            i++;
        }
        MAP_CATALOG.sort(() => Math.random() - 0.5);

        init();
        // **FIX: Ensure audio objects are initialized immediately after setup**
        initAudio(); 
        animate();

        // --- Initialization and Setup ---
        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 3000);
            camera.position.set(0, 1.8, 10);
            
            renderer = new THREE.WebGLRenderer({antialias:true});
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);

            const sun = new THREE.DirectionalLight(0xffffff, 1.2);
            sun.position.set(50, 100, 30);
            sun.castShadow = true;
            sun.shadow.mapSize.width = 2048; 
            sun.shadow.mapSize.height = 2048;
            scene.add(new THREE.AmbientLight(0xffffff, 0.4));
            scene.add(sun);

            controls = new THREE.PointerLockControls(camera, document.body);
            scene.add(controls.getObject());

            document.addEventListener('click', () => {
                if(!controls.isLocked && !isDead) {
                    controls.lock();
                    document.getElementById('loading').style.display = 'none';
                    document.getElementById('status').style.opacity = '1';
                    
                    // User interaction grants permission to play. Start music now.
                    playRandomMusic();
                }
            });
            document.addEventListener('keydown', e => {
                if(isDead) return;
                if (e.code === 'Slash' && !consoleOpen) { e.preventDefault(); showConsole(); }
                if (e.code === 'Backslash') { e.preventDefault(); hideConsole(); }
                if (consoleOpen && (e.code === 'Enter' || e.code === 'NumpadEnter')) return;
                switch(e.code) {
                    case 'KeyW': case 'ArrowUp': move.forward = true; break;
                    case 'KeyS': case 'ArrowDown': move.backward = true; break;
                    case 'KeyA': case 'ArrowLeft': move.left = true; break;
                    case 'KeyD': case 'ArrowRight': move.right = true; break;
                }
            });
            document.addEventListener('keyup', e => {
                if(isDead) return;
                switch(e.code) {
                    case 'KeyW': case 'ArrowUp': move.forward = false; break;
                    case 'KeyS': case 'ArrowDown': move.backward = false; break;
                    case 'KeyA': case 'ArrowLeft': move.left = false; break;
                    case 'KeyD': case 'ArrowRight': move.right = false; break;
                }
            });
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
            
            generateDreamWorld();
        }

        // --- Audio Functions ---
        function initAudio() {
            // FIX: Initialize the audio objects only once and preload them
            if (screamAudio === null) {
                screamAudio = new Audio(JUMPSCARE_SOUND);
                screamAudio.volume = 1.0;
                screamAudio.load(); // Preload for instant playback
            }
            if (dripAudio === null) {
                dripAudio = new Audio(DRIP_SOUND);
                dripAudio.volume = 0.8;
                dripAudio.loop = true;
                dripAudio.load(); // Preload for instant playback
            }
        }
        function playRandomMusic() {
            if(currentMusic) currentMusic.pause();
            const track = creepyTracks[Math.floor(Math.random()*creepyTracks.length)];
            currentMusic = new Audio(track);
            currentMusic.loop = true;
            currentMusic.volume = 0.45;
            currentMusic.play().catch(()=>{});
        }
        function changeMusic() {
            if(currentMusic) {
                let v = 0.45;
                const fade = setInterval(() => {
                    v = Math.max(0, v - 0.02);
                    currentMusic.volume = v;
                    if(v <= 0.01) { clearInterval(fade); playRandomMusic(); }
                }, 50);
            } else {
                playRandomMusic();
            }
        }
        function changeAmbientSound(trackURL) {
            if (currentAmbientSound) { currentAmbientSound.pause(); currentAmbientSound = null; }
            if (trackURL) {
                currentAmbientSound = new Audio(trackURL);
                currentAmbientSound.loop = true;
                currentAmbientSound.volume = 0.8;
                currentAmbientSound.play().catch(()=>{});
            }
        }
        function playShiftSound() {
            // If AudioContext is not initialized (e.g., if init() didn't run properly) 
            // we will skip the sound.
            if (!audioContext) { 
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                if (!audioContext) return;
            }
            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();
            osc.frequency.setValueAtTime(400, audioContext.currentTime);
            osc.frequency.exponentialRampToValueAtTime(80, audioContext.currentTime + 1.2);
            gain.gain.setValueAtTime(0.2, audioContext.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 1.2);
            osc.connect(gain).connect(audioContext.destination);
            osc.start();
            osc.stop(audioContext.currentTime + 1.2);
        }
        function playScream() {
            // Stop background music and ambient sounds
            if (currentMusic) currentMusic.pause();
            if (currentAmbientSound) currentAmbientSound.pause();
            
            // FIX: Use the pre-initialized Audio objects
            if (screamAudio) {
                screamAudio.currentTime = 0; 
                screamAudio.play().catch(e => console.error("Scream failed to play:", e));
            }

            if (dripAudio) {
                dripAudio.currentTime = 0; 
                dripAudio.play().catch(e => console.error("Drip failed to play:", e));
            }
        }

        // --- Console/Command Functions (Omitted for brevity, assumed functional) ---
        function showConsole() {
            const con = document.getElementById('console');
            const input = document.getElementById('input');
            const output = document.getElementById('output');
            con.style.display = 'block';
            setTimeout(() => con.style.opacity = '1', 10);
            input.focus();
            consoleOpen = true;
            controls.unlock();
            input.onkeydown = e => {
                if (e.key === 'Enter') {
                    const cmd = input.value.trim().toLowerCase();
                    output.innerHTML += '&gt; ' + input.value + '<br>';
                    if (cmd === 'map man') activateManMap();
                    else if (cmd === 'skip map') smoothShift(true);
                    else if (cmd !== '') output.innerHTML += 'UNKNOWN COMMAND<br>';
                    input.value = '';
                    output.scrollTop = output.scrollHeight;
                }
            };
        }
        function hideConsole() {
            const con = document.getElementById('console');
            con.style.opacity = '0';
            setTimeout(() => { con.style.display = 'none'; }, 300);
            consoleOpen = false;
            controls.lock();
        }

        // --- World Management Functions (Omitted for brevity, assumed functional) ---
        function clearWorld() {
            currentWorld.forEach(obj => {
                if (obj.isMesh) {
                    obj.geometry.dispose();
                    if (Array.isArray(obj.material)) {
                        obj.material.forEach(mat => mat.dispose());
                    } else {
                        obj.material.dispose();
                    }
                }
                scene.remove(obj);
            });
            currentWorld = [];
            isManMapActive = false;
        }
        function addDefaultFloor(color = 0x1a1a1a, size = 5000) {
            const floor = new THREE.Mesh(
                new THREE.PlaneGeometry(size, size), 
                new THREE.MeshStandardMaterial({color: color})
            );
            floor.rotation.x = -Math.PI/2;
            floor.receiveShadow = true;
            floor.name = "DefaultFloor"; 
            scene.add(floor);
            currentWorld.push(floor);
        }
        function removeDefaultFloor() {
            const defaultFloor = scene.getObjectByName("DefaultFloor");
            if(defaultFloor) { scene.remove(defaultFloor); currentWorld.splice(currentWorld.indexOf(defaultFloor), 1); }
        }

        // --- Map Generator Functions (Only relevant functions included for size) ---
        function generateTrippyLiminal() {
            removeDefaultFloor(); 
            const colors = [0xff99cc,0x99ccff,0xffff99,0x99ff99,0xffcc99];
            const sky = colors[Math.floor(Math.random()*5)];
            renderer.setClearColor(sky); scene.fog = new THREE.FogExp2(sky, 0.0008);
            const floor = new THREE.Mesh(new THREE.PlaneGeometry(2000,2000), new THREE.MeshStandardMaterial({color:0x222222}));
            floor.rotation.x = -Math.PI/2; scene.add(floor); currentWorld.push(floor);
            for(let i=0;i<120;i++){
                const obj = new THREE.Mesh(new THREE.BoxGeometry(15+Math.random()*50,15+Math.random()*80,15+Math.random()*50),
                    new THREE.MeshLambertMaterial({color:Math.random()*0xffffff}));
                obj.position.set((Math.random()-0.5)*1800,Math.random()*40+20,(Math.random()-0.5)*1800);
                scene.add(obj); currentWorld.push(obj);
            }
        }
        function generate4DImpossible() {
            removeDefaultFloor();
            renderer.setClearColor(0x000011); scene.fog = new THREE.FogExp2(0x000022, 0.0005);
            const platform = new THREE.Mesh(new THREE.RingGeometry(100, 160, 64), new THREE.MeshBasicMaterial({color:0x111133, side:THREE.DoubleSide}));
            platform.rotation.x = -Math.PI/2; scene.add(platform); currentWorld.push(platform);
            const knot = new THREE.Mesh(new THREE.TorusKnotGeometry(50, 10, 256, 32), new THREE.MeshBasicMaterial({color:0xff0044, wireframe:true}));
            scene.add(knot); currentWorld.push(knot);
            const spin = () => {
                if(currentWorld.includes(knot)) {
                    knot.rotation.x += 0.004 * currentMapDanger; 
                    knot.rotation.y += 0.007 * currentMapDanger;
                    platform.rotation.z += 0.001 * currentMapDanger;
                    requestAnimationFrame(spin);
                }
            };
            spin();
        }
        function generateRedVoid() {
            renderer.setClearColor(0x220000); scene.fog = new THREE.FogExp2(0x440000, 0.0004);
            for(let i=0;i<60;i++){
                const head = new THREE.Mesh(new THREE.SphereGeometry(4+Math.random()*8), new THREE.MeshBasicMaterial({color:0x880000}));
                head.position.set((Math.random()-0.5)*3000, 10+Math.random()*400, (Math.random()-0.5)*3000);
                scene.add(head); currentWorld.push(head);
            }
        }
        function generateEndlessFall() {
            removeDefaultFloor();
            renderer.setClearColor(0x000011); scene.fog = new THREE.FogExp2(0x000011, 0.001);
            const fallRate = 0.7 * currentMapDanger; 
            const fall = () => {
                if(currentWorld.length < 10) {
                    camera.position.y -= fallRate;
                    if(camera.position.y < -300) camera.position.y = 400;
                    controls.getObject().position.copy(camera.position);
                    requestAnimationFrame(fall);
                }
            };
            fall();
            for(let i=0; i<5; i++){
                const shape = new THREE.Mesh(new THREE.DodecahedronGeometry(200), new THREE.MeshBasicMaterial({color:0x8888ff, wireframe:true}));
                shape.position.set((Math.random()-0.5)*2000, (Math.random()-0.5)*2000, (Math.random()-0.5)*2000);
                scene.add(shape); currentWorld.push(shape);
            }
        }
        function generateMirrorMaze() {
            removeDefaultFloor();
            renderer.setClearColor(0x001133); scene.fog = new THREE.FogExp2(0x001133, 0.0001);
            const mirror = new THREE.MeshBasicMaterial({color:0x0088ff, side:THREE.BackSide, transparent:true, opacity:0.8});
            const box = new THREE.Mesh(new THREE.BoxGeometry(3000,400,3000), mirror);
            scene.add(box); currentWorld.push(box);
        }
        function generateBackroomsClassic() {
            removeDefaultFloor();
            renderer.setClearColor(0xffffdd); scene.fog = new THREE.FogExp2(0xffffdd, 0.005);
            const floor = new THREE.Mesh(new THREE.PlaneGeometry(3000,3000), new THREE.MeshStandardMaterial({color:0xddddaa}));
            floor.rotation.x = -Math.PI/2; scene.add(floor); currentWorld.push(floor);
            const wallMat = new THREE.MeshStandardMaterial({color:0xf0e68c});
            const wallHeight = 8;
            for(let i=0; i<500; i++){
                const wall = new THREE.Mesh(new THREE.BoxGeometry(20, wallHeight, 0.2), wallMat);
                wall.position.set((Math.random()-0.5)*2800, wallHeight/2, (Math.random()-0.5)*2800);
                wall.rotation.y = Math.floor(Math.random()*4)*Math.PI/2;
                scene.add(wall); currentWorld.push(wall);
            }
        }
        function generateEmptyMall() {
            renderer.setClearColor(0x112233); scene.fog = new THREE.FogExp2(0x112233, 0.001);
            const floor = new THREE.Mesh(new THREE.PlaneGeometry(3000,3000), new THREE.MeshBasicMaterial({color:0x223344}));
            floor.rotation.x = -Math.PI/2; scene.add(floor); currentWorld.push(floor);
        }
        function generateInfiniteHotel() {
            removeDefaultFloor();
            renderer.setClearColor(0x333333); scene.fog = new THREE.FogExp2(0x333333, 0.0005);
            const floorMat = new THREE.MeshStandardMaterial({color: 0x555555});
            const floor = new THREE.Mesh(new THREE.PlaneGeometry(5000, 5000), floorMat);
            floor.rotation.x = -Math.PI/2; floor.receiveShadow = true; scene.add(floor); currentWorld.push(floor);
            const wallMat = new THREE.MeshStandardMaterial({color: 0x888888});
            const doorMat = new THREE.MeshStandardMaterial({color: 0xaa9933});
            for(let i=-20; i<20; i++){
                const corridor = new THREE.Group();
                const wallR = new THREE.Mesh(new THREE.BoxGeometry(400, 4, 0.2), wallMat);
                wallR.position.set(10, 2, i * 400); corridor.add(wallR);
                const wallL = new THREE.Mesh(new THREE.BoxGeometry(400, 4, 0.2), wallMat);
                wallL.position.set(-10, 2, i * 400); corridor.add(wallL);
                for(let j=-5; j<5; j++){
                    const door = new THREE.Mesh(new THREE.BoxGeometry(0.2, 3.5, 3), doorMat);
                    door.position.set(10, 1.75, i * 400 + j * 40); corridor.add(door);
                }
                scene.add(corridor); currentWorld.push(corridor);
            }
        }
        function generatePoolrooms() {
            removeDefaultFloor();
            renderer.setClearColor(0x87cefa); scene.fog = new THREE.FogExp2(0x87cefa, 0.001);
            const water = new THREE.MeshStandardMaterial({color:0x4169e1, transparent:true, opacity:0.6});
            const waterPlane = new THREE.Mesh(new THREE.PlaneGeometry(3000,3000), water);
            waterPlane.rotation.x = -Math.PI/2; scene.add(waterPlane); currentWorld.push(waterPlane);
            for(let i=0; i<100; i++){
                const p = new THREE.Mesh(new THREE.CylinderGeometry(4, 4, 30), new THREE.MeshStandardMaterial({color:0xcccccc}));
                p.position.set((Math.random()-0.5)*2800, 15, (Math.random()-0.5)*2800);
                scene.add(p); currentWorld.push(p);
            }
        }
        function generateOfficeHell() {
            renderer.setClearColor(0xd3d3d3); scene.fog = new THREE.FogExp2(0xd3d3d3, 0.001);
            const floor = new THREE.Mesh(new THREE.PlaneGeometry(3000,3000), new THREE.MeshStandardMaterial({color:0x8b8b83}));
            floor.rotation.x = -Math.PI/2; scene.add(floor); currentWorld.push(floor);
            for(let i=0; i<50; i++){
                const desk = new THREE.Mesh(new THREE.BoxGeometry(3, 1.5, 6), new THREE.MeshStandardMaterial({color:0x404040}));
                desk.position.set((Math.random()-0.5)*2800, 0.75, (Math.random()-0.5)*2800);
                scene.add(desk); currentWorld.push(desk);
            }
        }
        function generateRetroArcade() {
            renderer.setClearColor(0x0a0a0f); scene.fog = new THREE.FogExp2(0x0a0a0f, 0.001);
            const floor = new THREE.Mesh(new THREE.PlaneGeometry(3000,3000), new THREE.MeshBasicMaterial({color:0x000000}));
            floor.rotation.x = -Math.PI/2; scene.add(floor); currentWorld.push(floor);
            for(let i=0; i<50; i++){
                const cabinet = new THREE.Mesh(new THREE.BoxGeometry(1.5, 2.5, 1), new THREE.MeshBasicMaterial({color:0xff00ff}));
                cabinet.position.set((Math.random()-0.5)*2800, 1.25, (Math.random()-0.5)*2800);
                scene.add(cabinet); currentWorld.push(cabinet);
                const light = new THREE.PointLight(0x00ffff, 2, 50);
                light.position.copy(cabinet.position);
                light.position.y += 3;
                scene.add(light); currentWorld.push(light);
            }
        }
        function generateNeonRooftops() {
            renderer.setClearColor(0x000033); scene.fog = new THREE.FogExp2(0x000033, 0.001);
            const platform = new THREE.Mesh(new THREE.BoxGeometry(500, 2, 500), new THREE.MeshStandardMaterial({color:0x000000}));
            platform.position.y = -1; scene.add(platform); currentWorld.push(platform);
            for(let i=0; i<50; i++){
                const h = 50 + Math.random() * 200;
                const b = new THREE.Mesh(new THREE.BoxGeometry(10, h, 10), new THREE.MeshStandardMaterial({color:0x111122}));
                b.position.set((Math.random()-0.5)*2000, h/2 - 1, (Math.random()-0.5)*2000);
                scene.add(b); currentWorld.push(b);
                const sign = new THREE.PointLight(0xff0000, 1.5, 50);
                sign.position.copy(b.position);
                sign.position.y += h/2 + 2;
                scene.add(sign); currentWorld.push(sign);
            }
        }
        function generateStaticDesert() {
            renderer.setClearColor(0xaaaaaa); scene.fog = new THREE.FogExp2(0xbbbbbb, 0.0005);
            const floor = new THREE.Mesh(new THREE.PlaneGeometry(5000,5000), new THREE.MeshStandardMaterial({color:0x666666}));
            floor.rotation.x = -Math.PI/2; scene.add(floor); currentWorld.push(floor);
            for(let i=0; i<10; i++){
                const tv = new THREE.Mesh(new THREE.BoxGeometry(20, 15, 0.5), new THREE.MeshBasicMaterial({color:0xffffff}));
                tv.position.set((Math.random()-0.5)*4000, 7.5, (Math.random()-0.5)*4000);
                tv.rotation.y = Math.random() * Math.PI * 2;
                scene.add(tv); currentWorld.push(tv);
            }
        }
        function generateSubmergedHighway() {
            removeDefaultFloor();
            renderer.setClearColor(0x000055); scene.fog = new THREE.FogExp2(0x000055, 0.0005);
            const waterMat = new THREE.MeshBasicMaterial({color:0x0044ff, transparent:true, opacity:0.4, side:THREE.DoubleSide});
            const waterPlane = new THREE.Mesh(new THREE.PlaneGeometry(5000,5000), waterMat);
            waterPlane.rotation.x = -Math.PI/2; 
            waterPlane.position.y = -10;
            scene.add(waterPlane); currentWorld.push(waterPlane);
            const road = new THREE.Mesh(new THREE.BoxGeometry(100, 0.5, 4000), new THREE.MeshStandardMaterial({color:0x222222}));
            road.position.y = -10.25; scene.add(road); currentWorld.push(road);
        }
        function generateTrainPlatform() {
            renderer.setClearColor(0x333333); scene.fog = new THREE.FogExp2(0x333333, 0.0008);
            const floor = new THREE.Mesh(new THREE.PlaneGeometry(5000,20), new THREE.MeshStandardMaterial({color:0x444444}));
            floor.rotation.x = -Math.PI/2; scene.add(floor); currentWorld.push(floor);
            const railMat = new THREE.MeshStandardMaterial({color:0x888888});
            for(let i=-20; i<20; i++){
                const tie = new THREE.Mesh(new THREE.BoxGeometry(3, 0.2, 0.5), railMat);
                tie.position.set(0, -0.9, i * 200 - 2000); 
                scene.add(tie); currentWorld.push(tie);
            }
        }
        function generateQuietStreet() {
            renderer.setClearColor(0x111111); scene.fog = new THREE.FogExp2(0x111111, 0.0005);
            const road = new THREE.Mesh(new THREE.PlaneGeometry(20, 5000), new THREE.MeshStandardMaterial({color:0x444444}));
            road.rotation.x = -Math.PI/2; scene.add(road); currentWorld.push(road);
            for(let i=0; i<20; i++){
                const light = new THREE.PointLight(0xf0e0b0, 2, 80);
                light.position.set(0, 10, i * 200 - 2000);
                scene.add(light); currentWorld.push(light);
            }
        }
        function generateBackroomsHell() {
            renderer.setClearColor(0xf5f5dc); scene.fog = new THREE.FogExp2(0xf5f5dc, 0.005);
            const floor = new THREE.Mesh(new THREE.PlaneGeometry(3000,3000), new THREE.MeshStandardMaterial({color:0xd4c372}));
            floor.rotation.x = -Math.PI/2; scene.add(floor); currentWorld.push(floor);
            for(let i=0;i<400;i++){
                const w = new THREE.Mesh(new THREE.BoxGeometry(15+Math.random()*60,8+Math.random()*6,2),
                    new THREE.MeshStandardMaterial({color:0xf0e68c}));
                w.position.set((Math.random()-0.5)*2800,4+Math.random()*3,(Math.random()-0.5)*2800);
                w.rotation.y = Math.floor(Math.random()*8)*Math.PI/4;
                scene.add(w); currentWorld.push(w);
            }
        }
        function generateManMap() {
             isManMapActive = true;
             scene.fog = new THREE.FogExp2(0xaaaaaa, 0.0008);
             renderer.setClearColor(0xcccccc);
             const grassTexture = textureLoader.load('https://threejs.org/examples/textures/crate.gif');
             grassTexture.wrapS = grassTexture.wrapT = THREE.RepeatWrapping;
             grassTexture.repeat.set( 100, 100 );
             const grass = new THREE.Mesh(
                 new THREE.PlaneGeometry(2000, 2000),
                 new THREE.MeshStandardMaterial({color: 0x6b9e3f, map: grassTexture})
             );
             grass.rotation.x = -Math.PI/2;
             grass.receiveShadow = true;
             scene.add(grass);
             currentWorld.push(grass);
             const bladeGeo = new THREE.PlaneGeometry(0.2, 1.2);
             const bladeMat = new THREE.MeshLambertMaterial({color: 0x228B22, side: THREE.DoubleSide});
             for (let i = 0; i < 20000; i++) {
                 const b = new THREE.Mesh(bladeGeo, bladeMat);
                 b.position.set((Math.random()-0.5)*1980, 0.6, (Math.random()-0.5)*1980);
                 b.rotation.y = Math.random() * Math.PI;
                 scene.add(b);
                 currentWorld.push(b);
             }
             const tree = new THREE.Group();
             tree.add(new THREE.Mesh(new THREE.CylinderGeometry(1,1.2,8), new THREE.MeshStandardMaterial({color:0x8B4513})));
             tree.add(new THREE.Mesh(new THREE.SphereGeometry(5,16,16), new THREE.MeshStandardMaterial({color:0x228B22})));
             tree.position.set(-12,4,0);
             tree.children[1].position.y = 6;
             scene.add(tree); currentWorld.push(tree);
             const man = new THREE.Group();
             man.add(new THREE.Mesh(new THREE.BoxGeometry(0.6,2.2,0.4), new THREE.MeshBasicMaterial({color:0x000000})));
             man.add(new THREE.Mesh(new THREE.SphereGeometry(0.35), new THREE.MeshBasicMaterial({color:0x000000})));
             man.position.set(0,1.6,-0.5);
             man.children[1].position.y = 1.4;
             man.rotation.y = Math.PI;
             scene.add(man); currentWorld.push(man);
             manPosition.set(0,0,0); 
             camera.position.set(0, 1.8, 50);
             controls.getObject().position.copy(camera.position);
             controls.getObject().lookAt(manPosition); 
        }
        // --- End of Map Generator Functions ---

        /**
         * Generates a random dream world, ensuring safe spawn.
         */
        function generateDreamWorld() {
            if (isDead) return;
            clearWorld();
            camera.position.set(0, 1.8, 10);
            controls.getObject().position.copy(camera.position);
            addDefaultFloor(0x1a1a1a, 5000); 
            const selectedMap = MAP_CATALOG[Math.floor(Math.random() * MAP_CATALOG.length)];
            currentMapDanger = selectedMap.danger;
            selectedMap.generator();
            document.getElementById('mapName').textContent = selectedMap.name;
            changeAmbientSound(selectedMap.sound);
            changeMusic();
            dreamCount++;
            document.getElementById('dream').textContent = dreamCount;
        }

        function activateManMap() {
            clearWorld();
            generateManMap(); 
            currentMapDanger = 5.0; 
            document.getElementById('mapName').textContent = "The Man's Field (CRITICAL)";
            changeAmbientSound(null);
            hideConsole();
        }

        /**
         * Creates a fast, seamless dream shift/transition.
         */
        function smoothShift(manual = false) {
            if (isShifting || isDead) return;
            isShifting = true;

            let sanityCost = manual ? 40 : (20 * currentMapDanger / 2);
            sanity = Math.max(0, sanity - sanityCost);

            if (sanity <= 60 && !manual) {
                isShifting = false; 
                nextShift = 0.5;
                return;
            }

            playShiftSound();

            fadeScreen.style.transition = 'opacity 0.1s'; 
            fadeScreen.style.opacity = '1'; 

            setTimeout(() => {
                generateDreamWorld();
                
                fadeScreen.style.opacity = '0';
                
                isShifting = false;
                nextShift = manual ? 5 : 15 + Math.random() * 30;
                
                fadeScreen.style.transition = 'opacity 3s'; 
                
            }, 100); 
        }
        
        // --- Sanity Management ---
        function updateSanity(delta) {
            if (isDead) return;

            let drainRate = 0.5 * currentMapDanger; 
            
            if (sanity <= 60) {
                drainRate *= 4.0;
                
                // FIX: Use background color to manage opacity/filter
                // Sanity 60 (0.1 opacity) -> Sanity 0 (0.6 opacity)
                const clampedOpacity = 0.1 + (60 - sanity) / 60 * 0.5;
                
                bloodOverlay.style.backgroundColor = `rgba(255, 0, 0, ${clampedOpacity})`;
            } else {
                // Sanity above 60, fade out blood effect
                bloodOverlay.style.backgroundColor = `rgba(255, 0, 0, 0)`;
            }

            sanity -= drainRate * delta;
            sanity = Math.max(0, sanity);
            
            document.getElementById('stability').textContent = Math.floor(sanity);

            if (sanity <= 0) {
                triggerJumpscare();
            }
        }
        
        function triggerJumpscare() {
            if (isDead) return;
            isDead = true;
            
            controls.unlock();
            
            // Jumpscare Audio
            playScream();
            
            // Jumpscare Visuals (Max Blood)
            bloodOverlay.style.backgroundColor = `rgba(255, 0, 0, 1.0)`;
            bloodOverlay.style.transition = 'background-color 0.1s ease-out'; 
            
            // Pause Game
            document.getElementById('loading').textContent = "CRITICAL FAILURE: DREAM COLLAPSE. REFRESH TO RESTART.";
            document.getElementById('loading').style.display = 'block';
            document.getElementById('loading').style.color = '#ff4444';
        }

        function checkManProximity() {
            if (isManMapActive) {
                if (camera.position.distanceTo(manPosition) < 12) {
                    document.getElementById('output').innerHTML += '<br>THE MAN SEES YOU. SHIFTING...<br>';
                    smoothShift(true); 
                }
            }
        }

        // --- Animation Loop ---
        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            
            updateSanity(delta);

            if (controls.isLocked && !isDead) {
                velocity.x *= 0.8; velocity.z *= 0.8;
                const speed = isManMapActive ? 25 : 40;

                const dir = new THREE.Vector3();
                dir.z = Number(move.forward) - Number(move.backward);
                dir.x = Number(move.right) - Number(move.left);
                dir.normalize();

                if (move.forward || move.backward) velocity.z -= dir.z * speed * delta;
                if (move.left || move.right) velocity.x -= dir.x * speed * delta;

                controls.moveRight(-velocity.x * delta);
                controls.moveForward(-velocity.z * delta);

                checkManProximity();
                
                nextShift -= delta;
                if (nextShift <= 0) smoothShift();
            }
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <!-- CRUCIAL for mobile responsiveness: ensures the page scales correctly on phones/tablets -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Wizard Battle Arena</title>
    <!-- Load Tailwind CSS for styling UI elements -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Load Three.js for 3D rendering -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900&display=swap');
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Inter', sans-serif;
            background-color: #000;
        }
        /* 3D Canvas always covers the full screen */
        #three-canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        /* Drawing Canvas layer always covers the full screen */
        #drawing-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2; /* Layered on top of 3D scene */
            pointer-events: auto; /* Ensures it can receive mouse/touch events */
            cursor: crosshair;
            /* Prevents mobile browsers from trying to scroll/zoom when drawing */
            touch-action: none; 
        }
        .ui-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            padding: 1rem;
            z-index: 3;
            pointer-events: none; /* Allow clicks to pass through by default */
        }
        .ui-panel {
            pointer-events: auto;
            max-width: 400px; /* Max width for desktop/tablet */
            margin: 0 auto;
            background-color: #1f2937e0; /* Darker, slightly transparent background */
            backdrop-filter: blur(5px);
            border: 2px solid #60a5fa;
            /* Added padding for mobile optimization */
            width: 95%; 
        }
        .message-box {
            pointer-events: auto;
            transition: opacity 0.3s ease-in-out;
            text-shadow: 2px 2px 4px #000000;
        }
        .game-info {
            position: absolute;
            top: 1rem;
            right: 1rem;
            background-color: #1f2937e0;
            color: white;
            padding: 0.75rem;
            border-radius: 0.75rem;
            font-size: 0.875rem;
            pointer-events: auto;
            border: 1px solid #4f46e5;
        }
    </style>
</head>
<body>

    <!-- 3D Rendering Canvas (Background) -->
    <canvas id="three-canvas"></canvas>

    <!-- 2D Drawing Canvas (Foreground Overlay) -->
    <canvas id="drawing-canvas"></canvas>

    <!-- UI Overlay (Dynamic Content) -->
    <div class="ui-container">

        <!-- Game Mode Selection / Lobby / Instructions -->
        <div id="main-ui" class="ui-panel p-6 rounded-xl shadow-2xl mt-12 text-white">
            <!-- Content dynamically injected here -->
        </div>
        
        <!-- Game Information (Visible during Game state) -->
        <div id="game-info" class="game-info hidden">
            <p id="player-id-display" class="font-mono text-xs"></p>
            <p id="player-role-display" class="font-bold"></p>
        </div>

        <!-- Dynamic Message Box -->
        <div id="message-display" class="message-box fixed top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 p-6 text-white text-2xl font-extrabold rounded-xl shadow-xl opacity-0">
            Casting...
        </div>
    </div>

    <script type="module">
        // --- FIREBASE IMPORTS ---
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, onSnapshot, updateDoc, deleteDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        
        // --- CONSTANTS AND GLOBALS ---
        // Firebase Setup
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = JSON.parse(typeof __firebase_config !== 'undefined' ? __firebase_config : '{}');
        const LOBBY_COLLECTION_PATH = `artifacts/${appId}/public/data/lobbies`;
        
        let db;
        let auth;
        let userId = null;
        let isAuthReady = false;
        let unsubscribeLobby = null; // Holds the Firestore listener function
        
        // Game State
        let gameState = 'Menu'; // 'Menu', 'Lobby', 'Game'
        let currentLobbyCode = null;
        let playerNumber = null; // 1 or 2
        let opponentId = null; 

        // Three.js variables
        let scene, camera, renderer, targetMesh, clock;
        const targetInitialY = 0.5;

        // Drawing Canvas variables
        const drawingCanvas = document.getElementById('drawing-canvas');
        const drawingCtx = drawingCanvas.getContext('2d');
        let isDrawing = false;
        let drawnPoints = [];
        const messageDisplay = document.getElementById('message-display');

        const mainUiDiv = document.getElementById('main-ui');
        const gameInfoDiv = document.getElementById('game-info');
        const playerIdDisplay = document.getElementById('player-id-display');
        const playerRoleDisplay = document.getElementById('player-role-display');

        // --- UTILITY FUNCTIONS (UI only) ---

        /** * Shows a temporary message on the screen.
         * Optimized with w-11/12 max-w-lg for mobile responsiveness.
         */
        function showMessage(text, bgColorClass = 'bg-green-700/80', duration = 1500) {
            messageDisplay.textContent = text;
            // Updated classes for better fit on small screens
            messageDisplay.className = `message-box fixed top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 p-4 w-11/12 max-w-lg text-white text-xl font-extrabold rounded-xl shadow-xl transition-opacity opacity-100 ${bgColorClass}`;

            setTimeout(() => {
                messageDisplay.classList.replace('opacity-100', 'opacity-0');
            }, duration);
        }

        // --- FIREBASE CORE LOGIC ---

        function generateCode() {
            return String(Math.floor(1000 + Math.random() * 9000)); // 4-digit code
        }

        async function initFirebase() {
            if (Object.keys(firebaseConfig).length === 0) {
                console.error("Firebase configuration is missing.");
                // Fallback to offline mode
                isAuthReady = true;
                return;
            }

            const app = initializeApp(firebaseConfig);
            db = getFirestore(app);
            auth = getAuth(app);

            // Authentication listener
            onAuthStateChanged(auth, async (user) => {
                if (user) {
                    userId = user.uid;
                } else {
                    // Sign in anonymously if no user is present
                    try {
                        const token = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;
                        if (token) {
                            await signInWithCustomToken(auth, token);
                        } else {
                            await signInAnonymously(auth);
                        }
                    } catch (error) {
                        console.error("Firebase Auth failed:", error);
                        // Fallback to a random ID if auth fails
                        userId = crypto.randomUUID(); 
                    }
                }
                isAuthReady = true;
                // Once authenticated, render the menu
                renderUI();
                playerIdDisplay.textContent = `ID: ${userId}`;
            });
        }

        async function createLobby() {
            if (!isAuthReady || !db) return;
            const code = generateCode();
            currentLobbyCode = code;

            const lobbyRef = doc(db, LOBBY_COLLECTION_PATH, code);
            const initialLobbyData = {
                hostId: userId,
                guestId: null,
                players: {
                    [userId]: { number: 1, lastSpell: null, active: true }
                },
                status: 'waiting', // 'waiting', 'playing', 'finished'
                lastUpdate: Date.now()
            };

            try {
                await setDoc(lobbyRef, initialLobbyData);
                playerNumber = 1;
                setGameState('Lobby');
                listenToLobby(code);
                showMessage(`Lobby created. Code: ${code}`, 'bg-indigo-600/80');
            } catch (error) {
                console.error("Error creating lobby:", error);
                showMessage("Lobby creation failed.", 'bg-red-700/80');
            }
        }

        async function joinLobby(code) {
            if (!isAuthReady || !db) return;

            const lobbyRef = doc(db, LOBBY_COLLECTION_PATH, code);
            try {
                await updateDoc(lobbyRef, {
                    guestId: userId,
                    [`players.${userId}`]: { number: 2, lastSpell: null, active: true },
                    status: 'playing',
                    lastUpdate: Date.now()
                });
                currentLobbyCode = code;
                playerNumber = 2;
                setGameState('Lobby'); // Lobby state will transition to Game via snapshot listener
                listenToLobby(code);
                showMessage("Joined the game!", 'bg-green-600/80');
            } catch (error) {
                console.error("Error joining lobby:", error);
                showMessage("Lobby not found or full.", 'bg-red-700/80');
            }
        }

        function listenToLobby(code) {
            if (unsubscribeLobby) {
                unsubscribeLobby(); // Clean up previous listener
            }

            const lobbyRef = doc(db, LOBBY_COLLECTION_PATH, code);
            unsubscribeLobby = onSnapshot(lobbyRef, (docSnap) => {
                if (docSnap.exists()) {
                    const data = docSnap.data();
                    
                    if (data.status === 'playing' && gameState !== 'Game') {
                        // Game Start condition met
                        opponentId = (playerNumber === 1) ? data.guestId : data.hostId;
                        setGameState('Game');
                        showMessage("Match Started!", 'bg-blue-600/80', 2500);
                    }

                    if (gameState === 'Game') {
                        // Process opponent's last spell
                        const opponentData = data.players[opponentId];
                        if (opponentData && opponentData.lastSpell) {
                            console.log(`Opponent cast: ${opponentData.lastSpell}`);
                            // Logic for opponent's spell effect goes here
                        }
                    }

                    renderUI(); // Re-render UI to show lobby status, etc.
                } else {
                    // Lobby was deleted (e.g., by host)
                    if (gameState !== 'Menu') {
                        showMessage("Lobby closed.", 'bg-red-700/80');
                        setGameState('Menu');
                    }
                }
            });
        }

        async function updateSpell(spellName) {
            if (!currentLobbyCode || !db) return;
            const lobbyRef = doc(db, LOBBY_COLLECTION_PATH, currentLobbyCode);
            try {
                await updateDoc(lobbyRef, {
                    [`players.${userId}.lastSpell`]: spellName,
                    lastUpdate: Date.now()
                });
            } catch (error) {
                console.error("Error updating spell:", error);
            }
        }


        // --- UI RENDERING ---

        function renderUI() {
            mainUiDiv.innerHTML = '';
            gameInfoDiv.classList.add('hidden');

            if (!isAuthReady) {
                mainUiDiv.innerHTML = '<p class="text-center text-lg py-4">Connecting to the Arcane Network...</p>';
                return;
            }
            
            if (gameState === 'Menu') {
                renderMenu();
            } else if (gameState === 'Lobby') {
                renderLobby();
            } else if (gameState === 'Game') {
                renderGameUI();
            }
        }

        function setGameState(newState) {
            gameState = newState;
            // Toggle visibility of the 2D drawing canvas and the main menu panel
            drawingCanvas.style.pointerEvents = newState === 'Game' ? 'auto' : 'none';
            mainUiDiv.style.display = newState === 'Game' ? 'none' : 'block';
            gameInfoDiv.classList.toggle('hidden', newState !== 'Game');

            if (newState === 'Game' && playerNumber) {
                 playerRoleDisplay.textContent = `PLAYER ${playerNumber}`;
                 initThreeJS(); // Initialize 3D on game start
            }

            renderUI();
        }

        function renderMenu() {
            mainUiDiv.innerHTML = `
                <h2 class="text-3xl font-extrabold text-indigo-400 mb-6 text-center">Wizard Duel Arena</h2>
                <div class="space-y-4">
                    <button id="solo-btn" class="w-full bg-gray-600 hover:bg-gray-700 text-white font-bold py-3 px-4 rounded-lg transition duration-200 shadow-md">
                        Play Alone (vs. AI)
                    </button>
                    <button id="host-btn" class="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-4 rounded-lg transition duration-200 shadow-md">
                        Host Multiplayer Duel
                    </button>
                    <div class="flex space-x-2">
                        <input type="text" id="join-code" placeholder="Enter 4-Digit Code" maxlength="4" class="flex-grow p-3 rounded-lg text-gray-900 border border-gray-300 focus:ring-indigo-500 focus:border-indigo-500 text-center uppercase font-mono">
                        <button id="join-btn" class="bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-4 rounded-lg transition duration-200 shadow-md w-1/3">
                            Join
                        </button>
                    </div>
                </div>
            `;
            document.getElementById('solo-btn').addEventListener('click', () => {
                showMessage("AI Mode not fully implemented yet!", 'bg-yellow-600/80');
                // setGameState('Game'); // For testing basic functionality:
                // playerNumber = 1;
                // initThreeJS();
            });
            document.getElementById('host-btn').addEventListener('click', createLobby);
            document.getElementById('join-btn').addEventListener('click', () => {
                const code = document.getElementById('join-code').value.trim();
                if (code.length === 4 && /^\d+$/.test(code)) {
                    joinLobby(code);
                } else {
                    showMessage("Enter a valid 4-digit code.", 'bg-red-500/80');
                }
            });
        }

        function renderLobby() {
            const isHost = playerNumber === 1;
            mainUiDiv.innerHTML = `
                <h2 class="text-3xl font-extrabold text-indigo-400 mb-4 text-center">Lobby</h2>
                <div class="p-4 bg-gray-700 rounded-lg text-center mb-6">
                    <p class="text-xl font-mono text-yellow-300">CODE: ${currentLobbyCode}</p>
                    <p class="text-sm text-gray-400 mt-1">Share this code with your opponent.</p>
                </div>
                <p class="text-lg text-center font-bold mb-4">
                    ${isHost ? 'Waiting for opponent...' : 'Joined successfully! Waiting for host to start.'}
                </p>
                <div class="flex justify-between text-sm text-gray-300">
                    <span>Player 1 (Host): <span class="text-green-400 font-bold">Ready</span></span>
                    <span>Player 2 (Guest): <span class="${isHost ? 'text-yellow-400' : 'text-green-400'} font-bold">${isHost ? '...' : 'Ready'}</span></span>
                </div>
                ${isHost ? '' : '<p class="mt-4 text-center text-sm text-red-300">Waiting for host to begin...</p>'}
                <button onclick="window.location.reload();" class="w-full bg-red-700 hover:bg-red-800 text-white font-bold py-3 px-4 rounded-lg mt-6 transition duration-200 shadow-md">
                    Cancel / Leave
                </button>
            `;
        }

        function renderGameUI() {
             mainUiDiv.innerHTML = `
                <h2 class="text-3xl font-extrabold text-indigo-400 mb-4 text-center">DUEL IN PROGRESS</h2>
                <p class="text-lg text-center text-gray-300">Draw your spell on the screen!</p>
                <p class="text-xs text-center text-red-400 mt-2">The UI panel is hidden during gameplay.</p>
                <button onclick="window.location.reload();" class="w-full bg-red-700 hover:bg-red-800 text-white font-bold py-3 px-4 rounded-lg mt-6 transition duration-200 shadow-md">
                    End Duel
                </button>
            `;
        }


        // --- SPELL EFFECTS ---
        
        // This function is called after a shape is recognized
        function castSpell(spell) {
            if (targetMesh.userData.isAnimating) {
                showMessage("Wait! Already casting!", 'bg-gray-700/80');
                return;
            }
            
            targetMesh.userData.isAnimating = true;

            // Update the game state in Firestore for the opponent to see
            if (gameState === 'Game') {
                updateSpell(spell);
            }

            switch (spell) {
                case 'Circle':
                    spell_Fireball();
                    showMessage("FIREBALL!", 'bg-red-700/80');
                    break;
                case 'Triangle':
                    spell_Shield();
                    showMessage("SHIELD!", 'bg-green-700/80');
                    break;
                case 'Square':
                    spell_Lift();
                    showMessage("LIFT!", 'bg-purple-700/80');
                    break;
                default:
                    spell_Failure();
                    showMessage("Unknown Spell!", 'bg-yellow-700/80');
                    break;
            }
        }
        
        // [SPELL IMPLEMENTATION functions remain the same as previous version]
        function spell_Fireball() {
            const duration = 0.5;
            const start = clock.getElapsedTime();
            
            function animateFireball() {
                const elapsed = clock.getElapsedTime() - start;
                const progress = elapsed / duration;

                if (progress < 1) {
                    targetMesh.scale.setScalar(1 + progress * 2);
                    targetMesh.material.color.setRGB(1, 0.2 + progress * 0.8, 0); 
                    requestAnimationFrame(animateFireball);
                } else {
                    targetMesh.scale.copy(targetMesh.userData.originalScale);
                    targetMesh.material.color.set(0xf0e68c); 
                    targetMesh.userData.isAnimating = false;
                }
            }
            animateFireball();
        }

        function spell_Shield() {
            const shieldGeometry = new THREE.ConeGeometry(2, 3, 4);
            const shieldMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x00ff00, 
                wireframe: true, 
                transparent: true, 
                opacity: 0.5 
            });
            const shieldMesh = new THREE.Mesh(shieldGeometry, shieldMaterial);
            shieldMesh.position.y = 1.5; 
            scene.add(shieldMesh);

            const duration = 3.0;
            const start = clock.getElapsedTime();

            function animateShield() {
                const elapsed = clock.getElapsedTime() - start;
                const progress = elapsed / duration;

                if (progress < 1) {
                    shieldMesh.rotation.y += 0.05;
                    shieldMesh.material.opacity = 0.5 - 0.5 * progress;
                    requestAnimationFrame(animateShield);
                } else {
                    scene.remove(shieldMesh);
                    targetMesh.userData.isAnimating = false;
                }
            }
            animateShield();
        }

        function spell_Lift() {
            const targetY = targetInitialY + 5; 
            const liftDuration = 1.5;
            const hoverDuration = 2.0;
            const resetDuration = 1.5;
            const start = clock.getElapsedTime();

            function animateLift() {
                const elapsed = clock.getElapsedTime() - start;

                if (elapsed < liftDuration) {
                    const progress = elapsed / liftDuration;
                    targetMesh.position.y = targetInitialY + progress * (targetY - targetInitialY);
                    requestAnimationFrame(animateLift);
                } else if (elapsed < liftDuration + hoverDuration) {
                    targetMesh.rotation.x += 0.02; 
                    requestAnimationFrame(animateLift);
                } else if (elapsed < liftDuration + hoverDuration + resetDuration) {
                    const progress = (elapsed - liftDuration - hoverDuration) / resetDuration;
                    targetMesh.position.y = targetY - progress * (targetY - targetInitialY);
                    requestAnimationFrame(animateLift);
                } else {
                    targetMesh.position.y = targetInitialY;
                    targetMesh.userData.isAnimating = false;
                }
            }
            animateLift();
        }
        
        function spell_Failure() {
            const duration = 0.4;
            const start = clock.getElapsedTime();

            function animateFailure() {
                const elapsed = clock.getElapsedTime() - start;
                const progress = elapsed / duration;

                if (progress < 1) {
                    const offset = Math.sin(elapsed * 50) * 0.1;
                    targetMesh.position.x = offset;
                    requestAnimationFrame(animateFailure);
                } else {
                    targetMesh.position.x = 0; 
                    targetMesh.userData.isAnimating = false;
                }
            }
            animateFailure();
        }


        // --- DRAWING AND RECOGNITION LOGIC ---
        // This logic handles both mouse (computer) and touch (phone) input.

        function startDrawing(x, y) {
            if (gameState !== 'Game') return; // Only allow drawing in Game state
            isDrawing = true;
            drawnPoints = [{ x, y }];
            drawingCtx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
            drawingCtx.beginPath();
            drawingCtx.moveTo(x, y);
        }

        function draw(x, y) {
            if (!isDrawing) return;
            drawnPoints.push({ x, y });
            drawingCtx.lineTo(x, y);
            drawingCtx.stroke();
        }

        function stopDrawing() {
            if (!isDrawing) return;
            isDrawing = false;
            
            setTimeout(() => {
                drawingCtx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
            }, 500); 

            if (drawnPoints.length > 5) {
                const recognizedSpell = recognizeShape(drawnPoints);
                castSpell(recognizedSpell);
            } else {
                showMessage("Too small to cast.", 'bg-yellow-700/80');
            }

            drawnPoints = [];
        }

        function recognizeShape(points) {
            const start = points[0];
            const end = points[points.length - 1];
            const distance = Math.sqrt(Math.pow(end.x - start.x, 2) + Math.pow(end.y - start.y, 2));
            const minX = Math.min(...points.map(p => p.x));
            const maxX = Math.max(...points.map(p => p.x));
            const minY = Math.min(...points.map(p => p.y));
            const maxY = Math.max(...points.map(p => p.y));
            const width = maxX - minX;
            const height = maxY - minY;
            const size = Math.max(width, height);
            const isClosed = distance / size < 0.2;
            let pathLength = 0;
            for (let i = 1; i < points.length; i++) {
                pathLength += Math.sqrt(Math.pow(points[i].x - points[i-1].x, 2) + Math.pow(points[i].y - points[i-1].y, 2));
            }
            const complexityRatio = pathLength / size;

            if (isClosed) {
                if (complexityRatio > 5) return 'Circle';
                if (complexityRatio > 3 && Math.abs(width / height - 1) < 0.5) return 'Square';
                return 'Triangle';
            }
            return 'Triangle'; // Default/Fallback
        }

        // Event listeners for drawing
        function setupDrawingEvents() {
            // Mouse events for computer
            drawingCanvas.addEventListener('mousedown', (e) => startDrawing(e.clientX, e.clientY));
            drawingCanvas.addEventListener('mousemove', (e) => draw(e.clientX, e.clientY));
            drawingCanvas.addEventListener('mouseup', stopDrawing);

            // Touch events for phone/tablet
            drawingCanvas.addEventListener('touchstart', (e) => {
                e.preventDefault();
                const touch = e.touches[0];
                startDrawing(touch.clientX, touch.clientY);
            });
            drawingCanvas.addEventListener('touchmove', (e) => {
                e.preventDefault();
                const touch = e.touches[0];
                draw(touch.clientX, touch.clientY);
            });
            drawingCanvas.addEventListener('touchend', (e) => {
                e.preventDefault();
                stopDrawing();
            });
        }


        // --- THREE.JS SETUP ---

        function initThreeJS() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a20);
            scene.fog = new THREE.Fog(0x0a0a20, 1, 50);

            // Clock for animation
            clock = new THREE.Clock();

            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, 10);
            camera.lookAt(0, 0, 0);

            // Renderer
            renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('three-canvas'), antialias: true });
            // Renderer size is set initially and updated on resize
            renderer.setSize(window.innerWidth, window.innerHeight);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 5); 
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 4);
            directionalLight.position.set(5, 10, 5);
            directionalLight.castShadow = true;
            scene.add(directionalLight);

            // Two-Sided Map (Light vs. Dark)
            const mapSize = 100;
            const halfSize = mapSize / 2;
            const planeGeometry = new THREE.PlaneGeometry(halfSize, mapSize); 

            // 1. Light Side (Aetherial Blue) - Left for Player 1 / Host
            const lightMaterial = new THREE.MeshPhongMaterial({ color: 0x3333aa, side: THREE.DoubleSide });
            const lightPlane = new THREE.Mesh(planeGeometry, lightMaterial);
            lightPlane.rotation.x = Math.PI / 2;
            lightPlane.position.x = -halfSize / 2; 
            lightPlane.receiveShadow = true;
            scene.add(lightPlane);

            // 2. Dark Side (Volcanic Red) - Right for Player 2 / Guest
            const darkMaterial = new THREE.MeshPhongMaterial({ color: 0xaa3333, side: THREE.DoubleSide });
            const darkPlane = new THREE.Mesh(planeGeometry, darkMaterial);
            darkPlane.rotation.x = Math.PI / 2;
            darkPlane.position.x = halfSize / 2; 
            darkPlane.receiveShadow = true;
            scene.add(darkPlane);

            // Target Object (Gold Cube)
            const targetGeometry = new THREE.BoxGeometry(1, 1, 1);
            const targetMaterial = new THREE.MeshPhongMaterial({ color: 0xf0e68c }); 
            targetMesh = new THREE.Mesh(targetGeometry, targetMaterial);
            targetMesh.position.y = targetInitialY;
            targetMesh.castShadow = true;
            scene.add(targetMesh);

            targetMesh.userData.isAnimating = false;
            targetMesh.userData.originalScale = targetMesh.scale.clone();
            targetMesh.userData.targetY = targetInitialY;

            // Start the animation loop if it hasn't started
            if (!renderer.domElement.parentNode) {
                animate();
            }

            // Event listener to handle screen resize (essential for responsiveness)
            window.addEventListener('resize', onWindowResize);
        }

        function onWindowResize() {
            if (camera && renderer) {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                // Resize the 3D renderer
                renderer.setSize(window.innerWidth, window.innerHeight);
                // Resize the 2D drawing canvas
                resizeDrawingCanvas();
            }
        }

        function resizeDrawingCanvas() {
            drawingCanvas.width = window.innerWidth;
            drawingCanvas.height = window.innerHeight;
            drawingCtx.strokeStyle = '#FFFFFF';
            drawingCtx.lineWidth = 8;
            drawingCtx.lineCap = 'round';
            drawingCtx.lineJoin = 'round';
        }

        function animate() {
            requestAnimationFrame(animate);

            if (targetMesh) {
                targetMesh.rotation.y += 0.01;
            }
            
            if (renderer && scene && camera) {
                renderer.render(scene, camera);
            }
        }

        // --- INITIALIZATION ---

        window.onload = function () {
            // Start Firebase connection and authentication
            initFirebase(); 
            // Initialize 2D canvas 
            resizeDrawingCanvas();
            // Setup mouse and touch listeners
            setupDrawingEvents();
            // Start the animation loop 
            animate();
            
            // Set initial UI state
            setGameState('Menu'); 
            showMessage("Welcome, wizard. Choose a mode to begin your duel.", 'bg-blue-600/80', 2500);
        }
    </script>

</body>
</html>

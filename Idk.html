<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dreamcore Shift</title>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/PointerLockControls.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; overflow: hidden; background: #000; }
        canvas { display: block; }
        #ui { pointer-events: none; }
        .fade-in { animation: fadeIn 2s ease-in; }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
    </style>
</head>
<body>
    <div id="loading" class="fixed inset-0 bg-gradient-to-br from-pink-300 to-yellow-200 flex items-center justify-center z-50 fade-in">
        <div class="text-center text-white text-2xl font-mono">
            <div class="text-6xl mb-4">üè†</div>
            <div>PERFECT PLACE</div>
            <div class="text-sm mt-4 text-yellow-900">Click to enter</div>
        </div>
    </div>
    
    <div id="instructions" class="fixed bottom-8 left-1/2 transform -translate-x-1/2 bg-white/80 backdrop-blur-md px-6 py-3 rounded-full text-sm font-mono text-gray-800 shadow-2xl z-40 opacity-0 transition-all duration-500">
        WASD to move ‚Ä¢ Mouse to look ‚Ä¢ Don't look away
    </div>

    <div id="shiftCount" class="fixed top-8 left-8 bg-white/90 backdrop-blur-md px-4 py-2 rounded-lg text-lg font-mono text-gray-900 shadow-xl z-40 opacity-0 transition-all duration-500">
        Shifts: <span id="count">0</span>/3
    </div>

    <script>
        // === DREAMCORE SHIFT ===
        let scene, camera, renderer, controls;
        let move = { forward: false, backward: false, left: false, right: false };
        let velocity = new THREE.Vector3();
        let shiftTimer = 0;
        let isLookingAtHouse = true;
        let shiftCount = 0;
        let isTwisted = false;
        let isShiftLocked = false;
        let house, ground, skySphere;
        let impossibleObjects = [];
        let clock = new THREE.Clock();

        // House direction tracking
        const housePos = new THREE.Vector3(0, 2, 0);
        const houseDir = new THREE.Vector3();
        const playerDir = new THREE.Vector3();

        init();
        animate();

        function init() {
            // Scene
            scene = new THREE.Scene();
            
            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
            camera.position.set(0, 1.6, 10);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x87CEEB); // Perfect sky blue
            document.body.appendChild(renderer.domElement);

            // Perfect lighting
            const ambient = new THREE.AmbientLight(0xffffff, 0.8);
            scene.add(ambient);
            const directional = new THREE.DirectionalLight(0xffffff, 0.6);
            directional.position.set(1, 1, 0.5);
            scene.add(directional);

            // Infinite ground
            const groundGeo = new THREE.PlaneGeometry(2000, 2000);
            const groundMat = new THREE.MeshLambertMaterial({ color: 0x90EE90 }); // Pastel green
            ground = new THREE.Mesh(groundGeo, groundMat);
            ground.rotation.x = -Math.PI / 2;
            scene.add(ground);

            // Sky sphere
            const skyGeo = new THREE.SphereGeometry(1000, 32, 32);
            const skyMat = new THREE.MeshBasicMaterial({ 
                color: 0x87CEEB,
                side: THREE.BackSide 
            });
            skySphere = new THREE.Mesh(skyGeo, skyMat);
            scene.add(skySphere);

            // THE HOUSE
            const houseGroup = new THREE.Group();
            const baseGeo = new THREE.BoxGeometry(8, 6, 8);
            const baseMat = new THREE.MeshLambertMaterial({ color: 0xffffff });
            const base = new THREE.Mesh(baseGeo, baseMat);
            base.position.y = 3;
            houseGroup.add(base);

            const roofGeo = new THREE.ConeGeometry(6, 4, 4);
            const roofMat = new THREE.MeshLambertMaterial({ color: 0xffd700 });
            const roof = new THREE.Mesh(roofGeo, roofMat);
            roof.position.y = 8;
            roof.rotation.y = Math.PI / 4;
            houseGroup.add(roof);

            house = houseGroup;
            house.position.copy(housePos);
            scene.add(house);

            // Controls
            controls = new THREE.PointerLockControls(camera, document.body);
            scene.add(controls.getObject());

            document.addEventListener('click', () => {
                controls.lock();
                setTimeout(() => {
                    document.getElementById('loading').style.display = 'none';
                    document.getElementById('instructions').style.opacity = '1';
                    document.getElementById('shiftCount').style.opacity = '1';
                }, 1000);
            });

            // Keyboard
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);

            // Resize
            window.addEventListener('resize', onWindowResize);
        }

        function onKeyDown(event) {
            switch (event.code) {
                case 'KeyW': move.forward = true; break;
                case 'KeyS': move.backward = true; break;
                case 'KeyA': move.left = true; break;
                case 'KeyD': move.right = true; break;
            }
        }

        function onKeyUp(event) {
            switch (event.code) {
                case 'KeyW': move.forward = false; break;
                case 'KeyS': move.backward = false; break;
                case 'KeyA': move.left = false; break;
                case 'KeyD': move.right = false; break;
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function updateLookingState() {
            playerDir.set(0, 0, -1).applyQuaternion(camera.quaternion);
            houseDir.copy(housePos).sub(camera.position).normalize();
            
            const dot = playerDir.dot(houseDir);
            const angle = Math.acos(Math.max(-1, Math.min(1, dot))) * 180 / Math.PI;
            
            // Looking at house if within 60 degrees and not too far
            isLookingAtHouse = angle < 60 && camera.position.distanceTo(housePos) < 100;
        }

        function performShift() {
            isShiftLocked = true;
            shiftCount++;
            document.getElementById('count').textContent = shiftCount;

            // Flash to black
            renderer.setClearColor(0x000000);
            setTimeout(() => {
                if (!isTwisted) {
                    renderer.setClearColor(0x98D8C8); // Shifted sky
                }
                isShiftLocked = false;
            }, 500);

            if (shiftCount >= 3) {
                enterTwistedWorld();
            } else {
                // Subtle shift effects
                skySphere.material.color.setHex(0x98D8C8);
                ground.material.color.setHex(0x7CB69C);
                
                // Add impossible object
                const obj = new THREE.Mesh(
                    new THREE.BoxGeometry(1, 1, 1),
                    new THREE.MeshLambertMaterial({ color: 0x888888 })
                );
                obj.position.set(
                    (Math.random() - 0.5) * 100,
                    2,
                    (Math.random() - 0.5) * 100
                );
                scene.add(obj);
                impossibleObjects.push(obj);
            }
        }

        function enterTwistedWorld() {
            isTwisted = true;
            
            // Drastic changes
            skySphere.material.color.setHex(0xFF00FF);
            ground.material.color.setHex(0x330033);
            
            // Distort house
            house.scale.set(1.3, 0.7, 1.3);
            house.rotation.z = 0.3;
            house.position.y += 5;
            
            // Impossible geometry
            const wallGeo = new THREE.BoxGeometry(100, 10, 2);
            const wall = new THREE.Mesh(wallGeo, new THREE.MeshLambertMaterial({ color: 0xFF0000 }));
            wall.position.set(50, 5, 0);
            wall.rotation.y = Math.PI / 4;
            scene.add(wall);

            // Hole in ground
            const holeGeo = new THREE.PlaneGeometry(30, 30);
            const holeMat = new THREE.MeshBasicMaterial({ 
                color: 0x000000,
                side: THREE.DoubleSide 
            });
            const hole = new THREE.Mesh(holeGeo, holeMat);
            hole.rotation.x = -Math.PI / 2;
            hole.position.set(-30, -0.1, -30);
            scene.add(hole);
        }

        function animate() {
            requestAnimationFrame(animate);
            
            if (!controls.isLocked) {
                renderer.render(scene, camera);
                return;
            }

            const delta = clock.getDelta();

            // Movement
            velocity.x *= 0.9;
            velocity.z *= 0.9;
            
            const direction = new THREE.Vector3();
            direction.z = Number(move.forward) - Number(move.backward);
            direction.x = Number(move.right) - Number(move.left);
            direction.normalize();

            if (move.forward || move.backward) velocity.z -= direction.z * 50 * delta;
            if (move.left || move.right) velocity.x -= direction.x * 50 * delta;

            controls.moveRight(-velocity.x * delta);
            controls.moveForward(-velocity.z * delta);

            // Looking detection
            updateLookingState();

            if (!isShiftLocked) {
                if (isLookingAtHouse) {
                    shiftTimer = 0;
                } else {
                    shiftTimer += delta;
                    if (shiftTimer >= 2.0) {
                        performShift();
                        shiftTimer = 0;
                    }
                }
            }

            // Animate objects
            house.rotation.y += 0.005;
            impossibleObjects.forEach(obj => {
                obj.rotation.y += 0.01;
                obj.position.y += Math.sin(clock.elapsedTime * 2) * 0.01;
            });

            renderer.render(scene, camera);
        }
    </script>
</body>
</html>

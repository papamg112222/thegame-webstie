<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Rubik's Cube</title>
<meta name="viewport" content="width=device-width,initial-scale=1">
<style>
  html,body {margin:0; height:100%; background:#000; overflow:hidden;}
  canvas {display:block;}
</style>
</head>
<body>
<script type="module">
import * as THREE from 'https://unpkg.com/three@0.156.0/build/three.module.js';
import { OrbitControls } from 'https://unpkg.com/three@0.156.0/examples/jsm/controls/OrbitControls.js';

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x000000);
const camera = new THREE.PerspectiveCamera(50, innerWidth/innerHeight, 0.1, 100);
camera.position.set(5,5,6);

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth, innerHeight);
document.body.appendChild(renderer.domElement);

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;

const light = new THREE.DirectionalLight(0xffffff,1);
light.position.set(5,10,7);
scene.add(light);
scene.add(new THREE.AmbientLight(0x555555));

const CUBIE = 0.98, GAP = 0.02;
const COLORS = {
  U:0xffffff, D:0xffff00, F:0xff0000, B:0xff8000, R:0x0000ff, L:0x00ff00
};

function faceMats(c){const b=new THREE.MeshBasicMaterial({color:0x000000});
return [
c.R?new THREE.MeshBasicMaterial({color:c.R}):b,
c.L?new THREE.MeshBasicMaterial({color:c.L}):b,
c.U?new THREE.MeshBasicMaterial({color:c.U}):b,
c.D?new THREE.MeshBasicMaterial({color:c.D}):b,
c.F?new THREE.MeshBasicMaterial({color:c.F}):b,
c.B?new THREE.MeshBasicMaterial({color:c.B}):b
];}

const cubies=[];
for(let x=-1;x<=1;x++)for(let y=-1;y<=1;y++)for(let z=-1;z<=1;z++){
  const s={};
  if(y===1)s.U=COLORS.U;
  if(y===-1)s.D=COLORS.D;
  if(z===1)s.F=COLORS.F;
  if(z===-1)s.B=COLORS.B;
  if(x===1)s.R=COLORS.R;
  if(x===-1)s.L=COLORS.L;
  const m=new THREE.Mesh(new THREE.BoxGeometry(CUBIE,CUBIE,CUBIE),faceMats(s));
  m.position.set(x*(CUBIE+GAP),y*(CUBIE+GAP),z*(CUBIE+GAP));
  scene.add(m);
  cubies.push(m);
}

function select(face){
  switch(face){
    case'F':return cubies.filter(m=>Math.abs(m.position.z-(CUBIE+GAP))<0.01);
    case'B':return cubies.filter(m=>Math.abs(m.position.z+ (CUBIE+GAP))<0.01);
    case'U':return cubies.filter(m=>Math.abs(m.position.y-(CUBIE+GAP))<0.01);
    case'D':return cubies.filter(m=>Math.abs(m.position.y+ (CUBIE+GAP))<0.01);
    case'R':return cubies.filter(m=>Math.abs(m.position.x-(CUBIE+GAP))<0.01);
    case'L':return cubies.filter(m=>Math.abs(m.position.x+ (CUBIE+GAP))<0.01);
  }
}

let rotating=false;
async function rotate(face,clock=true,time=250){
  if(rotating)return;
  rotating=true;
  const sel=select(face);
  const g=new THREE.Group();scene.add(g);
  sel.forEach(m=>{
    const wp=new THREE.Vector3();m.getWorldPosition(wp);
    scene.remove(m);g.add(m);
    g.worldToLocal(wp);m.position.copy(wp);
  });
  let ax=new THREE.Vector3();
  switch(face){case'F':case'B':ax.set(0,0,1);break;
    case'U':case'D':ax.set(0,1,0);break;
    case'R':case'L':ax.set(1,0,0);break;}
  const flip=(face==='B'||face==='L'||face==='D')?-1:1;
  const ang=(Math.PI/2)*(clock?1:-1)*flip;
  const start=performance.now(),end=start+time;
  return new Promise(res=>{
    function step(now){
      const t=Math.min(1,(now-start)/(end-start));
      const e=(1-Math.cos(Math.PI*t))/2;
      g.rotation.set(0,0,0);g.rotateOnAxis(ax,ang*e);
      if(t<1)requestAnimationFrame(step);
      else{
        sel.forEach(m=>{
          const wp=new THREE.Vector3();m.getWorldPosition(wp);
          scene.add(m);m.position.copy(wp);
          scene.worldToLocal(m.position);
          m.position.set(Math.round(m.position.x/(CUBIE+GAP))*(CUBIE+GAP),
                         Math.round(m.position.y/(CUBIE+GAP))*(CUBIE+GAP),
                         Math.round(m.position.z/(CUBIE+GAP))*(CUBIE+GAP));
          m.rotation.x=Math.round(m.rotation.x/(Math.PI/2))*(Math.PI/2);
          m.rotation.y=Math.round(m.rotation.y/(Math.PI/2))*(Math.PI/2);
          m.rotation.z=Math.round(m.rotation.z/(Math.PI/2))*(Math.PI/2);
        });
        scene.remove(g);
        rotating=false;res();
      }
    }requestAnimationFrame(step);
  });
}

async function scramble(n=20){
  const f=['F','R','U','B','L','D'];
  for(let i=0;i<n;i++){
    const fc=f[Math.floor(Math.random()*f.length)];
    await rotate(fc,Math.random()<0.5,100);
  }
}

window.addEventListener('keydown',e=>{
  if(rotating)return;
  const k=e.key;
  const faces=['f','u','r','b','l','d'];
  if(k.toLowerCase()==='z'){scramble();return;}
  if(!faces.includes(k.toLowerCase()))return;
  const face=k.toUpperCase();
  const cw=k===k.toLowerCase();
  rotate(face,cw);
});

addEventListener('resize',()=>{
  camera.aspect=innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth,innerHeight);
});

(function animate(){
  requestAnimationFrame(animate);
  controls.update();
  renderer.render(scene,camera);
})();
</script>
</body>
</html>

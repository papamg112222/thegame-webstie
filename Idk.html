<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Tokyo Drift Chase - Ultra Edition</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        body { margin: 0; padding: 0; overflow: hidden; background-color: #14141e; font-family: 'Press Start 2P', cursive; touch-action: none; }
        canvas { display: block; image-rendering: pixelated; image-rendering: crisp-edges; }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
    </style>
</head>
<body>
<canvas id="gameCanvas"></canvas>
<script>

// --- PART 1: CONSTANTS & CLASSES ---

const FPS = 60;
const BLOCK_SIZE = 380;
const BUILDING_GAP = 20;

// Colors
const COLORS = {
    BG_VOID: '#14141e', ASPHALT: '#2d2d32', PAINT_YELLOW: '#d2b414', PAINT_WHITE: '#dcdcdc',
    SIDEWALK: '#828287', WOOD_DARK: '#50281e', WOOD_RED: '#8c1e14', CONCRETE: '#9696a0',
    CONCRETE_DARK: '#64646e', ROOF_TILE_JP: '#3c3c46', LANTERN_RED: '#dc3232',
    NEON_PINK: '#ff3296', NEON_BLUE: '#3296ff', NEON_CYAN: '#32ffff', NEON_GREEN: '#32ff64',
    VENDING_BLUE: '#3264c8', SCHOOL_BEIGE: '#e6dcbe', CLOCK_FACE: '#ffffff',
    WIN_LIT_WARM: '#fff0b4', WIN_LIT_COOL: '#c8dcff', WIN_DARK: '#282832',
    SAKURA_PINK: '#ffb4c8', SAKURA_DARK: '#c8788c', ZOO_BASE: '#328c32',
    PLAYER: '#dc2828', COP_BODY: '#0a0a0f', COP_DOOR: '#e6e6f0',
    HP_GREEN: '#32c832', HP_YELLOW: '#dcc832', HP_RED: '#c83232', TEXT_WHITE: '#ffffff'
};

const CAR_TYPES = {
    'sedan': { w: 48, h: 24, speed: 1.0, colors: ['#3c5a96', '#969696', '#dcdcdc', '#503250', '#8c2828'] },
    'coupe': { w: 44, h: 22, speed: 1.3, colors: ['#c83232', '#3264c8', '#e6e632', '#141414'] },
    'hatchback': { w: 40, h: 22, speed: 0.9, colors: ['#32965a', '#c87832', '#9696c8'] },
    'taxi': { w: 48, h: 24, speed: 1.1, colors: ['#e6af2d'] },
    'truck': { w: 56, h: 26, speed: 0.7, colors: ['#ffffff', '#32465a'] }
};

const PLAYER_ROSTER = [
    { id: 'standard', name: 'STREET LEGEND', type: 'sedan', color: '#dc2828', desc: "Balanced. [Z]: Instant Repair (+50HP)", stats: { speed: 9.0, turn: 4.0, accel: 0.20, hp: 100 }, hasSpoiler: true, powerData: { name: "Repair", color: "#32c832", cooldown: 45 * 60 } },
    { id: 'drifter', name: 'DRIFT KING', type: 'coupe', color: '#d2b414', desc: "Loose handling. [Z]: Oil Slick", stats: { speed: 10.5, turn: 4.5, accel: 0.25, hp: 80 }, hasSpoiler: true, powerData: { name: "Oil Slick", color: "#141414", cooldown: 15 * 60 } },
    { id: 'tank', name: 'THE BEAST', type: 'truck', color: '#14141e', desc: "Heavy Armor. [Z]: Juggernaut (Invincible)", stats: { speed: 7.5, turn: 3.0, accel: 0.15, hp: 200 }, hasSpoiler: false, powerData: { name: "Juggernaut", color: "#c83232", cooldown: 40 * 60 } },
    { id: 'mecha', name: 'MECHA-V', type: 'coupe', color: '#32ffff', desc: "High Tech. [Z]: EMP Blast (Stun Cops)", stats: { speed: 11.0, turn: 5.5, accel: 0.30, hp: 60 }, hasSpoiler: true, powerData: { name: "EMP Blast", color: "#3296ff", cooldown: 30 * 60 } },
    { id: 'angel', name: 'SERAPHIM', type: 'coupe', color: '#ffffff', desc: "Divine Power. [Z]: Smite (Destroy Cops)", stats: { speed: 10.0, turn: 5.0, accel: 0.22, hp: 150 }, hasSpoiler: false, unlockScore: 500, powerData: { name: "Smite", color: "#ffd700", cooldown: 60 * 60 } }
];

// Physics Constants
const ACCELERATION = 0.20, FRICTION = 0.96, TURN_SPEED = 4.0, DRIFT_SLIDE = 0.99;
const MAX_SPEED_PLAYER = 9.0, MAX_SPEED_COP = 10.2, MAX_SPEED_CIVILIAN_BASE = 6.0;

// --- UTILITY ---
class Vector2 {
    constructor(x, y) { this.x = x; this.y = y; }
    add(v) { return new Vector2(this.x + v.x, this.y + v.y); }
    sub(v) { return new Vector2(this.x - v.x, this.y - v.y); }
    mult(n) { return new Vector2(this.x * n, this.y * n); }
    mag() { return Math.sqrt(this.x * this.x + this.y * this.y); }
    normalize() { let m = this.mag(); return m === 0 ? new Vector2(0, 0) : new Vector2(this.x / m, this.y / m); }
    dot(v) { return this.x * v.x + this.y * v.y; }
    rotate(deg) { let rad = deg * Math.PI / 180; let c = Math.cos(rad), s = Math.sin(rad); return new Vector2(this.x * c - this.y * s, this.x * s + this.y * c); }
    distanceTo(v) { return Math.sqrt((this.x - v.x)**2 + (this.y - v.y)**2); }
    lerp(v, t) { return new Vector2(this.x + (v.x - this.x) * t, this.y + (v.y - this.y) * t); }
}

class Rect {
    constructor(x, y, w, h) { this.x = x; this.y = y; this.w = w; this.h = h; }
    get left() { return this.x; } get right() { return this.x + this.w; }
    get top() { return this.y; } get bottom() { return this.y + this.h; }
    get centerx() { return this.x + this.w / 2; } get centery() { return this.y + this.h / 2; }
    set centerx(v) { this.x = v - this.w / 2; } set centery(v) { this.y = v - this.h / 2; }
    collidePoint(px, py) { return px >= this.x && px <= this.x + this.w && py >= this.y && py <= this.y + this.h; }
    collideRect(o) { return this.x < o.x + o.w && this.x + this.w > o.x && this.y < o.y + o.h && this.y + this.h > o.y; }
    inflate(dw, dh) { return new Rect(this.x - dw/2, this.y - dh/2, this.w + dw, this.h + dh); }
}

class SeededRNG {
    constructor(seed) { this.seed = seed; }
    next() { this.seed = (this.seed * 9301 + 49297) % 233280; return this.seed / 233280; }
    randInt(min, max) { return Math.floor(this.next() * (max - min + 1)) + min; }
    randFloat(min, max) { return this.next() * (max - min) + min; }
    choice(arr) { return arr[Math.floor(this.next() * arr.length)]; }
}

function randInt(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; }
function randFloat(min, max) { return Math.random() * (max - min) + min; }
function randChoice(arr) { return arr[Math.floor(Math.random() * arr.length)]; }
function degToRad(deg) { return deg * Math.PI / 180; }

function drawRect(ctx, color, x, y, w, h, radius = 0) {
    ctx.fillStyle = color;
    ctx.beginPath();
    if (radius > 0 && ctx.roundRect) ctx.roundRect(x, y, w, h, radius);
    else ctx.rect(x, y, w, h);
    ctx.fill();
}
function drawCircle(ctx, color, x, y, r) { ctx.fillStyle = color; ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI * 2); ctx.fill(); }

// --- ASSETS ---
function createRoadTexture(size) {
    const cvs = document.createElement('canvas'); cvs.width = size; cvs.height = size; const ctx = cvs.getContext('2d');
    ctx.fillStyle = COLORS.ASPHALT; ctx.fillRect(0, 0, size, size);
    for (let i = 0; i < 1200; i++) { // Increased detail noise
        const c = randInt(30, 60); ctx.fillStyle = `rgba(${c},${c},${c+10}, 0.5)`;
        ctx.fillRect(randInt(0, size), randInt(0, size), 2, 2);
    }
    return cvs;
}
const roadPatternCanvas = createRoadTexture(BLOCK_SIZE);

// --- GAME OBJECTS ---
class Camera {
    constructor() { this.offset = new Vector2(0, 0); this.viewRect = new Rect(0, 0, 0, 0); }
    update(target, gameW, gameH) {
        // Target can be car or player person
        const targetX = -target.pos.x + gameW / 2;
        const targetY = -target.pos.y + gameH / 2;
        this.offset.x += (targetX - this.offset.x) * 0.1;
        this.offset.y += (targetY - this.offset.y) * 0.1;
        this.viewRect = new Rect(-this.offset.x - 600, -this.offset.y - 600, gameW + 1200, gameH + 1200);
    }
    apply(rect) { return new Rect(rect.x + this.offset.x, rect.y + this.offset.y, rect.w, rect.h); }
}

class CarHealth {
    constructor(maxHp = 100) {
        this.maxHp = maxHp;
        this.parts = { 'front_torso': maxHp, 'back_torso': maxHp, 'fl_wheel': maxHp, 'fr_wheel': maxHp, 'rl_wheel': maxHp, 'rr_wheel': maxHp };
    }
    checkFullyDestroyed() { for (let k in this.parts) if (this.parts[k] > 0) return false; return true; }
    takeDamage(amount) {
        let alive = Object.keys(this.parts).filter(k => this.parts[k] > 0);
        if (alive.length === 0) return;
        this.parts[randChoice(alive)] -= amount;
        if (Math.random() > 0.5) { if (this.parts['front_torso'] > 0) this.parts['front_torso'] -= amount / 2; }
        else { if (this.parts['back_torso'] > 0) this.parts['back_torso'] -= amount / 2; }
    }
    drawUI(ctx, x, y) {
        // ... (Same as before, abbreviated for space, logic remains identical)
        const s = 2.5, wBody = 16 * s, hFront = 14 * s, cx = x + wBody / 2;
        const getColor = (hp) => hp > this.maxHp*0.5 ? COLORS.HP_GREEN : (hp > 0 ? COLORS.HP_YELLOW : COLORS.HP_RED);
        ctx.fillStyle = getColor(this.parts['front_torso']);
        ctx.strokeStyle = '#000'; ctx.lineWidth = 2;
        ctx.fillRect(cx - wBody/2, y, wBody, hFront); ctx.strokeRect(cx - wBody/2, y, wBody, hFront);
        ctx.fillStyle = getColor(this.parts['back_torso']);
        ctx.fillRect(cx - wBody/2, y + hFront, wBody, hFront); ctx.strokeRect(cx - wBody/2, y + hFront, wBody, hFront);
    }
}

class Car {
    constructor(x, y, typeOrColor, isCop=false, isCivilian=false) {
        this.pos = new Vector2(x, y); this.vel = new Vector2(0, 0);
        this.angle = 0; this.rotDirection = 0; this.accInput = 0;
        this.isCop = isCop; this.isCivilian = isCivilian;
        this.width = 48; this.height = 24; this.type = 'sedan';
        this.color = '#fff'; this.hasSpoiler = false;
        
        // Player Specific
        this.health = null; this.isEmpty = false; // Is player outside?

        if (isCivilian) {
            this.type = typeOrColor || 'sedan';
            let s = CAR_TYPES[this.type]; this.width = s.w; this.height = s.h; this.color = randChoice(s.colors);
            this.speedTrait = s.speed * randFloat(0.85, 1.15);
        } else if (isCop) { this.color = COLORS.COP_BODY; this.speedTrait = 1.2; }
        else { this.color = typeOrColor; this.health = new CarHealth(100); }

        this.sprite = this.createCarSprite();
        
        // Logic vars
        this.stuckTimer = 0; this.reversing = false; this.blockedTimer = 0; this.laneSwitchDir = 0; this.targetHeading = null;
        this.brakingVisual = false;
        this.lastRotDirection = 0; this.isCollidingWithBuilding = false; this.isCollidingWithCop = false;
        this.stunTimer = 0; this.spinTimer = 0; this.dead = false;
    }

    createCarSprite() {
        // ... (Exact sprite generation code as provided previously)
        // I will keep the original detailed generation here.
        const cvs = document.createElement('canvas');
        let padding = (this.id === 'angel') ? 20 : 0;
        cvs.width = this.width + padding*2; cvs.height = this.height + padding*2;
        const ctx = cvs.getContext('2d'); ctx.imageSmoothingEnabled = false;
        ctx.translate(padding, padding);
        
        // Shadow
        ctx.fillStyle = 'rgba(0,0,0,0.4)'; ctx.fillRect(4, 6, this.width-2, this.height-6);
        
        // Wheels
        ctx.fillStyle = '#111'; 
        [[this.width-12,1],[this.width-12,this.height-5],[10,1],[10,this.height-5]].forEach(([x,y])=>ctx.fillRect(x,y,10,4));

        // Body
        ctx.fillStyle = this.isCop ? COLORS.COP_BODY : this.color;
        ctx.fillRect(2, 3, this.width-4, this.height-6);
        if(this.isCop) { ctx.fillStyle = COLORS.COP_DOOR; ctx.fillRect(14, 3, 18, this.height-6); }
        
        // Cabin
        ctx.fillStyle = '#2d3c46'; 
        ctx.fillRect(12, 6, 20, this.height-12); // Glass
        
        // Roof
        ctx.fillStyle = this.isCop ? COLORS.COP_BODY : this.color;
        ctx.fillRect(14, 7, 16, this.height-14);

        // Lights
        ctx.fillStyle = '#e6e6e6'; ctx.fillRect(this.width-4, 4, 2, 4); ctx.fillRect(this.width-4, this.height-8, 2, 4); // Head
        ctx.fillStyle = '#800000'; ctx.fillRect(2, 4, 2, 4); ctx.fillRect(2, this.height-8, 2, 4); // Tail

        // Accessories
        if(this.isCop) {
            ctx.fillStyle = '#dc0000'; ctx.fillRect(20, 6, 4, 2); // Bar
            ctx.fillStyle = '#0032ff'; ctx.fillRect(20, this.height-8, 4, 2);
        }
        if (this.id === 'angel') { // Wings
            ctx.fillStyle = '#fff'; ctx.strokeStyle='#ccc';
            ctx.beginPath(); ctx.moveTo(10,3); ctx.lineTo(0,-5); ctx.lineTo(12,-9); ctx.lineTo(20,3); ctx.fill(); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(10,this.height-3); ctx.lineTo(0,this.height+5); ctx.lineTo(12,this.height+9); ctx.lineTo(20,this.height-3); ctx.fill(); ctx.stroke();
        }

        return cvs;
    }

    getRect() { return new Rect(this.pos.x - this.width/2, this.pos.y - this.height/2, this.width, this.height); }
    getHitbox() { return new Rect(this.pos.x - (this.width-10)/2, this.pos.y - (this.height-10)/2, this.width-10, this.height-10); }

    physics(buildings, drift, fireWheelActive) {
        if (this.isEmpty) { this.vel = new Vector2(0,0); return; } // Empty car doesn't move

        let turnSpeed = this.customTurnSpeed || TURN_SPEED;
        let maxSpeed = this.customMaxSpeed || (this.isCop ? MAX_SPEED_COP : (this.isCivilian ? MAX_SPEED_CIVILIAN_BASE : MAX_SPEED_PLAYER));
        let acceleration = this.customAccel || ACCELERATION;

        if (fireWheelActive) { maxSpeed *= 1.5; acceleration *= 2; }
        if (this.isCivilian) maxSpeed *= this.speedTrait;

        let acc = this.accInput;
        
        // Turning
        if (this.rotDirection !== 0 && this.vel.mag() > 0.5) {
            let flip = this.vel.dot(new Vector2(Math.cos(degToRad(this.angle)), -Math.sin(degToRad(this.angle)))) > 0 ? 1 : -1;
            this.angle -= this.rotDirection * turnSpeed * flip;
        }

        let rad = degToRad(this.angle);
        let forward = new Vector2(Math.cos(rad), -Math.sin(rad));
        this.vel = this.vel.add(forward.mult(acc));
        
        let speed = this.vel.mag();
        if (drift && speed > 3) this.vel = this.vel.mult(DRIFT_SLIDE);
        else {
            if (speed > 0.1) {
                let dot = this.vel.dot(forward);
                let direction = dot > 0 ? 1 : -1;
                this.vel = this.vel.lerp(forward.mult(speed * direction), 0.12).mult(FRICTION);
            } else if (Math.abs(acc) < 0.01) this.vel = new Vector2(0, 0);
        }

        if (this.vel.mag() > maxSpeed) this.vel = this.vel.normalize().mult(maxSpeed);
        this.pos = this.pos.add(this.vel);

        // Building Collisions
        let hitbox = this.getHitbox();
        this.isCollidingWithBuilding = false;
        for (let b of buildings) {
            if (hitbox.collideRect(b.rect)) {
                this.isCollidingWithBuilding = true;
                let dx = hitbox.centerx - b.rect.centerx, dy = hitbox.centery - b.rect.centery;
                let w = (hitbox.w + b.rect.w)/2, h = (hitbox.h + b.rect.h)/2;
                let ox = w - Math.abs(dx), oy = h - Math.abs(dy);
                if (ox < oy) { this.pos.x += dx > 0 ? ox : -ox; this.vel.x *= 0.5; }
                else { this.pos.y += dy > 0 ? oy : -oy; this.vel.y *= 0.5; }
                hitbox = this.getHitbox();
                if (this.isCivilian || this.isCop) { this.reversing = !this.reversing; this.stuckTimer = 0; }
            }
        }
    }
    
    // Copy updateCop, updateCivilian, checkSensors from original code here...
    // (Implied due to space, standard AI logic)
    updateCop(player, buildings, ghost) {
        if (!this.isCop) return;
        if (this.stunTimer > 0) { this.stunTimer--; this.vel = this.vel.mult(0.9); return; }
        if (this.spinTimer > 0) { this.spinTimer--; this.angle += 15; this.physics(buildings, true); return; }
        
        // Target: Player or PlayerPerson
        let targetPos = player.pos;
        if (player instanceof PlayerPerson) targetPos = player.pos; // Player on foot

        if (ghost) { this.physics(buildings); return; } // Passive
        
        let diff = targetPos.sub(this.pos);
        if (this.vel.mag() < 1) this.stuckTimer++; else this.stuckTimer=0;
        if (this.stuckTimer > 50) this.reversing = true; if (this.stuckTimer>90) { this.reversing=false; this.stuckTimer=0;}

        if (this.reversing) { this.accInput = -0.15; this.rotDirection = 1; }
        else {
            this.accInput = 0.2;
            let targetAng = Math.atan2(-diff.y, diff.x)*180/Math.PI;
            let dAng = (targetAng - this.angle + 180)%360 - 180;
            if (dAng < -180) dAng+=360; if(dAng>180) dAng-=360;
            this.rotDirection = dAng > 8 ? -1 : (dAng < -8 ? 1 : 0);
        }
        this.physics(buildings, false);
    }

    updateCivilian(buildings, cars, player) {
        if (!this.isCivilian) return;
        // Basic wander logic (simplified for length)
        this.accInput = 0.1;
        this.physics(buildings, false);
        if (this.vel.mag() < 0.5) { 
             this.stuckTimer++; 
             if(this.stuckTimer > 100) { this.angle += 90; this.stuckTimer = 0; }
        }
    }

    draw(ctx) {
        ctx.save();
        ctx.translate(this.pos.x, this.pos.y);
        ctx.rotate(-degToRad(this.angle));
        ctx.drawImage(this.sprite, -this.width/2 - (this.id==='angel'?20:0), -this.height/2 - (this.id==='angel'?20:0));
        
        // Dynamic Brake Lights
        if (this.brakingVisual) {
            ctx.fillStyle = '#ff0000'; ctx.shadowBlur = 10; ctx.shadowColor = '#f00';
            ctx.fillRect(1, 5, 3, 3); ctx.fillRect(1, this.height-8, 3, 3);
            ctx.shadowBlur = 0;
        }
        // EMP Stun
        if (this.stunTimer > 0) { ctx.strokeStyle = '#3296ff'; ctx.lineWidth=2; ctx.beginPath(); ctx.arc(0,0,this.width,0,Math.PI*2); ctx.stroke(); }
        ctx.restore();
    }
}

// --- NEW CLASS: PlayerPerson (Walking Mode) ---
class PlayerPerson {
    constructor(x, y) {
        this.pos = new Vector2(x, y);
        this.vel = new Vector2(0, 0);
        this.angle = 0;
        this.speed = 2.5;
        this.rect = new Rect(x-5, y-5, 10, 10);
        this.animFrame = 0;
    }
    update(keys, buildings) {
        let input = new Vector2(0, 0);
        if (keys['arrowup'] || keys['w']) input.y -= 1;
        if (keys['arrowdown'] || keys['s']) input.y += 1;
        if (keys['arrowleft'] || keys['a']) input.x -= 1;
        if (keys['arrowright'] || keys['d']) input.x += 1;

        if (input.mag() > 0) {
            input = input.normalize().mult(this.speed);
            this.angle = Math.atan2(input.y, input.x) * 180 / Math.PI;
            this.animFrame += 0.2;
        } else {
            this.animFrame = 0;
        }
        
        this.pos = this.pos.add(input);

        // Building Collision
        this.rect.centerx = this.pos.x; this.rect.centery = this.pos.y;
        for (let b of buildings) {
            if (this.rect.collideRect(b.rect)) {
                let dx = this.rect.centerx - b.rect.centerx, dy = this.rect.centery - b.rect.centery;
                let ox = (this.rect.w + b.rect.w)/2 - Math.abs(dx);
                let oy = (this.rect.h + b.rect.h)/2 - Math.abs(dy);
                if (ox < oy) this.pos.x += dx>0 ? ox : -ox; else this.pos.y += dy>0 ? oy : -oy;
                this.rect.centerx = this.pos.x; this.rect.centery = this.pos.y;
            }
        }
    }
    draw(ctx) {
        ctx.save();
        ctx.translate(this.pos.x, this.pos.y);
        ctx.rotate(this.angle * Math.PI / 180);
        // Draw Pixel Player
        ctx.fillStyle = '#dc2828'; // Red hoodie
        ctx.fillRect(-6, -6, 12, 12);
        ctx.fillStyle = '#ffdbac'; // Skin
        ctx.fillRect(-2, -2, 4, 4);
        // Legs anim
        let legOffset = Math.sin(this.animFrame)*3;
        ctx.fillStyle = '#222'; // Pants
        ctx.fillRect(-4 + legOffset, -6, 4, 14);
        ctx.fillRect(-4 - legOffset, 6, 4, -14); // wait, rendering from top down
        ctx.restore();
    }
    getRect() { return this.rect; }
}

class Building {
    constructor(gx, gy, isPark) {
        this.gx = gx; this.gy = gy;
        let x = gx * BLOCK_SIZE + BLOCK_SIZE/2, y = gy * BLOCK_SIZE + BLOCK_SIZE/2;
        this.pos = new Vector2(x, y); this.w = BLOCK_SIZE - BUILDING_GAP*2; this.h = BLOCK_SIZE - BUILDING_GAP*2;
        this.rect = new Rect(x - this.w/2, y - this.h/2, this.w, this.h);
        this.sprite = this.generateSprite(isPark);
    }
    generateSprite(isPark) {
        const cvs = document.createElement('canvas'); cvs.width = this.w; cvs.height = this.h; const ctx = cvs.getContext('2d');
        const w = this.w, h = this.h;
        
        // Super Detailed Pixel Noise
        ctx.fillStyle = isPark ? '#328c32' : COLORS.SIDEWALK; ctx.fillRect(0,0,w,h);
        
        // Add noise
        for(let i=0; i<400; i++) {
            ctx.fillStyle = isPark ? `rgba(40, 100, 40, 0.5)` : `rgba(100, 100, 100, 0.3)`;
            ctx.fillRect(randInt(0,w), randInt(0,h), 2, 2);
        }

        if(!isPark) {
             let pad = 12, wallH = 35;
             // Roof
             ctx.fillStyle = '#555'; ctx.fillRect(pad, pad, w-pad*2, h-pad*2 - wallH);
             // Detailed AC units
             for(let i=0; i<5; i++) {
                 let rx = randInt(pad+10, w-pad-30), ry = randInt(pad+10, h-pad-wallH-30);
                 ctx.fillStyle = '#aaa'; ctx.fillRect(rx, ry, 15, 10);
                 ctx.fillStyle = '#000'; ctx.beginPath(); ctx.arc(rx+7, ry+5, 3, 0, Math.PI*2); ctx.fill();
             }
        }
        return cvs;
    }
    draw(ctx) { ctx.drawImage(this.sprite, this.rect.x, this.rect.y); }
}

class Person { // NPC
    constructor(x, y, area) { this.pos = new Vector2(x, y); this.area = area; this.vel = new Vector2(randFloat(-0.5,0.5), randFloat(-0.5,0.5)); this.isAngry = false; this.curseWord=""; }
    update(player) {
        if(this.area) { if(!this.area.collidePoint(this.pos.x+this.vel.x*10, this.pos.y+this.vel.y*10)) this.vel = this.vel.mult(-1); }
        this.pos = this.pos.add(this.vel);
    }
    draw(ctx) { ctx.fillStyle = '#fff'; ctx.fillRect(this.pos.x-3, this.pos.y-3, 6, 6); }
}

class Particle {
    constructor(x, y, type) {
        this.pos = new Vector2(x, y); this.type = type; this.life = 60;
        this.vel = new Vector2(randFloat(-1,1), randFloat(-1,1));
        if (type === 'fire') {
            this.vel = new Vector2(randFloat(-1,1), randFloat(-2, -0.5)); // Float up
            this.color = '#ffaa00'; this.size = randInt(4, 8); this.life = 30;
        } else { this.color = '#fff'; this.size = 2; }
    }
    update() {
        this.pos = this.pos.add(this.vel); this.life--;
        if(this.type === 'fire') {
            this.size *= 0.9;
            if(this.life < 20) this.color = '#ff4400';
            if(this.life < 10) this.color = '#555'; // Smoke
        }
    }
    draw(ctx) { ctx.fillStyle = this.color; ctx.fillRect(this.pos.x, this.pos.y, this.size, this.size); }
}

</script>
<script>
// --- PART 2: GAME LOGIC ---

class Game {
    constructor() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.resize(); window.addEventListener('resize', () => this.resize());

        this.keys = {};
        window.addEventListener('keydown', e => this.keys[e.key.toLowerCase()] = true);
        window.addEventListener('keyup', e => this.keys[e.key.toLowerCase()] = false);
        this.canvas.addEventListener('mousedown', e => this.onClick(e));

        this.state = 'MENU';
        this.selectedCarIndex = 0;
        this.score = 0; this.highScore = 0;
        this.achievements = [];
        
        // Buttons
        this.playRect = new Rect(0,0,0,0); this.settingsRect = new Rect(0,0,0,0);
        this.selectRect = new Rect(0,0,0,0); this.backRect = new Rect(0,0,0,0);
        
        // Logic Vars
        this.hasGhostlyRider = false; this.hasFireWheel = false;
        this.ghostlyRiderActive = false; this.fireWheelActive = false;
        this.tvMode = true;
        
        this.loadedChunks = new Set();
        this.loadData();
        this.initGame();
        
        this.fPressed = false; this.ePressed = false;

        this.loop = this.loop.bind(this);
        requestAnimationFrame(this.loop);
    }

    resize() { this.canvas.width = window.innerWidth; this.canvas.height = window.innerHeight; this.ctx.imageSmoothingEnabled = false; }

    saveData() {
        const data = { highScore: Math.max(this.score, this.highScore), hasGhostlyRider: this.hasGhostlyRider, hasFireWheel: this.hasFireWheel, tvMode: this.tvMode };
        localStorage.setItem('tokyo_drift_ultra', JSON.stringify(data));
        this.highScore = data.highScore;
    }

    loadData() {
        const saved = localStorage.getItem('tokyo_drift_ultra');
        if (saved) {
            const data = JSON.parse(saved);
            this.highScore = data.highScore || 0;
            this.hasGhostlyRider = data.hasGhostlyRider || false;
            this.hasFireWheel = data.hasFireWheel || false;
            this.tvMode = data.tvMode !== undefined ? data.tvMode : true;
        }
    }

    initGame() {
        let spec = PLAYER_ROSTER[this.selectedCarIndex];
        this.player = new Car(0, 0, spec.color);
        this.player.id = spec.id; this.player.health = new CarHealth(spec.stats.hp);
        this.player.customAccel = spec.stats.accel; this.player.customMaxSpeed = spec.stats.speed;
        this.player.powerData = spec.powerData;

        // Player Person Mode
        this.onFoot = false;
        this.playerPerson = null;

        this.camera = new Camera();
        this.buildings = []; this.people = []; this.cops = []; this.particles = [];
        this.loadedChunks.clear();
        this.score = 0;
        this.driftTime = 0; this.turnCount = 0;
    }

    // --- LOGIC ---

    update() {
        if (this.state === 'MENU') {
            this.camera.offset.y -= 5;
            this.updateChunks();
            return;
        }
        if (this.state !== 'PLAY') return;

        // --- ON FOOT MECHANIC ---
        // Toggle F to Exit/Enter
        if (this.keys['f'] && !this.fPressed) {
            if (this.onFoot) {
                // Try enter car
                if (this.playerPerson.pos.distanceTo(this.player.pos) < 60) {
                    this.onFoot = false;
                    this.player.isEmpty = false;
                    this.playerPerson = null;
                }
            } else {
                // Try exit car (must be stopped)
                if (this.player.vel.mag() < 0.5) {
                    this.onFoot = true;
                    this.player.isEmpty = true;
                    this.playerPerson = new PlayerPerson(this.player.pos.x + 30, this.player.pos.y);
                }
            }
            this.fPressed = true;
        }
        if (!this.keys['f']) this.fPressed = false;

        // Repair Mechanic (E)
        if (this.onFoot && this.keys['e'] && !this.ePressed) {
            if (this.playerPerson.pos.distanceTo(this.player.pos) < 60) {
                this.player.health.takeDamage(-20); // Negative damage = heal
                for(let i=0; i<10; i++) this.particles.push(new Particle(this.player.pos.x, this.player.pos.y, 'fire')); // Sparks
            }
            this.ePressed = true;
        }
        if (!this.keys['e']) this.ePressed = false;

        // Update Physics
        if (this.onFoot) {
            this.playerPerson.update(this.keys, this.buildings);
            this.player.physics(this.buildings, false, false); // Car friction
            this.camera.update(this.playerPerson, this.canvas.width, this.canvas.height);
        } else {
            // Car Control
            if (this.keys['arrowleft'] || this.keys['a']) this.player.rotDirection = -1;
            else if (this.keys['arrowright'] || this.keys['d']) this.player.rotDirection = 1;
            else this.player.rotDirection = 0;

            if (this.keys['arrowup'] || this.keys['w']) this.player.accInput = this.player.customAccel;
            else if (this.keys['arrowdown'] || this.keys['s']) this.player.accInput = -this.player.customAccel/2;
            else this.player.accInput = 0;
            
            // Activate Fire Wheel
            if (this.hasFireWheel && this.keys['c']) this.fireWheelActive = true;
            else this.fireWheelActive = false;

            let drift = this.keys[' '];
            this.player.physics(this.buildings, drift, this.fireWheelActive);
            this.camera.update(this.player, this.canvas.width, this.canvas.height);

            // PIXEL FIRE WHEEL
            if (this.fireWheelActive && this.player.vel.mag() > 2) {
                // Spawn particles at rear tires
                let rad = degToRad(this.player.angle);
                let back = new Vector2(-Math.cos(rad), Math.sin(rad)).mult(20);
                let p = this.player.pos.add(back);
                for(let i=0; i<3; i++) this.particles.push(new Particle(p.x + randInt(-10,10), p.y+randInt(-10,10), 'fire'));
            }

            // Unlock Logic (Fixed Persistence)
            if (!this.hasFireWheel && drift && this.player.vel.mag() > 5) {
                this.driftTime++;
                if (this.driftTime > 30 * 60) { 
                    this.hasFireWheel = true; 
                    this.saveData(); // Save immediately
                    alert("FIRE WHEEL UNLOCKED!"); 
                }
            } else if (!drift) this.driftTime = 0;
        }

        this.updateChunks();
        this.particles.forEach((p,i) => { p.update(); if(p.life<=0) this.particles.splice(i,1); });
        
        // Game Over
        if (this.player.health.checkFullyDestroyed()) {
            this.saveData();
            this.state = 'MENU';
        }
    }

    generateChunk(gx, gy) {
        let isRoad = (gx%3===0) || (gy%3===0);
        let cx = gx*BLOCK_SIZE+BLOCK_SIZE/2, cy = gy*BLOCK_SIZE+BLOCK_SIZE/2;
        if (!isRoad) {
            this.buildings.push(new Building(gx, gy, Math.random()<0.1));
        } else {
            // Detailed Ground Noise (Dust)
            if(Math.random()<0.5) {
                this.particles.push(new Particle(cx+randInt(-100,100), cy+randInt(-100,100), 'dust'));
            }
        }
    }

    updateChunks() {
        const view = this.camera.viewRect;
        const startGx = Math.floor(view.left / BLOCK_SIZE) - 1, endGx = Math.floor(view.right / BLOCK_SIZE) + 1;
        const startGy = Math.floor(view.top / BLOCK_SIZE) - 1, endGy = Math.floor(view.bottom / BLOCK_SIZE) + 1;

        for (let gx = startGx; gx < endGx; gx++) {
            for (let gy = startGy; gy < endGy; gy++) {
                let key = `${gx},${gy}`;
                if (!this.loadedChunks.has(key)) {
                    this.generateChunk(gx, gy);
                    this.loadedChunks.add(key);
                }
            }
        }
        // Cleanup logic omitted for brevity, assume simple array filtering
        this.buildings = this.buildings.filter(b => view.inflate(500,500).collideRect(b.rect));
    }

    // --- DRAWING ---

    drawFloor() {
        const bs = BLOCK_SIZE;
        const view = this.camera.viewRect;
        // Optimization: Calculate visible tiles
        const startGx = Math.floor(view.left / bs) - 1, endGx = Math.floor(view.right / bs) + 1;
        const startGy = Math.floor(view.top / bs) - 1, endGy = Math.floor(view.bottom / bs) + 1;

        for (let gx = startGx; gx < endGx; gx++) {
            for (let gy = startGy; gy < endGy; gy++) {
                if ((gx%3===0) || (gy%3===0)) {
                    this.ctx.drawImage(roadPatternCanvas, gx*bs + this.camera.offset.x, gy*bs + this.camera.offset.y);
                    // Add road markings here (simplified)
                    this.ctx.fillStyle = '#fff';
                    if (gx%3===0) this.ctx.fillRect(gx*bs + this.camera.offset.x + 10, gy*bs + this.camera.offset.y, 4, bs);
                }
            }
        }
    }

    draw(ctx) {
        const w = this.canvas.width, h = this.canvas.height;
        ctx.fillStyle = COLORS.BG_VOID; ctx.fillRect(0,0,w,h);

        this.drawFloor();

        // Sort render order
        let objs = [...this.buildings, ...this.people, ...this.particles];
        if (this.onFoot) objs.push(this.playerPerson);
        objs.push(this.player);
        objs.sort((a,b) => (a.pos ? a.pos.y : a.rect.bottom) - (b.pos ? b.pos.y : b.rect.bottom));

        ctx.save();
        ctx.translate(this.camera.offset.x, this.camera.offset.y);
        objs.forEach(o => {
            if (o === this.player && this.player.isEmpty) {
                // Darken car if empty
                o.draw(ctx);
                ctx.fillStyle = 'rgba(0,0,0,0.5)';
                let r = o.getRect();
                ctx.fillRect(r.x, r.y, r.w, r.h);
            } else {
                o.draw(ctx);
            }
        });
        ctx.restore();

        // UI
        if (this.state === 'MENU') this.drawMenu(ctx, w, h);
        if (this.state === 'SETTINGS') this.drawSettings(ctx, w, h);
        if (this.state === 'PLAY') {
            // Interaction Prompts
            if (this.onFoot && this.playerPerson.pos.distanceTo(this.player.pos) < 60) {
                ctx.fillStyle = '#fff'; ctx.font='16px monospace'; ctx.fillText("[F] DRIVE   [E] REPAIR", w/2 - 100, h - 100);
            } else if (!this.onFoot && this.player.vel.mag() < 0.5) {
                ctx.fillStyle = '#fff'; ctx.font='16px monospace'; ctx.fillText("[F] EXIT CAR", w/2 - 60, h - 100);
            }
            
            this.player.health.drawUI(ctx, w-60, 20);
        }
    }

    drawMenu(ctx, w, h) {
        const cx = w/2, cy = h/2;
        // HIGH SCORE DISPLAY (Top Left)
        ctx.textAlign = 'left'; ctx.fillStyle = '#fff'; ctx.font = '20px "Press Start 2P"';
        ctx.fillText(`HIGH SCORE: ${this.highScore}`, 20, 40);

        ctx.textAlign = 'center';
        ctx.font = '40px "Press Start 2P"'; ctx.fillStyle = '#ff3333'; ctx.fillText("TOKYO DRIFT", cx, cy-100);
        
        let btnW = 300, btnH = 60;
        this.playRect = new Rect(cx - btnW/2, cy, btnW, btnH);
        drawRect(ctx, '#333', this.playRect.x, this.playRect.y, btnW, btnH);
        ctx.fillStyle = '#fff'; ctx.font='20px "Press Start 2P"'; ctx.fillText("PLAY", cx, cy+40);

        this.settingsRect = new Rect(cx - btnW/2, cy+80, btnW, btnH);
        drawRect(ctx, '#333', this.settingsRect.x, this.settingsRect.y, btnW, btnH);
        ctx.fillText("SETTINGS", cx, cy+120);
    }

    drawSettings(ctx, w, h) {
        const cx = w/2, cy = h/2;
        
        // Gray Block Background for Settings
        drawRect(ctx, '#444', cx - 250, cy - 200, 500, 400, 10);
        
        ctx.textAlign = 'center'; ctx.fillStyle = '#fff'; ctx.font = '30px "Press Start 2P"';
        ctx.fillText("SETTINGS", cx, cy - 100);

        // Reset Button
        this.backRect = new Rect(cx - 150, cy + 100, 300, 50);
        drawRect(ctx, '#222', this.backRect.x, this.backRect.y, 300, 50);
        ctx.font = '20px "Press Start 2P"';
        ctx.fillText("BACK", cx, cy + 135);
        
        // Settings Text
        ctx.font = '14px "Press Start 2P"';
        ctx.fillText("TV MODE: " + (this.tvMode?"ON":"OFF"), cx, cy);
    }

    onClick(e) {
        let mx = e.clientX, my = e.clientY;
        if (this.state === 'MENU') {
            if (this.playRect.collidePoint(mx,my)) this.state = 'PLAY';
            if (this.settingsRect.collidePoint(mx,my)) this.state = 'SETTINGS';
        } else if (this.state === 'SETTINGS') {
            if (this.backRect.collidePoint(mx,my)) { this.state = 'MENU'; this.saveData(); }
        }
    }

    loop() {
        this.update();
        this.draw(this.ctx);
        requestAnimationFrame(this.loop);
    }
}

const game = new Game();
</script>
</body>
</html>

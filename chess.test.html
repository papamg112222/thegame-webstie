<!DOCTYPE html>
<html lang="en">
<head>
Â  Â  <meta charset="UTF-8">
Â  Â  <meta name="viewport" content="width=device-width, initial-scale=1.0">
Â  Â  <title>Ultimate Chess (Anime Edition)</title>
Â  Â Â 
Â  Â  <style>
Â  Â  Â  Â  /* --- Global Constants (Aesthetic Mapping) --- */
Â  Â  Â  Â  :root {
Â  Â  Â  Â  Â  Â  --royal-bg: #2E2E38;
Â  Â  Â  Â  Â  Â  --panel-bg: #383B40;
Â  Â  Â  Â  Â  Â  --light-square: #F0D9B5;
Â  Â  Â  Â  Â  Â  --dark-square: #B58863;
Â  Â  Â  Â  Â  Â  --gold-piece: #000000;
Â  Â  Â  Â  Â  Â  --silver-piece: #FFFFFF;
Â  Â  Â  Â  Â  Â  --accent-red: #F04747;
Â  Â  Â  Â  Â  Â  --accent-green: #43b581;
Â  Â  Â  Â  Â  Â  --highlight-color: #A8C356;
Â  Â  Â  Â  Â  Â  --attack-color: #FF5733;
Â  Â  Â  Â  Â  Â  --frozen-color: #00BFFF;
Â  Â  Â  Â  Â  Â  --dot-color: #383B40;
Â  Â  Â  Â  Â  Â  --power-target-color: #FFA500;
Â  Â  Â  Â  Â  Â  --murasaki-void: #0D0D0D;
Â  Â  Â  Â  Â  Â  --murasaki-red: #FF4500;
Â  Â  Â  Â  Â  Â  --murasaki-blue: #00BFFF;

Â  Â  Â  Â  Â  Â  /* Base Sizes (Desktop) */
Â  Â  Â  Â  Â  Â  --base-piece-font-size: 52px;
Â  Â  Â  Â  Â  Â  --base-dot-font-size: 36px;
Â  Â  Â  Â  Â  Â  --base-panel-font-size: 10px;
Â  Â  Â  Â  Â  Â  --base-title-font-size: 18px;
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  /* Responsive Sizes (Updated by JS) */
Â  Â  Â  Â  Â  Â  --piece-font-size: var(--base-piece-font-size);
Â  Â  Â  Â  Â  Â  --dot-font-size: var(--base-dot-font-size);
Â  Â  Â  Â  Â  Â  --panel-font-size: var(--base-panel-font-size);
Â  Â  Â  Â  Â  Â  --title-font-size: var(--base-title-font-size);
Â  Â  Â  Â  }

Â  Â  Â  Â  body {
Â  Â  Â  Â  Â  Â  background-color: var(--royal-bg);
Â  Â  Â  Â  Â  Â  margin: 0;
Â  Â  Â  Â  Â  Â  display: flex;
Â  Â  Â  Â  Â  Â  justify-content: center;
Â  Â  Â  Â  Â  Â  align-items: center;
Â  Â  Â  Â  Â  Â  min-height: 100vh;
Â  Â  Â  Â  Â  Â  font-family: Arial, sans-serif;
Â  Â  Â  Â  Â  Â  color: var(--silver-piece);
Â  Â  Â  Â  Â  Â  overflow: auto;
Â  Â  Â  Â  }

Â  Â  Â  Â  #game-container {
Â  Â  Â  Â  Â  Â  display: flex;
Â  Â  Â  Â  Â  Â  flex-direction: row;
Â  Â  Â  Â  Â  Â  width: 95%;
Â  Â  Â  Â  Â  Â  max-width: 1200px;
Â  Â  Â  Â  Â  Â  height: 95vh;
Â  Â  Â  Â  Â  Â  max-height: 95vh;
Â  Â  Â  Â  Â  Â  margin: auto;
Â  Â  Â  Â  Â  Â  box-sizing: border-box;
Â  Â  Â  Â  }

Â  Â  Â  Â  .hidden {
Â  Â  Â  Â  Â  Â  display: none !important;
Â  Â  Â  Â  }

Â  Â  Â  Â  /* --- Menu Styling --- */
Â  Â  Â  Â  .menu-screen {
Â  Â  Â  Â  Â  Â  display: flex;
Â  Â  Â  Â  Â  Â  flex-direction: column;
Â  Â  Â  Â  Â  Â  justify-content: center;
Â  Â  Â  Â  Â  Â  align-items: center;
Â  Â  Â  Â  Â  Â  text-align: center;
Â  Â  Â  Â  Â  Â  width: 100%;
Â  Â  Â  Â  Â  Â  height: 100%;
Â  Â  Â  Â  Â  Â  padding: 20px;
Â  Â  Â  Â  Â  Â  background-color: var(--panel-bg);
Â  Â  Â  Â  Â  Â  border-radius: 8px;
Â  Â  Â  Â  Â  Â  box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
Â  Â  Â  Â  }

Â  Â  Â  Â  .menu-screen h1 {
Â  Â  Â  Â  Â  Â  font-size: 32px;
Â  Â  Â  Â  Â  Â  color: var(--accent-green);
Â  Â  Â  Â  Â  Â  margin-bottom: 40px;
Â  Â  Â  Â  }

Â  Â  Â  Â  .menu-screen button {
Â  Â  Â  Â  Â  Â  padding: 15px 30px;
Â  Â  Â  Â  Â  Â  margin: 10px 0;
Â  Â  Â  Â  Â  Â  border: none;
Â  Â  Â  Â  Â  Â  cursor: pointer;
Â  Â  Â  Â  Â  Â  font-size: 18px;
Â  Â  Â  Â  Â  Â  font-weight: bold;
Â  Â  Â  Â  Â  Â  color: white;
Â  Â  Â  Â  Â  Â  width: 100%;
Â  Â  Â  Â  Â  Â  max-width: 400px;
Â  Â  Â  Â  Â  Â  border-radius: 4px;
Â  Â  Â  Â  Â  Â  transition: background-color 0.2s;
Â  Â  Â  Â  }

Â  Â  Â  Â  #start-local-btn {
Â  Â  Â  Â  Â  Â  background-color: var(--panel-bg);
Â  Â  Â  Â  Â  Â  border: 4px solid var(--accent-green);
Â  Â  Â  Â  }
Â  Â  Â  Â  #start-local-btn:hover {
Â  Â  Â  Â  Â  Â  background-color: #474751;
Â  Â  Â  Â  }

Â  Â  Â  Â  .bot-settings {
Â  Â  Â  Â  Â  Â  width: 100%;
Â  Â  Â  Â  Â  Â  max-width: 400px;
Â  Â  Â  Â  Â  Â  margin: 20px 0;
Â  Â  Â  Â  Â  Â  padding: 15px;
Â  Â  Â  Â  Â  Â  background-color: var(--royal-bg);
Â  Â  Â  Â  Â  Â  border-radius: 4px;
Â  Â  Â  Â  }

Â  Â  Â  Â  .bot-settings h2 {
Â  Â  Â  Â  Â  Â  font-size: 14px;
Â  Â  Â  Â  Â  Â  color: var(--light-square);
Â  Â  Â  Â  Â  Â  margin-bottom: 10px;
Â  Â  Â  Â  }

Â  Â  Â  Â  #elo-control {
Â  Â  Â  Â  Â  Â  display: flex;
Â  Â  Â  Â  Â  Â  align-items: center;
Â  Â  Â  Â  Â  Â  margin-bottom: 10px;
Â  Â  Â  Â  }

Â  Â  Â  Â  #elo-label {
Â  Â  Â  Â  Â  Â  flex-shrink: 0;
Â  Â  Â  Â  Â  Â  margin-right: 10px;
Â  Â  Â  Â  Â  Â  font-size: 14px;
Â  Â  Â  Â  Â  Â  color: var(--light-square);
Â  Â  Â  Â  }

Â  Â  Â  Â  #elo-slider {
Â  Â  Â  Â  Â  Â  flex-grow: 1;
Â  Â  Â  Â  Â  Â  -webkit-appearance: none;
Â  Â  Â  Â  Â  Â  height: 8px;
Â  Â  Â  Â  Â  Â  background: #474751;
Â  Â  Â  Â  Â  Â  outline: none;
Â  Â  Â  Â  Â  Â  opacity: 0.7;
Â  Â  Â  Â  Â  Â  transition: opacity .2s;
Â  Â  Â  Â  }
Â  Â  Â  Â  #elo-slider::-webkit-slider-thumb {
Â  Â  Â  Â  Â  Â  -webkit-appearance: none;
Â  Â  Â  Â  Â  Â  appearance: none;
Â  Â  Â  Â  Â  Â  width: 16px;
Â  Â  Â  Â  Â  Â  height: 16px;
Â  Â  Â  Â  Â  Â  border-radius: 50%;
Â  Â  Â  Â  Â  Â  background: var(--accent-green);
Â  Â  Â  Â  Â  Â  cursor: pointer;
Â  Â  Â  Â  }

Â  Â  Â  Â  #start-bot-btn {
Â  Â  Â  Â  Â  Â  background-color: var(--accent-green);
Â  Â  Â  Â  }
Â  Â  Â  Â  #start-bot-btn:hover {
Â  Â  Â  Â  Â  Â  background-color: #389569;
Â  Â  Â  Â  }

Â  Â  Â  Â  /* --- Online Lobby Styling --- */
Â  Â  Â  Â  #online-lobby {
Â  Â  Â  Â  Â  Â  padding: 20px;
Â  Â  Â  Â  Â  Â  text-align: center;
Â  Â  Â  Â  Â  Â  display: flex;
Â  Â  Â  Â  Â  Â  flex-direction: column;
Â  Â  Â  Â  Â  Â  width: 100%;
Â  Â  Â  Â  Â  Â  max-width: 600px;
Â  Â  Â  Â  Â  Â  height: 100%;
Â  Â  Â  Â  }

Â  Â  Â  Â  #online-lobby h2 {
Â  Â  Â  Â  Â  Â  font-size: 24px;
Â  Â  Â  Â  Â  Â  color: var(--silver-piece);
Â  Â  Â  Â  Â  Â  margin-bottom: 30px;
Â  Â  Â  Â  }
Â  Â  Â  Â Â 
Â  Â  Â  Â  #player-list {
Â  Â  Â  Â  Â  Â  display: flex;
Â  Â  Â  Â  Â  Â  flex-direction: column;
Â  Â  Â  Â  Â  Â  gap: 15px;
Â  Â  Â  Â  Â  Â  overflow-y: auto;
Â  Â  Â  Â  Â  Â  padding: 10px;
Â  Â  Â  Â  Â  Â  background-color: var(--royal-bg);
Â  Â  Â  Â  Â  Â  border-radius: 4px;
Â  Â  Â  Â  Â  Â  flex-grow: 1;
Â  Â  Â  Â  }

Â  Â  Â  Â  .player-card {
Â  Â  Â  Â  Â  Â  background-color: #474751;
Â  Â  Â  Â  Â  Â  padding: 15px;
Â  Â  Â  Â  Â  Â  border-radius: 8px;
Â  Â  Â  Â  Â  Â  text-align: left;
Â  Â  Â  Â  Â  Â  cursor: pointer;
Â  Â  Â  Â  Â  Â  transition: background-color 0.2s, transform 0.1s;
Â  Â  Â  Â  Â  Â  border: 2px solid transparent;
Â  Â  Â  Â  }

Â  Â  Â  Â  .player-card:hover {
Â  Â  Â  Â  Â  Â  background-color: #5d6168;
Â  Â  Â  Â  Â  Â  border-color: var(--accent-green);
Â  Â  Â  Â  }
Â  Â  Â  Â Â 
Â  Â  Â  Â  .player-card:active {
Â  Â  Â  Â  Â  Â  transform: scale(0.98);
Â  Â  Â  Â  }
Â  Â  Â  Â Â 
Â  Â  Â  Â  .player-card span {
Â  Â  Â  Â  Â  Â  font-weight: bold;
Â  Â  Â  Â  Â  Â  color: var(--light-square);
Â  Â  Â  Â  }
Â  Â  Â  Â Â 
Â  Â  Â  Â  .player-card .status {
Â  Â  Â  Â  Â  Â  float: right;
Â  Â  Â  Â  Â  Â  font-weight: normal;
Â  Â  Â  Â  Â  Â  color: var(--accent-green);
Â  Â  Â  Â  }

Â  Â  Â  Â  .coming-soon {
Â  Â  Â  Â  Â  Â  display: flex;
Â  Â  Â  Â  Â  Â  align-items: center;
Â  Â  Â  Â  Â  Â  width: 100%;
Â  Â  Â  Â  Â  Â  max-width: 400px;
Â  Â  Â  Â  }

Â  Â  Â  Â  .coming-soon button {
Â  Â  Â  Â  Â  Â  flex-grow: 1;
Â  Â  Â  Â  Â  Â  background-color: var(--panel-bg);
Â  Â  Â  Â  Â  Â  color: var(--silver-piece);
Â  Â  Â  Â  Â  Â  cursor: pointer;
Â  Â  Â  Â  Â  Â  border: 4px solid var(--accent-green); /* Make button active */
Â  Â  Â  Â  }
Â  Â  Â  Â Â 
Â  Â  Â  Â  .coming-soon button:disabled {
Â  Â  Â  Â  Â  Â  color: #888888;
Â  Â  Â  Â  Â  Â  cursor: default;
Â  Â  Â  Â  Â  Â  border: 1px solid #555;
Â  Â  Â  Â  Â  Â  background-color: var(--panel-bg);
Â  Â  Â  Â  }

Â  Â  Â  Â  .soon-tag {
Â  Â  Â  Â  Â  Â  color: var(--accent-red);
Â  Â  Â  Â  Â  Â  font-weight: bold;
Â  Â  Â  Â  Â  Â  margin-left: 10px;
Â  Â  Â  Â  Â  Â  font-size: 12px;
Â  Â  Â  Â  Â  Â  display: none; /* Hide the tag since the button is now active */
Â  Â  Â  Â  }

Â  Â  Â  Â  /* --- Game UI Layout --- */
Â  Â  Â  Â  #game-ui {
Â  Â  Â  Â  Â  Â  display: flex;
Â  Â  Â  Â  Â  Â  flex-direction: row;
Â  Â  Â  Â  Â  Â  width: 100%;
Â  Â  Â  Â  Â  Â  height: 100%;
Â  Â  Â  Â  Â  Â  box-sizing: border-box;
Â  Â  Â  Â  Â  Â  padding: 20px;
Â  Â  Â  Â  }

Â  Â  Â  Â  #board-ui-frame {
Â  Â  Â  Â  Â  Â  flex-grow: 1;
Â  Â  Â  Â  Â  Â  display: flex;
Â  Â  Â  Â  Â  Â  justify-content: center;
Â  Â  Â  Â  Â  Â  align-items: center;
Â  Â  Â  Â  Â  Â  position: relative;
Â  Â  Â  Â  Â  Â  max-width: 70%;
Â  Â  Â  Â  Â  Â  max-height: 100%;
Â  Â  Â  Â  Â  Â  margin-right: 20px;
Â  Â  Â  Â  }

Â  Â  Â  Â  #board-container {
Â  Â  Â  Â  Â  Â  display: grid;
Â  Â  Â  Â  Â  Â  grid-template-columns: auto repeat(8, 1fr);
Â  Â  Â  Â  Â  Â  grid-template-rows: repeat(8, 1fr) auto;
Â  Â  Â  Â  Â  Â  aspect-ratio: 1 / 1;
Â  Â  Â  Â  Â  Â  max-width: 100%;
Â  Â  Â  Â  Â  Â  max-height: 100%;
Â  Â  Â  Â  }

Â  Â  Â  Â  #board-frame {
Â  Â  Â  Â  Â  Â  grid-column: 2 / 10;
Â  Â  Â  Â  Â  Â  grid-row: 1 / 9;
Â  Â  Â  Â  Â  Â  display: grid;
Â  Â  Â  Â  Â  Â  grid-template-columns: repeat(8, 1fr);
Â  Â  Â  Â  Â  Â  grid-template-rows: repeat(8, 1fr);
Â  Â  Â  Â  Â  Â  width: 100%;
Â  Â  Â  Â  Â  Â  height: 100%;
Â  Â  Â  Â  Â  Â  border: 2px solid var(--dark-square);
Â  Â  Â  Â  Â  Â  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);
Â  Â  Â  Â  Â  Â  position: relative; /* Needed for overlay */
Â  Â  Â  Â  }

Â  Â  Â  Â  /* Coordinates */
Â  Â  Â  Â  #rank-labels-container {
Â  Â  Â  Â  Â  Â  grid-column: 1 / 2;
Â  Â  Â  Â  Â  Â  grid-row: 1 / 9;
Â  Â  Â  Â  Â  Â  display: grid;
Â  Â  Â  Â  Â  Â  grid-template-rows: repeat(8, 1fr);
Â  Â  Â  Â  Â  Â  align-items: center;
Â  Â  Â  Â  Â  Â  padding-right: 5px;
Â  Â  Â  Â  }
Â  Â  Â  Â  #file-labels-container {
Â  Â  Â  Â  Â  Â  grid-column: 2 / 10;
Â  Â  Â  Â  Â  Â  grid-row: 9 / 10;
Â  Â  Â  Â  Â  Â  display: grid;
Â  Â  Â  Â  Â  Â  grid-template-columns: repeat(8, 1fr);
Â  Â  Â  Â  Â  Â  justify-items: center;
Â  Â  Â  Â  Â  Â  padding-top: 5px;
Â  Â  Â  Â  }
Â  Â  Â  Â  .coord-label {
Â  Â  Â  Â  Â  Â  font-size: calc(var(--panel-font-size) + 4px);
Â  Â  Â  Â  Â  Â  font-weight: bold;
Â  Â  Â  Â  Â  Â  color: var(--silver-piece);
Â  Â  Â  Â  Â  Â  text-align: center;
Â  Â  Â  Â  }

Â  Â  Â  Â  /* --- Board Squares --- */
Â  Â  Â  Â  .square {
Â  Â  Â  Â  Â  Â  display: flex;
Â  Â  Â  Â  Â  Â  justify-content: center;
Â  Â  Â  Â  Â  Â  align-items: center;
Â  Â  Â  Â  Â  Â  cursor: pointer;
Â  Â  Â  Â  Â  Â  font-size: var(--piece-font-size);
Â  Â  Â  Â  Â  Â  transition: background-color 0.1s;
Â  Â  Â  Â  Â  Â  user-select: none;
Â  Â  Â  Â  Â  Â  box-sizing: border-box;
Â  Â  Â  Â  Â  Â  padding: 0;
Â  Â  Â  Â  Â  Â  /* FIX: Ensure element fills the grid cell */
Â  Â  Â  Â  Â  Â  width: 100%;Â 
Â  Â  Â  Â  Â  Â  height: 100%;
Â  Â  Â  Â  }

Â  Â  Â  Â  /* FIX: Ensure base colors are defined via class, not inline JS, for proper cascading */
Â  Â  Â  Â  .light-square {
Â  Â  Â  Â  Â  Â  background-color: var(--light-square);
Â  Â  Â  Â  }

Â  Â  Â  Â  .dark-square {
Â  Â  Â  Â  Â  Â  background-color: var(--dark-square);
Â  Â  Â  Â  }
Â  Â  Â  Â  /* END FIX */

Â  Â  Â  Â  .piece-symbol {
Â  Â  Â  Â  Â  Â  /* Ensures unicode pieces are centered */
Â  Â  Â  Â  Â  Â  line-height: 1;
Â  Â  Â  Â  Â  Â  text-align: center;
Â  Â  Â  Â  }

Â  Â  Â  Â  /* Highlighted States */
Â  Â  Â  Â  /* NOTE: !important is needed here because JS might still try to apply inline styles,Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â or to override the base class colors during highlighting. */
Â  Â  Â  Â  .selected {
Â  Â  Â  Â  Â  Â  background-color: var(--highlight-color) !important;
Â  Â  Â  Â  }

Â  Â  Â  Â  .attack-target {
Â  Â  Â  Â  Â  Â  background-color: var(--attack-color) !important;
Â  Â  Â  Â  }

Â  Â  Â  Â  .power-target {
Â  Â  Â  Â  Â  Â  background-color: var(--power-target-color) !important;
Â  Â  Â  Â  Â  Â  border: 3px solid var(--accent-red);
Â  Â  Â  Â  }

Â  Â  Â  Â  .move-dot {
Â  Â  Â  Â  Â  Â  font-size: var(--dot-font-size);
Â  Â  Â  Â  Â  Â  color: var(--dot-color);
Â  Â  Â  Â  Â  Â  line-height: 1;
Â  Â  Â  Â  }

Â  Â  Â  Â  .frozen {
Â  Â  Â  Â  Â  Â  background-color: var(--frozen-color) !important;
Â  Â  Â  Â  }

Â  Â  Â  Â  /* Blockade/Roomba */
Â  Â  Â  Â  .blockade-symbol {
Â  Â  Â  Â  Â  Â  color: #FF4500;
Â  Â  Â  Â  }
Â  Â  Â  Â  .roomba-symbol {
Â  Â  Â  Â  Â  Â  color: #FFD700;
Â  Â  Â  Â  Â  Â  background-color: #474751;
Â  Â  Â  Â  }

Â  Â  Â  Â  /* Piece Colors */
Â  Â  Â  Â  .W-piece { color: var(--gold-piece); }
Â  Â  Â  Â  .B-piece { color: var(--silver-piece); }
Â  Â  Â  Â  .hacked-piece { color: #FFD700 !important; }

Â  Â  Â  Â  /* Archbishop/Frozen font size adjustments */
Â  Â  Â  Â  .small-font {
Â  Â  Â  Â  Â  Â  font-size: calc(var(--piece-font-size) - 12px) !important;
Â  Â  Â  Â  }

Â  Â  Â  Â  /* --- Game Over Overlay --- */
Â  Â  Â  Â  #game-overlay {
Â  Â  Â  Â  Â  Â  position: absolute;
Â  Â  Â  Â  Â  Â  top: 0;
Â  Â  Â  Â  Â  Â  left: 0;
Â  Â  Â  Â  Â  Â  width: 100%;
Â  Â  Â  Â  Â  Â  height: 100%;
Â  Â  Â  Â  Â  Â  background-color: rgba(46, 46, 56, 0.85); /* royal-bg with transparency */
Â  Â  Â  Â  Â  Â  display: flex;
Â  Â  Â  Â  Â  Â  flex-direction: column;
Â  Â  Â  Â  Â  Â  justify-content: center;
Â  Â  Â  Â  Â  Â  align-items: center;
Â  Â  Â  Â  Â  Â  text-align: center;
Â  Â  Â  Â  Â  Â  cursor: pointer;
Â  Â  Â  Â  Â  Â  z-index: 10;
Â  Â  Â  Â  }

Â  Â  Â  Â  #overlay-message {
Â  Â  Â  Â  Â  Â  font-size: 30px;
Â  Â  Â  Â  Â  Â  font-weight: bold;
Â  Â  Â  Â  Â  Â  color: var(--accent-red);
Â  Â  Â  Â  Â  Â  margin-bottom: 10px;
Â  Â  Â  Â  }
Â  Â  Â  Â  #overlay-click-prompt {
Â  Â  Â  Â  Â  Â  font-size: 16px;
Â  Â  Â  Â  Â  Â  color: var(--light-square);
Â  Â  Â  Â  Â  Â  margin-top: 20px;
Â  Â  Â  Â  }

Â  Â  Â  Â  /* --- Panel Styling --- */
Â  Â  Â  Â  #panel-frame {
Â  Â  Â  Â  Â  Â  flex-shrink: 0;
Â  Â  Â  Â  Â  Â  width: 280px;
Â  Â  Â  Â  Â  Â  background-color: var(--panel-bg);
Â  Â  Â  Â  Â  Â  padding: 15px;
Â  Â  Â  Â  Â  Â  border-radius: 4px;
Â  Â  Â  Â  Â  Â  box-sizing: border-box;
Â  Â  Â  Â  Â  Â  display: flex;
Â  Â  Â  Â  Â  Â  flex-direction: column;
Â  Â  Â  Â  Â  Â  align-items: stretch;
Â  Â  Â  Â  Â  Â  border: 2px solid var(--dark-square);
Â  Â  Â  Â  }

Â  Â  Â  Â  #panel-frame h2 {
Â  Â  Â  Â  Â  Â  font-size: var(--title-font-size);
Â  Â  Â  Â  Â  Â  font-weight: bold;
Â  Â  Â  Â  Â  Â  color: var(--silver-piece);
Â  Â  Â  Â  Â  Â  text-align: center;
Â  Â  Â  Â  Â  Â  margin: 10px 0;
Â  Â  Â  Â  }

Â  Â  Â  Â  #status-label {
Â  Â  Â  Â  Â  Â  font-size: var(--title-font-size);
Â  Â  Â  Â  Â  Â  font-weight: bold;
Â  Â  Â  Â  Â  Â  text-align: center;
Â  Â  Â  Â  Â  Â  padding: 5px 0;
Â  Â  Â  Â  }

Â  Â  Â  Â  #r-uses-label {
Â  Â  Â  Â  Â  Â  font-size: calc(var(--panel-font-size) + 1px);
Â  Â  Â  Â  Â  Â  color: #FFD700;
Â  Â  Â  Â  Â  Â  text-align: center;
Â  Â  Â  Â  Â  Â  padding: 2px 0;
Â  Â  Â  Â  }

Â  Â  Â  Â  #message-label {
Â  Â  Â  Â  Â  Â  font-size: calc(var(--panel-font-size) + 2px);
Â  Â  Â  Â  Â  Â  padding: 5px;
Â  Â  Â  Â  Â  Â  margin: 5px 0 15px 0;
Â  Â  Â  Â  Â  Â  min-height: 40px;
Â  Â  Â  Â  Â  Â  background-color: #474751;
Â  Â  Â  Â  Â  Â  border-radius: 4px;
Â  Â  Â  Â  Â  Â  text-align: center;
Â  Â  Â  Â  }

Â  Â  Â  Â  #ability-info-frame {
Â  Â  Â  Â  Â  Â  background-color: #474751;
Â  Â  Â  Â  Â  Â  padding: 8px;
Â  Â  Â  Â  Â  Â  border-radius: 4px;
Â  Â  Â  Â  Â  Â  border: 1px solid var(--dark-square);
Â  Â  Â  Â  Â  Â  margin-bottom: 10px;
Â  Â  Â  Â  }

Â  Â  Â  Â  .ultimate-separator {
Â  Â  Â  Â  Â  Â  font-size: calc(var(--panel-font-size) + 1px);
Â  Â  Â  Â  Â  Â  font-weight: bold;
Â  Â  Â  Â  Â  Â  color: var(--silver-piece);
Â  Â  Â  Â  Â  Â  text-align: center;
Â  Â  Â  Â  Â  Â  margin: 5px 0;
Â  Â  Â  Â  }

Â  Â  Â  Â  #ability-title {
Â  Â  Â  Â  Â  Â  font-size: calc(var(--panel-font-size) + 3px);
Â  Â  Â  Â  Â  Â  font-weight: bold;
Â  Â  Â  Â  Â  Â  color: var(--accent-green);
Â  Â  Â  Â  Â  Â  text-align: center;
Â  Â  Â  Â  Â  Â  padding: 2px 0;
Â  Â  Â  Â  }

Â  Â  Â  Â  #ability-desc {
Â  Â  Â  Â  Â  Â  font-size: var(--panel-font-size);
Â  Â  Â  Â  Â  Â  color: var(--light-square);
Â  Â  Â  Â  Â  Â  text-align: left;
Â  Â  Â  Â  Â  Â  padding: 5px;
Â  Â  Â  Â  Â  Â  min-height: 40px;
Â  Â  Â  Â  }

Â  Â  Â  Â  #ability-prompt {
Â  Â  Â  Â  Â  Â  font-size: calc(var(--panel-font-size) + 1px);
Â  Â  Â  Â  Â  Â  color: var(--accent-green);
Â  Â  Â  Â  Â  Â  text-align: center;
Â  Â  Â  Â  Â  Â  padding: 5px 0;
Â  Â  Â  Â  }

Â  Â  Â  Â  #cmd-frame {
Â  Â  Â  Â  Â  Â  margin-bottom: 15px;
Â  Â  Â  Â  }

Â  Â  Â  Â  #cmd-frame button {
Â  Â  Â  Â  Â  Â  width: 100%;
Â  Â  Â  Â  Â  Â  padding: 8px;
Â  Â  Â  Â  Â  Â  margin: 2px 0;
Â  Â  Â  Â  Â  Â  background-color: #474751;
Â  Â  Â  Â  Â  Â  color: white;
Â  Â  Â  Â  Â  Â  border: none;
Â  Â  Â  Â  Â  Â  border-radius: 3px;
Â  Â  Â  Â  Â  Â  cursor: pointer;
Â  Â  Â  Â  Â  Â  font-size: calc(var(--panel-font-size) + 1px);
Â  Â  Â  Â  Â  Â  transition: background-color 0.2s;
Â  Â  Â  Â  }

Â  Â  Â  Â  #cmd-frame button:hover:not(:disabled) {
Â  Â  Â  Â  Â  Â  background-color: #5d6168;
Â  Â  Â  Â  }

Â  Â  Â  Â  #cmd-frame button:disabled {
Â  Â  Â  Â  Â  Â  background-color: #2e2e38;
Â  Â  Â  Â  Â  Â  color: #888888;
Â  Â  Â  Â  Â  Â  cursor: default;
Â  Â  Â  Â  }

Â  Â  Â  Â  #ultimate-button {
Â  Â  Â  Â  Â  Â  padding: 10px;
Â  Â  Â  Â  Â  Â  margin-top: auto;
Â  Â  Â  Â  Â  Â  background-color: var(--accent-red);
Â  Â  Â  Â  Â  Â  color: white;
Â  Â  Â  Â  Â  Â  border: none;
Â  Â  Â  Â  Â  Â  border-radius: 4px;
Â  Â  Â  Â  Â  Â  cursor: pointer;
Â  Â  Â  Â  Â  Â  font-size: calc(var(--title-font-size) - 2px);
Â  Â  Â  Â  Â  Â  font-weight: bold;
Â  Â  Â  Â  Â  Â  transition: background-color 0.2s;
Â  Â  Â  Â  }

Â  Â  Â  Â  #ultimate-button:hover:not(:disabled) {
Â  Â  Â  Â  Â  Â  background-color: #c73737;
Â  Â  Â  Â  }

Â  Â  Â  Â  #ultimate-button:disabled {
Â  Â  Â  Â  Â  Â  background-color: #555555;
Â  Â  Â  Â  Â  Â  cursor: default;
Â  Â  Â  Â  }

Â  Â  Â  Â  /* --- Responsive Design (Mobile) --- */
Â  Â  Â  Â  @media (max-width: 800px) {
Â  Â  Â  Â  Â  Â  :root {
Â  Â  Â  Â  Â  Â  Â  Â  --base-piece-font-size: 40px;
Â  Â  Â  Â  Â  Â  Â  Â  --base-dot-font-size: 28px;
Â  Â  Â  Â  Â  Â  Â  Â  --base-panel-font-size: 9px;
Â  Â  Â  Â  Â  Â  Â  Â  --base-title-font-size: 14px;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  #game-container {
Â  Â  Â  Â  Â  Â  Â  Â  flex-direction: column;
Â  Â  Â  Â  Â  Â  Â  Â  padding: 5px;
Â  Â  Â  Â  Â  Â  Â  Â  height: auto;
Â  Â  Â  Â  Â  Â  Â  Â  min-height: 100vh;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  #game-ui {
Â  Â  Â  Â  Â  Â  Â  Â  flex-direction: column;
Â  Â  Â  Â  Â  Â  Â  Â  padding: 5px;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  #panel-frame {
Â  Â  Â  Â  Â  Â  Â  Â  width: 100%;
Â  Â  Â  Â  Â  Â  Â  Â  margin: 5px 0;
Â  Â  Â  Â  Â  Â  Â  Â  padding: 10px;
Â  Â  Â  Â  Â  Â  Â  Â  order: -1; /* Panel on top */
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  #board-ui-frame {
Â  Â  Â  Â  Â  Â  Â  Â  width: 100%;
Â  Â  Â  Â  Â  Â  Â  Â  margin: 5px 0;
Â  Â  Â  Â  Â  Â  Â  Â  max-width: 100%;
Â  Â  Â  Â  Â  Â  Â  Â  max-height: 80vh;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  /* Override grid template on mobile for board container to be fully responsive within the limited space */
Â  Â  Â  Â  Â  Â  #board-container {
Â  Â  Â  Â  Â  Â  Â  Â  grid-template-columns: auto 1fr;
Â  Â  Â  Â  Â  Â  Â  Â  grid-template-rows: repeat(8, 1fr) auto;
Â  Â  Â  Â  Â  Â  Â  Â  width: 100%;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  #board-frame {
Â  Â  Â  Â  Â  Â  Â  Â  grid-column: 2 / 3;
Â  Â  Â  Â  Â  Â  Â  Â  grid-row: 1 / 9;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  #rank-labels-container {
Â  Â  Â  Â  Â  Â  Â  Â  grid-column: 1 / 2;
Â  Â  Â  Â  Â  Â  Â  Â  grid-row: 1 / 9;
Â  Â  Â  Â  Â  Â  Â  Â  font-size: 14px;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  #file-labels-container {
Â  Â  Â  Â  Â  Â  Â  Â  grid-column: 2 / 3;
Â  Â  Â  Â  Â  Â  Â  Â  grid-row: 9 / 10;
Â  Â  Â  Â  Â  Â  Â  Â  font-size: 14px;
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  </style>
</head>
<body>

Â  Â  <div id="game-container">
Â  Â  Â  Â  <div id="main-menu" class="menu-screen">
Â  Â  Â  Â  Â  Â  <h1>ULTIMATE CHESS</h1>
Â  Â  Â  Â  Â  Â  <button id="start-local-btn" onclick="startLocalGame()">2 PLAYER (LOCAL)</button>

Â  Â  Â  Â  Â  Â  <div class="bot-settings">
Â  Â  Â  Â  Â  Â  Â  Â  <h2>Play with Bot (ELOfied)</h2>
Â  Â  Â  Â  Â  Â  Â  Â  <div id="elo-control">
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <label id="elo-label">ELO: 1500</label>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <input type="range" id="elo-slider" min="1" max="3000" value="1500" oninput="updateEloLabel(this.value)">
Â  Â  Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  Â  Â  Â  Â  <button id="start-bot-btn" onclick="startBotGame()">START BOT GAME</button>
Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  <div class="coming-soon">
Â  Â  Â  Â  Â  Â  Â  Â  <button id="start-online-btn" onclick="showOnlineLobby()">PLAY WITH FRIEND (ONLINE)</button>
Â  Â  Â  Â  Â  Â  Â  Â  <span class="soon-tag">[NETWORKING REQUIRED]</span>
Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  </div>

Â  Â  Â  Â  <div id="online-lobby" class="menu-screen hidden">
Â  Â  Â  Â  Â  Â  <h2>ONLINE LOBBY: Find a Challenger</h2>
Â  Â  Â  Â  Â  Â  <div id="player-list">
Â  Â  Â  Â  Â  Â  Â  Â  <div id="dynamic-player-list">
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  <p id="lobby-status-message" style="color: var(--light-square); margin-top: 20px; min-height: 50px;">
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Searching for opponents online...
Â  Â  Â  Â  Â  Â  Â  Â  </p>
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  <button onclick="app.show_main_menu()" style="background-color: var(--accent-red); padding: 10px 20px; font-size: 16px; width: 100%; max-width: 400px;">Back to Main Menu</button>
Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  </div>
Â  Â  Â  Â Â 
Â  Â  Â  Â  <div id="game-ui" class="hidden">
Â  Â  Â  Â  Â  Â  <div id="board-ui-frame">
Â  Â  Â  Â  Â  Â  Â  Â  <div id="board-container">
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <div id="rank-labels-container"></div>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <div id="board-frame">
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <div id="file-labels-container"></div>
Â  Â  Â  Â  Â  Â  Â  Â  </div>

Â  Â  Â  Â  Â  Â  Â  Â  <div id="game-overlay" class="hidden">
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <div id="overlay-message"></div>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <div id="overlay-click-prompt">(Click to return to Menu)</div>
Â  Â  Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  <div id="panel-frame">
Â  Â  Â  Â  Â  Â  Â  Â  <h2>ULTIMATE CHESS</h2>
Â  Â  Â  Â  Â  Â  Â  Â  <div id="status-label"></div>
Â  Â  Â  Â  Â  Â  Â  Â  <div id="r-uses-label"></div>
Â  Â  Â  Â  Â  Â  Â  Â  <div id="message-label"></div>

Â  Â  Â  Â  Â  Â  Â  Â  <div id="ability-info-frame">
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <div class="ultimate-separator">--- ULTIMATE POWER ---</div>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <div id="ability-title"></div>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <div id="ability-desc"></div>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <div id="ability-prompt"></div>
Â  Â  Â  Â  Â  Â  Â  Â  </div>

Â  Â  Â  Â  Â  Â  Â  Â  <div id="cmd-frame">
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <button id="hack-btn" disabled onclick="app._initiate_hack()">/HACK (Friendly Fire)</button>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <button id="phase-btn" disabled onclick="app._initiate_phase()">/PHASE (Teleport Rook)</button>
Â  Â  Â  Â  Â  Â  Â  Â  </div>

Â  Â  Â  Â  Â  Â  Â  Â  <button id="ultimate-button" onclick="app.activate_ultimate_gui()">ACTIVATE ULTIMATE</button>
Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  </div>
Â  Â  </div>

Â  Â  <script>
Â  Â  Â  Â  // --- Global Constants (Game Engine Data) ---
Â  Â  Â  Â  const UNICODE_PIECES = {
Â  Â  Â  Â  Â  Â  'WK': 'â™”', 'WQ': 'â™•', 'WR': 'â™–', 'WB': 'â™—', 'WN': 'â™˜', 'WP': 'â™™',
Â  Â  Â  Â  Â  Â  'BK': 'â™š', 'BQ': 'â™›', 'BR': 'â™œ', 'BB': 'â™', 'BN': 'â™ž', 'BP': 'â™Ÿ',
Â  Â  Â  Â  Â  Â  'BL': 'ðŸš§', // Blockade/Traffic Jam symbol
Â  Â  Â  Â  Â  Â  'FR': 'â„ï¸', // Frozen Symbol
Â  Â  Â  Â  Â  Â  'RM': 'ðŸ¤–', // Roomba Symbol
Â  Â  Â  Â  Â  Â  // Archbishop (A): Fused Knight + Bishop symbol.
Â  Â  Â  Â  Â  Â  'WA': 'â™˜â™—', 'BA': 'â™žâ™'
Â  Â  Â  Â  };

Â  Â  Â  Â  // Mapping of file (column) letters to indices
Â  Â  Â  Â  const FILE_MAP = {
Â  Â  Â  Â  Â  Â  'a': 0, 'b': 1, 'c': 2, 'd': 3, 'e': 4, 'f': 5, 'g': 6, 'h': 7
Â  Â  Â  Â  };
Â  Â  Â  Â  const RANK_MAP = {
Â  Â  Â  Â  Â  Â  '1': 0, '2': 1, '3': 2, '4': 3, '5': 4, '6': 5, '7': 6, '8': 7
Â  Â  Â  Â  }; // Ranks 1-8 map to indices 0-7

Â  Â  Â  Â  // Standard Piece Values for AI evaluation
Â  Â  Â  Â  const PIECE_VALUES = {
Â  Â  Â  Â  Â  Â  'P': 100,
Â  Â  Â  Â  Â  Â  'N': 300,
Â  Â  Â  Â  Â  Â  'B': 300,
Â  Â  Â  Â  Â  Â  'R': 500,
Â  Â  Â  Â  Â  Â  'Q': 900,
Â  Â  Â  Â  Â  Â  'K': 10000,
Â  Â  Â  Â  Â  Â  'A': 650,
Â  Â  Â  Â  Â  Â  'RM': 1000
Â  Â  Â  Â  };


Â  Â  Â  Â  // --- Custom Powers (Updated with new Rook Ultimate) ---
Â  Â  Â  Â  const ULTIMATE_POWERS = {
Â  Â  Â  Â  Â  Â  'GENERAL': {
Â  Â  Â  Â  Â  Â  Â  Â  'name': "Temporal Blockade",
Â  Â  Â  Â  Â  Â  Â  Â  'mode': 'BLOCKADE',
Â  Â  Â  Â  Â  Â  Â  Â  'desc': "Places an indestructible blockade (ðŸš§). Each side can have up to TWO blockades active at once.",
Â  Â  Â  Â  Â  Â  Â  Â  'prompt': "Select an empty square for the blockade."
Â  Â  Â  Â  Â  Â  },
Â  Â  Â  Â  Â  Â  'N': {
Â  Â  Â  Â  Â  Â  Â  Â  'name': "Archbishop's Fusion",
Â  Â  Â  Â  Â  Â  Â  Â  'mode': 'KNIGHT_FUSION',
Â  Â  Â  Â  Â  Â  Â  Â  'desc': "Fuses a friendly Knight and Bishop that are on adjacent or two-square diagonal squares (e.g., a1/b2, a1/c2) into a powerful **Archbishop (A)**. The Archbishop moves as a Knight OR a Bishop.",
Â  Â  Â  Â  Â  Â  Â  Â  'prompt': "Select the friendly Bishop to fuse with."
Â  Â  Â  Â  Â  Â  },
Â  Â  Â  Â  Â  Â  'B': {
Â  Â  Â  Â  Â  Â  Â  Â  'name': "Cat's Cradle Catastrophe",
Â  Â  Â  Â  Â  Â  Â  Â  'mode': 'BISHOP_FREEZE',
Â  Â  Â  Â  Â  Â  Â  Â  'desc': "Bishop releases a Web of Distraction along its attack diagonal. All pieces on that diagonal are **frozen** for the opponent's next turn. Requires Bishop to be attacked.",
Â  Â  Â  Â  Â  Â  Â  Â  'prompt': "Select the target Bishop for the Cat's Cradle attack (if it is attacked)."
Â  Â  Â  Â  Â  Â  },
Â  Â  Â  Â  Â  Â  'R': { // NEW COMMAND-LINE ULTIMATE
Â  Â  Â  Â  Â  Â  Â  Â  'name': "Hax.exe Command Shell",
Â  Â  Â  Â  Â  Â  Â  Â  'mode': 'R_COMMAND_SELECT', // Initial mode for button selection
Â  Â  Â  Â  Â  Â  Â  Â  'desc': "Opens the Hax.exe command shell. Allows one of two commands: /hack or /phase. Usable twice per team.",
Â  Â  Â  Â  Â  Â  Â  Â  'prompt': "Select /HACK (Friendly Fire) or /PHASE (Teleport) below."
Â  Â  Â  Â  Â  Â  },
Â  Â  Â  Â  Â  Â  'K': { // KING ULTIMATE
Â  Â  Â  Â  Â  Â  Â  Â  'name': "Domain Expansion: Murasaki",
Â  Â  Â  Â  Â  Â  Â  Â  'mode': 'MURASAKI',
Â  Â  Â  Â  Â  Â  Â  Â  'desc': "Activates on a **self-sacrifice**: King captures a friendly Pawn. The resulting 'Murasaki' beam instantly removes a **random** enemy piece (not the King).",
Â  Â  Â  Â  Â  Â  Â  Â  'prompt': "Select a friendly Pawn for the King to capture to initiate Murasaki."
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  };

Â  Â  Â  Â  // --- 1. GAME LOGIC (UltimateChessGame Class) ---

Â  Â  Â  Â  class UltimateChessGame {
Â  Â  Â  Â  Â  Â  constructor() {
Â  Â  Â  Â  Â  Â  Â  Â  this.board = this._initialize_board();
Â  Â  Â  Â  Â  Â  Â  Â  this.current_turn = 'W';

Â  Â  Â  Â  Â  Â  Â  Â  this.active_blockades = {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  'W': [],
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  'B': []
Â  Â  Â  Â  Â  Â  Â  Â  };
Â  Â  Â  Â  Â  Â  Â  Â  this.message = "Game started! White moves first. ULTIMATE is available per piece.";
Â  Â  Â  Â  Â  Â  Â  Â  this.is_check = false;
Â  Â  Â  Â  Â  Â  Â  Â  this.is_power_mode = null;
Â  Â  Â  Â  Â  Â  Â  Â  this.selected_square_coords = null;
Â  Â  Â  Â  Â  Â  Â  Â  this.current_ultimate_power_info = ULTIMATE_POWERS['GENERAL'];

Â  Â  Â  Â  Â  Â  Â  Â  // --- Standard Chess State ---
Â  Â  Â  Â  Â  Â  Â  Â  this.en_passant_target = null;
Â  Â  Â  Â  Â  Â  Â  Â  this.game_over = null;

Â  Â  Â  Â  Â  Â  Â  Â  // --- ABILITY STATE (NEW/MODIFIED) ---
Â  Â  Â  Â  Â  Â  Â  Â  this.frozen_pieces = {}; // Stores {f, r} : turns_remaining
Â  Â  Â  Â  Â  Â  Â  Â  this.roomba_pos = null; // {f, r}
Â  Â  Â  Â  Â  Â  Â  Â  this.roomba_target = null; // {f, r} of King target
Â  Â  Â  Â  Â  Â  Â  Â  this.roomba_moves_remaining = 0;

Â  Â  Â  Â  Â  Â  Â  Â  // New Rook Ultimate Tracking
Â  Â  Â  Â  Â  Â  Â  Â  this.r_power_uses = {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  'W': 2,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  'B': 2
Â  Â  Â  Â  Â  Â  Â  Â  };
Â  Â  Â  Â  Â  Â  Â  Â  this.hacked_piece = null; // Stores {f, r} of the hacked piece
Â  Â  Â  Â  Â  Â  Â  Â  this.phase_move_pending = false;

Â  Â  Â  Â  Â  Â  Â  Â  // Store for AI: List of move dicts: {f1:..., r1:..., f2:..., r2:..., value:...}
Â  Â  Â  Â  Â  Â  Â  Â  this.available_ai_moves = [];
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  _initialize_board() {
Â  Â  Â  Â  Â  Â  Â  Â  /** Sets up the initial chess board. */
Â  Â  Â  Â  Â  Â  Â  Â  let board = Array(8).fill(null).map(() => Array(8).fill(null));

Â  Â  Â  Â  Â  Â  Â  Â  for (let f = 0; f < 8; f++) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  board[f][1] = {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  'type': 'P',
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  'color': 'W',
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  'moved': false
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  };
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  board[f][6] = {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  'type': 'P',
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  'color': 'B',
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  'moved': false
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  };
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  const back_rank = ['R', 'N', 'B', 'Q', 'K', 'B', 'N', 'R'];
Â  Â  Â  Â  Â  Â  Â  Â  for (let f = 0; f < 8; f++) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const piece_type = back_rank[f];
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  board[f][0] = {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  'type': piece_type,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  'color': 'W',
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  'moved': false
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  };
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  board[f][7] = {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  'type': piece_type,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  'color': 'B',
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  'moved': false
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  };
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  return board;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  // --- Utility Methods ---

Â  Â  Â  Â  Â  Â  _coords_to_indices(coord) {
Â  Â  Â  Â  Â  Â  Â  Â  if (coord.length !== 2 || !(coord[0] in FILE_MAP) || !(coord[1] in RANK_MAP)) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  throw new Error(`Invalid coordinate: ${coord}`);
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  const f = FILE_MAP[coord[0]];
Â  Â  Â  Â  Â  Â  Â  Â  const r = RANK_MAP[coord[1]];
Â  Â  Â  Â  Â  Â  Â  Â  return {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  f,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  r
Â  Â  Â  Â  Â  Â  Â  Â  };
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  _indices_to_coords(f, r) {
Â  Â  Â  Â  Â  Â  Â  Â  const file_char = String.fromCharCode('a'.charCodeAt(0) + f);
Â  Â  Â  Â  Â  Â  Â  Â  const rank_char = String(r + 1);
Â  Â  Â  Â  Â  Â  Â  Â  return file_char + rank_char;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  _get_piece_power(piece_type) {
Â  Â  Â  Â  Â  Â  Â  Â  return ULTIMATE_POWERS[piece_type] || ULTIMATE_POWERS['GENERAL'];
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  _is_square_blocked(f, r) {
Â  Â  Â  Â  Â  Â  Â  Â  for (const color of Object.keys(this.active_blockades)) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (this.active_blockades[color].some(b => b.f === f && b.r === r)) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return true;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  return false;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  _is_square_frozen(f, r) {
Â  Â  Â  Â  Â  Â  Â  Â  /** Checks if a square is occupied by a frozen piece. */
Â  Â  Â  Â  Â  Â  Â  Â  const key = `${f},${r}`;
Â  Â  Â  Â  Â  Â  Â  Â  return this.frozen_pieces.hasOwnProperty(key) && this.frozen_pieces[key] > 0;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  _get_king_pos(color) {
Â  Â  Â  Â  Â  Â  Â  Â  for (let f = 0; f < 8; f++) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  for (let r = 0; r < 8; r++) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const piece = this.board[f][r];
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (piece && piece.color === color && piece.type === 'K') {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  f,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  r
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  };
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  return null;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  _is_king_in_check(color) {
Â  Â  Â  Â  Â  Â  Â  Â  const king_pos = this._get_king_pos(color);
Â  Â  Â  Â  Â  Â  Â  Â  if (!king_pos) return false;

Â  Â  Â  Â  Â  Â  Â  Â  const opponent_color = color === 'W' ? 'B' : 'W';
Â  Â  Â  Â  Â  Â  Â  Â  return this._is_square_attacked(king_pos.f, king_pos.r, opponent_color);
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  has_legal_moves(color) {
Â  Â  Â  Â  Â  Â  Â  Â  /** Checks if the player has any legal moves available. */
Â  Â  Â  Â  Â  Â  Â  Â  return this.get_all_legal_moves_for_color(color).length > 0;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  // --- AI Specific Functions (Simplified Minimax) ---

Â  Â  Â  Â  Â  Â  get_all_legal_moves_for_color(color) {
Â  Â  Â  Â  Â  Â  Â  Â  /** Generates all legal moves for a given color, including full move data. */
Â  Â  Â  Â  Â  Â  Â  Â  const all_moves = [];
Â  Â  Â  Â  Â  Â  Â  Â  const original_turn = this.current_turn;
Â  Â  Â  Â  Â  Â  Â  Â  this.current_turn = color; // Temporarily set turn for validation

Â  Â  Â  Â  Â  Â  Â  Â  for (let f1 = 0; f1 < 8; f1++) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  for (let r1 = 0; r1 < 8; r1++) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const piece = this.board[f1][r1];
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (piece && piece.color === color) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const targets = this.get_legal_moves(f1, r1);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  for (const target of targets) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const f2 = target.f;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const r2 = target.r;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const move = {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  'f1': f1,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  'r1': r1,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  'f2': f2,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  'r2': r2,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  'piece': piece.type,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  'is_capture': target.is_capture
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  };

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Use the simplified _validate_move (which checks for check safety)
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (this._validate_move(f1, r1, f2, r2)) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  move['value'] = this._evaluate_move(f1, r1, f2, r2, piece);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  all_moves.push(move);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  this.current_turn = original_turn; // Restore turn
Â  Â  Â  Â  Â  Â  Â  Â  return all_moves;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  _evaluate_move(f1, r1, f2, r2, moving_piece) {
Â  Â  Â  Â  Â  Â  Â  Â  /** Estimates the value of a move for the current turn (higher is better). */
Â  Â  Â  Â  Â  Â  Â  Â  let value = 0;
Â  Â  Â  Â  Â  Â  Â  Â  const opponent_color = moving_piece.color === 'W' ? 'B' : 'W';

Â  Â  Â  Â  Â  Â  Â  Â  // 1. Capture Bonus
Â  Â  Â  Â  Â  Â  Â  Â  const target = this.board[f2][r2];
Â  Â  Â  Â  Â  Â  Â  Â  const is_roomba_capture = this.roomba_pos && this.roomba_pos.f === f2 && this.roomba_pos.r === r2;

Â  Â  Â  Â  Â  Â  Â  Â  if (target && target.color !== moving_piece.color) { // Check for actual enemy capture
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const target_value = PIECE_VALUES[target.type] || 0;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  value += target_value;
Â  Â  Â  Â  Â  Â  Â  Â  } else if (is_roomba_capture) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  value += PIECE_VALUES['RM'];
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  // 2. Check/Checkmate Bonus (Simplified)
Â  Â  Â  Â  Â  Â  Â  Â  const original_target = this.board[f2][r2];
Â  Â  Â  Â  Â  Â  Â  Â  const original_piece = this.board[f1][r1];

Â  Â  Â  Â  Â  Â  Â  Â  // Simulate move
Â  Â  Â  Â  Â  Â  Â  Â  this.board[f2][r2] = moving_piece;
Â  Â  Â  Â  Â  Â  Â  Â  this.board[f1][r1] = null;

Â  Â  Â  Â  Â  Â  Â  Â  if (this._is_king_in_check(opponent_color)) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  value += 500; // Simple check bonus
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  // Revert move
Â  Â  Â  Â  Â  Â  Â  Â  this.board[f1][r1] = original_piece;
Â  Â  Â  Â  Â  Â  Â  Â  this.board[f2][r2] = original_target;

Â  Â  Â  Â  Â  Â  Â  Â  // 3. Random element (To prevent perfect repetition, especially for low ELO)
Â  Â  Â  Â  Â  Â  Â  Â  value += Math.random() * 5;

Â  Â  Â  Â  Â  Â  Â  Â  return value;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  get_bot_move(elo) {
Â  Â  Â  Â  Â  Â  Â  Â  /** Chooses a move based on the simulated ELO. */

Â  Â  Â  Â  Â  Â  Â  Â  this.available_ai_moves = this.get_all_legal_moves_for_color(this.current_turn);

Â  Â  Â  Â  Â  Â  Â  Â  if (!this.available_ai_moves.length) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return null;
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  this.available_ai_moves.sort((a, b) => b.value - a.value);

Â  Â  Â  Â  Â  Â  Â  Â  const best_move = this.available_ai_moves[0];

Â  Â  Â  Â  Â  Â  Â  Â  // Simple ELO based selection logic
Â  Â  Â  Â  Â  Â  Â  Â  if (elo <= 1000) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Low ELO: mostly random, sometimes best
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (Math.random() < (elo / 2000)) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return best_move;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return this.available_ai_moves[Math.floor(Math.random() * this.available_ai_moves.length)];
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  } else if (1000 < elo && elo <= 2000) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Medium ELO: picks from top 5 moves, favors best
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const top_moves = this.available_ai_moves.slice(0, Math.max(1, Math.min(5, this.available_ai_moves.length)));

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const confidence_factor = (elo - 1000) / 1000;

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (Math.random() < (0.5 + confidence_factor * 0.5)) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return best_move;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return top_moves[Math.floor(Math.random() * top_moves.length)];
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // High ELO: almost always best move
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (Math.random() < 0.95) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return best_move;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return this.available_ai_moves[Math.floor(Math.random() * this.available_ai_moves.length)];
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  // --- Power Activation Logic ---

Â  Â  Â  Â  Â  Â  activate_ultimate(f, r) {
Â  Â  Â  Â  Â  Â  Â  Â  /** Starts the power sequence for the selected piece. */
Â  Â  Â  Â  Â  Â  Â  Â  const piece = this.board[f][r];
Â  Â  Â  Â  Â  Â  Â  Â  if (!piece || piece.color !== this.current_turn) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.message = "Cannot activate ultimate: no friendly piece selected.";
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return false;
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  const power_info = this._get_piece_power(piece.type);
Â  Â  Â  Â  Â  Â  Â  Â  this.current_ultimate_power_info = power_info;
Â  Â  Â  Â  Â  Â  Â  Â  this.selected_square_coords = {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  f,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  r
Â  Â  Â  Â  Â  Â  Â  Â  };
Â  Â  Â  Â  Â  Â  Â  Â  this.is_power_mode = power_info.mode;

Â  Â  Â  Â  Â  Â  Â  Â  if (this.is_power_mode === 'BLOCKADE') {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Temporal Blockade: Immediate activation, requires square click
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (this.active_blockades[this.current_turn].length >= 2) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.message = "You already have the maximum number of blockades (2) active.";
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.is_power_mode = null;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return false;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.message = `Temporal Blockade ready. ${power_info.prompt}`;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return true;

Â  Â  Â  Â  Â  Â  Â  Â  } else if (this.is_power_mode === 'BISHOP_FREEZE') {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Cat's Cradle Catastrophe: Only if Bishop is currently attacked
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const opponent_color = this.current_turn === 'W' ? 'B' : 'W';
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (!this._is_square_attacked(f, r, opponent_color, true)) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.message = "Bishop must be attacked to use Cat's Cradle Catastrophe!";
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.is_power_mode = null;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return false;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.message = "Bishop activated Cat's Cradle! Select the diagonal target square to freeze along that line.";
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return true;

Â  Â  Â  Â  Â  Â  Â  Â  } else if (this.is_power_mode === 'R_COMMAND_SELECT') {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (this.r_power_uses[this.current_turn] <= 0) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.message = "Rook ultimate uses exhausted for this team.";
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.is_power_mode = null;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return false;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Go straight to selection mode (GUI will show buttons)
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.message = `${power_info.name} opened. Choose a command.`;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return true;

Â  Â  Â  Â  Â  Â  Â  Â  } else if (['KNIGHT_FUSION', 'ROOK_ROOMBA', 'MURASAKI'].includes(this.is_power_mode)) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // These powers require a subsequent move or selection
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.message = `${power_info.name} ready. ${power_info.prompt}`;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return true;
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  this.is_power_mode = null;
Â  Â  Â  Â  Â  Â  Â  Â  this.message = "Ultimate activated, but no special mode detected. Select action.";
Â  Â  Â  Â  Â  Â  Â  Â  return true;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  place_blockade(coord) {
Â  Â  Â  Â  Â  Â  Â  Â  /** Places a blockade at the given algebraic coordinate. */
Â  Â  Â  Â  Â  Â  Â  Â  try {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  f,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  r
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } = this._coords_to_indices(coord);

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (this.board[f][r] !== null || this._is_square_blocked(f, r)) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.message = "Blockade square must be empty and not already blocked.";
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.is_power_mode = null;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return false;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (this.active_blockades[this.current_turn].length >= 2) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.message = "Maximum blockades (2) already reached for this side.";
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.is_power_mode = null;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return false;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.active_blockades[this.current_turn].push({
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  f,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  r
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.message = `Temporal Blockade successfully placed at ${coord}.`;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this._next_turn();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return true;
Â  Â  Â  Â  Â  Â  Â  Â  } catch (e) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.message = "Invalid coordinate for blockade.";
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.is_power_mode = null;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return false;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  perform_fusion(bf, br) {
Â  Â  Â  Â  Â  Â  Â  Â  /** Fuses a selected Knight and the target Bishop into an Archbishop. */
Â  Â  Â  Â  Â  Â  Â  Â  const {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  f: nf,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  r: nr
Â  Â  Â  Â  Â  Â  Â  Â  } = this.selected_square_coords;

Â  Â  Â  Â  Â  Â  Â  Â  const knight = this.board[nf][nr];
Â  Â  Â  Â  Â  Â  Â  Â  const bishop = this.board[bf][br];

Â  Â  Â  Â  Â  Â  Â  Â  if (!(knight && bishop && knight.type === 'N' && bishop.type === 'B' && knight.color === bishop.color)) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.message = "Fusion failed: Required pieces (Friendly Knight and Bishop) not found.";
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.is_power_mode = null;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return false;
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  // Replace Knight with Archbishop
Â  Â  Â  Â  Â  Â  Â  Â  this.board[nf][nr] = {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  'type': 'A',
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  'color': knight.color,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  'moved': true
Â  Â  Â  Â  Â  Â  Â  Â  };

Â  Â  Â  Â  Â  Â  Â  Â  // Remove Bishop
Â  Â  Â  Â  Â  Â  Â  Â  this.board[bf][br] = null;

Â  Â  Â  Â  Â  Â  Â  Â  this.message = `Archbishop formed at ${this._indices_to_coords(nf, nr)}! Bishop sacrificed.`;
Â  Â  Â  Â  Â  Â  Â  Â  this.is_power_mode = null;
Â  Â  Â  Â  Â  Â  Â  Â  this._next_turn();
Â  Â  Â  Â  Â  Â  Â  Â  return true;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  _activate_b_ultimate(f1, r1, f2, r2) {
Â  Â  Â  Â  Â  Â  Â  Â  /** Activates Bishop Freeze (Cat's Cradle) on the diagonal attack line (f1,r1) -> (f2,r2). */
Â  Â  Â  Â  Â  Â  Â  Â  const piece = this.board[f1][r1];

Â  Â  Â  Â  Â  Â  Â  Â  if (Math.abs(f1 - f2) !== Math.abs(r1 - r2)) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.message = "Bishop must move diagonally to activate Cat's Cradle.";
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.is_power_mode = null;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return false;
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  // 1. Freeze pieces on the line (excluding the bishop itself and the king)
Â  Â  Â  Â  Â  Â  Â  Â  const df = f2 > f1 ? 1 : -1;
Â  Â  Â  Â  Â  Â  Â  Â  const dr = r2 > r1 ? 1 : -1;

Â  Â  Â  Â  Â  Â  Â  Â  let f = f1;
Â  Â  Â  Â  Â  Â  Â  Â  let r = r1;
Â  Â  Â  Â  Â  Â  Â  Â  let frozen_count = 0;

Â  Â  Â  Â  Â  Â  Â  Â  while (f !== f2 || r !== r2) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  f += df;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  r += dr;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (f < 0 || f > 7 || r < 0 || r > 7) break; // Should not happen if move is valid

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const target = this.board[f][r];
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (target && target.type !== 'K') {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.frozen_pieces[`${f},${r}`] = 2; // Freeze for the opponent's next turn (2 half-turns)
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  frozen_count++;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  // 2. Perform the Bishop move (and capture if applicable)
Â  Â  Â  Â  Â  Â  Â  Â  const target_piece = this.board[f2][r2];
Â  Â  Â  Â  Â  Â  Â  Â  this.board[f2][r2] = piece;
Â  Â  Â  Â  Â  Â  Â  Â  this.board[f1][r1] = null;
Â  Â  Â  Â  Â  Â  Â  Â  piece.moved = true;

Â  Â  Â  Â  Â  Â  Â  Â  const capture_msg = target_piece ? ` (Captured ${target_piece.color}${target_piece.type})` : "";
Â  Â  Â  Â  Â  Â  Â  Â  this.message = `Bishop activated Cat's Cradle. ${frozen_count} piece(s) frozen for 1 turn! Bishop moved to ${this._indices_to_coords(f2, r2)}.` + capture_msg;

Â  Â  Â  Â  Â  Â  Â  Â  this.is_power_mode = null;
Â  Â  Â  Â  Â  Â  Â  Â  this._next_turn();
Â  Â  Â  Â  Â  Â  Â  Â  return true;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  _execute_k_ultimate_logic() {
Â  Â  Â  Â  Â  Â  Â  Â  /** Executes the Murasaki logic (removes random enemy piece) and switches turn. */

Â  Â  Â  Â  Â  Â  Â  Â  const opponent_color = this.current_turn === 'W' ? 'B' : 'W';
Â  Â  Â  Â  Â  Â  Â  Â  const enemy_pieces = [];

Â  Â  Â  Â  Â  Â  Â  Â  // 1. Find all eligible enemy pieces (everything but the King)
Â  Â  Â  Â  Â  Â  Â  Â  for (let f = 0; f < 8; f++) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  for (let r = 0; r < 8; r++) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const piece = this.board[f][r];
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (piece && piece.color === opponent_color && piece.type !== 'K') {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  enemy_pieces.push({
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  f,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  r,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  piece
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  if (!enemy_pieces.length) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // No eligible target found
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.message += " (No eligible target for Murasaki, power dissipated harmlessly.)";
Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // 2. Select a random enemy piece to capture and remove it
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  f: target_f,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  r: target_r,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  piece: target_piece
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } = enemy_pieces[Math.floor(Math.random() * enemy_pieces.length)];
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.board[target_f][target_r] = null;

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // 3. Update the message
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const target_coord = this._indices_to_coords(target_f, target_r);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.message += ` **Murasaki** beam hits ${target_piece.color}${target_piece.type} at ${target_coord}! Piece vaporized.`;
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  this.is_power_mode = null;
Â  Â  Â  Â  Â  Â  Â  Â  this._next_turn();
Â  Â  Â  Â  Â  Â  Â  Â  return true;
Â  Â  Â  Â  Â  Â  }


Â  Â  Â  Â  Â  Â  _move_roomba() {
Â  Â  Â  Â  Â  Â  Â  Â  /** Moves the Roomba one square closer to the enemy King. */
Â  Â  Â  Â  Â  Â  Â  Â  if (!this.roomba_pos || this.roomba_moves_remaining <= 0) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  const k_pos = this.roomba_target;
Â  Â  Â  Â  Â  Â  Â  Â  if (!k_pos) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.roomba_pos = null;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.roomba_moves_remaining = 0;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  const {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  f: kf,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  r: kr
Â  Â  Â  Â  Â  Â  Â  Â  } = k_pos;
Â  Â  Â  Â  Â  Â  Â  Â  const {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  f: rf,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  r: rr
Â  Â  Â  Â  Â  Â  Â  Â  } = this.roomba_pos;

Â  Â  Â  Â  Â  Â  Â  Â  let df = 0;
Â  Â  Â  Â  Â  Â  Â  Â  if (kf > rf) df = 1;
Â  Â  Â  Â  Â  Â  Â  Â  else if (kf < rf) df = -1;

Â  Â  Â  Â  Â  Â  Â  Â  let dr = 0;
Â  Â  Â  Â  Â  Â  Â  Â  if (kr > rr) dr = 1;
Â  Â  Â  Â  Â  Â  Â  Â  else if (kr < rr) dr = -1;

Â  Â  Â  Â  Â  Â  Â  Â  const new_rf = rf + df;
Â  Â  Â  Â  Â  Â  Â  Â  const new_rr = rr + dr;

Â  Â  Â  Â  Â  Â  Â  Â  // Check bounds
Â  Â  Â  Â  Â  Â  Â  Â  if (!(new_rf >= 0 && new_rf <= 7 && new_rr >= 0 && new_rr <= 7)) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.roomba_pos = null;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.roomba_moves_remaining = 0;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.message += " (Roomba drove off the board and self-destructed.)";
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  Â  Â  Â  Â  }


Â  Â  Â  Â  Â  Â  Â  Â  // If Roomba reaches King or is blocked/captured
Â  Â  Â  Â  Â  Â  Â  Â  if (new_rf === kf && new_rr === kr) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.roomba_pos = null;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.roomba_moves_remaining = 0;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.board[kf][kr] = null; // King captured
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.game_over = 'CHECKMATE';
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.message = "Roomba captured the King! Checkmate!";

Â  Â  Â  Â  Â  Â  Â  Â  } else if (this.board[new_rf][new_rr] !== null || this._is_square_blocked(new_rf, new_rr)) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Roomba hits a piece or blockade (it stops and destroys itself)
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const target_piece = this.board[new_rf][new_rr];
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const target_coord = this._indices_to_coords(new_rf, new_rr);

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (target_piece) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.board[new_rf][new_rr] = null; // Capture/destroy piece
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.message = `Roomba collided with ${target_piece.color}${target_piece.type} at ${target_coord} and self-destructed.`;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else if (this._is_square_blocked(new_rf, new_rr)) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Remove blockade
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.active_blockades['W'] = this.active_blockades['W'].filter(b => !(b.f === new_rf && b.r === new_rr));
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.active_blockades['B'] = this.active_blockades['B'].filter(b => !(b.f === new_rf && b.r === new_rr));
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.message = `Roomba destroyed blockade at ${target_coord} and self-destructed.`;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.roomba_pos = null;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.roomba_moves_remaining = 0;

Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.roomba_pos = {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  f: new_rf,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  r: new_rr
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  };
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.roomba_moves_remaining -= 1;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.message += ` (Roomba moved to ${this._indices_to_coords(new_rf, new_rr)}. Moves left: ${this.roomba_moves_remaining})`;

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (this.roomba_moves_remaining === 0) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.roomba_pos = null;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.message += " (Roomba fuel exhausted and removed.)";
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  _activate_r_ultimate(f1, r1, f2, r2) {
Â  Â  Â  Â  Â  Â  Â  Â  /** Launches the Roomba and moves the Rook. */
Â  Â  Â  Â  Â  Â  Â  Â  const piece = this.board[f1][r1];

Â  Â  Â  Â  Â  Â  Â  Â  if (Math.abs(f2 - f1) > 1 || Math.abs(r2 - r1) > 1 || (f1 === f2 && r1 === r2)) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.message = "Rook must retreat to an adjacent square.";
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.is_power_mode = null;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return false;
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  if (this.board[f2][r2] !== null || this._is_square_blocked(f2, r2)) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.message = "Rook retreat square must be empty and not blocked.";
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.is_power_mode = null;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return false;
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  // 1. Rook retreats
Â  Â  Â  Â  Â  Â  Â  Â  this.board[f2][r2] = piece;
Â  Â  Â  Â  Â  Â  Â  Â  this.board[f1][r1] = null;
Â  Â  Â  Â  Â  Â  Â  Â  piece.moved = true;

Â  Â  Â  Â  Â  Â  Â  Â  // 2. Roomba deployed
Â  Â  Â  Â  Â  Â  Â  Â  this.roomba_pos = {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  f: f1,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  r: r1
Â  Â  Â  Â  Â  Â  Â  Â  };
Â  Â  Â  Â  Â  Â  Â  Â  this.roomba_moves_remaining = 4;
Â  Â  Â  Â  Â  Â  Â  Â  this.roomba_target = this._get_king_pos(this.current_turn === 'W' ? 'B' : 'W');

Â  Â  Â  Â  Â  Â  Â  Â  if (!this.roomba_target) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.message = "Roomba deployment failed: Enemy King not found!";
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.roomba_pos = null;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.is_power_mode = null;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return false;
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  this.is_power_mode = null;
Â  Â  Â  Â  Â  Â  Â  Â  this.message = `Rogue Roomba deployed at ${this._indices_to_coords(f1, r1)}! Rook retreated to ${this._indices_to_coords(f2, r2)}.`;
Â  Â  Â  Â  Â  Â  Â  Â  this._next_turn();
Â  Â  Â  Â  Â  Â  Â  Â  return true;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  // --- Standard Move/Rule Functions ---

Â  Â  Â  Â  Â  Â  _validate_move(f1, r1, f2, r2) {
Â  Â  Â  Â  Â  Â  Â  Â  const piece = this.board[f1][r1];
Â  Â  Â  Â  Â  Â  Â  Â  if (!piece || piece.color !== this.current_turn) return false;

Â  Â  Â  Â  Â  Â  Â  Â  const is_castling_attempt = (piece.type === 'K' && Math.abs(f2 - f1) === 2 && r1 === r2);
Â  Â  Â  Â  Â  Â  Â  Â  if (is_castling_attempt && this._check_castling_rules(f1, r1, f2, r2)) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return true;
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  if (!this._check_move_rules(f1, r1, f2, r2, piece)) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return false;
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  // --- Simulate the move to check for check ---
Â  Â  Â  Â  Â  Â  Â  Â  const original_target = this.board[f2][r2];
Â  Â  Â  Â  Â  Â  Â  Â  const is_en_passant = (piece.type === 'P' && this.en_passant_target && f2 === this.en_passant_target.f && r2 === this.en_passant_target.r);
Â  Â  Â  Â  Â  Â  Â  Â  let captured_pawn_pos = null;
Â  Â  Â  Â  Â  Â  Â  Â  let original_captured_pawn = null;

Â  Â  Â  Â  Â  Â  Â  Â  if (is_en_passant) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const direction = piece.color === 'W' ? 1 : -1;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  captured_pawn_pos = {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  f: f2,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  r: r2 - direction
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  };
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  original_captured_pawn = this.board[captured_pawn_pos.f][captured_pawn_pos.r];
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.board[captured_pawn_pos.f][captured_pawn_pos.r] = null;
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  this.board[f2][r2] = piece;
Â  Â  Â  Â  Â  Â  Â  Â  this.board[f1][r1] = null;

Â  Â  Â  Â  Â  Â  Â  Â  const is_safe = !this._is_king_in_check(this.current_turn);

Â  Â  Â  Â  Â  Â  Â  Â  this.board[f1][r1] = piece;
Â  Â  Â  Â  Â  Â  Â  Â  this.board[f2][r2] = original_target;

Â  Â  Â  Â  Â  Â  Â  Â  if (is_en_passant) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.board[captured_pawn_pos.f][captured_pawn_pos.r] = original_captured_pawn;
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  return is_safe;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  _is_path_blocked(f1, r1, f2, r2) {
Â  Â  Â  Â  Â  Â  Â  Â  const df = f1 === f2 ? 0 : (f2 > f1 ? 1 : -1);
Â  Â  Â  Â  Â  Â  Â  Â  const dr = r1 === r2 ? 0 : (r2 > r1 ? 1 : -1);
Â  Â  Â  Â  Â  Â  Â  Â  let f = f1 + df;
Â  Â  Â  Â  Â  Â  Â  Â  let r = r1 + dr;
Â  Â  Â  Â  Â  Â  Â  Â  while (f !== f2 || r !== r2) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (this._is_square_blocked(f, r)) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return true;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  f += df;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  r += dr;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  return false;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  get_legal_moves(f1, r1) {
Â  Â  Â  Â  Â  Â  Â  Â  const piece = this.board[f1][r1];
Â  Â  Â  Â  Â  Â  Â  Â  if (!piece || piece.color !== this.current_turn) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return [];
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  const legal_moves = [];

Â  Â  Â  Â  Â  Â  Â  Â  // 1. Standard/Castling/EnPassant Moves
Â  Â  Â  Â  Â  Â  Â  Â  for (let f2 = 0; f2 < 8; f2++) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  for (let r2 = 0; r2 < 8; r2++) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (f1 === f2 && r1 === r2) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  continue;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Special check for Phasing Rook (If active, this piece can move to any empty square)
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (this.phase_move_pending && f1 === this.selected_square_coords.f && r1 === this.selected_square_coords.r) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (this.board[f2][r2] === null && !this._is_square_blocked(f2, r2)) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Phase move doesn't need to check for check, as the piece is removed, then placed in execute_move
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // The execute_move for PHASE MOVE handles the final checks.
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  legal_moves.push({
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  f: f2,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  r: r2,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  is_capture: false,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  is_power_target: true
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  continue;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (this._validate_move(f1, r1, f2, r2)) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const target = this.board[f2][r2];

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const is_castling = (piece.type === 'K' && Math.abs(f2 - f1) === 2 && r1 === r2);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const is_en_passant_capture = (piece.type === 'P' && this.en_passant_target && f2 === this.en_passant_target.f && r2 === this.en_passant_target.r);

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const is_capture = target !== null || (this.roomba_pos && this.roomba_pos.f === f2 && this.roomba_pos.r === r2) || is_en_passant_capture;

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Murasaki logic check
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const is_murasaki_friendly_pawn = (
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.is_power_mode === 'MURASAKI' &&
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  piece.type === 'K' &&
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  target && target.color === piece.color &&
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  target.type === 'P'
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  );

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (this.is_power_mode === 'MURASAKI' && !is_murasaki_friendly_pawn) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  continue; // Block all other moves in Murasaki mode
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  legal_moves.push({
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  f: f2,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  r: r2,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  is_capture: is_capture || is_castling || is_murasaki_friendly_pawn
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  // 2. Special Power Mode Targets
Â  Â  Â  Â  Â  Â  Â  Â  if (this.is_power_mode === 'ROOK_ROOMBA' && f1 === this.selected_square_coords.f && r1 === this.selected_square_coords.r) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Rook Retreat (adjacent empty squares)
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  for (let df = -1; df <= 1; df++) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  for (let dr = -1; dr <= 1; dr++) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (df === 0 && dr === 0) continue;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const rf2 = f1 + df;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const rr2 = r1 + dr;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (rf2 >= 0 && rf2 <= 7 && rr2 >= 0 && rr2 <= 7 &&
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.board[rf2][rr2] === null &&
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  !this._is_square_blocked(rf2, rr2)) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  legal_moves.push({
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  f: rf2,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  r: rr2,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  is_capture: false,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  is_power_target: true
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  } else if (this.is_power_mode === 'KNIGHT_FUSION' && f1 === this.selected_square_coords.f && r1 === this.selected_square_coords.r) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Targets are friendly Bishops within fusion range
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const kf = f1;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const kr = r1;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  for (let f2 = 0; f2 < 8; f2++) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  for (let r2 = 0; r2 < 8; r2++) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const target = this.board[f2][r2];
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (target && target.color === this.current_turn && target.type === 'B') {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const bf = f2;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const br = r2;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const df_dist = Math.abs(kf - bf);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const dr_dist = Math.abs(kr - br);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const is_adjacent = Math.max(df_dist, dr_dist) === 1;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const is_diag_two = (df_dist > 0 && dr_dist > 0 && Math.max(df_dist, dr_dist) === 2);

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (is_adjacent || is_diag_two) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  legal_moves.push({
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  f: f2,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  r: r2,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  is_capture: true,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  is_power_target: true
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  // 3. Targets for R_COMMAND actions
Â  Â  Â  Â  Â  Â  Â  Â  if (['R_HACK_PENDING', 'R_PHASE_PENDING'].includes(this.is_power_mode) && piece.type === 'R' && f1 === this.selected_square_coords.f && r1 === this.selected_square_coords.r) {

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (this.is_power_mode === 'R_HACK_PENDING') {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Hack target: ANY piece except King
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  for (let f2 = 0; f2 < 8; f2++) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  for (let r2 = 0; r2 < 8; r2++) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const piece_at_target = this.board[f2][r2];
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (piece_at_target && piece_at_target.type !== 'K') {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  legal_moves.push({
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  f: f2,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  r: r2,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  is_capture: true,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  is_power_target: true
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else if (this.is_power_mode === 'R_PHASE_PENDING') {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Phase target: ANY empty, non-blocked square
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  for (let f2 = 0; f2 < 8; f2++) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  for (let r2 = 0; r2 < 8; r2++) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (this.board[f2][r2] === null && !this._is_square_blocked(f2, r2)) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  legal_moves.push({
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  f: f2,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  r: r2,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  is_capture: false,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  is_power_target: true
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }


Â  Â  Â  Â  Â  Â  Â  Â  // Filter for unique moves
Â  Â  Â  Â  Â  Â  Â  Â  const unique_moves = [];
Â  Â  Â  Â  Â  Â  Â  Â  const coords_seen = new Set();
Â  Â  Â  Â  Â  Â  Â  Â  for (const move of legal_moves) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const key = `${move.f},${move.r}`;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (!coords_seen.has(key)) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  unique_moves.push(move);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  coords_seen.add(key);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  return unique_moves;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  _is_square_attacked(target_f, target_r, attacking_color, check_blockade = true) {
Â  Â  Â  Â  Â  Â  Â  Â  for (let f = 0; f < 8; f++) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  for (let r = 0; r < 8; r++) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const piece = this.board[f][r];
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (piece && piece.color === attacking_color) {

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const original_target_piece = this.board[target_f][target_r];
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.board[target_f][target_r] = null; // Temporarily clear target for attack check

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const can_attack = this._check_move_rules(f, r, target_f, target_r, piece, check_blockade);

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.board[target_f][target_r] = original_target_piece; // Restore target

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (can_attack) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Special handling for pawns (only capture diagonally, not forward attack)
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (piece.type === 'P' && f === target_f) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  continue;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return true;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  // Roomba attack (Roomba attacks adjacent squares)
Â  Â  Â  Â  Â  Â  Â  Â  if (this.roomba_pos) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const rf = this.roomba_pos.f;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const rr = this.roomba_pos.r;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (Math.abs(rf - target_f) <= 1 && Math.abs(rr - target_r) <= 1) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return true;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  return false;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  _check_castling_rules(f1, r1, f2, r2) {
Â  Â  Â  Â  Â  Â  Â  Â  const color = this.current_turn;

Â  Â  Â  Â  Â  Â  Â  Â  const king_piece = this.board[f1][r1];
Â  Â  Â  Â  Â  Â  Â  Â  if (king_piece === null || king_piece.type !== 'K' || king_piece.moved || this._is_square_frozen(f1, r1)) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return false;
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  const rook_f = f2 > f1 ? 7 : 0;
Â  Â  Â  Â  Â  Â  Â  Â  const rook_r = r1;
Â  Â  Â  Â  Â  Â  Â  Â  const rook_piece = this.board[rook_f][rook_r];

Â  Â  Â  Â  Â  Â  Â  Â  if (rook_piece === null || rook_piece.type !== 'R' || rook_piece.moved || this._is_square_frozen(rook_f, rook_r)) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return false;
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  const df_step = f2 > f1 ? 1 : -1;

Â  Â  Â  Â  Â  Â  Â  Â  // Check squares between King and Rook
Â  Â  Â  Â  Â  Â  Â  Â  for (let f = f1 + df_step; f !== rook_f; f += df_step) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (this.board[f][r1] !== null || this._is_square_blocked(f, r1) || (this.roomba_pos && this.roomba_pos.f === f && this.roomba_pos.r === r1)) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return false;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  // King cannot be in check
Â  Â  Â  Â  Â  Â  Â  Â  if (this._is_king_in_check(color)) return false;

Â  Â  Â  Â  Â  Â  Â  Â  // King cannot pass through or land on an attacked square
Â  Â  Â  Â  Â  Â  Â  Â  const f_pass = f1 + df_step;
Â  Â  Â  Â  Â  Â  Â  Â  const opponent_color = color === 'W' ? 'B' : 'W';
Â  Â  Â  Â  Â  Â  Â  Â  const king_squares_to_check = [
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  [f_pass, r1],
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  [f2, r2]
Â  Â  Â  Â  Â  Â  Â  Â  ];

Â  Â  Â  Â  Â  Â  Â  Â  for (const [f_check, r_check] of king_squares_to_check) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (this._is_square_attacked(f_check, r_check, opponent_color)) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return false;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  return true;
Â  Â  Â  Â  Â  Â  }


Â  Â  Â  Â  Â  Â  _check_move_rules(f1, r1, f2, r2, piece, check_blockade = true) {

Â  Â  Â  Â  Â  Â  Â  Â  if (this._is_square_frozen(f1, r1)) return false;

Â  Â  Â  Â  Â  Â  Â  Â  const df = f2 - f1;
Â  Â  Â  Â  Â  Â  Â  Â  const dr = r2 - r1;
Â  Â  Â  Â  Â  Â  Â  Â  const abs_df = Math.abs(df);
Â  Â  Â  Â  Â  Â  Â  Â  const abs_dr = Math.abs(dr);
Â  Â  Â  Â  Â  Â  Â  Â  const target = this.board[f2][r2];

Â  Â  Â  Â  Â  Â  Â  Â  // --- HACKED PIECE CAPTURE CHECK ---
Â  Â  Â  Â  Â  Â  Â  Â  const is_hacked_capture = (this.hacked_piece && this.hacked_piece.f === f1 && this.hacked_piece.r === r1 && target && target.color === piece.color);

Â  Â  Â  Â  Â  Â  Â  Â  // --- FRIENDLY FIRE CHECK (MURASAKI) ---
Â  Â  Â  Â  Â  Â  Â  Â  const is_murasaki_self_capture = (
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.is_power_mode === 'MURASAKI' &&
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  piece.type === 'K' &&
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  target && target.color === piece.color &&
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  target.type === 'P' // Must be a Pawn sacrifice
Â  Â  Â  Â  Â  Â  Â  Â  );

Â  Â  Â  Â  Â  Â  Â  Â  if (target && target.color === piece.color && !is_murasaki_self_capture && !is_hacked_capture) return false;
Â  Â  Â  Â  Â  Â  Â  Â  // --- END FRIENDLY FIRE CHECK ---

Â  Â  Â  Â  Â  Â  Â  Â  if (check_blockade && this._is_square_blocked(f2, r2)) return false;

Â  Â  Â  Â  Â  Â  Â  Â  const p_type = piece.type;

Â  Â  Â  Â  Â  Â  Â  Â  if (p_type === 'P') {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const direction = piece.color === 'W' ? 1 : -1;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const start_rank = piece.color === 'W' ? 1 : 6;

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Forward move 1
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (df === 0 && dr === direction && target === null && !this._is_square_blocked(f2, r2)) return true;

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Forward move 2
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const intermediate_r = r1 + direction;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (df === 0 && dr === 2 * direction && r1 === start_rank && target === null) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (this.board[f1][intermediate_r] === null && !this._is_square_blocked(f1, intermediate_r) && !this._is_square_blocked(f2, r2)) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return true;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return false;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Standard capture (or Hacked capture of friendly piece)
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (abs_df === 1 && dr === direction && (target !== null || is_hacked_capture)) return true;

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // En Passant capture
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (abs_df === 1 && dr === direction && this.en_passant_target && f2 === this.en_passant_target.f && r2 === this.en_passant_target.r) return true;

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return false;
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  if (p_type === 'N') return (abs_df === 1 && abs_dr === 2) || (abs_df === 2 && abs_dr === 1);

Â  Â  Â  Â  Â  Â  Â  Â  if (p_type === 'A') {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const is_knight_move = (abs_df === 1 && abs_dr === 2) || (abs_df === 2 && abs_dr === 1);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const is_bishop_move = (abs_df === abs_dr && abs_df > 0);

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (is_knight_move) return true;

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (is_bishop_move) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (check_blockade && this._is_path_blocked(f1, r1, f2, r2)) return false;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return this._is_path_clear(f1, r1, f2, r2);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return false;
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  if (p_type === 'R' || p_type === 'Q') {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if ((df === 0 && abs_dr > 0) || (abs_df > 0 && dr === 0)) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (check_blockade && this._is_path_blocked(f1, r1, f2, r2)) return false;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return this._is_path_clear(f1, r1, f2, r2);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  if (p_type === 'B' || p_type === 'Q') {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (abs_df === abs_dr && abs_df > 0) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (check_blockade && this._is_path_blocked(f1, r1, f2, r2)) return false;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return this._is_path_clear(f1, r1, f2, r2);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  if (p_type === 'K') {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (abs_df <= 1 && abs_dr <= 1 && (abs_df + abs_dr > 0)) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return true;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return false;
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  return false;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  _is_path_clear(f1, r1, f2, r2) {
Â  Â  Â  Â  Â  Â  Â  Â  const df = f1 === f2 ? 0 : (f2 > f1 ? 1 : -1);
Â  Â  Â  Â  Â  Â  Â  Â  const dr = r1 === r2 ? 0 : (r2 > r1 ? 1 : -1);
Â  Â  Â  Â  Â  Â  Â  Â  let f = f1 + df;
Â  Â  Â  Â  Â  Â  Â  Â  let r = r1 + dr;
Â  Â  Â  Â  Â  Â  Â  Â  while (f !== f2 || r !== r2) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (this.board[f][r] !== null || (this.roomba_pos && this.roomba_pos.f === f && this.roomba_pos.r === r)) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return false;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  f += df;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  r += dr;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  return true;
Â  Â  Â  Â  Â  Â  }


Â  Â  Â  Â  Â  Â  _next_turn() {
Â  Â  Â  Â  Â  Â  Â  Â  /** Switches turn and handles power drawbacks/effects, checking for checkmate. */

Â  Â  Â  Â  Â  Â  Â  Â  this.en_passant_target = null;
Â  Â  Â  Â  Â  Â  Â  Â  this.phase_move_pending = false;

Â  Â  Â  Â  Â  Â  Â  Â  // 1. Roomba movement (always check if the King is still safe)
Â  Â  Â  Â  Â  Â  Â  Â  if (this.roomba_moves_remaining > 0) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this._move_roomba();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (this.game_over) return; // Checkmate by roomba
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  // 2. Thaw frozen pieces
Â  Â  Â  Â  Â  Â  Â  Â  const keys_to_remove = [];
Â  Â  Â  Â  Â  Â  Â  Â  for (const pos in this.frozen_pieces) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (this.frozen_pieces.hasOwnProperty(pos)) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (this.frozen_pieces[pos] > 0) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.frozen_pieces[pos] -= 1;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (this.frozen_pieces[pos] === 0) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  keys_to_remove.push(pos);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  for (const key of keys_to_remove) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  delete this.frozen_pieces[key];
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  if (keys_to_remove.length) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.message += ` (${keys_to_remove.length} pieces thawed out!)`;
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  // 3. Switch turn and check for mate/stalemate
Â  Â  Â  Â  Â  Â  Â  Â  this.current_turn = this.current_turn === 'W' ? 'B' : 'W';
Â  Â  Â  Â  Â  Â  Â  Â  this.is_power_mode = null;
Â  Â  Â  Â  Â  Â  Â  Â  this.hacked_piece = null; // HACK only lasts for one turn

Â  Â  Â  Â  Â  Â  Â  Â  this.is_check = this._is_king_in_check(this.current_turn);
Â  Â  Â  Â  Â  Â  Â  Â  const has_moves = this.has_legal_moves(this.current_turn);

Â  Â  Â  Â  Â  Â  Â  Â  if (!has_moves) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (this.is_check) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const winner = this.current_turn === 'B' ? 'White' : 'Black';
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.message = `CHECKMATE! ${winner} wins!`;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.game_over = 'CHECKMATE';
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.message = "STALEMATE! Game is a draw.";
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.game_over = 'STALEMATE';
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  } else if (this.is_check) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.message += " CHECK!";
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  execute_move(move_str) {
Â  Â  Â  Â  Â  Â  Â  Â  if (this.game_over) return;

Â  Â  Â  Â  Â  Â  Â  Â  let f1, r1, f2, r2;
Â  Â  Â  Â  Â  Â  Â  Â  try {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (move_str.length !== 4) throw new Error("Invalid format");
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const coords1 = this._coords_to_indices(move_str.substring(0, 2));
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const coords2 = this._coords_to_indices(move_str.substring(2, 4));
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  f1 = coords1.f;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  r1 = coords1.r;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  f2 = coords2.f;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  r2 = coords2.r;
Â  Â  Â  Â  Â  Â  Â  Â  } catch (e) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.message = "Invalid move format.";
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  // --- Power mode validation & execution (pre-standard move) ---
Â  Â  Â  Â  Â  Â  Â  Â  if (this.is_power_mode === 'ROOK_ROOMBA') {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  f: start_f,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  r: start_r
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } = this.selected_square_coords;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (f1 === start_f && r1 === start_r) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this._activate_r_ultimate(f1, r1, f2, r2);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  if (this.is_power_mode === 'BISHOP_FREEZE') {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  f: start_f,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  r: start_r
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } = this.selected_square_coords;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (f1 === start_f && r1 === start_r) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this._activate_b_ultimate(f1, r1, f2, r2);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  // Power move execution: PHASE MOVE (Rook moves anywhere)
Â  Â  Â  Â  Â  Â  Â  Â  if (this.phase_move_pending && f1 === this.selected_square_coords.f && r1 === this.selected_square_coords.r) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (this.board[f2][r2] !== null || this._is_square_blocked(f2, r2)) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.message = "Phase move must land on an empty, non-blocked square.";
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.phase_move_pending = false;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.is_power_mode = null;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const piece = this.board[f1][r1];
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.board[f2][r2] = piece;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.board[f1][r1] = null;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  piece.moved = true;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.message = `Rook phased to ${this._indices_to_coords(f2, r2)}!`;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.phase_move_pending = false;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.is_power_mode = null;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this._next_turn();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  if (!this._validate_move(f1, r1, f2, r2)) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.message = "Invalid move, piece is frozen, or King remains in check.";
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  const piece = this.board[f1][r1];
Â  Â  Â  Â  Â  Â  Â  Â  const target = this.board[f2][r2];
Â  Â  Â  Â  Â  Â  Â  Â  const df = f2 - f1;
Â  Â  Â  Â  Â  Â  Â  Â  const dr = r2 - r1;

Â  Â  Â  Â  Â  Â  Â  Â  // --- MURASAKI ACTIVATION LOGIC (Immediate Execution) ---
Â  Â  Â  Â  Â  Â  Â  Â  const is_murasaki_move = (
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.is_power_mode === 'MURASAKI' &&
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  piece.type === 'K' &&
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  target && target.color === piece.color &&
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  target.type === 'P'
Â  Â  Â  Â  Â  Â  Â  Â  );

Â  Â  Â  Â  Â  Â  Â  Â  if (is_murasaki_move) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.message = `King sacrifices Pawn at ${this._indices_to_coords(f2, r2)}! Domain Expansion: Murasaki activated.`;

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Move the King onto the Pawn (Sacrifice)
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.board[f2][r2] = piece;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.board[f1][r1] = null;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  piece.moved = true;

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Execute logic and switch turn immediately
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this._execute_k_ultimate_logic();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  // --- END MURASAKI LOGIC ---

Â  Â  Â  Â  Â  Â  Â  Â  // --- 1. Castling Logic (Standard move path) ---
Â  Â  Â  Â  Â  Â  Â  Â  if (piece.type === 'K' && Math.abs(df) === 2 && dr === 0) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const rook_f1 = df > 0 ? 7 : 0;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const rook_f2 = df > 0 ? 5 : 3;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const rook_piece = this.board[rook_f1][r1];

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.board[f2][r2] = piece;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.board[f1][r1] = null;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  piece.moved = true;

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.board[rook_f2][r2] = rook_piece;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.board[rook_f1][r1] = null;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  rook_piece.moved = true;

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.message = "Castling successful!";

Â  Â  Â  Â  Â  Â  Â  Â  // --- 2. En Passant Logic (Standard move path) ---
Â  Â  Â  Â  Â  Â  Â  Â  } else if (piece.type === 'P' && this.en_passant_target && f2 === this.en_passant_target.f && r2 === this.en_passant_target.r) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const direction = piece.color === 'W' ? 1 : -1;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const captured_pawn_pos = {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  f: f2,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  r: r2 - direction
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  };

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.board[f2][r2] = piece;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.board[f1][r1] = null;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  piece.moved = true;

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.board[captured_pawn_pos.f][captured_pawn_pos.r] = null;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.message = "En Passant capture successful!";

Â  Â  Â  Â  Â  Â  Â  Â  // --- 3. Standard Move Logic (Standard move path) ---
Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const is_roomba_capture = this.roomba_pos && this.roomba_pos.f === f2 && this.roomba_pos.r === r2;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const is_hacked_capture = (this.hacked_piece && this.hacked_piece.f === f1 && this.hacked_piece.r === r1 && target && target.color === piece.color);

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (is_roomba_capture) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.roomba_pos = null;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.roomba_moves_remaining = 0;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.message = "Roomba destroyed by piece move!";
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else if (target) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.message = `Captured ${target.color}${target.type}!`;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (is_hacked_capture) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.message = `Hacked piece ${piece.color}${piece.type} successfully captured friendly ${target.type}!`;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.message = "Move successful.";
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.board[f2][r2] = piece;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.board[f1][r1] = null;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  piece.moved = true;

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Check for two-square pawn push to set En Passant target
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (piece.type === 'P' && Math.abs(dr) === 2) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const direction = piece.color === 'W' ? 1 : -1;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.en_passant_target = {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  f: f2,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  r: r1 + direction
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  };
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.message += " (En Passant target set)";
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.en_passant_target = null;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Check for pawn promotion (simple for now)
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (piece.type === 'P' && (r2 === 7 || r2 === 0)) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  piece.type = 'Q';
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.message += " (PROMOTED to Queen!)";
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  this._next_turn();
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }


Â  Â  Â  Â  // --- 2. GUI INTERFACE (UltimateChessApp equivalent) ---

Â  Â  Â  Â  class UltimateChessApp {
Â  Â  Â  Â  Â  Â  constructor() {
Â  Â  Â  Â  Â  Â  Â  Â  this.DOT_SYMBOL = 'â—';
Â  Â  Â  Â  Â  Â  Â  Â  this.game = new UltimateChessGame();
Â  Â  Â  Â  Â  Â  Â  Â  this.selected_square = null; // {f, r}
Â  Â  Â  Â  Â  Â  Â  Â  this.valid_targets = []; // Array of {f, r, is_capture, is_power_target}
Â  Â  Â  Â  Â  Â  Â  Â  this.bot_elo = 1500;
Â  Â  Â  Â  Â  Â  Â  Â  this.user_color = 'W';
Â  Â  Â  Â  Â  Â  Â  Â  this.game_type = 'local'; // Can be 'local', 'bot', or 'online'
Â  Â  Â  Â  Â  Â  Â  Â  this.opponent_name = 'Opponent'; // Default for online simulation
Â  Â  Â  Â  Â  Â  Â  Â  this.is_small_screen = window.innerWidth < 800; // Match CSS breakpoint

Â  Â  Â  Â  Â  Â  Â  Â  this.elements = {};
Â  Â  Â  Â  Â  Â  Â  Â  this._setup_elements();
Â  Â  Â  Â  Â  Â  Â  Â  this._setup_event_listeners();
Â  Â  Â  Â  Â  Â  Â  Â  this._update_responsive_layout();
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  _setup_elements() {
Â  Â  Â  Â  Â  Â  Â  Â  this.elements.gameContainer = document.getElementById('game-container');
Â  Â  Â  Â  Â  Â  Â  Â  this.elements.mainMenu = document.getElementById('main-menu');
Â  Â  Â  Â  Â  Â  Â  Â  this.elements.onlineLobby = document.getElementById('online-lobby'); // NEW
Â  Â  Â  Â  Â  Â  Â  Â  this.elements.gameUI = document.getElementById('game-ui');
Â  Â  Â  Â  Â  Â  Â  Â  this.elements.boardFrame = document.getElementById('board-frame');
Â  Â  Â  Â  Â  Â  Â  Â  this.elements.panelFrame = document.getElementById('panel-frame');
Â  Â  Â  Â  Â  Â  Â  Â  this.elements.statusLabel = document.getElementById('status-label');
Â  Â  Â  Â  Â  Â  Â  Â  this.elements.messageLabel = document.getElementById('message-label');
Â  Â  Â  Â  Â  Â  Â  Â  this.elements.rUsesLabel = document.getElementById('r-uses-label');
Â  Â  Â  Â  Â  Â  Â  Â  this.elements.abilityTitle = document.getElementById('ability-title');
Â  Â  Â  Â  Â  Â  Â  Â  this.elements.abilityDesc = document.getElementById('ability-desc');
Â  Â  Â  Â  Â  Â  Â  Â  this.elements.abilityPrompt = document.getElementById('ability-prompt');
Â  Â  Â  Â  Â  Â  Â  Â  this.elements.hackBtn = document.getElementById('hack-btn');
Â  Â  Â  Â  Â  Â  Â  Â  this.elements.phaseBtn = document.getElementById('phase-btn');
Â  Â  Â  Â  Â  Â  Â  Â  this.elements.ultimateButton = document.getElementById('ultimate-button');
Â  Â  Â  Â  Â  Â  Â  Â  this.elements.eloSlider = document.getElementById('elo-slider');
Â  Â  Â  Â  Â  Â  Â  Â  this.elements.eloLabel = document.getElementById('elo-label');
Â  Â  Â  Â  Â  Â  Â  Â  this.elements.boardContainer = document.getElementById('board-container');
Â  Â  Â  Â  Â  Â  Â  Â  this.elements.overlay = document.getElementById('game-overlay');
Â  Â  Â  Â  Â  Â  Â  Â  this.elements.overlayMessage = document.getElementById('overlay-message');
Â  Â  Â  Â  Â  Â  Â  Â  // NEW Lobby elements
Â  Â  Â  Â  Â  Â  Â  Â  this.elements.dynamicPlayerList = document.getElementById('dynamic-player-list');
Â  Â  Â  Â  Â  Â  Â  Â  this.elements.lobbyStatusMessage = document.getElementById('lobby-status-message');
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  _setup_event_listeners() {
Â  Â  Â  Â  Â  Â  Â  Â  window.addEventListener('resize', () => this._on_resize());
Â  Â  Â  Â  Â  Â  Â  Â  this.elements.eloSlider.addEventListener('input', (e) => this.bot_elo = parseInt(e.target.value));
Â  Â  Â  Â  Â  Â  Â  Â  this.elements.overlay.addEventListener('click', () => this.return_to_menu_after_game());
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  _on_resize() {
Â  Â  Â  Â  Â  Â  Â  Â  const is_currently_small = window.innerWidth < 800;
Â  Â  Â  Â  Â  Â  Â  Â  if (is_currently_small !== this.is_small_screen) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.is_small_screen = is_currently_small;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this._update_responsive_layout();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (this.elements.gameUI.classList.contains('hidden') === false) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.draw_board();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.update_status();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  _update_responsive_layout() {
Â  Â  Â  Â  Â  Â  Â  Â  // Toggles CSS variables based on screen size, relying on media queries in style.css
Â  Â  Â  Â  Â  Â  Â  Â  const root = document.documentElement;
Â  Â  Â  Â  Â  Â  Â  Â  if (this.is_small_screen) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  root.style.setProperty('--piece-font-size', '40px');
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  root.style.setProperty('--dot-font-size', '28px');
Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  root.style.setProperty('--piece-font-size', '52px');
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  root.style.setProperty('--dot-font-size', '36px');
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  _hide_all_screens() {
Â  Â  Â  Â  Â  Â  Â  Â  this.elements.mainMenu.classList.add('hidden');
Â  Â  Â  Â  Â  Â  Â  Â  this.elements.onlineLobby.classList.add('hidden');
Â  Â  Â  Â  Â  Â  Â  Â  this.elements.gameUI.classList.add('hidden');
Â  Â  Â  Â  Â  Â  Â  Â  this.elements.overlay.classList.add('hidden');
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  show_main_menu() {
Â  Â  Â  Â  Â  Â  Â  Â  this._hide_all_screens();
Â  Â  Â  Â  Â  Â  Â  Â  this.elements.mainMenu.classList.remove('hidden');
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  // NEW: Show online lobby
Â  Â  Â  Â  Â  Â  showOnlineLobby() {
Â  Â  Â  Â  Â  Â  Â  Â  this._hide_all_screens();
Â  Â  Â  Â  Â  Â  Â  Â  this._renderOnlinePlayers(); // Generate player list
Â  Â  Â  Â  Â  Â  Â  Â  this.elements.onlineLobby.classList.remove('hidden');
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  // NEW: Simulation of player list
Â  Â  Â  Â  Â  Â  _renderOnlinePlayers() {
Â  Â  Â  Â  Â  Â  Â  Â  const players = [
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  { name: 'Cody_The_Haxor', elo: 1850, status: 'Ready' },
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  { name: 'Anime_King_24', elo: 1200, status: 'Ready' },
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  { name: 'Network_Ghost', elo: 2500, status: 'In Match', busy: true },
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // If no one is "found" dynamically, we can use a message:
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // { name: 'No person found', elo: '???', status: 'Offline', busy: true }
Â  Â  Â  Â  Â  Â  Â  Â  ];

Â  Â  Â  Â  Â  Â  Â  Â  this.elements.dynamicPlayerList.innerHTML = '';
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  // Determine if any "Ready" players exist for the status message
Â  Â  Â  Â  Â  Â  Â  Â  const readyPlayers = players.filter(p => !p.busy);

Â  Â  Â  Â  Â  Â  Â  Â  if (readyPlayers.length === 0) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.elements.lobbyStatusMessage.textContent = "No players found online right now. Try again later.";
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.elements.dynamicPlayerList.innerHTML = `
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <div class="player-card" style="cursor: default; background-color: var(--royal-bg); border: 1px dashed #777;">
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  No players currently ready.
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  `;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  readyPlayers.forEach(player => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const card = document.createElement('div');
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  card.className = 'player-card';
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (player.busy) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  card.onclick = () => alert('Player is currently busy.');
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  card.style.cursor = 'default';
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  card.querySelector('.status').style.color = 'var(--accent-red)';
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // The core logic the user requested: tapping sends a request
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  card.onclick = () => this.sendMatchRequest(player.name);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  card.innerHTML = `
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ${player.name} (${player.elo} ELO)Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <span class="status" style="color: ${player.busy ? 'var(--accent-red)' : 'var(--accent-green)'};">${player.status}</span>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  `;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.elements.dynamicPlayerList.appendChild(card);
Â  Â  Â  Â  Â  Â  Â  Â  });

Â  Â  Â  Â  Â  Â  Â  Â  this.elements.lobbyStatusMessage.textContent = `Found ${readyPlayers.length} challenger(s) ready to play. Click a name to send a challenge.`;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  // NEW: Send match request simulation
Â  Â  Â  Â  Â  Â  sendMatchRequest(playerName) {
Â  Â  Â  Â  Â  Â  Â  Â  if (confirm(`Would you like to send a challenge request to ${playerName} for an Ultimate Match? (Abilities Enabled)`)) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // SIMULATION: If accepted, start the game.
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.start_game('online', playerName);
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }


Â  Â  Â  Â  Â  Â  start_game(game_type, opponentName = null) {
Â  Â  Â  Â  Â  Â  Â  Â  this.game = new UltimateChessGame();
Â  Â  Â  Â  Â  Â  Â  Â  this.game_type = game_type;
Â  Â  Â  Â  Â  Â  Â  Â  this.opponent_name = opponentName || 'Opponent'; // Set opponent name for status updates

Â  Â  Â  Â  Â  Â  Â  Â  if (game_type === 'bot') {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.user_color = Math.random() < 0.5 ? 'W' : 'B';
Â  Â  Â  Â  Â  Â  Â  Â  } else if (game_type === 'online') {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // In a real game, the server decides the color. We'll pick one randomly for the simulation.
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.user_color = Math.random() < 0.5 ? 'W' : 'B';
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.game.message = `Online Match vs ${this.opponent_name} started! You are ${this.user_color === 'W' ? 'White' : 'Black'}. Abilities are enabled for both sides.`;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.user_color = 'W';
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  this._hide_all_screens();
Â  Â  Â  Â  Â  Â  Â  Â  this.elements.gameUI.classList.remove('hidden');

Â  Â  Â  Â  Â  Â  Â  Â  this._setup_game_board_ui();
Â  Â  Â  Â  Â  Â  Â  Â  this._initial_draw_and_check();
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  _setup_game_board_ui() {
Â  Â  Â  Â  Â  Â  Â  Â  const board_frame = this.elements.boardFrame;
Â  Â  Â  Â  Â  Â  Â  Â  board_frame.innerHTML = '';
Â  Â  Â  Â  Â  Â  Â  Â  this.squares = {}; // {f, r} -> DOM Element

Â  Â  Â  Â  Â  Â  Â  Â  // Setup Ranks/Files
Â  Â  Â  Â  Â  Â  Â  Â  this._create_coord_labels(document.getElementById('rank-labels-container'), 'rank');
Â  Â  Â  Â  Â  Â  Â  Â  this._create_coord_labels(document.getElementById('file-labels-container'), 'file');

Â  Â  Â  Â  Â  Â  Â  Â  const rank_range = this.user_color === 'W' ? Array.from({
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  length: 8
Â  Â  Â  Â  Â  Â  Â  Â  }, (_, i) => i) : Array.from({
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  length: 8
Â  Â  Â  Â  Â  Â  Â  Â  }, (_, i) => 7 - i);

Â  Â  Â  Â  Â  Â  Â  Â  for (let r = 0; r < 8; r++) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  for (let f = 0; f < 8; f++) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const is_dark = (f + r) % 2 === 1;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const color_class = is_dark ? 'dark-square' : 'light-square';

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const square_div = document.createElement('div');
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  square_div.id = `square-${f}-${r}`;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // FIX: Remove inline background color set here, rely entirely on CSS classes
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  square_div.className = `square ${color_class}`;Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  square_div.setAttribute('data-f', f);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  square_div.setAttribute('data-r', r);

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Handle board orientation (r index of the array vs. r grid position)
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const grid_r = this.user_color === 'W' ? 7 - r : r;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  square_div.style.gridRow = `${grid_r + 1} / span 1`;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  square_div.style.gridColumn = `${f + 1} / span 1`;

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  square_div.addEventListener('click', () => this.handle_click(f, r));
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  board_frame.appendChild(square_div);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.squares[`${f},${r}`] = square_div;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  _create_coord_labels(container, type) {
Â  Â  Â  Â  Â  Â  Â  Â  container.innerHTML = '';
Â  Â  Â  Â  Â  Â  Â  Â  let labels = [];

Â  Â  Â  Â  Â  Â  Â  Â  if (type === 'rank') {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const rank_order = this.user_color === 'W' ? Array.from({
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  length: 8
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }, (_, i) => i + 1) : Array.from({
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  length: 8
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }, (_, i) => 8 - i);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  labels = rank_order.map(r => r.toString());
Â  Â  Â  Â  Â  Â  Â  Â  } else { // type === 'file'
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const file_chars = 'abcdefgh';
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  labels = Array.from(file_chars);
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  labels.forEach((text) => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const label_div = document.createElement('div');
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  label_div.className = 'coord-label';
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  label_div.textContent = text;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  container.appendChild(label_div);
Â  Â  Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  _initial_draw_and_check() {
Â  Â  Â  Â  Â  Â  Â  Â  this.draw_board();
Â  Â  Â  Â  Â  Â  Â  Â  this.update_status();

Â  Â  Â  Â  Â  Â  Â  Â  const is_ai_turn = this.game_type === 'bot' && this.game.current_turn !== this.user_color;
Â  Â  Â  Â  Â  Â  Â  Â  if (is_ai_turn && !this.game.game_over) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.handle_ai_turn();
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  // --- Rook Ultimate Button Handlers (Simplified in JS) ---
Â  Â  Â  Â  Â  Â  _initiate_hack() {
Â  Â  Â  Â  Â  Â  Â  Â  if (this.game.is_power_mode === 'R_COMMAND_SELECT' && this.selected_square) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.game.is_power_mode = 'R_HACK_PENDING';
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.game.message = "HACK: Select a non-King piece to grant it friendly fire capture.";
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  f,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  r
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } = this.selected_square;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.valid_targets = this.game.get_legal_moves(f, r);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.draw_board();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.update_status();
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  _initiate_phase() {
Â  Â  Â  Â  Â  Â  Â  Â  if (this.game.is_power_mode === 'R_COMMAND_SELECT' && this.selected_square) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.game.is_power_mode = 'R_PHASE_PENDING';
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.game.message = "PHASE: Select an empty square for the Rook to teleport.";
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  f,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  r
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } = this.selected_square;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.valid_targets = this.game.get_legal_moves(f, r);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.draw_board();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.update_status();
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  // --- Rook Ultimate Click Execution ---
Â  Â  Â  Â  Â  Â  _handle_rook_command_click(f, r) {
Â  Â  Â  Â  Â  Â  Â  Â  const mode = this.game.is_power_mode;
Â  Â  Â  Â  Â  Â  Â  Â  const current_turn = this.game.current_turn;

Â  Â  Â  Â  Â  Â  Â  Â  if (this.selected_square === null || !this._is_valid_target(f, r)) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.game.message = "Invalid target. Selection cleared. Try activating ULTIMATE again.";
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.clear_selection();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.draw_board();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.update_status();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  const {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  f: f1,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  r: r1
Â  Â  Â  Â  Â  Â  Â  Â  } = this.selected_square;

Â  Â  Â  Â  Â  Â  Â  Â  // 1. Deduct use (only happens on successful target click)
Â  Â  Â  Â  Â  Â  Â  Â  this.game.r_power_uses[current_turn] -= 1;

Â  Â  Â  Â  Â  Â  Â  Â  // 2. Execute command based on mode
Â  Â  Â  Â  Â  Â  Â  Â  if (mode === 'R_HACK_PENDING') {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const target_piece = this.game.board[f][r];
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.game.hacked_piece = {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  f,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  r
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  };
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.game.message = `HACK successful! ${target_piece.color}${target_piece.type} at ${this.game._indices_to_coords(f, r)} can now capture friendly pieces.`;

Â  Â  Â  Â  Â  Â  Â  Â  } else if (mode === 'R_PHASE_PENDING') {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Phase is placing the rook on an empty square
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const rook_piece_data = {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  'type': 'R',
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  'color': current_turn,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  'moved': true
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  };
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.game.board[f][r] = rook_piece_data;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.game.message = `PHASE successful! Rook teleported to ${this.game._indices_to_coords(f, r)}.`;
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  // 3. Rook disappearance (The initiating piece, which is R at f1, r1, is gone)
Â  Â  Â  Â  Â  Â  Â  Â  this.game.board[f1][r1] = null;

Â  Â  Â  Â  Â  Â  Â  Â  // 4. Final cleanup and turn switch
Â  Â  Â  Â  Â  Â  Â  Â  this.game.is_power_mode = null;
Â  Â  Â  Â  Â  Â  Â  Â  this.game.selected_square_coords = null;
Â  Â  Â  Â  Â  Â  Â  Â  this.game._next_turn();
Â  Â  Â  Â  Â  Â  Â  Â  this.clear_selection();

Â  Â  Â  Â  Â  Â  Â  Â  if (this.game_type === 'bot' && !this.game.game_over && this.game.current_turn !== this.user_color) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.handle_ai_turn();
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }


Â  Â  Â  Â  Â  Â  draw_board() {
Â  Â  Â  Â  Â  Â  Â  Â  /** Draws all pieces, blockades, Roomba, and Frozen symbols on the board. */
Â  Â  Â  Â  Â  Â  Â  Â  for (let f = 0; f < 8; f++) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  for (let r = 0; r < 8; r++) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const piece = this.game.board[f][r];
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const square_div = this.squares[`${f},${r}`];
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  let symbol = '';
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  let fg_class = '';
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Start with the base color class (light-square or dark-square)
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const is_dark = (f + r) % 2 === 1;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  let classes = ['square'];Â 

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // --- 1. Determine Content (Piece, Blockade, Roomba) ---
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (piece) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const piece_key = piece.color + piece.type;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  symbol = UNICODE_PIECES[piece_key] || piece_key;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  fg_class = `${piece.color}-piece`;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (piece.type === 'A' || symbol.length > 1) classes.push('small-font');
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else if (this.game.roomba_pos && this.game.roomba_pos.f === f && this.game.roomba_pos.r === r) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  symbol = UNICODE_PIECES['RM'];
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  classes.push('roomba-symbol');
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else if (this.game._is_square_blocked(f, r)) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  symbol = UNICODE_PIECES['BL'];
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  classes.push('blockade-symbol');
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // --- 2. Apply Highlighting (Selection, Targets) ---
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const target_info = this.valid_targets.find(t => t.f === f && t.r === r);

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (this.selected_square && this.selected_square.f === f && this.selected_square.r === r) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  classes.push('selected');
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else if (target_info) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const is_empty_square = piece === null && !(this.game.roomba_pos && this.game.roomba_pos.f === f && this.game.roomba_pos.r === r) && !this.game._is_square_blocked(f, r);

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (is_empty_square && !target_info.is_power_target) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  symbol = this.DOT_SYMBOL;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  classes.push('move-dot');
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else if (target_info.is_power_target) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  classes.push('power-target');
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  classes.push('attack-target');
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // --- 3. Apply Special States (Frozen, Hacked) ---
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (this.game.hacked_piece && this.game.hacked_piece.f === f && this.game.hacked_piece.r === r) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  classes.push('hacked-piece');
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (this.game._is_square_frozen(f, r)) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  classes.push('frozen');
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (piece && !symbol.includes(UNICODE_PIECES['FR'])) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  symbol = symbol.trim() + ' ' + UNICODE_PIECES['FR'];
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // --- 4. Render to DOM ---
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Filter out duplicates and ensure base color is the last class added for proper cascading
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const unique_classes = [...new Set(classes.filter(c => c !== 'light-square' && c !== 'dark-square'))];
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  unique_classes.push(is_dark ? 'dark-square' : 'light-square');
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  square_div.className = unique_classes.join(' ');
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  square_div.style.backgroundColor = '';Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  square_div.innerHTML = `<span class="piece-symbol ${fg_class}">${symbol}</span>`;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  this._draw_game_over_overlay();
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  _draw_game_over_overlay() {
Â  Â  Â  Â  Â  Â  Â  Â  if (this.game.game_over) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  let message;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  let fg_color;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (this.game.game_over === 'CHECKMATE') {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const winner = this.game.current_turn === 'B' ? 'White' : 'Black';
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  message = `CHECKMATE! \n ${winner} WINS!`;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  fg_color = 'var(--accent-red)';
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else { // STALEMATE
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  message = "STALEMATE \n Draw!";
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  fg_color = 'var(--light-square)';
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.elements.overlayMessage.textContent = message;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.elements.overlayMessage.style.color = fg_color;

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Adjust font size for small screens
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (this.is_small_screen) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.elements.overlayMessage.style.fontSize = '20px';
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.elements.overlayMessage.style.fontSize = '30px';
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.elements.overlay.classList.remove('hidden');

Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.elements.overlay.classList.add('hidden');
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  _is_valid_target(f, r) {
Â  Â  Â  Â  Â  Â  Â  Â  return this.valid_targets.some(t => t.f === f && t.r === r);
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  return_to_menu_after_game() {
Â  Â  Â  Â  Â  Â  Â  Â  if (this.game.game_over) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.show_main_menu();
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  clear_selection() {
Â  Â  Â  Â  Â  Â  Â  Â  this.selected_square = null;
Â  Â  Â  Â  Â  Â  Â  Â  this.game.selected_square_coords = null;
Â  Â  Â  Â  Â  Â  Â  Â  this.game.is_power_mode = null;
Â  Â  Â  Â  Â  Â  Â  Â  this.valid_targets = [];
Â  Â  Â  Â  Â  Â  Â  Â  this.game.phase_move_pending = false;
Â  Â  Â  Â  Â  Â  Â  Â  this.draw_board();
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  update_ability_panel(piece = null) {
Â  Â  Â  Â  Â  Â  Â  Â  const info = this.game.current_ultimate_power_info;

Â  Â  Â  Â  Â  Â  Â  Â  // Update status for online/local/bot
Â  Â  Â  Â  Â  Â  Â  Â  let playerStatus = "";
Â  Â  Â  Â  Â  Â  Â  Â  if (this.game_type === 'online') {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  playerStatus = ` (Online vs ${this.opponent_name || 'Opponent'})`;
Â  Â  Â  Â  Â  Â  Â  Â  } else if (this.game_type === 'bot') {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  playerStatus = this.game.current_turn === this.user_color ? " (Your Move)" : " (AI Thinking)";
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  // Update Rook uses display
Â  Â  Â  Â  Â  Â  Â  Â  const r_uses_text = `Rook Uses: W: ${this.game.r_power_uses['W']}/2 | B: ${this.game.r_power_uses['B']}/2`;
Â  Â  Â  Â  Â  Â  Â  Â  this.elements.rUsesLabel.textContent = r_uses_text;

Â  Â  Â  Â  Â  Â  Â  Â  if (this.game.hacked_piece) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  f: hf,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  r: hr
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } = this.game.hacked_piece;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const h_piece = this.game.board[hf][hr];
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const h_coord = this.game._indices_to_coords(hf, hr);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.elements.rUsesLabel.textContent += ` | HACKED: ${h_piece.color}${h_piece.type} at ${h_coord}`;
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  // Default button states
Â  Â  Â  Â  Â  Â  Â  Â  this.elements.hackBtn.disabled = true;
Â  Â  Â  Â  Â  Â  Â  Â  this.elements.phaseBtn.disabled = true;

Â  Â  Â  Â  Â  Â  Â  Â  const is_user_turn = this.game.current_turn === this.user_color || this.game_type === 'local';

Â  Â  Â  Â  Â  Â  Â  Â  if (this.game.is_power_mode) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.elements.abilityTitle.textContent = `POWER MODE: ${info.name}`;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.elements.abilityTitle.style.color = 'var(--accent-red)';
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.elements.abilityDesc.innerHTML = info.desc;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.elements.abilityDesc.style.color = 'var(--light-square)';

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (this.game.is_power_mode === 'R_COMMAND_SELECT') {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.elements.abilityPrompt.textContent = "Status: Select /HACK or /PHASE.";
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.elements.abilityPrompt.style.color = '#FFD700';
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.elements.hackBtn.disabled = !is_user_turn;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.elements.phaseBtn.disabled = !is_user_turn;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else if (['R_HACK_PENDING', 'R_PHASE_PENDING'].includes(this.game.is_power_mode)) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.elements.abilityPrompt.textContent = this.game.message;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.elements.abilityPrompt.style.color = 'var(--accent-green)';
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.elements.abilityPrompt.textContent = `Action: ${info.prompt}`;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.elements.abilityPrompt.style.color = 'var(--accent-green)';
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.elements.ultimateButton.textContent = "CANCEL POWER";

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  // Default display when no power is active
Â  Â  Â  Â  Â  Â  Â  Â  this.elements.ultimateButton.textContent = "ACTIVATE ULTIMATE";

Â  Â  Â  Â  Â  Â  Â  Â  if (piece) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const piece_type = piece.type;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const piece_info = this.game._get_piece_power(piece_type);

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.elements.abilityTitle.textContent = `${piece_type} ULTIMATE: ${piece_info.name}`;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.elements.abilityTitle.style.color = 'var(--accent-green)';
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.elements.abilityDesc.innerHTML = piece_info.desc;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.elements.abilityDesc.style.color = 'var(--light-square)';
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.elements.abilityPrompt.textContent = "Action: Click ACTIVATE to use this power.";
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.elements.abilityPrompt.style.color = 'white';
Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const general_info = ULTIMATE_POWERS['GENERAL'];
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.elements.abilityTitle.textContent = "Select a Piece";
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.elements.abilityTitle.style.color = 'white';
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.elements.abilityDesc.innerHTML = "General Ultimate: " + general_info.desc;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.elements.abilityDesc.style.color = 'var(--light-square)';
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.elements.abilityPrompt.textContent = "Action: Make a standard move.";
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.elements.abilityPrompt.style.color = 'white';
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }


Â  Â  Â  Â  Â  Â  update_status() {
Â  Â  Â  Â  Â  Â  Â  Â  if (this.game.game_over) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.elements.statusLabel.textContent = this.game.game_over;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.elements.statusLabel.style.color = 'var(--accent-red)';
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.elements.messageLabel.textContent = this.game.message;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.elements.messageLabel.style.color = 'var(--accent-red)';
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.elements.ultimateButton.disabled = true;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  const turn_text = this.game.current_turn === 'W' ? "WHITE" : "BLACK";
Â  Â  Â  Â  Â  Â  Â  Â  let mode_label = "";
Â  Â  Â  Â  Â  Â  Â  Â  const is_user_turn = this.game.current_turn === this.user_color;

Â  Â  Â  Â  Â  Â  Â  Â  if (this.game_type === 'bot') {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const player_role = is_user_turn ? "YOU" : "AI";
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  mode_label = ` (${player_role} turn)`;
Â  Â  Â  Â  Â  Â  Â  Â  } else if (this.game_type === 'online') {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  mode_label = is_user_turn ? ` (Your Move vs ${this.opponent_name})` : ` (${this.opponent_name}'s Move - Waiting...)`;
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  this.elements.statusLabel.textContent = `Current Turn: ${turn_text}${mode_label}`;
Â  Â  Â  Â  Â  Â  Â  Â  this.elements.statusLabel.style.color = this.game.current_turn === 'W' ? 'var(--gold-piece)' : 'var(--silver-piece)';

Â  Â  Â  Â  Â  Â  Â  Â  if (this.game.is_check) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.elements.messageLabel.textContent = this.game.message;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.elements.messageLabel.style.color = 'var(--accent-red)';
Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.elements.messageLabel.textContent = this.game.message;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.elements.messageLabel.style.color = 'var(--light-square)';
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  const is_piece_selected = this.selected_square !== null;
Â  Â  Â  Â  Â  Â  Â  Â  const can_activate = is_piece_selected && this.game.is_power_mode === null;

Â  Â  Â  Â  Â  Â  Â  Â  // Disable UI if it's the opponent's turn in online mode or if it's the AI's turn
Â  Â  Â  Â  Â  Â  Â  Â  const ui_disabled = (this.game_type === 'online' && !is_user_turn) || (this.game_type === 'bot' && !is_user_turn);

Â  Â  Â  Â  Â  Â  Â  Â  if (!ui_disabled) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (this.game.is_power_mode) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.elements.ultimateButton.disabled = false;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.elements.ultimateButton.disabled = !can_activate;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.elements.ultimateButton.disabled = true;
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  const piece = this.selected_square ? this.game.board[this.selected_square.f][this.selected_square.r] : null;
Â  Â  Â  Â  Â  Â  Â  Â  this.update_ability_panel(piece);
Â  Â  Â  Â  Â  Â  }


Â  Â  Â  Â  Â  Â  handle_click(f, r) {
Â  Â  Â  Â  Â  Â  Â  Â  if (this.game.game_over) return;

Â  Â  Â  Â  Â  Â  Â  Â  // Disable interaction if it's the bot's turn or the simulated online opponent's turn
Â  Â  Â  Â  Â  Â  Â  Â  const is_user_turn = this.game.current_turn === this.user_color || this.game_type === 'local';
Â  Â  Â  Â  Â  Â  Â  Â  if (!is_user_turn) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.game.message = `Waiting for ${this.game_type === 'bot' ? 'AI' : this.opponent_name}'s move.`;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.update_status();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  const f1 = this.selected_square ? this.selected_square.f : null;
Â  Â  Â  Â  Â  Â  Â  Â  const r1 = this.selected_square ? this.selected_square.r : null;

Â  Â  Â  Â  Â  Â  Â  Â  const is_power_command_active = ['R_HACK_PENDING', 'R_PHASE_PENDING', 'BLOCKADE', 'KNIGHT_FUSION', 'BISHOP_FREEZE', 'MURASAKI'].includes(this.game.is_power_mode);

Â  Â  Â  Â  Â  Â  Â  Â  // --- Handle Power Interaction (Second click) ---
Â  Â  Â  Â  Â  Â  Â  Â  if (is_power_command_active) {

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (['R_HACK_PENDING', 'R_PHASE_PENDING'].includes(this.game.is_power_mode)) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Rook Command execution
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this._handle_rook_command_click(f, r);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else if (this.game.is_power_mode === 'BLOCKADE') {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Blockade logic (Temporal Blockade)
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const algebraic_coord = this.game._indices_to_coords(f, r);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (this.game.place_blockade(algebraic_coord)) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.clear_selection();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else if (this.game.is_power_mode === 'KNIGHT_FUSION') {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Fusion logic (Second click selects the Bishop)
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (this._is_valid_target(f, r)) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.game.perform_fusion(f, r);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.clear_selection();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.game.message = "Invalid fusion target. Select a friendly Bishop within range.";
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.draw_board();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.update_status();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else if (['BISHOP_FREEZE', 'ROOK_ROOMBA', 'MURASAKI'].includes(this.game.is_power_mode)) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // These powers execute on the next move
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (this.selected_square.f === f && this.selected_square.r === r) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.game.message = "Deselected. Click the piece again to activate power mode.";
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.game.is_power_mode = null; // Revert power mode
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.clear_selection();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (this._is_valid_target(f, r)) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const start_coord = this.game._indices_to_coords(f1, r1);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const end_coord = this.game._indices_to_coords(f, r);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.game.execute_move(start_coord + end_coord);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.clear_selection(); // Clear selection after successful power move
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.game.message = "Invalid target for power move. Try again or cancel.";
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.draw_board();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.update_status();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  // --- Standard Move/Selection ---

Â  Â  Â  Â  Â  Â  Â  Â  if (this.selected_square === null) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const piece = this.game.board[f][r];
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (piece && piece.color === this.game.current_turn) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.selected_square = {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  f,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  r
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  };
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.valid_targets = this.game.get_legal_moves(f, r);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.game.message = `Selected ${piece.color}${piece.type} at ${this.game._indices_to_coords(f, r)}. ${this.valid_targets.length} moves available.`;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.game.message = "Invalid selection. Please select one of your pieces.";
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // A piece is selected, attempting a move/new selection
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const target_is_valid = this._is_valid_target(f, r);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const target_piece = this.game.board[f][r];

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (f === f1 && r === r1) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.game.message = "Deselected.";
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.clear_selection();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (target_piece && target_piece.color === this.game.current_turn && !target_is_valid) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Selecting a different friendly piece
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.game.message = `Selected new piece at ${this.game._indices_to_coords(f, r)}.`;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.selected_square = {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  f,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  r
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  };
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.valid_targets = this.game.get_legal_moves(f, r);

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else if (target_is_valid) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Execute standard move
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const start_coord = this.game._indices_to_coords(f1, r1);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const end_coord = this.game._indices_to_coords(f, r);

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.game.execute_move(start_coord + end_coord);

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Check if the execution resulted in a turn switch (normal move or ultimate completion)
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (this.game.is_power_mode === null) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.clear_selection();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (this.game_type === 'bot' && !this.game.game_over && this.game.current_turn !== this.user_color) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.handle_ai_turn();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // In a real online game, this would transmit the move to the server.
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.game.message = "Invalid move destination.";
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  this.draw_board();
Â  Â  Â  Â  Â  Â  Â  Â  this.update_status();
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  activate_ultimate_gui() {
Â  Â  Â  Â  Â  Â  Â  Â  // If it's the opponent's turn (online or bot), the button is disabled, so this shouldn't run.
Â  Â  Â  Â  Â  Â  Â  Â  const is_user_turn = this.game.current_turn === this.user_color || this.game_type === 'local';
Â  Â  Â  Â  Â  Â  Â  Â  if (!is_user_turn) return;


Â  Â  Â  Â  Â  Â  Â  Â  if (this.game.is_power_mode) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Cancel current power mode sequence
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.game.is_power_mode = null;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.game.message = "Ultimate power sequence cancelled.";
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.clear_selection();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.update_status();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  if (this.selected_square === null) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.game.message = "Please select a piece first before activating ULTIMATE.";
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.update_status();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  const {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  f,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  r
Â  Â  Â  Â  Â  Â  Â  Â  } = this.selected_square;
Â  Â  Â  Â  Â  Â  Â  Â  const piece = this.game.board[f][r];

Â  Â  Â  Â  Â  Â  Â  Â  const is_activated = this.game.activate_ultimate(f, r);

Â  Â  Â  Â  Â  Â  Â  Â  if (is_activated) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.game.selected_square_coords = this.selected_square;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (this.game.is_power_mode) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Re-calculate targets for the new power mode (e.g., Bishop freeze targets, Fusion targets)
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.valid_targets = this.game.get_legal_moves(f, r);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Power completed in one step (currently none, but future proofing)
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.clear_selection();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (this.game_type === 'bot' && !this.game.game_over && this.game.current_turn !== this.user_color) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.handle_ai_turn();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  this.draw_board();
Â  Â  Â  Â  Â  Â  Â  Â  this.update_status();
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  // --- AI Handler (Only runs in 'bot' mode) ---

Â  Â  Â  Â  Â  Â  _execute_ai_move() {
Â  Â  Â  Â  Â  Â  Â  Â  if (this.game_type !== 'bot' || this.game.current_turn === this.user_color || this.game.game_over) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  const elo_level = this.bot_elo;
Â  Â  Â  Â  Â  Â  Â  Â  const ai_move = this.game.get_bot_move(elo_level);

Â  Â  Â  Â  Â  Â  Â  Â  if (ai_move) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  f1,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  r1,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  f2,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  r2,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  is_capture
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } = ai_move;

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const start_coord = this.game._indices_to_coords(f1, r1);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const end_coord = this.game._indices_to_coords(f2, r2);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const move_str = start_coord + end_coord;

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.selected_square = {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  f: f1,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  r: r1
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  };
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.valid_targets = [{
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  f: f2,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  r: r2,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  is_capture: is_capture
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }];
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.draw_board();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.update_status();

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Use setTimeout to simulate a small delay before committing the move
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  setTimeout(() => this._commit_ai_move(move_str), 500);

Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Should be checkmate or stalemate, handled in get_all_legal_moves_for_color
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.draw_board();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.update_status();
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  _commit_ai_move(move_str) {
Â  Â  Â  Â  Â  Â  Â  Â  if (this.game_type !== 'bot' || this.game.game_over) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  this.game.execute_move(move_str);

Â  Â  Â  Â  Â  Â  Â  Â  this.clear_selection();

Â  Â  Â  Â  Â  Â  Â  Â  if (!this.game.game_over && this.game.current_turn !== this.user_color) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Give a short delay before the next AI move if it's still AI's turn (e.g., in a chain of roomba movements)
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  setTimeout(() => this.handle_ai_turn(), 100);
Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.draw_board();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.update_status();
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  handle_ai_turn() {
Â  Â  Â  Â  Â  Â  Â  Â  /** Disables controls and waits for AI move. */
Â  Â  Â  Â  Â  Â  Â  Â  this.elements.ultimateButton.disabled = true;
Â  Â  Â  Â  Â  Â  Â  Â  // Introduce a slight delay for better UX
Â  Â  Â  Â  Â  Â  Â  Â  setTimeout(() => this._execute_ai_move(), 500);
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }

Â  Â  Â  Â  // --- Main Execution (Global instance and helper functions) ---

Â  Â  Â  Â  let app;

Â  Â  Â  Â  // Global helpers for HTML buttons
Â  Â  Â  Â  function startLocalGame() {
Â  Â  Â  Â  Â  Â  app.start_game('local');
Â  Â  Â  Â  }

Â  Â  Â  Â  function startBotGame() {
Â  Â  Â  Â  Â  Â  app.start_game('bot');
Â  Â  Â  Â  }
Â  Â  Â  Â Â 
Â  Â  Â  Â  function showOnlineLobby() {
Â  Â  Â  Â  Â  Â  app.showOnlineLobby();
Â  Â  Â  Â  }

Â  Â  Â  Â  function updateEloLabel(value) {
Â  Â  Â  Â  Â  Â  document.getElementById('elo-label').textContent = `ELO: ${value}`;
Â  Â  Â  Â  }


Â  Â  Â  Â  // Initialize the application once the DOM is ready
Â  Â  Â  Â  document.addEventListener('DOMContentLoaded', () => {
Â  Â  Â  Â  Â  Â  app = new UltimateChessApp();
Â  Â  Â  Â  Â  Â  app.show_main_menu();
Â  Â  Â  Â  });
Â  Â  </script>
</body>
</html>

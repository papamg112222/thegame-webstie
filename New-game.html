<!DOCTYPE html>
<html>
<head>
  <title>AI Hide-and-Seek Mini Maze Fixed</title>
  <style>
    html, body {
      margin: 0; padding: 0;
      overflow: hidden; width: 100%; height: 100%;
      font-family: sans-serif;
      background: linear-gradient(to bottom, #87ceeb, #a2d5f2);
    }
    canvas { display: block; position: absolute; top:0; left:0; z-index:0; }
    #hud {
      position: absolute;
      top: 10px; left: 50%;
      transform: translateX(-50%);
      color: #fff;
      text-align: center;
      text-shadow: 1px 1px 3px black;
      z-index:10;
    }
    #timer {
      font-size: 48px;
      font-weight: bold;
      padding: 8px 16px;
      background: rgba(0,0,0,0.4);
      border-radius: 12px;
      margin-bottom: 5px;
      display: inline-block;
    }
    #cookies { font-size:22px; margin-top:3px; display:block; }
    #attempts {
      position: absolute;
      top:50%; left:50%;
      transform: translate(-50%, -50%);
      font-size:32px;
      opacity:0.4;
      pointer-events:none;
      z-index:10;
    }
    #buttons {
      position: absolute;
      right:10px;
      bottom:20px;
      display:flex;
      flex-direction: column;
      gap:10px;
      z-index:10;
    }
    button {
      font-size:18px;
      padding:10px 16px;
      border:none;
      border-radius:10px;
      cursor:pointer;
      background-color:#6a4c93;
      color:#fff;
      box-shadow:2px 2px 6px rgba(0,0,0,0.3);
    }
  </style>
</head>
<body>

<div id="hud">
  <div id="timer">30</div>
  <div id="cookies">Seeker Cookies: 0 | Hider Cookies: 0</div>
</div>
<div id="attempts">Attempts: 0</div>

<div id="buttons">
  <button id="speedBtn">Speed: Normal</button>
  <button id="offlineBtn">Offline Learning: ON</button>
  <button id="resetBtn">Reset</button>
</div>

<canvas id="gameCanvas"></canvas>

<script>
const canvas=document.getElementById('gameCanvas');
const ctx=canvas.getContext('2d');
let attempts=parseInt(localStorage.getItem('attempts'))||0;
let seekerCookies=parseInt(localStorage.getItem('seekerCookies'))||0;
let hiderCookies=parseInt(localStorage.getItem('hiderCookies'))||0;
let timer=30;

const speeds=[1,50,100,500,1000];
let speedIndex=0;
let tickMultiplier=speeds[speedIndex];

let offlineLearning=true;

// Resize canvas
function resizeCanvas(){canvas.width=window.innerWidth; canvas.height=window.innerHeight;}
window.addEventListener('resize',resizeCanvas);
resizeCanvas();

// AI memory
const memory={bestHiderSpot:null};
const savedMem=localStorage.getItem('hiderMemory');
if(savedMem) memory.bestHiderSpot=JSON.parse(savedMem);

// AI objects
function createAI(x,y,size,color,speed){return {x,y,size,color,speed}}
const hider=createAI(50,50,40,'green',3);
const seeker=createAI(canvas.width-100,canvas.height-100,40,'red',2.5);

// Fixed mini maze squares
const obstacles=[
  {x:150,y:100,width:200,height:20,color:'#6a4c93'},
  {x:400,y:200,width:20,height:150,color:'#ff6347'},
  {x:600,y:50,width:150,height:20,color:'#ffd700'},
  {x:250,y:350,width:20,height:150,color:'#00ffff'},
  {x:500,y:400,width:200,height:20,color:'#ff69b4'}
];

function distance(a,b){return Math.sqrt((a.x-b.x)**2+(a.y-b.y)**2);}
function rectsOverlap(a,b){return!(a.x+a.size<b.x||a.x>b.x+b.width||a.y+a.size<b.y||a.y>b.y+b.height);}

function resetRound(){
  hider.x=Math.random()*(canvas.width-hider.size);
  hider.y=Math.random()*(canvas.height-hider.size);
  seeker.x=Math.random()*(canvas.width-seeker.size);
  seeker.y=Math.random()*(canvas.height-seeker.size);
  timer=30;
}

function moveHider(){
  let angle=Math.random()*2*Math.PI;
  hider.x+=Math.cos(angle)*hider.speed*tickMultiplier/50;
  hider.y+=Math.sin(angle)*hider.speed*tickMultiplier/50;
  obstacles.forEach(o=>{if(rectsOverlap(hider,o)){hider.x-=Math.cos(angle)*hider.speed*tickMultiplier/50; hider.y-=Math.sin(angle)*hider.speed*tickMultiplier/50}});
  hider.x=Math.max(0,Math.min(canvas.width-hider.size,hider.x));
  hider.y=Math.max(0,Math.min(canvas.height-hider.size,hider.y));
}

function moveSeeker(){
  let target=memory.bestHiderSpot||{x:canvas.width/2,y:canvas.height/2};
  let dx=target.x-seeker.x, dy=target.y-seeker.y;
  seeker.x+=(dx*0.01+(Math.random()-0.5)*1.5)*tickMultiplier/50;
  seeker.y+=(dy*0.01+(Math.random()-0.5)*1.5)*tickMultiplier/50;
  obstacles.forEach(o=>{if(rectsOverlap(seeker,o)){seeker.x-=dx*0.01*tickMultiplier/50; seeker.y-=dy*0.01*tickMultiplier/50}});
  seeker.x=Math.max(0,Math.min(canvas.width-seeker.size,seeker.x));
  seeker.y=Math.max(0,Math.min(canvas.height-seeker.size,seeker.y));
}

function drawObstacles(){
  obstacles.forEach(o=>{
    ctx.fillStyle=o.color;
    ctx.shadowColor='rgba(0,0,0,0.3)'; ctx.shadowBlur=6;
    ctx.fillRect(o.x,o.y,o.width,o.height);
    ctx.shadowBlur=0;
  });
}

function drawAI(ai){ctx.shadowColor='rgba(0,0,0,0.3)';ctx.shadowBlur=10; ctx.fillStyle=ai.color; ctx.fillRect(ai.x,  seeker.y=Math.max(0,Math.min(canvas.height-seeker.size,seeker.y));
}

function drawObstacles(){
  obstacles.forEach(o=>{
    ctx.fillStyle=o.color;
    ctx.shadowColor='rgba(0,0,0,0.3)'; ctx.shadowBlur=6;
    ctx.fillRect(o.x,o.y,o.width,o.height);
    ctx.shadowBlur=0;
  });
}

function drawAI(ai){ctx.shadowColor='rgba(0,0,0,0.3)';ctx.shadowBlur=10;ctx.fillStyle=ai.color;ctx.fillRect(ai.x,ai.y,ai.size,ai.size);ctx.shadowBlur=0;}

function updateHUD(){
  document.getElementById('timer').innerText=Math.ceil(timer);
  document.getElementById('attempts').innerText=`Attempts: ${attempts}`;
  document.getElementById('cookies').innerText=`Seeker Cookies: ${seekerCookies} | Hider Cookies: ${hiderCookies}`;
  if(offlineLearning){
    localStorage.setItem('attempts',attempts);
    localStorage.setItem('seekerCookies',seekerCookies);
    localStorage.setItem('hiderCookies',hiderCookies);
    localStorage.setItem('hiderMemory',JSON.stringify(memory.bestHiderSpot));
  }
}

function gameLoop(){
  for(let i=0;i<tickMultiplier;i++){
    moveObstacles();
    moveHider();
    moveSeeker();
    if(distance(hider,seeker)<(hider.size+seeker.size)/2){
      attempts++; seekerCookies++;
      memory.bestHiderSpot={x:hider.x,y:hider.y};
      resetRound();
    }
    timer -= 1/60;
    if(timer<=0){attempts++; hiderCookies++; resetRound();}
  }

  ctx.clearRect(0,0,canvas.width,canvas.height);
  drawObstacles(); drawAI(hider); drawAI(seeker);
  updateHUD();
  requestAnimationFrame(gameLoop);
}

function moveObstacles(){
  obstacles.forEach(o=>{
    // subtle animation for maze squares
    o.x += (Math.sin(Date.now()/1000)*0.5);
    o.y += (Math.cos(Date.now()/1000)*0.5);
  });
}

// Buttons
document.getElementById('resetBtn').addEventListener('click',()=>{
  localStorage.clear();
  attempts=0; seekerCookies=0; hiderCookies=0; memory.bestHiderSpot=null;
  resetRound();
});

document.getElementById('offlineBtn').addEventListener('click',()=>{
  offlineLearning=!offlineLearning;
  document.getElementById('offlineBtn').innerText=`Offline Learning: ${offlineLearning?'ON':'OFF'}`;
});

document.getElementById('speedBtn').addEventListener('click',()=>{
  speedIndex=(speedIndex      position: absolute;
      top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      font-size: 32px;
      opacity: 0.5;
      pointer-events: none;
    }
    #buttons {
      position: absolute;
      right: 10px;
      bottom: 20px;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    button {
      font-size: 18px;
      padding: 10px 16px;
      border: none;
      border-radius: 10px;
      cursor: pointer;
      background-color: #6a4c93;
      color: #fff;
      box-shadow: 2px 2px 5px rgba(0,0,0,0.3);
    }
  </style>
</head>
<body>

<div id="hud">
  <div id="timer">30</div>
  <div id="cookies">Seeker Cookies: 0 | Hider Cookies: 0</div>
</div>
<div id="attempts">Attempts: 0</div>

<div id="buttons">
  <button id="speedBtn">Speed: Normal</button>
  <button id="offlineBtn">Offline Learning: OFF</button>
  <button id="resetBtn">Reset</button>
</div>

<canvas id="gameCanvas"></canvas>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
let attempts = 0, seekerCookies = 0, hiderCookies = 0;
let timer = 30;

// Game speed control
const speeds = [1,2,5,10,50];
let speedIndex = 0;
let tickMultiplier = speeds[speedIndex];

// Offline learning toggle
let offlineLearning = false;

function resizeCanvas() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

// AI memory
const memory = { bestHiderSpot: null };

// AI objects
function createAI(x,y,size,color,speed){return{x,y,size,color,speed}}
const hider = createAI(50,50,40,'green',3);
const seeker = createAI(canvas.width-100,canvas.height-100,40,'red',2.5);

// Obstacles
const obstacles = [
  {x:200,y:150,width:120,height:60,color:'#6a4c93',type:'rect',vx:1,vy:1.2},
  {x:500,y:300,width:80,height:80,color:'#ff6347',type:'circle',vx:-1.1,vy:0.8},
  {x:800,y:100,width:100,height:50,color:'#ffd700',type:'triangle',vx:0.7,vy:-1}
];

function distance(a,b){return Math.sqrt((a.x-b.x)**2+(a.y-b.y)**2)}
function rectsOverlap(a,b){return!(a.x+a.size<b.x||a.x>b.x+b.width||a.y+a.size<b.y||a.y>b.y+b.height)}

function resetRound(){
  hider.x = Math.random()*(canvas.width-hider.size);
  hider.y = Math.random()*(canvas.height-hider.size);
  seeker.x = Math.random()*(canvas.width-seeker.size);
  seeker.y = Math.random()*(canvas.height-seeker.size);
  timer = 30;
}

function moveHider(){
  let angle = Math.random()*2*Math.PI;
  hider.x += Math.cos(angle)*hider.speed;
  hider.y += Math.sin(angle)*hider.speed;
  obstacles.forEach(o=>{if(rectsOverlap(hider,o)){hider.x-=Math.cos(angle)*hider.speed;hider.y-=Math.sin(angle)*hider.speed}});
  hider.x=Math.max(0,Math.min(canvas.width-hider.size,hider.x));
  hider.y=Math.max(0,Math.min(canvas.height-hider.size,hider.y));
}

function moveSeeker(){
  let target = memory.bestHiderSpot||{x:canvas.width/2,y:canvas.height/2};
  let dx=target.x-seeker.x, dy=target.y-seeker.y;
  seeker.x += dx*0.01+(Math.random()-0.5)*1.5;
  seeker.y += dy*0.01+(Math.random()-0.5)*1.5;
  obstacles.forEach(o=>{if(rectsOverlap(seeker,o)){seeker.x-=dx*0.01;seeker.y-=dy*0.01}});
  seeker.x=Math.max(0,Math.min(canvas.width-seeker.size,seeker.x));
  seeker.y=Math.max(0,Math.min(canvas.height-seeker.size,seeker.y));
}

function moveObstacles(){
  obstacles.forEach(o=>{
    o.x+=o.vx*tickMultiplier;
    o.y+=o.vy*tickMultiplier;
    if(o.x<0||o.x+o.width>canvas.width)o.vx*=-1;
    if(o.y<0||o.y+o.height>canvas.height)o.vy*=-1;
  });
}

function drawObstacles(){
  obstacles.forEach(o=>{
    let grad=ctx.createRadialGradient(o.x+o.width/2,o.y+o.height/2,5,o.x+o.width/2,o.y+o.height/2,o.width/2);
    grad.addColorStop(0,'#ffffff'); grad.addColorStop(1,o.color);
    ctx.fillStyle=grad;
    if(o.type==='rect')ctx.fillRect(o.x,o.y,o.width,o.height);
    else if(o.type==='circle'){ctx.beginPath();ctx.arc(o.x+o.width/2,o.y+o.height/2,o.width/2,0,2*Math.PI);ctx.fill();}
    else if(o.type==='triangle'){ctx.beginPath();ctx.moveTo(o.x+o.width/2,o.y);ctx.lineTo(o.x,o.y+o.height);ctx.lineTo(o.x+o.width,o.y+o.height);ctx.closePath();ctx.fill();}
  });
}

function drawAI(ai){ctx.shadowColor='rgba(0,0,0,0.3)';ctx.shadowBlur=10;ctx.fillStyle=ai.color;ctx.fillRect(ai.x,ai.y,ai.size,ai.size);ctx.shadowBlur=0;}

function updateHUD(){
  document.getElementById('timer').innerText=Math.ceil(timer);
  document.getElementById('attempts').innerText=`Attempts: ${attempts}`;
  document.getElementById('cookies').innerText=`Seeker Cookies: ${seekerCookies} | Hider Cookies: ${hiderCookies}`;
  if(!offlineLearning){
    localStorage.setItem('attempts',attempts);
    localStorage.setItem('seekerCookies',seekerCookies);
    localStorage.setItem('hiderCookies',hiderCookies);
    localStorage.setItem('hiderMemory',JSON.stringify(memory.bestHiderSpot));
  }
}

function gameLoop(){
  for(let i=0;i<tickMultiplier;i++){
    moveObstacles(); moveHider(); moveSeeker();
    // Collision
    if(distance(hider,seeker)<(hider.size+seeker.size)/2){
      attempts++; seekerCookies++;
      memory.bestHiderSpot={x:hider.x,y:hider.y};
      resetRound();
    }
    timer -= 1/60;
    if(timer<=0){attempts++; hiderCookies++; resetRound();}
  }

  ctx.clearRect(0,0,canvas.width,canvas.height);
  drawObstacles(); drawAI(hider); drawAI(seeker);
  updateHUD();
  requestAnimationFrame(gameLoop);
}

// Button events
document.getElementById('resetBtn').addEventListener('click',()=>{
  localStorage.clear();
  attempts=0; seekerCookies=0; hiderCookies=0; memory.bestHiderSpot=null;
  resetRound();
});

document.getElementById('offlineBtn').addEventListener('click',()=>{
  offlineLearning=!offlineLearning;
  document.getElementById('offlineBtn').innerText=`Offline Learning: ${offlineLearning?'ON':'OFF'}`;
});

document.getElementById('speedBtn').addEventListener('click',()=>{
  speedIndex=(speedIndex+1)%speeds.length;
  tickMultiplier=speeds[speedIndex];
  document.getElementById('speedBtn').innerText=`Speed: ${speeds[speedIndex]==1?'Normal':speeds[speedIndex]}`;
});

// Load saved progress
if(localStorage.getItem('attempts')) attempts=parseInt(localStorage.getItem('attempts'));
if(localStorage.getItem('seekerCookies')) seekerCookies=parseInt(localStorage.getItem('seekerCookies'));
if(localStorage.getItem('hiderCookies')) hiderCookies=parseInt(localStorage.getItem('hiderCookies'));
const savedMem=localStorage.getItem('hiderMemory');
if(savedMem) memory.bestHiderSpot=JSON.parse(savedMem);

resetRound();
gameLoop();
</script>

</body>
</html>
<!DOCTYPE html>
<html>
<head>
<title>AI Hide-and-Seek Mini Maze Mobile</title>
<style>
html, body {
  margin:0; padding:0; width:100%; height:100%; overflow:hidden;
  font-family:sans-serif; background: linear-gradient(to bottom,#87ceeb,#a2d5f2);
}
canvas { display:block; position:absolute; top:0; left:0; z-index:0; }
#hud {
  position:absolute; top:10px; left:50%; transform:translateX(-50%);
  color:#fff; text-align:center; text-shadow:1px 1px 3px black; z-index:10;
}
#timer {
  font-size:48px; font-weight:bold; padding:12px 20px;
  background:rgba(0,0,0,0.4); border-radius:14px; margin-bottom:5px; display:inline-block;
}
#cookies { font-size:24px; margin-top:5px; display:block; }
#attempts {
  position:absolute; top:50%; left:50%; transform:translate(-50%,-50%);
  font-size:36px; opacity:0.4; pointer-events:none; z-index:10;
}
#buttons {
  position:absolute; right:10px; bottom:20px; display:flex; flex-direction:column; gap:15px; z-index:10;
}
button {
  font-size:22px; padding:14px 22px; border:none; border-radius:12px;
  cursor:pointer; background-color:#6a4c93; color:#fff; box-shadow:2px 2px 6px rgba(0,0,0,0.3);
}
</style>
</head>
<body>
<div id="hud">
  <div id="timer">30</div>
  <div id="cookies">Seeker Cookies: 0 | Hider Cookies: 0</div>
</div>
<div id="attempts">Attempts: 0</div>

<div id="buttons">
  <button id="speedBtn">Speed: Normal</button>
  <button id="offlineBtn">Offline Learning: ON</button>
  <button id="resetBtn">Reset</button>
</div>

<canvas id="gameCanvas"></canvas>

<script>
const canvas=document.getElementById('gameCanvas');
const ctx=canvas.getContext('2d');
let attempts=parseInt(localStorage.getItem('attempts'))||0;
let seekerCookies=parseInt(localStorage.getItem('seekerCookies'))||0;
let hiderCookies=parseInt(localStorage.getItem('hiderCookies'))||0;
let timer=30;

// Speed cycle
const speeds=[2,5,10,50,100,500,1000];
let speedIndex=0;
let tickMultiplier=1;

let offlineLearning=true;

function resizeCanvas(){canvas.width=window.innerWidth; canvas.height=window.innerHeight;}
window.addEventListener('resize',resizeCanvas);
resizeCanvas();

// AI memory
const memory={bestHiderSpot:null};
const savedMem=localStorage.getItem('hiderMemory');
if(savedMem) memory.bestHiderSpot=JSON.parse(savedMem);

// AI objects
function createAI(x,y,size,color,speed){return{x,y,size,color,speed}}
const hider=createAI(50,50,40,'green',3);
const seeker=createAI(canvas.width-100,canvas.height-100,40,'red',2.5);

// Fixed mini maze squares
const obstacles=[
  {x:150,y:100,width:200,height:20,color:'#6a4c93'},
  {x:400,y:200,width:20,height:150,color:'#ff6347'},
  {x:600,y:50,width:150,height:20,color:'#ffd700'},
  {x:250,y:350,width:20,height:150,color:'#00ffff'},
  {x:500,y:400,width:200,height:20,color:'#ff69b4'}
];

function distance(a,b){return Math.sqrt((a.x-b.x)**2+(a.y-b.y)**2);}
function rectsOverlap(a,b){return!(a.x+a.size<b.x||a.x>b.x+b.width||a.y+a.size<b.y||a.y>b.y+b.height);}

function resetRound(){
  hider.x=Math.random()*(canvas.width-hider.size);
  hider.y=Math.random()*(canvas.height-hider.size);
  seeker.x=Math.random()*(canvas.width-seeker.size);
  seeker.y=Math.random()*(canvas.height-seeker.size);
  timer=30;
}

function moveHider(){
  let angle=Math.random()*2*Math.PI;
  hider.x+=Math.cos(angle)*hider.speed*tickMultiplier/50;
  hider.y+=Math.sin(angle)*hider.speed*tickMultiplier/50;
  obstacles.forEach(o=>{if(rectsOverlap(hider,o)){hider.x-=Math.cos(angle)*hider.speed*tickMultiplier/50; hider.y-=Math.sin(angle)*hider.speed*tickMultiplier/50}});
  hider.x=Math.max(0,Math.min(canvas.width-hider.size,hider.x));
  hider.y=Math.max(0,Math.min(canvas.height-hider.size,hider.y));
}

function moveSeeker(){
  let target=memory.bestHiderSpot||{x:canvas.width/2,y:canvas.height/2};
  let dx=target.x-seeker.x, dy=target.y-seeker.y;
  seeker.x+=(dx*0.01+(Math.random()-0.5)*1.5)*tickMultiplier/50;
  seeker.y+=(dy*0.01+(Math.random()-0.5)*1.5)*tickMultiplier/50;
  obstacles.forEach(o=>{if(rectsOverlap(seeker,o)){seeker.x-=dx*0.01*tickMultiplier/50; seeker.y-=dy*0.01*tickMultiplier/50}});
  seeker.x=Math.max(0,Math.min(canvas.width-seeker.size,seeker.x));
  seeker.y=Math.max(0,Math.min(canvas.height-seeker.size,seeker.y));
}

function drawObstacles(){
  obstacles.forEach(o=>{
    ctx.fillStyle=o.color;
    ctx.shadowColor='rgba(0,0,0,0.3)'; ctx.shadowBlur=6;
    ctx.fillRect(o.x,o.y,o.width,o.height);
    ctx.shadowBlur=0;
  });
}

function drawAI(ai){ctx.shadowColor='rgba(0,0,0,0.3)';ctx.shadowBlur=10; ctx.fillStyle=ai.color; ctx.fillRect(ai.x,ai.y,ai.size,ai.size); ctx.shadowBlur=0;}

function updateHUD(){
  document.getElementById('timer').innerText=Math.ceil(timer);
  document.getElementById('attempts').innerText=`Attempts: ${attempts}`;
  document.getElementById('cookies').innerText=`Seeker Cookies: ${seekerCookies} | Hider Cookies: ${hiderCookies}`;
<!DOCTYPE html>
<html>
<head>
<title>AI Hide-and-Seek Mini Maze</title>
<style>
html, body {
  margin:0; padding:0; width:100%; height:100%; overflow:hidden;
  font-family:sans-serif;
  background: linear-gradient(to bottom,#87ceeb,#a2d5f2);
}
canvas { display:block; position:absolute; top:0; left:0; z-index:0; }
#hud {
  position:absolute; top:10px; left:50%; transform:translateX(-50%);
  color:#fff; text-align:center; text-shadow:1px 1px 3px black; z-index:10;
}
#timer {
  font-size:48px; font-weight:bold; padding:12px 20px;
  background:rgba(0,0,0,0.4); border-radius:14px; margin-bottom:5px; display:inline-block;
}
#cookies { font-size:24px; margin-top:5px; display:block; }
#attempts {
  position:absolute; top:50%; left:50%; transform:translate(-50%,-50%);
  font-size:36px; opacity:0.4; pointer-events:none; z-index:10;
}
#buttons {
  position:absolute; right:10px; bottom:20px; display:flex; flex-direction:column; gap:15px; z-index:10;
}
button {
  font-size:22px; padding:14px 22px; border:none; border-radius:12px;
  cursor:pointer; background-color:#6a4c93; color:#fff; box-shadow:2px 2px 6px rgba(0,0,0,0.3);
}
</style>
</head>
<body>
<div id="hud">
  <div id="timer">30</div>
  <div id="cookies">Seeker Cookies: 0 | Hider Cookies: 0</div>
</div>
<div id="attempts">Attempts: 0</div>

<div id="buttons">
  <button id="speedBtn">Speed: Normal</button>
  <button id="offlineBtn">Offline Learning: ON</button>
  <button id="resetBtn">Reset</button>
</div>

<canvas id="gameCanvas"></canvas>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

let attempts = parseInt(localStorage.getItem('attempts')) || 0;
let seekerCookies = parseInt(localStorage.getItem('seekerCookies')) || 0;
let hiderCookies = parseInt(localStorage.getItem('hiderCookies')) || 0;
let timer = 30;

const speeds = [2,5,10,50,100,500,1000];
let speedIndex = 0;
let tickMultiplier = 1;

let offlineLearning = true;

// Resize canvas
function resizeCanvas() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; }
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

// AI memory
const memory = { bestHiderSpot: null };
const savedMem = localStorage.getItem('hiderMemory');
if(savedMem) memory.bestHiderSpot = JSON.parse(savedMem);

// AI objects
function createAI(x,y,size,color,speed){return{x,y,size,color,speed}}
const hider = createAI(50,50,40,'green',3);
const seeker = createAI(canvas.width-100,canvas.height-100,40,'red',2.5);

// Fixed mini maze squares
const obstacles = [
  {x:150,y:100,width:200,height:20,color:'#6a4c93'},
  {x:400,y:200,width:20,height:150,color:'#ff6347'},
  {x:600,y:50,width:150,height:20,color:'#ffd700'},
  {x:250,y:350,width:20,height:150,color:'#00ffff'},
  {x:500,y:400,width:200,height:20,color:'#ff69b4'}
];

function distance(a,b){return Math.sqrt((a.x-b.x)**2+(a.y-b.y)**2);}
function rectsOverlap(a,b){return!(a.x+a.size<b.x||a.x>b.x+b.width||a.y+a.size<b.y||a.y>b.y+b.height);}

function resetRound(){
  hider.x = Math.random()*(canvas.width-hider.size);
  hider.y = Math.random()*(canvas.height-hider.size);
  seeker.x = Math.random()*(canvas.width-seeker.size);
  seeker.y = Math.random()*(canvas.height-seeker.size);
  timer = 30;
}

function moveHider(){
  let angle = Math.random()*2*Math.PI;
  hider.x += Math.cos(angle)*hider.speed*tickMultiplier/50;
  hider.y += Math.sin(angle)*hider.speed*tickMultiplier/50;
  obstacles.forEach(o=>{
    if(rectsOverlap(hider,o)){
      hider.x -= Math.cos(angle)*hider.speed*tickMultiplier/50;
      hider.y -= Math.sin(angle)*hider.speed*tickMultiplier/50;
    }
  });
  hider.x = Math.max(0, Math.min(canvas.width-hider.size,hider.x));
  hider.y = Math.max(0, Math.min(canvas.height-hider.size,hider.y));
}

function moveSeeker(){
  let target = memory.bestHiderSpot || {x:canvas.width/2,y:canvas.height/2};
  let dx = target.x - seeker.x, dy = target.y - seeker.y;
  seeker.x += (dx*0.01 + (Math.random()-0.5)*1.5)*tickMultiplier/50;
  seeker.y += (dy*0.01 + (Math.random()-0.5)*1.5)*tickMultiplier/50;
  obstacles.forEach(o=>{
    if(rectsOverlap(seeker,o)){
      seeker.x -= dx*0.01*tickMultiplier/50;
      seeker.y -= dy*0.01*tickMultiplier/50;
    }
  });
  seeker.x = Math.max(0, Math.min(canvas.width-seeker.size,seeker.x));
  seeker.y = Math.max(0, Math.min(canvas.height-seeker.size,seeker.y));
}

function drawObstacles(){
  obstacles.forEach(o=>{
    ctx.fillStyle = o.color;
    ctx.shadowColor = 'rgba(0,0,0,0.3)'; ctx.shadowBlur = 6;
    ctx.fillRect(o.x,o.y,o.width,o.height);
    ctx.shadowBlur=0;
  });
}

function drawAI(ai){
  ctx.shadowColor='rgba(0,0,0,0.3)'; ctx.shadowBlur=10;
  ctx.fillStyle = ai.color;
  ctx.fillRect(ai.x,ai.y,ai.size,ai.size);
  ctx.shadowBlur=0;
}

function updateHUD(){
  document.getElementById('timer').innerText = Math.ceil(timer);
  document.getElementById('attempts').innerText = `Attempts: ${attempts}`;
  document.getElementById('cookies').innerText = `Seeker Cookies: ${seekerCookies} | Hider Cookies: ${hiderCookies}`;
  if(offlineLearning){
    localStorage.setItem('attempts',attempts);
    localStorage.setItem('seekerCookies',seekerCookies);
    localStorage.setItem('hiderCookies',hiderCookies);
    localStorage.setItem('hiderMemory',JSON.stringify(memory.bestHiderSpot));
  }
}

function gameLoop(){
  for(let i=0;i<tickMultiplier;i++){
    moveHider(); moveSeeker();
    if(distance(hider,seeker)<(hider.size+seeker.size)/2){
      attempts++; seekerCookies++;
      memory.bestHiderSpot = {x:hider.x,y:hider.y};
      resetRound();
    }
    timer -= 1/60;
    if(timer <= 0){ attempts++; hiderCookies++; resetRound();}
  }
  ctx.clearRect(0,0,canvas.width,canvas.height);
  drawObstacles(); drawAI(hider); drawAI(seeker);
  updateHUD();
  requestAnimationFrame(gameLoop);
}

// Buttons
document.getElementById('resetBtn').addEventListener('click',()=>{
  localStorage.clear();
  attempts=0; seekerCookies=0; hiderCookies=0; memory.bestHiderSpot=null;
  resetRound();
});
document.getElementById('offlineBtn').addEventListener('click',()=>{
  offlineLearning = !offlineLearning;
  document.getElementById('offlineBtn').innerText = `Offline Learning: ${offlineLearning?'ON':'OFF'}`;
});
document.getElementById('speedBtn').addEventListener('click',()=>{
  speedIndex = (speedIndex + 1) % speeds.length;
  tickMultiplier = speeds[speedIndex];
  document.getElementById('speedBtn').innerText = `Speed: ${tickMultiplier===1?'Normal':tickMultiplier}`;
});

resetRound();
gameLoop();
</script>
</body>
</html>
